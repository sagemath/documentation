<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="../../../../genindex.html" /><link rel="search" title="Search" href="../../../../search.html" /><link rel="next" title="Witt symmetric functions" href="witt.html" /><link rel="prev" title="Symmetric functions, with their multiple realizations" href="sf.html" />

    <meta name="generator" content="sphinx-5.2.3, furo 2022.09.29"/>
        <title>Symmetric Functions - Combinatorics</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo.css?digest=d81277517bee4d6b0349d71bb2661d4890b5617c" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/custom-furo.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">Combinatorics</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../../_static/logo_sagemath_black.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../../_static/logo_sagemath_white.svg" alt="Dark Logo"/>
  </div>
  
      <span class="sidebar-brand-text">Sage 10.0 Reference Manual</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-home">
  <div class="sidebar-tree">
    <ul><li class="toctree-l1">
      <a class="reference internal" href="../../../index.html">Home - Combinatorics</a>
    </li></ul>
  </div>
</div><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="../../../module_list.html">Comprehensive Module List</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../abstract_tree.html">Abstract Recursive Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../affine_permutation.html">Affine Permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algebraic_combinatorics.html">Algebraic combinatorics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../all.html">Combinatorics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../alternating_sign_matrix.html">Alternating Sign Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backtrack.html">Backtracking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../baxter_permutations.html">Baxter permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bijectionist.html">A bijectionist’s toolkit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../binary_recurrence_sequences.html">Binary Recurrence Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../binary_tree.html">Binary Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blob_algebra.html">Blob Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cartesian_product.html">Cartesian Products</a></li>
<li class="toctree-l2"><a class="reference internal" href="../catalog_partitions.html">Enumerated sets of partitions, tableaux, …</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chas/all.html">Combinatorial Hopf algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chas/fsym.html">Poirier-Reutenauer Hopf algebra of standard tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chas/wqsym.html">Word Quasi-symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cluster_algebra_quiver/all.html">Cluster algebras and quivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cluster_algebra_quiver/cluster_seed.html">ClusterSeed</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cluster_algebra_quiver/mutation_class.html">mutation_class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cluster_algebra_quiver/mutation_type.html">Helper functions for mutation types of quivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cluster_algebra_quiver/quiver.html">Quiver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cluster_algebra_quiver/quiver_mutation_type.html">Quiver mutation types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cluster_complex.html">Cluster complex (or generalized dual associahedron)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../colored_permutations.html">Colored Permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../combinat.html">Combinatorial Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../combinat_cython.html">Fast computation of combinatorial functions (Cython + mpz)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../combination.html">Combinations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../combinatorial_map.html">Combinatorial maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../composition.html">Integer compositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../composition_signed.html">Signed Compositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../composition_tableau.html">Composition Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constellation.html">Constellations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../core.html">Cores</a></li>
<li class="toctree-l2"><a class="reference internal" href="../counting.html">Counting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/affine.html">Affine Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/affine_factorization.html">Affine factorization crystal of type <span class="math notranslate nohighlight">\(A\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/affinization.html">Affinization Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/alcove_path.html">Alcove paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/all.html">Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/bkk_crystals.html">Benkart-Kang-Kashiwara crystals for the general-linear Lie superalgebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/catalog.html">Catalog Of Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/catalog_elementary_crystals.html">Catalog Of Elementary Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/catalog_infinity_crystals.html">Catalog Of Crystal Models For <span class="math notranslate nohighlight">\(B(\infty)\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/catalog_kirillov_reshetikhin.html">Catalog Of Crystal Models For Kirillov-Reshetikhin Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/crystals.html">An introduction to crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/direct_sum.html">Direct Sum of Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/elementary_crystals.html">Elementary Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/fast_crystals.html">Fast Rank Two Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/fully_commutative_stable_grothendieck.html">Fully commutative stable Grothendieck crystal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/generalized_young_walls.html">Crystals of Generalized Young Walls</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/highest_weight_crystals.html">Highest weight crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/induced_structure.html">Induced Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/infinity_crystals.html"><span class="math notranslate nohighlight">\(\mathcal{B}(\infty)\)</span> Crystals of Tableaux in Nonexceptional Types and <span class="math notranslate nohighlight">\(G_2\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/kac_modules.html">Crystals of Kac modules of the general-linear Lie superalgebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/kirillov_reshetikhin.html">Kirillov-Reshetikhin Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/kyoto_path_model.html">Kyoto Path Model for Affine Highest Weight Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/letters.html">Crystals of letters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/littelmann_path.html">Littelmann paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/monomial_crystals.html">Crystals of Modified Nakajima Monomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/multisegments.html">Crystal of Bernstein-Zelevinsky Multisegments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/mv_polytopes.html">Crystal Of Mirković-Vilonen (MV) Polytopes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/pbw_crystal.html"><span class="math notranslate nohighlight">\(\mathcal{B}(\infty)\)</span> Crystal Of PBW Monomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/pbw_datum.html">PBW Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/polyhedral_realization.html">Polyhedral Realization of <span class="math notranslate nohighlight">\(B(\infty)\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/spins.html">Spin Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/star_crystal.html">Star-Crystal Structure On <span class="math notranslate nohighlight">\(B(\infty)\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/tensor_product.html">Tensor Products of Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crystals/tensor_product_element.html">Tensor Products of Crystal Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cyclic_sieving_phenomenon.html">Cyclic sieving phenomenon</a></li>
<li class="toctree-l2"><a class="reference internal" href="../debruijn_sequence.html">De Bruijn sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../degree_sequences.html">Degree sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../derangements.html">Derangements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../descent_algebra.html">Descent Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/all.html">Combinatorial designs and incidence structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/bibd.html">Balanced Incomplete Block Designs (BIBD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/resolvable_bibd.html">Resolvable Balanced Incomplete Block Design (RBIBD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/group_divisible_designs.html">Group-Divisible Designs (GDD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/block_design.html">Block designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/covering_design.html">Covering designs: coverings of <span class="math notranslate nohighlight">\(t\)</span>-element subsets of a <span class="math notranslate nohighlight">\(v\)</span>-set by <span class="math notranslate nohighlight">\(k\)</span>-sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/database.html">Database of small combinatorial designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/design_catalog.html">Catalog of designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/designs_pyx.html">Cython functions for combinatorial designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/difference_family.html">Difference families</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/difference_matrices.html">Difference Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/evenly_distributed_sets.html">Evenly distributed sets in finite fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/ext_rep.html">External Representations of Block Designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/gen_quadrangles_with_spread.html">Database of generalised quadrangles with spread</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/incidence_structures.html">Incidence structures (i.e. hypergraphs, i.e. set systems)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/latin_squares.html">Mutually Orthogonal Latin Squares (MOLS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/orthogonal_arrays.html">Orthogonal arrays (OA)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/orthogonal_arrays_build_recursive.html">Orthogonal arrays (build recursive constructions)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/orthogonal_arrays_find_recursive.html">Orthogonal arrays (find recursive constructions)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/steiner_quadruple_systems.html">Steiner Quadruple Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/subhypergraph_search.html">Hypergraph isomorphic copy search</a></li>
<li class="toctree-l2"><a class="reference internal" href="../designs/twographs.html">Two-graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../diagram.html">Combinatorial diagrams</a></li>
<li class="toctree-l2"><a class="reference internal" href="../diagram_algebras.html">Diagram and Partition Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dlx.html">Exact Cover Problem via Dancing Links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dyck_word.html">Dyck Words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../e_one_star.html">Substitutions over unit cube faces (Rauzy fractals)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../enumerated_sets.html">Enumerated sets and combinatorial objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../enumeration_mod_permgroup.html">Tools for enumeration modulo the action of a permutation group</a></li>
<li class="toctree-l2"><a class="reference internal" href="../expnums.html">Compute Bell and Uppuluri-Carpenter numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../family.html">Families</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fast_vector_partitions.html">Brent Yorgey’s fast algorithm for integer vector (multiset) partitions.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fully_commutative_elements.html">Fully commutative elements of Coxeter groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../finite_state_machine.html">Finite state machines, automata, transducers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../finite_state_machine_generators.html">Common Automata and Transducers (Finite State Machines Generators)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fqsym.html">Free Quasi-symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../free_module.html">Free modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../free_dendriform_algebra.html">Free Dendriform Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../free_prelie_algebra.html">Free Pre-Lie Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fully_packed_loop.html">Fully packed loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gelfand_tsetlin_patterns.html">Gelfand-Tsetlin Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../graph_path.html">Paths in Directed Acyclic Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gray_codes.html">Gray codes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../growth.html">Growth diagrams and dual graded graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../grossman_larson_algebras.html">Grossman-Larson Hopf Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hall_polynomial.html">Hall Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hillman_grassl.html">The Hillman-Grassl correspondence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integer_lists/base.html">Enumerated set of lists of integers with constraints: base classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integer_lists/lists.html">Enumerated set of lists of integers with constraints: front-end</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integer_lists/invlex.html">Enumerated set of lists of integers with constraints, in inverse lexicographic order</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integer_matrices.html">Counting, generating, and manipulating non-negative integer matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integer_vector.html">(Non-negative) Integer vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integer_vector_weighted.html">Weighted Integer Vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integer_vectors_mod_permgroup.html">Integer vectors modulo the action of a permutation group</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interval_posets.html">Tamari Interval-posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../k_regular_sequence.html"><span class="math notranslate nohighlight">\(k\)</span>-regular Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../k_tableau.html">Strong and weak tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kazhdan_lusztig.html">Kazhdan-Lusztig Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../key_polynomial.html">Key polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../knutson_tao_puzzles.html">Knutson-Tao Puzzles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../matrices/all.html">Combinatorics on matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../matrices/dancing_links.html">Dancing Links internal pyx code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../matrices/dlxcpp.html">Dancing links C++ wrapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="../matrices/hadamard_matrix.html">Hadamard matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../matrices/latin.html">Latin Squares</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc.html">Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="../multiset_partition_into_sets_ordered.html">Ordered Multiset Partitions into Sets and the Minimaj Crystal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsf_qsym/all.html">Non-commutative symmetric functions and quasi-symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsf_qsym/combinatorics.html">Common combinatorial tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsf_qsym/generic_basis_code.html">Generic code for bases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsf_qsym/ncsf.html">Non-Commutative Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsf_qsym/qsym.html">Quasisymmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsf_qsym/tutorial.html">Introduction to Quasisymmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsym/all.html">Symmetric functions in non-commuting variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsym/bases.html">Bases for <span class="math notranslate nohighlight">\(NCSym\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsym/dual.html">Dual Symmetric Functions in Non-Commuting Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ncsym/ncsym.html">Symmetric Functions in Non-Commuting Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../necklace.html">Necklaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../non_decreasing_parking_function.html">Non-Decreasing Parking Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nu_dyck_word.html"><span class="math notranslate nohighlight">\(\nu\)</span>-Dyck Words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nu_tamari_lattice.html"><span class="math notranslate nohighlight">\(\nu\)</span>-Tamari lattice</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ordered_tree.html">Ordered Rooted Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../output.html">Output functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallelogram_polyomino.html">Parallelogram Polyominoes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parking_functions.html">Parking Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../path_tableaux/catalog.html">Catalog of Path Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../path_tableaux/dyck_path.html">Dyck Paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="../path_tableaux/frieze.html">Frieze Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../path_tableaux/path_tableau.html">Path Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../path_tableaux/semistandard.html">Semistandard Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plane_partition.html">Plane Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../partition.html">Integer partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../partition_algebra.html">Partition/Diagram Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../partition_kleshchev.html">Kleshchev partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../partition_shifting_algebras.html">Partition Shifting Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../partition_tuple.html">Partition tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../partitions.html">Iterators over the partitions of an integer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../perfect_matching.html">Perfect matchings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../permutation.html">Permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../permutation_cython.html">Permutations (Cython file)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../posets/all.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../posets/cartesian_product.html">Cartesian products of Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../posets/d_complete.html">D-Complete Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../posets/mobile.html">Mobile posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../posets/elements.html">Elements of posets, lattices, semilattices, etc.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../posets/forest.html">Forest Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../posets/hasse_diagram.html">Hasse diagrams of posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../posets/incidence_algebras.html">Incidence Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../posets/lattices.html">Finite lattices and semilattices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../posets/linear_extensions.html">Linear Extensions of Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../posets/moebius_algebra.html">Möbius Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../posets/poset_examples.html">Catalog of posets and lattices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../posets/posets.html">Finite posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../q_analogues.html"><span class="math notranslate nohighlight">\(q\)</span>-Analogues</a></li>
<li class="toctree-l2"><a class="reference internal" href="../q_bernoulli.html"><span class="math notranslate nohighlight">\(q\)</span>-Bernoulli Numbers and Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../quickref.html">Combinatorics quickref</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ranker.html">Rankers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../recognizable_series.html">Recognizable Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="../restricted_growth.html">Restricted growth arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ribbon.html">Ribbons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ribbon_shaped_tableau.html">Ribbon Shaped Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ribbon_tableau.html">Ribbon Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/all.html">Rigged configurations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_abstract_class.html">Abstract classes for the rigged configuration bijections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_infinity.html">Bijection between rigged configurations for <span class="math notranslate nohighlight">\(B(\infty)\)</span> and marginally large tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_type_A.html">Bijection classes for type <span class="math notranslate nohighlight">\(A_n^{(1)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_type_A2_dual.html">Bijection classes for type <span class="math notranslate nohighlight">\(A_{2n}^{(2)\dagger}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_type_A2_even.html">Bijection classes for type <span class="math notranslate nohighlight">\(A_{2n}^{(2)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_type_A2_odd.html">Bijection classes for type <span class="math notranslate nohighlight">\(A_{2n-1}^{(2)}\)</span>.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_type_B.html">Bijection classes for type <span class="math notranslate nohighlight">\(B_n^{(1)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_type_C.html">Bijection classes for type <span class="math notranslate nohighlight">\(C_n^{(1)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_type_D.html">Bijection classes for type <span class="math notranslate nohighlight">\(D_n^{(1)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_type_D_twisted.html">Bijection classes for type <span class="math notranslate nohighlight">\(D_{n+1}^{(2)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bij_type_D_tri.html">Bijection classes for type <span class="math notranslate nohighlight">\(D_4^{(3)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/bijection.html">Bijection between rigged configurations and KR tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/kleber_tree.html">Kleber Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/kr_tableaux.html">Kirillov-Reshetikhin Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/rc_crystal.html">Crystal of Rigged Configurations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/rc_infinity.html">Rigged Configurations of <span class="math notranslate nohighlight">\(\mathcal{B}(\infty)\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/rigged_configuration_element.html">Rigged Configuration Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/rigged_configurations.html">Rigged Configurations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/rigged_partition.html">Rigged Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/tensor_product_kr_tableaux.html">Tensor Product of Kirillov-Reshetikhin Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rigged_configurations/tensor_product_kr_tableaux_element.html">Tensor Product of Kirillov-Reshetikhin Tableaux Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/all.html">Root Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/ambient_space.html">Ambient lattices and ambient spaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/associahedron.html">Associahedron</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/braid_move_calculator.html">Braid Move Calculator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/braid_orbit.html">Braid Orbit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/branching_rules.html">Branching Rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/cartan_matrix.html">Cartan matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/cartan_type.html">Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/coxeter_group.html">Coxeter Groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/coxeter_matrix.html">Coxeter Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/coxeter_type.html">Coxeter Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/dynkin_diagram.html">Dynkin diagrams</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/hecke_algebra_representation.html">Hecke algebra representations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/integrable_representations.html">Integrable Representations of Affine Lie Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/non_symmetric_macdonald_polynomials.html">Nonsymmetric Macdonald polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/pieri_factors.html">Pieri Factors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/plot.html">Tutorial: visualizing root systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/reflection_group_complex.html">Finite complex reflection groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/reflection_group_real.html">Finite real reflection groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/root_lattice_realization_algebras.html">Group algebras of root lattice realizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/root_lattice_realizations.html">Root lattice realizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/root_space.html">Root lattices and root spaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/root_system.html">Root systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_super_A.html">Root system data for super type A</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_A.html">Root system data for type A</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_A_affine.html">Root system data for (untwisted) type A affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_A_infinity.html">Root system data for type A infinity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_B.html">Root system data for type B</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_BC_affine.html">Root system data for type BC affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_B_affine.html">Root system data for (untwisted) type B affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_C.html">Root system data for type C</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_C_affine.html">Root system data for (untwisted) type C affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_D.html">Root system data for type D</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_D_affine.html">Root system data for (untwisted) type D affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_E.html">Root system data for type E</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_E_affine.html">Root system data for (untwisted) type E affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_F.html">Root system data for type F</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_F_affine.html">Root system data for (untwisted) type F affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_G.html">Root system data for type G</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_G_affine.html">Root system data for (untwisted) type G affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_H.html">Root system data for type H</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_I.html">Root system data for type I</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_Q.html">Root system data for type Q</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_affine.html">Root system data for affine Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_dual.html">Root system data for dual Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/extended_affine_weyl_group.html">Extended Affine Weyl Groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/fundamental_group.html">Fundamental Group of an Extended Affine Weyl Group</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_folded.html">Root system data for folded Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_marked.html">Root system data for Cartan types with marked nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_reducible.html">Root system data for reducible Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/type_relabel.html">Root system data for relabelled Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/weight_lattice_realizations.html">Weight lattice realizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/weight_space.html">Weight lattices and weight spaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/weyl_characters.html">Weyl Character Rings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../root_system/weyl_group.html">Weyl Groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rooted_tree.html">Rooted (Unordered) Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rsk.html">Robinson-Schensted-Knuth correspondence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../schubert_polynomial.html">Schubert Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../set_partition.html">Set Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../set_partition_ordered.html">Ordered Set Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="all.html">Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="character.html">Characters of the symmetric group as bases of the symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="classical.html">Classical symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="dual.html">Generic dual bases symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="elementary.html">Elementary symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="hall_littlewood.html">Hall-Littlewood Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="hecke.html">Hecke Character Basis</a></li>
<li class="toctree-l2"><a class="reference internal" href="homogeneous.html">Homogeneous symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="jack.html">Jack Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="k_dual.html">Quotient of symmetric function space by ideal generated by Hall-Littlewood symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="kfpoly.html">Kostka-Foulkes Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="llt.html">LLT symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="macdonald.html">Macdonald Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="monomial.html">Monomial symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="multiplicative.html">Multiplicative symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="new_kschur.html"><span class="math notranslate nohighlight">\(k\)</span>-Schur Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ns_macdonald.html">Non-symmetric Macdonald Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="orthogonal.html">Orthogonal Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="orthotriang.html">Symmetric functions defined by orthogonality and triangularity</a></li>
<li class="toctree-l2"><a class="reference internal" href="powersum.html">Power sum symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="schur.html">Schur symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="symplectic.html">Symplectic Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf.html">Symmetric functions, with their multiple realizations</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="witt.html">Witt symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../shard_order.html">Shard intersection order</a></li>
<li class="toctree-l2"><a class="reference internal" href="../shifted_primed_tableau.html">Shifted primed tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../shuffle.html">Shuffle product of iterables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sidon_sets.html">Sidon sets and their generalizations, Sidon <span class="math notranslate nohighlight">\(g\)</span>-sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../similarity_class_type.html">Similarity class types of matrices with entries in a finite field</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sine_gordon.html">sine-Gordon Y-system plotter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../six_vertex_model.html">Six Vertex Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../skew_partition.html">Skew Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../skew_tableau.html">Skew Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sloane_functions.html">Functions that compute some of the sequences in Sloane’s tables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/all.html">Combinatorial species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/characteristic_species.html">Characteristic Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/composition_species.html">Composition species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/cycle_species.html">Cycle Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/empty_species.html">Empty Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/functorial_composition_species.html">Functorial composition species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/generating_series.html">Generating Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/library.html">Examples of Combinatorial Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/linear_order_species.html">Linear-order Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/misc.html">Miscellaneous Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/partition_species.html">Partition Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/permutation_species.html">Permutation species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/product_species.html">Product species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/recursive_species.html">Recursive Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/set_species.html">Set Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/species.html">Combinatorial Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/structure.html">Species structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/subset_species.html">Subset Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../species/sum_species.html">Sum species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../specht_module.html">Specht Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subset.html">Subsets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsets_hereditary.html">Subsets satisfying a hereditary property</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsets_pairwise.html">Subsets whose elements satisfy a predicate pairwise</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subword.html">Subwords</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subword_complex.html">Subword complex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../super_tableau.html">Super Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../superpartition.html">Super Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../symmetric_group_algebra.html">Symmetric Group Algebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../symmetric_group_representations.html">Representations of the Symmetric Group</a></li>
<li class="toctree-l2"><a class="reference internal" href="../t_sequences.html">T-sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tableau.html">Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tableau_residues.html">Residue sequences of tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tableau_tuple.html">TableauTuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tamari_lattices.html">Generalized Tamari lattices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tiling.html">Tiling Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tools.html">Transitive ideal closure tool</a></li>
<li class="toctree-l2"><a class="reference internal" href="../triangles_FHM.html">Combinatorial triangles for posets and fans</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tuple.html">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial.html">Introduction to combinatorics in Sage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vector_partition.html">Vector Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/abstract_word.html">Abstract word (finite or infinite)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/all.html">Combinatorics on words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/alphabet.html">Alphabet</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/finite_word.html">Finite word</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/infinite_word.html">Infinite word</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/lyndon_word.html">Lyndon words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/morphism.html">Word morphisms/substitutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/paths.html">Word paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/shuffle_product.html">Shuffle product of words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/suffix_trees.html">Suffix Tries and Suffix Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/word.html">Word classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/word_char.html">Fast word datatype using an array of unsigned char</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/word_datatypes.html">Datatypes for finite words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/word_generators.html">Common words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/word_infinite_datatypes.html">Datatypes for words defined by iterators and callables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/word_options.html">User-customizable options for words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../words/words.html">Set of words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../yang_baxter_graph.html">Yang-Baxter Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../rings/cfinite_sequence.html">C-Finite Sequences</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="symmetric-functions">
<span id="sage-combinat-sf-sfa"></span><h1>Symmetric Functions<a class="headerlink" href="#symmetric-functions" title="Permalink to this heading">#</a></h1>
<span class="target" id="module-sage.combinat.sf.sfa"></span><p>For a comprehensive tutorial on how to use symmetric functions in Sage</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="sf.html#sage.combinat.sf.sf.SymmetricFunctions" title="sage.combinat.sf.sf.SymmetricFunctions"><code class="xref py py-func docutils literal notranslate"><span class="pre">SymmetricFunctions()</span></code></a></p>
</div>
<p>We define the algebra of symmetric functions in the Schur and elementary bases:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">elementary</span><span class="p">()</span>
</pre></div>
</div>
<p>Each is actually a graded Hopf algebra whose basis is indexed by
integer partitions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of graded bases of Symmetric Functions over Rational Field</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">Partitions</span>
</pre></div>
</div>
<p>Let us compute with some elements in different bases:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f1</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span> <span class="n">f1</span>
<span class="go">s[2, 1]</span>
<span class="gp">sage: </span><span class="n">f2</span> <span class="o">=</span> <span class="n">e</span><span class="p">(</span><span class="n">f1</span><span class="p">);</span> <span class="n">f2</span> <span class="c1"># basis conversion</span>
<span class="go">e[2, 1] - e[3]</span>
<span class="gp">sage: </span><span class="n">f1</span> <span class="o">==</span> <span class="n">f2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f1</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">])</span>
<span class="go">x^2*y + x*y^2 + x^2*z + 2*x*y*z + y^2*z + x*z^2 + y*z^2</span>
<span class="gp">sage: </span><span class="n">f2</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">])</span>
<span class="go">x^2*y + x*y^2 + x^2*z + 2*x*y*z + y^2*z + x*z^2 + y*z^2</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">m[3, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># This is the constant 4, not the partition 4.</span>
<span class="go">4*m[]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="c1"># This is the partition 4.</span>
<span class="go">m[4]</span>
<span class="gp">sage: </span><span class="mi">3</span><span class="o">*</span><span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span>
<span class="go">3*m[3, 1] - 1/2*m[4]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">power</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">3*p[]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the powersum basis</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">+</span> <span class="n">p</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">3*p[] + p[3, 2]</span>
</pre></div>
</div>
<p>One can convert symmetric functions to symmetric polynomials and vice versa:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">powersum</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">homogeneous</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">poly</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">poly</span>
<span class="go">2*x0^4 + 2*x0^3*x1 + 2*x0*x1^3 + 2*x1^4 + 2*x0^3*x2 + 2*x1^3*x2 + 2*x0*x2^3 + 2*x1*x2^3 + 2*x2^4</span>
<span class="go">+ x0^3 + 2*x0^2*x1 + 2*x0*x1^2 + x1^3 + 2*x0^2*x2 + 3*x0*x1*x2 + 2*x1^2*x2 + 2*x0*x2^2 + 2*x1*x2^2 + x2^3</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">from_polynomial</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
<span class="go">3*m[1, 1, 1] + 2*m[2, 1] + m[3] + 2*m[3, 1] + 2*m[4]</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">from_polynomial</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">poly</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">from_polynomial</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">s[3, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">h[3, 1] - h[4]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1/8*p[1, 1, 1, 1] + 1/4*p[2, 1, 1] - 1/8*p[2, 2] - 1/4*p[4]</span>
<span class="gp">sage: </span><span class="n">e</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">e[2, 1, 1] - e[2, 2] - e[3, 1] + e[4]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3*m[1, 1, 1, 1] + 2*m[2, 1, 1] + m[2, 2] + m[3, 1]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">x0^3*x1 + x0^2*x1^2 + x0*x1^3 + x0^3*x2 + 2*x0^2*x1*x2 + 2*x0*x1^2*x2 + x1^3*x2 + x0^2*x2^2 + 2*x0*x1*x2^2 + x1^2*x2^2 + x0*x2^3 + x1*x2^3 + x0^3*x3 + 2*x0^2*x1*x3 + 2*x0*x1^2*x3 + x1^3*x3 + 2*x0^2*x2*x3 + 3*x0*x1*x2*x3 + 2*x1^2*x2*x3 + 2*x0*x2^2*x3 + 2*x1*x2^2*x3 + x2^3*x3 + x0^2*x3^2 + 2*x0*x1*x3^2 + x1^2*x3^2 + 2*x0*x2*x3^2 + 2*x1*x2*x3^2 + x2^2*x3^2 + x0*x3^3 + x1*x3^3 + x2*x3^3</span>
</pre></div>
</div>
<p>Here are further examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span><span class="p">(</span><span class="n">m</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">h[1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span> <span class="n">m</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span><span class="n">m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>
<span class="go">h[2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span> <span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span> <span class="o">+</span> <span class="n">m</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>
<span class="go">h[3]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span> <span class="n">m</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="o">+</span> <span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">m</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">m</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>
<span class="go">h[4]</span>
<span class="gp">sage: </span><span class="n">k</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span> <span class="nb">sum</span><span class="p">([</span> <span class="n">m</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">k</span><span class="p">)])</span> <span class="p">)</span>
<span class="go">h[5]</span>
<span class="gp">sage: </span><span class="n">k</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span> <span class="nb">sum</span><span class="p">([</span> <span class="n">m</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">k</span><span class="p">)])</span> <span class="p">)</span>
<span class="go">h[10]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P3</span> <span class="o">=</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P3</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[3], [2, 1], [1, 1, 1]]</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">m</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">get_print_style</span><span class="p">()</span>
<span class="go">&#39;lex&#39;</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">m[1, 1, 1] + m[2, 1] + m[3]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s1">&#39;length&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">m[3] + m[2, 1] + m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s1">&#39;maximal_part&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">m[1, 1, 1] + m[2, 1] + m[3]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s1">&#39;lex&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*m[3, 1, 1, 1] + m[3, 2, 1] + 2*m[4, 1, 1] + m[4, 2] + m[5, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[2, 1, 1, 1, 1] - s[2, 2, 2] - s[3, 3] + s[5, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">s[2, 1, 1, 1, 1] - s[2, 2, 2] - s[3, 3] + s[5, 1]</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span><span class="o">*</span><span class="n">e</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="n">e</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">e[4, 3, 1]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">coefficient</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">length</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">support</span><span class="p">())</span>
<span class="go">[[1, 1, 1], [2, 1]]</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>AUTHORS:</p>
<ul class="simple">
<li><p>Mike Hansen (2007-06-15)</p></li>
<li><p>Nicolas M. Thiery (partial refactoring)</p></li>
<li><p>Mike Zabrocki, Anne Schilling (2012)</p></li>
<li><p>Darij Grinberg (2013) Sym over rings that are not characteristic 0</p></li>
</ul>
<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.FilteredSymmetricFunctionsBases">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.sf.sfa.</span></span><span class="sig-name descname"><span class="pre">FilteredSymmetricFunctionsBases</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parent_with_realization</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.FilteredSymmetricFunctionsBases" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/realizations.html#sage.categories.realizations.Category_realization_of_parent" title="(in Category Framework v10.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Category_realization_of_parent</span></code></a></p>
<p>The category of filtered bases of the ring of symmetric functions.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.FilteredSymmetricFunctionsBases.super_categories">
<span class="sig-name descname"><span class="pre">super_categories</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.FilteredSymmetricFunctionsBases.super_categories" title="Permalink to this definition">#</a></dt>
<dd><p>The super categories of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.sf.sfa</span> <span class="kn">import</span> <span class="n">FilteredSymmetricFunctionsBases</span>
<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bases</span> <span class="o">=</span> <span class="n">FilteredSymmetricFunctionsBases</span><span class="p">(</span><span class="n">Sym</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bases</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of bases of Symmetric Functions over Rational Field,</span>
<span class="go"> Category of commutative filtered hopf algebras with basis over Rational Field]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.GradedSymmetricFunctionsBases">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.sf.sfa.</span></span><span class="sig-name descname"><span class="pre">GradedSymmetricFunctionsBases</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parent_with_realization</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/realizations.html#sage.categories.realizations.Category_realization_of_parent" title="(in Category Framework v10.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Category_realization_of_parent</span></code></a></p>
<p>The category of graded bases of the ring of symmetric functions.</p>
<p>These are further required to have the property that the basis element
indexed by the empty partition is <span class="math notranslate nohighlight">\(1\)</span>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ElementMethods">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ElementMethods</span></span><a class="headerlink" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ElementMethods" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ElementMethods.degree_negation">
<span class="sig-name descname"><span class="pre">degree_negation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ElementMethods.degree_negation" title="Permalink to this definition">#</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the degree negation
automorphism of the ring of symmetric functions.</p>
<p>The degree negation is the automorphism which scales every
homogeneous element of degree <span class="math notranslate nohighlight">\(k\)</span> by <span class="math notranslate nohighlight">\((-1)^k\)</span> (for all <span class="math notranslate nohighlight">\(k\)</span>).</p>
<p>Calling <code class="docutils literal notranslate"><span class="pre">degree_negation(self)</span></code> is equivalent to calling
<code class="docutils literal notranslate"><span class="pre">self.parent().degree_negation(self)</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">m</span><span class="p">[[]]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">()</span>
<span class="go">-3*m[] + 5*m[1] + 4*m[1, 1] - 2*m[2, 1]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">();</span> <span class="n">x</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">m</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ElementMethods.degree_zero_coefficient">
<span class="sig-name descname"><span class="pre">degree_zero_coefficient</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ElementMethods.degree_zero_coefficient" title="Permalink to this definition">#</a></dt>
<dd><p>Return the degree zero coefficient of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">m</span><span class="p">[[]]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">degree_zero_coefficient</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ElementMethods.is_unit">
<span class="sig-name descname"><span class="pre">is_unit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ElementMethods.is_unit" title="Permalink to this definition">#</a></dt>
<dd><p>Return whether this element is a unit in the ring.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[[]])</span><span class="o">.</span><span class="n">is_unit</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">([]))</span><span class="o">.</span><span class="n">is_unit</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ParentMethods</span></span><a class="headerlink" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods.antipode_by_coercion">
<span class="sig-name descname"><span class="pre">antipode_by_coercion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods.antipode_by_coercion" title="Permalink to this definition">#</a></dt>
<dd><p>The antipode of <code class="docutils literal notranslate"><span class="pre">element</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">element</span></code> – element in a basis of the ring of symmetric functions</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">h</span><span class="p">([])</span> <span class="o">+</span> <span class="n">h</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="c1"># indirect doctest</span>
<span class="go">h[] - h[1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">s</span><span class="p">([])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">s[] - s[1] + s[1, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">p</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">-p[2] - p[3]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">e</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">e</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">e[1, 1] - e[1, 1, 1] - e[2] + 2*e[2, 1] - e[3]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">-f[3, 2, 1] - 4*f[3, 3] - 2*f[4, 2] - 2*f[5, 1] - 6*f[6]</span>
</pre></div>
</div>
<p>The antipode is an involution:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The antipode is an algebra homomorphism:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">23</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods.counit">
<span class="sig-name descname"><span class="pre">counit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods.counit" title="Permalink to this definition">#</a></dt>
<dd><p>Return the counit of <code class="docutils literal notranslate"><span class="pre">element</span></code>.</p>
<p>The counit is the constant term of <code class="docutils literal notranslate"><span class="pre">element</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">element</span></code> – element in a basis of the ring of symmetric functions</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">m</span><span class="p">[[]]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">counit</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods.degree_negation">
<span class="sig-name descname"><span class="pre">degree_negation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods.degree_negation" title="Permalink to this definition">#</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">element</span></code> under the degree negation
automorphism of the ring of symmetric functions.</p>
<p>The degree negation is the automorphism which scales every
homogeneous element of degree <span class="math notranslate nohighlight">\(k\)</span> by <span class="math notranslate nohighlight">\((-1)^k\)</span> (for all <span class="math notranslate nohighlight">\(k\)</span>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">element</span></code> – symmetric function written in <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">m</span><span class="p">[[]]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">-3*m[] + 5*m[1] + 4*m[1, 1] - 2*m[2, 1]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.super_categories">
<span class="sig-name descname"><span class="pre">super_categories</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.super_categories" title="Permalink to this definition">#</a></dt>
<dd><p>The super categories of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.sf.sfa</span> <span class="kn">import</span> <span class="n">GradedSymmetricFunctionsBases</span>
<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bases</span> <span class="o">=</span> <span class="n">GradedSymmetricFunctionsBases</span><span class="p">(</span><span class="n">Sym</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bases</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of filtered bases of Symmetric Functions over Rational Field,</span>
<span class="go"> Category of commutative graded hopf algebras with basis over Rational Field]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.sf.sfa.</span></span><span class="sig-name descname"><span class="pre">SymmetricFunctionAlgebra_generic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Sym</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">graded</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">CombinatorialFreeModule</span></code></a></p>
<p>Abstract base class for symmetric function algebras.</p>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>Most of the methods in this class are generic (manipulations of
morphisms, …) and should be generalized (or removed)</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.Element">
<span class="sig-name descname"><span class="pre">Element</span></span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.Element" title="Permalink to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricFunctionAlgebra_generic_Element</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.basis_name">
<span class="sig-name descname"><span class="pre">basis_name</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.basis_name" title="Permalink to this definition">#</a></dt>
<dd><p>Return the name of the basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This is used for output and, for the classical bases of
symmetric functions, to connect this basis with Symmetrica.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">basis_name</span><span class="p">()</span>
<span class="go">&#39;Schur&#39;</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">basis_name</span><span class="p">()</span>
<span class="go">&#39;powersum&#39;</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">basis_name</span><span class="p">()</span>
<span class="go">&#39;homogeneous&#39;</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">basis_name</span><span class="p">()</span>
<span class="go">&#39;elementary&#39;</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">basis_name</span><span class="p">()</span>
<span class="go">&#39;monomial&#39;</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">basis_name</span><span class="p">()</span>
<span class="go">&#39;forgotten&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.coproduct_by_coercion">
<span class="sig-name descname"><span class="pre">coproduct_by_coercion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.coproduct_by_coercion" title="Permalink to this definition">#</a></dt>
<dd><p>Return the coproduct of the element <code class="docutils literal notranslate"><span class="pre">elt</span></code> by coercion to
the Schur basis.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elt</span></code> – an instance of this basis</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The image of <code class="docutils literal notranslate"><span class="pre">elt</span></code> under the comultiplication (=coproduct)
of the coalgebra of symmetric functions. The result is an
element of the tensor squared of the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">m[] # m[3, 1, 1] + m[1] # m[3, 1] + m[1, 1] # m[3] + m[3] # m[1, 1] + m[3, 1] # m[1] + m[3, 1, 1] # m[]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">coproduct_by_coercion</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">m[] # m[2, 1] + m[1] # m[2] + m[2] # m[1] + m[2, 1] # m[]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">coproduct_by_coercion</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">m</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">McdH</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">McdH</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">McdH[] # McdH[2, 1] + ((q^2*t-1)/(q*t-1))*McdH[1] # McdH[1, 1] + ((q*t^2-1)/(q*t-1))*McdH[1] # McdH[2] + ((q^2*t-1)/(q*t-1))*McdH[1, 1] # McdH[1] + ((q*t^2-1)/(q*t-1))*McdH[2] # McdH[1] + McdH[2, 1] # McdH[]</span>
<span class="gp">sage: </span><span class="n">HLQp</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">Qp</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">HLQp</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">HLQp[] # HLQp[2, 1] + HLQp[1] # HLQp[1, 1] + HLQp[1] # HLQp[2] + HLQp[1, 1] # HLQp[1] + HLQp[2] # HLQp[1] + HLQp[2, 1] # HLQp[]</span>
<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">LLT</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">llt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">LLT</span><span class="o">.</span><span class="n">cospin</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">(t+1)*m[] # m[1, 1] + m[] # m[2] + (t+1)*m[1] # m[1] + (t+1)*m[1, 1] # m[] + m[2] # m[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">f[] # f[3] + f[3] # f[]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">f[] # f[3, 2, 1] + f[1] # f[3, 2] + f[2] # f[3, 1] + f[2, 1] # f[3] + f[3] # f[2, 1] + f[3, 1] # f[2] + f[3, 2] # f[1] + f[3, 2, 1] # f[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.dual_basis">
<span class="sig-name descname"><span class="pre">dual_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scalar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.dual_basis" title="Permalink to this definition">#</a></dt>
<dd><p>Return the dual basis of <code class="docutils literal notranslate"><span class="pre">self</span></code> with respect to the scalar
product <code class="docutils literal notranslate"><span class="pre">scalar</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">scalar</span></code> – A function <code class="docutils literal notranslate"><span class="pre">zee</span></code> from partitions to the base ring
which specifies the scalar product by <span class="math notranslate nohighlight">\(\langle p_{\lambda},
p_{\lambda} \rangle = \mathrm{zee}(\lambda)\)</span>. (Independently on the
function chosen, the power sum basis will always be orthogonal;
the function <code class="docutils literal notranslate"><span class="pre">scalar</span></code> only determines the norms of the basis
elements.) If <code class="docutils literal notranslate"><span class="pre">scalar</span></code> is None, then the standard (Hall) scalar
product is used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">scalar_name</span></code> – name of the scalar function</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prefix</span></code> – prefix used to display the basis</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The duals of the elementary symmetric functions with respect to the
Hall scalar product are the forgotten symmetric functions.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">dual_basis</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">);</span> <span class="n">f</span>
<span class="go">Dual basis to Symmetric Functions over Rational Field in the elementary basis with respect to the Hall scalar product</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span>
<span class="go">4*f[2, 2, 1, 1] + 6*f[2, 2, 2] + 2*f[3, 2, 1] + 2*f[3, 3] + 2*f[4, 1, 1] + f[4, 2]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">e</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">e</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Since the power-sum symmetric functions are orthogonal, their duals
with respect to the Hall scalar product are scalar multiples of
themselves.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">dual_basis</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;q&#39;</span><span class="p">);</span> <span class="n">q</span>
<span class="go">Dual basis to Symmetric Functions over Rational Field in the powersum basis with respect to the Hall scalar product</span>
<span class="gp">sage: </span><span class="n">q</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span>
<span class="go">4*q[2, 2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">q</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">q</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.from_polynomial">
<span class="sig-name descname"><span class="pre">from_polynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.from_polynomial" title="Permalink to this definition">#</a></dt>
<dd><p>Convert polynomial to a symmetric function in the monomial basis
and then to the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">poly</span></code> – a symmetric polynomial</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) boolean, specifies whether
the computation checks that the polynomial is indeed symmetric</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">homogeneous</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="p">([])</span> <span class="o">+</span> <span class="n">h</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">h</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">from_polynomial</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">h[] + h[2, 1] + h[3]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">([])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">g</span>
<span class="go">x0^2*x1 + x0*x1^2 + x0^2*x2 + 2*x0*x1*x2 + x1^2*x2 + x0*x2^2 + x1*x2^2 + 1</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">from_polynomial</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">s[] + s[2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.get_print_style">
<span class="sig-name descname"><span class="pre">get_print_style</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.get_print_style" title="Permalink to this definition">#</a></dt>
<dd><p>Return the value of the current print style for <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">get_print_style</span><span class="p">()</span>
<span class="go">&#39;lex&#39;</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s1">&#39;length&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">get_print_style</span><span class="p">()</span>
<span class="go">&#39;length&#39;</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s1">&#39;lex&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.prefix">
<span class="sig-name descname"><span class="pre">prefix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.prefix" title="Permalink to this definition">#</a></dt>
<dd><p>Return the prefix on the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">schur</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">schur</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">schur</span><span class="o">.</span><span class="n">prefix</span><span class="p">()</span>
<span class="go">&#39;s&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.product_by_coercion">
<span class="sig-name descname"><span class="pre">product_by_coercion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.product_by_coercion" title="Permalink to this definition">#</a></dt>
<dd><p>Return the product of elements <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> by coercion to
the Schur basis.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">left</span></code>, <code class="docutils literal notranslate"><span class="pre">right</span></code> – instances of this basis</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the product of <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> expressed in the basis <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">product_by_coercion</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">p[3, 2, 2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">product_by_coercion</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.set_print_style">
<span class="sig-name descname"><span class="pre">set_print_style</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.set_print_style" title="Permalink to this definition">#</a></dt>
<dd><p>Set the value of the current print style to <code class="docutils literal notranslate"><span class="pre">ps</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ps</span></code> – a string specifying the printing style</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">get_print_style</span><span class="p">()</span>
<span class="go">&#39;lex&#39;</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s1">&#39;length&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">get_print_style</span><span class="p">()</span>
<span class="go">&#39;length&#39;</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s1">&#39;lex&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.symmetric_function_ring">
<span class="sig-name descname"><span class="pre">symmetric_function_ring</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.symmetric_function_ring" title="Permalink to this definition">#</a></dt>
<dd><p>Return the family of symmetric functions associated to the
basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>returns an instance of the ring of symmetric functions</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">schur</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">schur</span><span class="o">.</span><span class="n">symmetric_function_ring</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field</span>
<span class="gp">sage: </span><span class="n">power</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">power</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">power</span><span class="o">.</span><span class="n">symmetric_function_ring</span><span class="p">()</span>
<span class="go">Symmetric Functions over Univariate Polynomial Ring in t over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.transition_matrix">
<span class="sig-name descname"><span class="pre">transition_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.transition_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Return the transition matrix between <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">basis</span></code> for the
homogeneous component of degree <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">basis</span></code> – a basis of the ring of symmetric functions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a nonnegative integer</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>a matrix of coefficients giving the expansion of the
homogeneous degree-<span class="math notranslate nohighlight">\(n\)</span> elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> in the
degree-<span class="math notranslate nohighlight">\(n\)</span> elements of <code class="docutils literal notranslate"><span class="pre">basis</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="go">[1 1 1 1 1 1 1]</span>
<span class="go">[0 1 1 2 2 3 4]</span>
<span class="go">[0 0 1 1 2 3 5]</span>
<span class="go">[0 0 0 1 1 3 6]</span>
<span class="go">[0 0 0 0 1 2 5]</span>
<span class="go">[0 0 0 0 0 1 4]</span>
<span class="go">[0 0 0 0 0 0 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[1]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">[ 1/4  1/3  1/8  1/4 1/24]</span>
<span class="go">[-1/4    0 -1/8  1/4  1/8]</span>
<span class="go">[   0 -1/3  1/4    0 1/12]</span>
<span class="go">[ 1/4    0 -1/8 -1/4  1/8]</span>
<span class="go">[-1/4  1/3  1/8 -1/4 1/24]</span>
<span class="gp">sage: </span><span class="n">StoP</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">5</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="n">s</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span>
<span class="go">5*s[1, 1, 1, 1] + s[3, 1] - s[4]</span>
<span class="gp">sage: </span><span class="n">mon</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">support</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mon</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">coeffs</span>
<span class="go">[5, 1, -1]</span>
<span class="gp">sage: </span><span class="n">mon</span>
<span class="go">[[1, 1, 1, 1], [3, 1], [4]]</span>
<span class="gp">sage: </span><span class="n">cm</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">cm</span> <span class="o">*</span> <span class="n">StoP</span>
<span class="go">[-7/4  4/3  3/8 -5/4 7/24]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">7/24*p[1, 1, 1, 1] - 5/4*p[2, 1, 1] + 3/8*p[2, 2] + 4/3*p[3, 1] - 7/4*p[4]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="n">e</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">[ 1 -1  0  1  0 -1  1]</span>
<span class="go">[ 1  0 -1  0  1  0 -1]</span>
<span class="go">[ 1 -1  1  0 -1  1 -1]</span>
<span class="go">[ 1  1 -1  0 -1  1  1]</span>
<span class="go">[ 1  0  1 -2  1  0  1]</span>
<span class="go">[ 1  2  1  0 -1 -2 -1]</span>
<span class="go">[ 1  4  5  6  5  4  1]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="n">e</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.sf.sfa.</span></span><span class="sig-name descname"><span class="pre">SymmetricFunctionAlgebra_generic_Element</span></span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../modules/sage/modules/with_basis/indexed_element.html#sage.modules.with_basis.indexed_element.IndexedFreeModuleElement" title="(in Modules v10.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">IndexedFreeModuleElement</span></code></a></p>
<p>Class of generic elements for the symmetric function algebra.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.arithmetic_product">
<span class="sig-name descname"><span class="pre">arithmetic_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.arithmetic_product" title="Permalink to this definition">#</a></dt>
<dd><p>Return the arithmetic product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> in the
basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The arithmetic product is a binary operation <span class="math notranslate nohighlight">\(\boxdot\)</span> on the
ring of symmetric functions which is bilinear in its two
arguments and satisfies</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[p_{\lambda} \boxdot p_{\mu} = \prod\limits_{i \geq 1, j \geq 1}
p_{\mathrm{lcm}(\lambda_i, \mu_j)}^{\mathrm{gcd}(\lambda_i, \mu_j)}\]</div>
</div>
<p>for any two partitions <span class="math notranslate nohighlight">\(\lambda = (\lambda_1, \lambda_2, \lambda_3,
\dots )\)</span> and <span class="math notranslate nohighlight">\(\mu = (\mu_1, \mu_2, \mu_3, \dots )\)</span> (where <span class="math notranslate nohighlight">\(p_{\nu}\)</span>
denotes the power-sum symmetric function indexed by the partition
<span class="math notranslate nohighlight">\(\nu\)</span>, and <span class="math notranslate nohighlight">\(p_i\)</span> denotes the <span class="math notranslate nohighlight">\(i\)</span>-th power-sum symmetric function).
This is enough to define the arithmetic product if the base ring
is torsion-free as a <span class="math notranslate nohighlight">\(\ZZ\)</span>-module; for all other cases the
arithmetic product is uniquely determined by requiring it to be
functorial in the base ring. See
<a class="reference external" href="http://mathoverflow.net/questions/138148/">http://mathoverflow.net/questions/138148/</a> for a discussion of
this arithmetic product.</p>
<p>If <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are two symmetric functions which are homogeneous
of degrees <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>, respectively, then <span class="math notranslate nohighlight">\(f \boxdot g\)</span> is
homogeneous of degree <span class="math notranslate nohighlight">\(ab\)</span>.</p>
<p>The arithmetic product is commutative and associative and has
unity <span class="math notranslate nohighlight">\(e_1 = p_1 = h_1\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the
same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<p>Arithmetic product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code>; this is a symmetric
function over the same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">arithmetic_product</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">s[1, 1, 1, 1] + 2*s[2, 2] + s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">arithmetic_product</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[2, 1, 1] + s[3, 1]</span>
</pre></div>
</div>
<p>The symmetric function <code class="docutils literal notranslate"><span class="pre">e[1]</span></code> is the unity for the arithmetic
product:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">arithmetic_product</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">==</span> <span class="n">e</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The arithmetic product is commutative:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">arithmetic_product</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">arithmetic_product</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>  <span class="c1"># long time (26s on sage.math, 2013)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The currently existing implementation of this function is
technically unsatisfactory. It distinguishes the case when the
base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra (in which case the arithmetic product
can be easily computed using the power sum basis) from the case
where it isn’t. In the latter, it does a computation using
universal coefficients, again distinguishing the case when it is
able to compute the “corresponding” basis of the symmetric function
algebra over <span class="math notranslate nohighlight">\(\QQ\)</span> (using the <code class="docutils literal notranslate"><span class="pre">corresponding_basis_over</span></code> hack)
from the case when it isn’t (in which case it transforms everything
into the Schur basis, which is slow).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.bernstein_creation_operator">
<span class="sig-name descname"><span class="pre">bernstein_creation_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.bernstein_creation_operator" title="Permalink to this definition">#</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the <span class="math notranslate nohighlight">\(n\)</span>-th Bernstein creation
operator.</p>
<p>Let <span class="math notranslate nohighlight">\(n\)</span> be an integer. The <span class="math notranslate nohighlight">\(n\)</span>-th Bernstein creation operator
<span class="math notranslate nohighlight">\(\mathbf{B}_n\)</span> is defined as the endomorphism of the space
<span class="math notranslate nohighlight">\(Sym\)</span> of symmetric functions which sends every <span class="math notranslate nohighlight">\(f\)</span> to</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\sum_{i \geq 0} (-1)^i h_{n+i} e_i^\perp,\]</div>
</div>
<p>where usual notations are in place (<span class="math notranslate nohighlight">\(h\)</span> stands for the complete
homogeneous symmetric functions, <span class="math notranslate nohighlight">\(e\)</span> for the elementary ones,
and <span class="math notranslate nohighlight">\(e_i^\perp\)</span> means skewing (<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.skew_by" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.skew_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">skew_by()</span></code></a>) by <span class="math notranslate nohighlight">\(e_i\)</span>).</p>
<p>This has been studied in <a class="reference internal" href="../ncsf_qsym/qsym.html#bbssz2012" id="id2"><span>[BBSSZ2012]</span></a>, section 2.2, where the
following rule is given for computing <span class="math notranslate nohighlight">\(\mathbf{B}_n\)</span> on a
Schur function: If <span class="math notranslate nohighlight">\((\alpha_1, \alpha_2, \ldots, \alpha_n)\)</span> is
an <span class="math notranslate nohighlight">\(n\)</span>-tuple of integers (positive or not), then</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathbf{B}_n s_{(\alpha_1, \alpha_2, \ldots, \alpha_n)}
= s_{(n, \alpha_1, \alpha_2, \ldots, \alpha_n)}.\]</div>
</div>
<p>Here, <span class="math notranslate nohighlight">\(s_{(\alpha_1, \alpha_2, \ldots, \alpha_n)}\)</span> is the
“Schur function” associated to the <span class="math notranslate nohighlight">\(n\)</span>-tuple
<span class="math notranslate nohighlight">\((\alpha_1, \alpha_2, \ldots, \alpha_n)\)</span>, and defined by
literally applying the Jacobi-Trudi identity, i.e., by</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[s_{(\alpha_1, \alpha_2, \ldots, \alpha_n)}
= \det \left( (h_{\alpha_i - i + j})_{i, j = 1, 2, \ldots, n} \right).\]</div>
</div>
<p>This notion of a Schur function clearly extends the classical
notion of Schur function corresponding to a partition, but is
easily reduced to the latter (in fact, for any <span class="math notranslate nohighlight">\(n\)</span>-tuple
<span class="math notranslate nohighlight">\(\alpha\)</span> of integers, one easily sees that <span class="math notranslate nohighlight">\(s_\alpha\)</span> is
either <span class="math notranslate nohighlight">\(0\)</span> or minus-plus a Schur function corresponding to a
partition; and it is easy to determine which of these is the
case and find the partition by a combinatorial algorithm).</p>
<p>EXAMPLES:</p>
<p>Let us check that what this method computes agrees with the
definition:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">bernstein_creation_by_def</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="c1"># `n`-th Bernstein creation operator applied to `f`</span>
<span class="gp">....: </span>    <span class="c1"># computed according to its definition.</span>
<span class="gp">....: </span>    <span class="n">res</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="n">res</span>
<span class="gp">....: </span>    <span class="n">max_degree</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">n</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="n">res</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">i</span> <span class="o">*</span> <span class="n">h</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">res</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">bernstein_creation_by_def</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">bernstein_creation_by_def</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">bernstein_creation_by_def</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="o">==</span> <span class="n">e</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Some examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">s[3, 3, 2]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">-s[2, 2, 2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">h[2, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">h[2, 1, 1] - h[2, 2] - h[3, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">-h[3, 1, 1] + h[3, 2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">-h[2, 2, 2] + h[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-h[3, 3, 1] + h[4, 2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.character_to_frobenius_image">
<span class="sig-name descname"><span class="pre">character_to_frobenius_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.character_to_frobenius_image" title="Permalink to this definition">#</a></dt>
<dd><p>Interpret <code class="docutils literal notranslate"><span class="pre">self</span></code> as a <span class="math notranslate nohighlight">\(GL_n\)</span> character and then take the Frobenius
image of this character of the permutation matrices <span class="math notranslate nohighlight">\(S_n\)</span> which
naturally sit inside of <span class="math notranslate nohighlight">\(GL_n\)</span>.</p>
<p>To know the value of this character at a permutation of cycle structure
<span class="math notranslate nohighlight">\(\rho\)</span> the symmetric function <code class="docutils literal notranslate"><span class="pre">self</span></code> is evaluated at the
eigenvalues of a permutation of cycle structure <span class="math notranslate nohighlight">\(\rho\)</span>.  The
Frobenius image is then defined as
<span class="math notranslate nohighlight">\(\sum_{\rho \vdash n} f[ \Xi_\rho ] p_\rho/z_\rho\)</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.eval_at_permutation_roots" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.eval_at_permutation_roots"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eval_at_permutation_roots()</span></code></a></p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a non-negative integer to interpret <code class="docutils literal notranslate"><span class="pre">self</span></code> as
a character of <span class="math notranslate nohighlight">\(GL_n\)</span></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>a symmetric function of degree <code class="docutils literal notranslate"><span class="pre">n</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">s[3, 1, 1] + s[4, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">s[2, 2, 1] + 2*s[3, 1, 1] + 2*s[3, 2] + 3*s[4, 1] + s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">s[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">s[2, 2] + 2*s[3, 1] + 2*s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">2*s[2, 2, 1] + s[3, 1, 1] + 4*s[3, 2] + 3*s[4, 1] + 2*s[5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.degree">
<span class="sig-name descname"><span class="pre">degree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.degree" title="Permalink to this definition">#</a></dt>
<dd><p>Return the degree of <code class="docutils literal notranslate"><span class="pre">self</span></code> (which is defined to be <span class="math notranslate nohighlight">\(0\)</span>
for the zero element).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.derivative_with_respect_to_p1">
<span class="sig-name descname"><span class="pre">derivative_with_respect_to_p1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.derivative_with_respect_to_p1" title="Permalink to this definition">#</a></dt>
<dd><p>Return the symmetric function obtained by taking the derivative of
<code class="docutils literal notranslate"><span class="pre">self</span></code> with respect to the power-sum symmetric function <span class="math notranslate nohighlight">\(p_1\)</span>
when the expansion of <code class="docutils literal notranslate"><span class="pre">self</span></code> in the power-sum basis is considered
as a polynomial in <span class="math notranslate nohighlight">\(p_k\)</span>’s (with <span class="math notranslate nohighlight">\(k \geq 1\)</span>).</p>
<p>This is the same as skewing <code class="docutils literal notranslate"><span class="pre">self</span></code> by the first power-sum symmetric
function <span class="math notranslate nohighlight">\(p_1\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – (default: 1) nonnegative integer which determines
which power of the derivative is taken</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">3*p[1, 1]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">3*p[1, 1]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">6*p[1]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">6*p[]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">s[2]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">s[1, 1] + s[2]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">s[1, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">s[]</span>
</pre></div>
</div>
<p>Let us check that taking the derivative with respect to <code class="docutils literal notranslate"><span class="pre">p[1]</span></code>
is equivalent to skewing by <code class="docutils literal notranslate"><span class="pre">p[1]</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p1</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.eval_at_permutation_roots">
<span class="sig-name descname"><span class="pre">eval_at_permutation_roots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.eval_at_permutation_roots" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluate at eigenvalues of a permutation matrix.</p>
<p>Evaluate a symmetric function at the eigenvalues of a permutation
matrix whose cycle structure is <code class="docutils literal notranslate"><span class="pre">rho</span></code>.  This computation is
computed by coercing to the power sum basis where the value may
be computed on the generators.</p>
<p>This function evaluates an element at the roots of unity</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\Xi_{\rho_1},\Xi_{\rho_2},\ldots,\Xi_{\rho_\ell}\]</div>
</div>
<p>where</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\Xi_{m} = 1,\zeta_m,\zeta_m^2,\ldots,\zeta_m^{m-1}\]</div>
</div>
<p>and <span class="math notranslate nohighlight">\(\zeta_m\)</span> is an <span class="math notranslate nohighlight">\(m\)</span> root of unity.
These roots of unity represent the eigenvalues of permutation
matrix with cycle structure <span class="math notranslate nohighlight">\(\rho\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rho</span></code> – a partition or a list of non-negative integers</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>an element of the base ring</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">eval_at_permutation_roots</span><span class="p">([</span><span class="mi">6</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">eval_at_permutation_roots</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">eval_at_permutation_roots</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">eval_at_permutation_roots</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">eval_at_permutation_roots</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">175</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">eval_at_permutation_roots</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.expand">
<span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphabet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.expand" title="Permalink to this definition">#</a></dt>
<dd><p>Expand the symmetric function <code class="docutils literal notranslate"><span class="pre">self</span></code> as a symmetric polynomial
in <code class="docutils literal notranslate"><span class="pre">n</span></code> variables.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a nonnegative integer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alphabet</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'x'</span></code>) a variable for the expansion</p></li>
</ul>
<p>OUTPUT:</p>
<p>A monomial expansion of <code class="docutils literal notranslate"><span class="pre">self</span></code> in the <span class="math notranslate nohighlight">\(n\)</span> variables
labelled <code class="docutils literal notranslate"><span class="pre">x0</span></code>, <code class="docutils literal notranslate"><span class="pre">x1</span></code>, …, <code class="docutils literal notranslate"><span class="pre">x{n-1}</span></code> (or just <code class="docutils literal notranslate"><span class="pre">x</span></code>
if <span class="math notranslate nohighlight">\(n = 1\)</span>), where <code class="docutils literal notranslate"><span class="pre">x</span></code> is <code class="docutils literal notranslate"><span class="pre">alphabet</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">jack</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">J</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">J</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">4*x0^2*x1 + 4*x0*x1^2 + 4*x0^2*x2 + 6*x0*x1*x2 + 4*x1^2*x2 + 4*x0*x2^2 + 4*x1*x2^2</span>
<span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">J</span><span class="p">([</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">J</span><span class="p">([]))</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.exponential_specialization">
<span class="sig-name descname"><span class="pre">exponential_specialization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.exponential_specialization" title="Permalink to this definition">#</a></dt>
<dd><p>Return the exponential specialization of a
symmetric function (when <span class="math notranslate nohighlight">\(q = 1\)</span>), or the
<span class="math notranslate nohighlight">\(q\)</span>-exponential specialization (when <span class="math notranslate nohighlight">\(q \neq 1\)</span>).</p>
<p>The <em>exponential specialization</em> <span class="math notranslate nohighlight">\(ex\)</span> at <span class="math notranslate nohighlight">\(t\)</span> is a
<span class="math notranslate nohighlight">\(K\)</span>-algebra homomorphism from the <span class="math notranslate nohighlight">\(K\)</span>-algebra of
symmetric functions to another <span class="math notranslate nohighlight">\(K\)</span>-algebra <span class="math notranslate nohighlight">\(R\)</span>.
It is defined whenever the base ring <span class="math notranslate nohighlight">\(K\)</span> is a
<span class="math notranslate nohighlight">\(\QQ\)</span>-algebra and <span class="math notranslate nohighlight">\(t\)</span> is an element of <span class="math notranslate nohighlight">\(R\)</span>.
The easiest way to define it is by specifying its
values on the powersum symmetric functions to be
<span class="math notranslate nohighlight">\(p_1 = t\)</span> and <span class="math notranslate nohighlight">\(p_n = 0\)</span> for <span class="math notranslate nohighlight">\(n &gt; 1\)</span>.
Equivalently, on the homogeneous functions it is
given by <span class="math notranslate nohighlight">\(ex(h_n) = t^n / n!\)</span>; see Proposition 7.8.4 of
<a class="reference internal" href="../../../../references/index.html#enumcomb2" id="id3"><span>[EnumComb2]</span></a>.</p>
<p>By analogy, the <span class="math notranslate nohighlight">\(q\)</span>-exponential specialization is a
<span class="math notranslate nohighlight">\(K\)</span>-algebra homomorphism from the <span class="math notranslate nohighlight">\(K\)</span>-algebra of
symmetric functions to another <span class="math notranslate nohighlight">\(K\)</span>-algebra <span class="math notranslate nohighlight">\(R\)</span> that
depends on two elements <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(q\)</span> of <span class="math notranslate nohighlight">\(R\)</span> for which
the elements <span class="math notranslate nohighlight">\(1 - q^i\)</span> for all positive integers <span class="math notranslate nohighlight">\(i\)</span>
are invertible.
It can be defined by specifying its values on the
complete homogeneous symmetric functions to be</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[ex_q(h_n) = t^n / [n]_q!,\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\([n]_q!\)</span> is the <span class="math notranslate nohighlight">\(q\)</span>-factorial.  Equivalently, for
<span class="math notranslate nohighlight">\(q \neq 1\)</span> and a homogeneous symmetric function <span class="math notranslate nohighlight">\(f\)</span> of
degree <span class="math notranslate nohighlight">\(n\)</span>, we have</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[ex_q(f) = (1-q)^n t^n ps_q(f),\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(ps_q(f)\)</span> is the stable principal specialization of <span class="math notranslate nohighlight">\(f\)</span>
(see <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.principal_specialization" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.principal_specialization"><code class="xref py py-meth docutils literal notranslate"><span class="pre">principal_specialization()</span></code></a>).
(See (7.29) in <a class="reference internal" href="../../../../references/index.html#enumcomb2" id="id4"><span>[EnumComb2]</span></a>.)</p>
<p>The limit of <span class="math notranslate nohighlight">\(ex_q\)</span> as <span class="math notranslate nohighlight">\(q \to 1\)</span> is <span class="math notranslate nohighlight">\(ex\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) – the value to use for <span class="math notranslate nohighlight">\(t\)</span>;
the default is to create a ring of polynomials in <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> (default: <span class="math notranslate nohighlight">\(1\)</span>) – the value to use for <span class="math notranslate nohighlight">\(q\)</span>.  If
<code class="docutils literal notranslate"><span class="pre">q</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, then a ring (or fraction field) of
polynomials in <code class="docutils literal notranslate"><span class="pre">q</span></code> is created.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">exponential_specialization</span><span class="p">()</span>
<span class="go">1/2*t^2</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">exponential_specialization</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1/2*t^2</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">exponential_specialization</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">(q/(q + 1))*t^2</span>
<span class="gp">sage: </span><span class="n">Qq</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s2">&quot;q&quot;</span><span class="p">);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Qq</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">exponential_specialization</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">)</span>
<span class="go">(q/(q + 1))*t^2</span>
<span class="gp">sage: </span><span class="n">Qt</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s2">&quot;t&quot;</span><span class="p">);</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Qt</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">exponential_specialization</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
<span class="go">1/2*t^2</span>
<span class="gp">sage: </span><span class="n">Qqt</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="s2">&quot;t&quot;</span><span class="p">]);</span> <span class="n">q</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Qqt</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">exponential_specialization</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
<span class="go">q*t^2/(q + 1)</span>

<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">homogeneous_degree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s2">&quot;q t&quot;</span><span class="p">)</span>
<span class="go">(q, t)</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">principal_specialization</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">^</span><span class="n">d</span><span class="o">*</span><span class="n">t</span><span class="o">^</span><span class="n">d</span><span class="p">))</span>
<span class="go">t^3/((q^2 + q + 1)*(q + 1))</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">exponential_specialization</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">))</span>
<span class="go">t^3/((q^2 + q + 1)*(q + 1))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.factor">
<span class="sig-name descname"><span class="pre">factor</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.factor" title="Permalink to this definition">#</a></dt>
<dd><p>Return the factorization of this symmetric function.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">((</span><span class="mi">5</span><span class="o">*</span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">(e[1] + e[2, 1] + 5*e[3]) * (7*e[2] + e[5, 1])</span>

<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">((</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span>
<span class="go">(-s[] + (-x)*s[2, 1] - s[3]) * ((-x*y)*s[] + (-3*y)*s[2] - s[4, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius">
<span class="sig-name descname"><span class="pre">frobenius</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius" title="Permalink to this definition">#</a></dt>
<dd><p>Return the image of the symmetric function <code class="docutils literal notranslate"><span class="pre">self</span></code> under the
<span class="math notranslate nohighlight">\(n\)</span>-th Frobenius operator.</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Frobenius operator <span class="math notranslate nohighlight">\(\mathbf{f}_n\)</span> is defined to be the
map from the ring of symmetric functions to itself that sends
every symmetric function <span class="math notranslate nohighlight">\(P(x_1, x_2, x_3, \ldots)\)</span> to
<span class="math notranslate nohighlight">\(P(x_1^n, x_2^n, x_3^n, \ldots)\)</span>. This operator <span class="math notranslate nohighlight">\(\mathbf{f}_n\)</span>
is a Hopf algebra endomorphism, and satisfies</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathbf{f}_n m_{(\lambda_1, \lambda_2, \lambda_3, \ldots)} =
m_{(n\lambda_1, n\lambda_2, n\lambda_3, \ldots)}\]</div>
</div>
<p>for every partition <span class="math notranslate nohighlight">\((\lambda_1, \lambda_2, \lambda_3, \ldots)\)</span>
(where <span class="math notranslate nohighlight">\(m\)</span> means the monomial basis). Moreover,
<span class="math notranslate nohighlight">\(\mathbf{f}_n (p_r) = p_{nr}\)</span> for every positive integer <span class="math notranslate nohighlight">\(r\)</span> (where
<span class="math notranslate nohighlight">\(p_k\)</span> denotes the <span class="math notranslate nohighlight">\(k\)</span>-th powersum symmetric function).</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Frobenius operator is also called the <span class="math notranslate nohighlight">\(n\)</span>-th
Frobenius endomorphism. It is not related to the Frobenius map
which connects the ring of symmetric functions with the
representation theory of the symmetric group.</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Frobenius operator is also the <span class="math notranslate nohighlight">\(n\)</span>-th Adams operator
of the <span class="math notranslate nohighlight">\(\Lambda\)</span>-ring of symmetric functions over the integers.</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Frobenius operator can also be described via plethysm:
Every symmetric function <span class="math notranslate nohighlight">\(P\)</span> satisfies
<span class="math notranslate nohighlight">\(\mathbf{f}_n(P) = p_n \circ P = P \circ p_n\)</span>,
where <span class="math notranslate nohighlight">\(p_n\)</span> is the <span class="math notranslate nohighlight">\(n\)</span>-th powersum symmetric function, and <span class="math notranslate nohighlight">\(\circ\)</span>
denotes (outer) plethysm.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a positive integer</p></li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the <span class="math notranslate nohighlight">\(n\)</span>-th Frobenius operator (on the ring of
symmetric functions) to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-s[3, 3] + s[4, 2] - s[5, 1] + s[6]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">m[12, 6, 3]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">p[12, 6, 3]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">h[4, 4] - 2*h[5, 3] + 2*h[6, 2] - 2*h[7, 1] + 2*h[8]</span>
</pre></div>
</div>
<p>The Frobenius endomorphisms are multiplicative:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># long time</span>
<span class="gp">....: </span>          <span class="o">==</span> <span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">....: </span>          <span class="o">==</span> <span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">....: </span>          <span class="o">==</span> <span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Being Hopf algebra endomorphisms, the Frobenius operators
commute with the antipode:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Testing the <span class="math notranslate nohighlight">\(\mathbf{f}_n(P) = p_n \circ P = P \circ p_n\)</span>
equality (over <span class="math notranslate nohighlight">\(\QQ\)</span>, since plethysm is currently not
defined over <span class="math notranslate nohighlight">\(\ZZ\)</span> in Sage):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">plethysm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)))</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>By Exercise 7.61 in Stanley’s EC2 <a class="reference internal" href="sf.html#sta" id="id5"><span>[STA]</span></a> (see the errata on his
website), <span class="math notranslate nohighlight">\(\mathbf{f}_n(h_m)\)</span> is a linear combination of
Schur polynomials (of straight shapes) using coefficients <span class="math notranslate nohighlight">\(0\)</span>,
<span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(-1\)</span> only; moreover, all partitions whose Schur
polynomials occur with coefficient <span class="math notranslate nohighlight">\(\neq 0\)</span> in this
combination have empty <span class="math notranslate nohighlight">\(n\)</span>-cores. Let us check this on
examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="p">(</span><span class="n">coeff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">....: </span>               <span class="ow">and</span> <span class="n">lam</span><span class="o">.</span><span class="n">core</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">Partition</span><span class="p">([])</span>
<span class="gp">....: </span>               <span class="k">for</span> <span class="n">lam</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">s</span><span class="p">([</span><span class="n">m</span><span class="p">])</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plethysm()</span></code></a></p>
</div>
<div class="admonition-todo admonition" id="id7">
<p class="admonition-title">Todo</p>
<p>This method is fast on the monomial and the powersum
bases, while all other bases get converted to the
monomial basis. For most bases, this is probably the
quickest way to do, but at least the Schur basis should
have a better option. (Quoting from Stanley’s EC2 <a class="reference internal" href="sf.html#sta" id="id6"><span>[STA]</span></a>:
“D. G. Duncan, J. London Math. Soc. 27 (1952), 235-236,
or Y. M. Chen, A. M. Garsia, and J. B. Remmel, Contemp.
Math. 34 (1984), 109-153”.)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.gcd">
<span class="sig-name descname"><span class="pre">gcd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.gcd" title="Permalink to this definition">#</a></dt>
<dd><p>Return the greatest common divisor with <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> – the other symmetric function</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="mi">7</span><span class="o">*</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">gcd</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">B</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="n">B</span><span class="o">*</span><span class="n">C</span><span class="p">)</span>
<span class="go">7*e[2] + e[5, 1]</span>

<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">gcd</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">e[2]</span>
<span class="gp">sage: </span><span class="n">gcd</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">p[2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.hl_creation_operator">
<span class="sig-name descname"><span class="pre">hl_creation_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.hl_creation_operator" title="Permalink to this definition">#</a></dt>
<dd><p>This is the vertex operator that generalizes Jing’s operator.</p>
<p>It is a linear operator that raises the degree by
<span class="math notranslate nohighlight">\(|\nu|\)</span>. This creation operator is a t-analogue of
multiplication by <code class="docutils literal notranslate"><span class="pre">s(nu)</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Proposition 5 in <a class="reference internal" href="#sz2001" id="id8"><span>[SZ2001]</span></a>.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nu</span></code> – a partition or a list of integers</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>, in which case <code class="docutils literal notranslate"><span class="pre">t</span></code> is used) an element
of the base ring</p></li>
</ul>
<p>REFERENCES:</p>
<div role="list" class="citation-list">
<div class="citation" id="sz2001" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">SZ2001</a><span class="fn-bracket">]</span></span>
<p>M. Shimozono, M. Zabrocki,
Hall-Littlewood vertex operators and generalized Kostka polynomials.
Adv. Math. 158 (2001), no. 1, 66-85.</p>
</div>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[3, 2, 2] + t*s[3, 3, 1] + t*s[4, 2, 1] + t^2*s[4, 3] + t^2*s[5, 2]</span>

<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">HLQp</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">Qp</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">HLQp</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">HLQp[3, 2, 2]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">t*s[2, 2, 2, 1] + t^2*s[3, 2, 1, 1] + t^2*s[3, 2, 2] + t^3*s[3, 3, 1] + t^3*s[4, 2, 1] + t^4*s[4, 3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">(t^2-t)*s[2, 2, 2, 2, 1] + t^3*s[3, 2, 2, 1, 1]</span>
<span class="go"> + (t^3-t^2)*s[3, 2, 2, 2] + t^3*s[3, 3, 1, 1, 1]</span>
<span class="go"> + t^4*s[3, 3, 2, 1] + t^3*s[4, 2, 1, 1, 1] + t^4*s[4, 2, 2, 1]</span>
<span class="go"> + 2*t^4*s[4, 3, 1, 1] + t^5*s[4, 3, 2] + t^5*s[4, 4, 1]</span>
<span class="go"> + t^4*s[5, 2, 1, 1] + t^5*s[5, 3, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="go">(-t^2+t)*s[1, 1, 1] + (-t^2+1)*s[2, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: nu must be a list of integers</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">s[3, 2] + t*s[4, 1] + t^2*s[5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_plethysm">
<span class="sig-name descname"><span class="pre">inner_plethysm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_plethysm" title="Permalink to this definition">#</a></dt>
<dd><p>Return the inner plethysm of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>Whenever <span class="math notranslate nohighlight">\(R\)</span> is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra, and <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are two
symmetric functions over <span class="math notranslate nohighlight">\(R\)</span> such that the constant term of <span class="math notranslate nohighlight">\(f\)</span>
is zero, the inner plethysm of <span class="math notranslate nohighlight">\(f\)</span> with <span class="math notranslate nohighlight">\(g\)</span> is a symmetric
function over <span class="math notranslate nohighlight">\(R\)</span>, and the degree of this symmetric function is
the same as the degree of <span class="math notranslate nohighlight">\(g\)</span>. We will denote the inner plethysm
of <span class="math notranslate nohighlight">\(f\)</span> with <span class="math notranslate nohighlight">\(g\)</span> by <span class="math notranslate nohighlight">\(f \{ g \}\)</span> (in contrast to the notation of
outer plethysm which is generally denoted <span class="math notranslate nohighlight">\(f [ g ]\)</span>); in Sage
syntax, it is <code class="docutils literal notranslate"><span class="pre">f.inner_plethysm(g)</span></code>.</p>
<p>First we describe the axiomatic definition of the operation; see
below for a representation-theoretic interpretation.
In the following equations, we denote the outer product
(i.e., the standard product on the ring of symmetric functions,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">product()</span></code>)
by <span class="math notranslate nohighlight">\(\cdot\)</span> and the Kronecker product (<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itensor()</span></code></a>) by <span class="math notranslate nohighlight">\(\ast\)</span>).</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}(f + g) \{ h \} = f \{ h \} + g \{ h \}\\(f \cdot g) \{ h \} = (f \{ h \}) \ast (g \{ h \})\\p_k \{ f + g \} = p_k \{ f \} + p_k \{ g \}\end{aligned}\end{align} \]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(p_k\)</span> is the <span class="math notranslate nohighlight">\(k\)</span>-th power-sum symmetric function for every
<span class="math notranslate nohighlight">\(k &gt; 0\)</span>.</p>
<p>Let <span class="math notranslate nohighlight">\(\sigma\)</span> be a permutation of cycle type <span class="math notranslate nohighlight">\(\mu\)</span> and let <span class="math notranslate nohighlight">\(\mu^k\)</span>
be the cycle type of <span class="math notranslate nohighlight">\(\sigma^k\)</span>. Then,</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[p_k \{ p_\mu/z_\mu \} = \sum_{\nu : \nu^k = \mu } p_{\nu}/z_{\nu}\]</div>
</div>
<p>Since <span class="math notranslate nohighlight">\((p_\mu/z_\mu)_{\mu}\)</span> is a basis for the symmetric
functions, these four formulas define the symmetric function
operation <span class="math notranslate nohighlight">\(f \{ g \}\)</span> for any symmetric functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>
(where <span class="math notranslate nohighlight">\(f\)</span> has constant term <span class="math notranslate nohighlight">\(0\)</span>) by expanding <span class="math notranslate nohighlight">\(f\)</span> in the
power sum basis and <span class="math notranslate nohighlight">\(g\)</span> in the dual basis <span class="math notranslate nohighlight">\(p_\mu/z_\mu\)</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itensor()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">partition_power()</span></code>,
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plethysm()</span></code></a></p>
</div>
<p>This operation admits a representation-theoretic interpretation
in the case where <span class="math notranslate nohighlight">\(f\)</span> is a Schur function <span class="math notranslate nohighlight">\(s_\lambda\)</span> and
<span class="math notranslate nohighlight">\(g\)</span> is a homogeneous degree <span class="math notranslate nohighlight">\(n\)</span> symmetric function with
nonnegative integral coefficients in the Schur basis.
The symmetric function <span class="math notranslate nohighlight">\(f \{ g \}\)</span> is the Frobenius
image of the <span class="math notranslate nohighlight">\(S_n\)</span>-representation constructed as follows.</p>
<p>The assumptions on <span class="math notranslate nohighlight">\(g\)</span> imply that <span class="math notranslate nohighlight">\(g\)</span> is the Frobenius image of a
representation <span class="math notranslate nohighlight">\(\rho\)</span> of the symmetric group <span class="math notranslate nohighlight">\(S_n\)</span>:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\rho : S_n \to GL_N.\]</div>
</div>
<p>If the degree <span class="math notranslate nohighlight">\(N\)</span> of this representation is greater than or equal
to the number of parts of <span class="math notranslate nohighlight">\(\lambda\)</span>, then <span class="math notranslate nohighlight">\(f\)</span>, which denotes <span class="math notranslate nohighlight">\(s_\lambda\)</span>,
corresponds to the character of some irreducible <span class="math notranslate nohighlight">\(GL_N\)</span>-representation, say</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\sigma : GL_N \to GL_M.\]</div>
</div>
<p>The composition <span class="math notranslate nohighlight">\(\sigma \circ \rho : S_n \to GL_M\)</span> is a representation
of <span class="math notranslate nohighlight">\(S_n\)</span> whose Frobenius image is precisely <span class="math notranslate nohighlight">\(f \{ g \}\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(N\)</span> is less than the number of parts of <span class="math notranslate nohighlight">\(\lambda\)</span>,
then <span class="math notranslate nohighlight">\(f \{ g \}\)</span> is <span class="math notranslate nohighlight">\(0\)</span> by definition.</p>
<p>When <span class="math notranslate nohighlight">\(f\)</span> is a symmetric function with constant term <span class="math notranslate nohighlight">\(\neq 0\)</span>, the
inner plethysm <span class="math notranslate nohighlight">\(f \{ g \}\)</span> isn’t well-defined in the ring of
symmetric functions. Indeed, it is not clear how to define
<span class="math notranslate nohighlight">\(1 \{ g \}\)</span>. The most sensible way to get around this probably is
defining it as the infinite sum <span class="math notranslate nohighlight">\(h_0 + h_1 + h_2 + \cdots\)</span> (where
<span class="math notranslate nohighlight">\(h_i\)</span> means the <span class="math notranslate nohighlight">\(i\)</span>-th complete homogeneous symmetric function)
in the completion of this ring with respect to its grading. This is
how <a class="reference internal" href="#schathi1994" id="id9"><span>[SchaThi1994]</span></a> defines <span class="math notranslate nohighlight">\(1 \{ g \}\)</span>. The present method,
however, sets it to be the sum of <span class="math notranslate nohighlight">\(h_i\)</span> over all <span class="math notranslate nohighlight">\(i\)</span> for which the
<span class="math notranslate nohighlight">\(i\)</span>-th homogeneous component of <span class="math notranslate nohighlight">\(g\)</span> is nonzero. This is rather a
hack than a reasonable definition. Use with caution!</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If a symmetric function <span class="math notranslate nohighlight">\(g\)</span> is written in the form
<span class="math notranslate nohighlight">\(g = g_0 + g_1 + g_2 + \cdots\)</span> with each <span class="math notranslate nohighlight">\(g_i\)</span> homogeneous
of degree <span class="math notranslate nohighlight">\(i\)</span>, then
<span class="math notranslate nohighlight">\(f \{ g \} = f \{ g_0 \} + f \{ g_1 \} + f \{ g_2 \} + \cdots\)</span>
for every <span class="math notranslate nohighlight">\(f\)</span> with constant term <span class="math notranslate nohighlight">\(0\)</span>. But in general, inner
plethysm is not linear in the second variable.</p>
</div>
<p>REFERENCES:</p>
<div role="list" class="citation-list">
<div class="citation" id="king" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>King<span class="fn-bracket">]</span></span>
<p>King, R. Branching rules for <span class="math notranslate nohighlight">\(GL_m \supset \Sigma_n\)</span>
and the evaluation of inner plethysms.
J. Math. Phys. 15, 258 (1974) <a class="reference external" href="https://doi.org/10.1063/1.1666632">doi:10.1063/1.1666632</a></p>
</div>
<div class="citation" id="schathi1994" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">SchaThi1994</a><span class="fn-bracket">]</span></span>
<p>Thomas Scharf, Jean-Yves Thibon.
<em>A Hopf-algebra approach to inner plethysm</em>.
Advances in Mathematics 104 (1994), pp. 30-58.
<a class="reference external" href="ftp://ftp.mathe2.uni-bayreuth.de/axel/papers/scharf:a_hopf_algebra_approach_to_inner_plethysm.ps.gz">ftp://ftp.mathe2.uni-bayreuth.de/axel/papers/scharf:a_hopf_algebra_approach_to_inner_plethysm.ps.gz</a></p>
</div>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the same
base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>an element of symmetric functions in the parent of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">power</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[2, 1] + s[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">inner_tensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1] + s[2, 1] + s[3]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">s[1, 1, 1] + s[2, 1] + 4*s[2, 1, 1] + 4*s[2, 2] + s[3] + 4*s[3, 1] + 4*s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">)</span>
<span class="go">s[1, 1, 1] + s[2, 1] + 4*s[2, 1, 1] + 4*s[2, 2] + s[3] + 4*s[3, 1] + 4*s[4]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="p">([])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">s[2] + s[3]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">s</span><span class="p">([])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">la</span><span class="p">))</span> <span class="k">for</span> <span class="n">la</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
<span class="go">[s[4], s[4], s[4], s[4], s[4]]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">([]))</span>
<span class="go">s[]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[3]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">p[1, 1, 1] + 2*p[3]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">24</span><span class="p">)</span>
<span class="go">1/24*p[1, 1, 1, 1] + 1/4*p[2, 1, 1] + 1/8*p[2, 2] + 1/4*p[4]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">6*p[1, 1, 1] + 12*p[3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor">
<span class="sig-name descname"><span class="pre">inner_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor" title="Permalink to this definition">#</a></dt>
<dd><p>Return the internal (tensor) product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> in the
basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The internal tensor product can be defined as the linear extension
of the definition on power sums
<span class="math notranslate nohighlight">\(p_{\lambda} \ast p_{\mu} = \delta_{\lambda,\mu} z_{\lambda}
p_{\lambda}\)</span>, where <span class="math notranslate nohighlight">\(z_{\lambda} = (1^{r_1} r_1!) (2^{r_2} r_2!)
\cdots\)</span> for <span class="math notranslate nohighlight">\(\lambda = (1^{r_1} 2^{r_2} \cdots )\)</span> and where <span class="math notranslate nohighlight">\(\ast\)</span>
denotes the internal tensor product.
The internal tensor product is also known as the Kronecker product,
or as the second multiplication on the ring of symmetric functions.</p>
<p>Note that the internal product of any two homogeneous symmetric
functions of equal degrees is a homogeneous symmetric function of the
same degree. On the other hand, the internal product of two homogeneous
symmetric functions of distinct degrees is <span class="math notranslate nohighlight">\(0\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The internal product is sometimes referred to as “inner product”
in the literature, but unfortunately this name is shared by a
different operation, namely the Hall inner product
(see <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scalar()</span></code></a>).</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the
same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the internal product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code> (an element of the
ring of symmetric functions in the same basis as <code class="docutils literal notranslate"><span class="pre">self</span></code>)</p></li>
</ul>
<p>The methods <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itensor()</span></code></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product()</span></code></a>,
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kronecker_product()</span></code></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">inner_tensor()</span></code></a> are all
synonyms.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">s[2, 1]</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">s[1, 1, 1, 1, 1, 1] + 2*s[2, 1, 1, 1, 1] + 3*s[2, 2, 1, 1] + 2*s[2, 2, 2]</span>
<span class="go"> + 4*s[3, 1, 1, 1] + 5*s[3, 2, 1] + 2*s[3, 3] + 4*s[4, 1, 1]</span>
<span class="go"> + 3*s[4, 2] + 2*s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>There are few quantitative results pertaining to Kronecker products
in general, which makes their computation so difficult. Let us test
a few of them in different bases.</p>
<p>The Kronecker product of any homogeneous symmetric function <span class="math notranslate nohighlight">\(f\)</span> of
degree <span class="math notranslate nohighlight">\(n\)</span> with the <span class="math notranslate nohighlight">\(n\)</span>-th complete homogeneous symmetric function
<code class="docutils literal notranslate"><span class="pre">h[n]</span></code> (a.k.a. <code class="docutils literal notranslate"><span class="pre">s[n]</span></code>) is <span class="math notranslate nohighlight">\(f\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product of a Schur function <span class="math notranslate nohighlight">\(s_{\lambda}\)</span> with the <span class="math notranslate nohighlight">\(n\)</span>-th
elementary symmetric function <code class="docutils literal notranslate"><span class="pre">e[n]</span></code>, where <span class="math notranslate nohighlight">\(n = \left| \lambda
\right|\)</span>, is <span class="math notranslate nohighlight">\(s_{\lambda'}\)</span> (where <span class="math notranslate nohighlight">\(\lambda'\)</span> is the conjugate
partition of <span class="math notranslate nohighlight">\(\lambda\)</span>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product is commutative:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">mq</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">mh</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">==</span> <span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>   <span class="c1"># long time</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us check (on examples) Proposition 5.2 of Gelfand, Krob, Lascoux, Leclerc,
Retakh, Thibon, “Noncommutative symmetric functions”, <a class="reference external" href="https://arxiv.org/abs/hep-th/9407124">arXiv hep-th/9407124</a>, for
<span class="math notranslate nohighlight">\(r = 2\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_copr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>  <span class="c1"># computes \mu ((u \otimes v) * \Delta(w)) with</span>
<span class="gp">....: </span>                           <span class="c1"># * meaning Kronecker product and \mu meaning the</span>
<span class="gp">....: </span>                           <span class="c1"># usual multiplication.</span>
<span class="gp">....: </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">partition_pair</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">w</span><span class="o">.</span><span class="n">coproduct</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">result</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">result</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_copr</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>   <span class="c1"># long time</span>
<span class="gp">....: </span>               <span class="o">==</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
<span class="gp">....: </span>               <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Some examples from Briand, Orellana, Rosas, “The stability of the Kronecker
products of Schur functions.” <a class="reference external" href="https://arxiv.org/abs/0907.4652">arXiv 0907.4652</a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[1, 1, 1, 1] + s[2, 2] + s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 1, 1, 1] + s[2, 2, 1] + s[3, 1, 1] + s[3, 2] + s[4, 1] + s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 2, 2] + s[3, 1, 1, 1] + 2*s[3, 2, 1] + s[4, 1, 1] + 2*s[4, 2] + s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>An example from p. 220 of Thibon, “Hopf algebras of symmetric functions
and tensor products of symmetric group representations”, International
Journal of Algebra and Computation, 1991:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQbar</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1] + s[2, 1] + s[3]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The currently existing implementation of this function is
technically unsatisfactory. It distinguishes the case when the
base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra (in which case the Kronecker product
can be easily computed using the power sum basis) from the case
where it isn’t. In the latter, it does a computation using
universal coefficients, again distinguishing the case when it is
able to compute the “corresponding” basis of the symmetric function
algebra over <span class="math notranslate nohighlight">\(\QQ\)</span> (using the <code class="docutils literal notranslate"><span class="pre">corresponding_basis_over</span></code> hack)
from the case when it isn’t (in which case it transforms everything
into the Schur basis, which is slow).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_coproduct">
<span class="sig-name descname"><span class="pre">internal_coproduct</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_coproduct" title="Permalink to this definition">#</a></dt>
<dd><p>Return the inner coproduct of <code class="docutils literal notranslate"><span class="pre">self</span></code> in the basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The inner coproduct (also known as the Kronecker coproduct, as the
internal coproduct, or as the second comultiplication on the ring of
symmetric functions) is a ring homomorphism <span class="math notranslate nohighlight">\(\Delta^\times\)</span> from the
ring of symmetric functions to the tensor product (over the base
ring) of this ring with itself. It is uniquely characterized by the
formula</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\Delta^{\times}(h_n) = \sum_{\lambda \vdash n} s_{\lambda}
\otimes s_{\lambda} = \sum_{\lambda \vdash n} h_{\lambda} \otimes
m_{\lambda} = \sum_{\lambda \vdash n} m_{\lambda} \otimes
h_{\lambda},\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\lambda \vdash n\)</span> means <span class="math notranslate nohighlight">\(\lambda\)</span> is a partition of <span class="math notranslate nohighlight">\(n\)</span>, and
<span class="math notranslate nohighlight">\(n\)</span> is any nonnegative integer. It also satisfies</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\Delta^\times (p_n) = p_n \otimes p_n\]</div>
</div>
<p>for any positive integer <span class="math notranslate nohighlight">\(n\)</span>. If the base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra, it
also satisfies</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\Delta^{\times}(h_n) = \sum_{\lambda \vdash n} z_{\lambda}^{-1}
p_{\lambda} \otimes p_{\lambda},\]</div>
</div>
<p>where</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[z_{\lambda} = \prod_{i=1}^\infty i^{m_i(\lambda)} m_i(\lambda)!\]</div>
</div>
<p>with <span class="math notranslate nohighlight">\(m_i(\lambda)\)</span> meaning the number of appearances of <span class="math notranslate nohighlight">\(i\)</span>
in <span class="math notranslate nohighlight">\(\lambda\)</span> (see <a class="reference internal" href="#sage.combinat.sf.sfa.zee" title="sage.combinat.sf.sfa.zee"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zee()</span></code></a>).</p>
<p>The method <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_coproduct" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_coproduct"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kronecker_coproduct()</span></code></a> is a synonym of
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_coproduct" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_coproduct"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_coproduct()</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="go">s[1, 1, 1] # s[2, 1] + s[2, 1] # s[1, 1, 1] + s[2, 1] # s[2, 1] + s[2, 1] # s[3] + s[3] # s[2, 1]</span>

<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="go">e[1, 1] # e[2] + e[2] # e[1, 1] - 2*e[2] # e[2]</span>
</pre></div>
</div>
<p>The internal coproduct is adjoint to the internal product with respect
to the Hall inner product: Any three symmetric functions <span class="math notranslate nohighlight">\(f\)</span>, <span class="math notranslate nohighlight">\(g\)</span> and
<span class="math notranslate nohighlight">\(h\)</span> satisfy <span class="math notranslate nohighlight">\(\langle f * g, h \rangle = \sum_i \langle f, h^{\prime}_i
\rangle \langle g, h^{\prime\prime}_i \rangle\)</span>, where we write
<span class="math notranslate nohighlight">\(\Delta^{\times}(h)\)</span> as <span class="math notranslate nohighlight">\(\sum_i h^{\prime}_i \otimes
h^{\prime\prime}_i\)</span>. Let us check this in degree <span class="math notranslate nohighlight">\(4\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_incopr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>  <span class="c1"># computes \sum_i \left&lt; f, h&#39;_i \right&gt; \left&lt; g, h&#39;&#39;_i \right&gt;</span>
<span class="gp">....: </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">partition_pair</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">result</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">h</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">h</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">result</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_incopr</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>  <span class="c1"># long time (10s on sage.math, 2013)</span>
<span class="gp">....: </span>               <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us check the formulas for <span class="math notranslate nohighlight">\(\Delta^{\times}(h_n)\)</span> and
<span class="math notranslate nohighlight">\(\Delta^{\times}(p_n)\)</span> given in the description of this method:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">h</span><span class="p">([</span><span class="n">n</span><span class="p">]))</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">tensor</span><span class="p">([</span><span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">),</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)])</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">tensor</span><span class="p">([</span><span class="n">h</span><span class="p">(</span><span class="n">lam</span><span class="p">),</span> <span class="n">h</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">))])</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">h</span><span class="p">([</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">lam</span><span class="o">.</span><span class="n">conjugacy_class_size</span><span class="p">()</span> <span class="o">*</span> <span class="n">tensor</span><span class="p">([</span><span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)),</span> <span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">))])</span>
<span class="gp">....: </span>             <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product">
<span class="sig-name descname"><span class="pre">internal_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product" title="Permalink to this definition">#</a></dt>
<dd><p>Return the internal (tensor) product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> in the
basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The internal tensor product can be defined as the linear extension
of the definition on power sums
<span class="math notranslate nohighlight">\(p_{\lambda} \ast p_{\mu} = \delta_{\lambda,\mu} z_{\lambda}
p_{\lambda}\)</span>, where <span class="math notranslate nohighlight">\(z_{\lambda} = (1^{r_1} r_1!) (2^{r_2} r_2!)
\cdots\)</span> for <span class="math notranslate nohighlight">\(\lambda = (1^{r_1} 2^{r_2} \cdots )\)</span> and where <span class="math notranslate nohighlight">\(\ast\)</span>
denotes the internal tensor product.
The internal tensor product is also known as the Kronecker product,
or as the second multiplication on the ring of symmetric functions.</p>
<p>Note that the internal product of any two homogeneous symmetric
functions of equal degrees is a homogeneous symmetric function of the
same degree. On the other hand, the internal product of two homogeneous
symmetric functions of distinct degrees is <span class="math notranslate nohighlight">\(0\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The internal product is sometimes referred to as “inner product”
in the literature, but unfortunately this name is shared by a
different operation, namely the Hall inner product
(see <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scalar()</span></code></a>).</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the
same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the internal product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code> (an element of the
ring of symmetric functions in the same basis as <code class="docutils literal notranslate"><span class="pre">self</span></code>)</p></li>
</ul>
<p>The methods <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itensor()</span></code></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product()</span></code></a>,
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kronecker_product()</span></code></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">inner_tensor()</span></code></a> are all
synonyms.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">s[2, 1]</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">s[1, 1, 1, 1, 1, 1] + 2*s[2, 1, 1, 1, 1] + 3*s[2, 2, 1, 1] + 2*s[2, 2, 2]</span>
<span class="go"> + 4*s[3, 1, 1, 1] + 5*s[3, 2, 1] + 2*s[3, 3] + 4*s[4, 1, 1]</span>
<span class="go"> + 3*s[4, 2] + 2*s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>There are few quantitative results pertaining to Kronecker products
in general, which makes their computation so difficult. Let us test
a few of them in different bases.</p>
<p>The Kronecker product of any homogeneous symmetric function <span class="math notranslate nohighlight">\(f\)</span> of
degree <span class="math notranslate nohighlight">\(n\)</span> with the <span class="math notranslate nohighlight">\(n\)</span>-th complete homogeneous symmetric function
<code class="docutils literal notranslate"><span class="pre">h[n]</span></code> (a.k.a. <code class="docutils literal notranslate"><span class="pre">s[n]</span></code>) is <span class="math notranslate nohighlight">\(f\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product of a Schur function <span class="math notranslate nohighlight">\(s_{\lambda}\)</span> with the <span class="math notranslate nohighlight">\(n\)</span>-th
elementary symmetric function <code class="docutils literal notranslate"><span class="pre">e[n]</span></code>, where <span class="math notranslate nohighlight">\(n = \left| \lambda
\right|\)</span>, is <span class="math notranslate nohighlight">\(s_{\lambda'}\)</span> (where <span class="math notranslate nohighlight">\(\lambda'\)</span> is the conjugate
partition of <span class="math notranslate nohighlight">\(\lambda\)</span>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product is commutative:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">mq</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">mh</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">==</span> <span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>   <span class="c1"># long time</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us check (on examples) Proposition 5.2 of Gelfand, Krob, Lascoux, Leclerc,
Retakh, Thibon, “Noncommutative symmetric functions”, <a class="reference external" href="https://arxiv.org/abs/hep-th/9407124">arXiv hep-th/9407124</a>, for
<span class="math notranslate nohighlight">\(r = 2\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_copr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>  <span class="c1"># computes \mu ((u \otimes v) * \Delta(w)) with</span>
<span class="gp">....: </span>                           <span class="c1"># * meaning Kronecker product and \mu meaning the</span>
<span class="gp">....: </span>                           <span class="c1"># usual multiplication.</span>
<span class="gp">....: </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">partition_pair</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">w</span><span class="o">.</span><span class="n">coproduct</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">result</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">result</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_copr</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>   <span class="c1"># long time</span>
<span class="gp">....: </span>               <span class="o">==</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
<span class="gp">....: </span>               <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Some examples from Briand, Orellana, Rosas, “The stability of the Kronecker
products of Schur functions.” <a class="reference external" href="https://arxiv.org/abs/0907.4652">arXiv 0907.4652</a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[1, 1, 1, 1] + s[2, 2] + s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 1, 1, 1] + s[2, 2, 1] + s[3, 1, 1] + s[3, 2] + s[4, 1] + s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 2, 2] + s[3, 1, 1, 1] + 2*s[3, 2, 1] + s[4, 1, 1] + 2*s[4, 2] + s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>An example from p. 220 of Thibon, “Hopf algebras of symmetric functions
and tensor products of symmetric group representations”, International
Journal of Algebra and Computation, 1991:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQbar</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1] + s[2, 1] + s[3]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The currently existing implementation of this function is
technically unsatisfactory. It distinguishes the case when the
base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra (in which case the Kronecker product
can be easily computed using the power sum basis) from the case
where it isn’t. In the latter, it does a computation using
universal coefficients, again distinguishing the case when it is
able to compute the “corresponding” basis of the symmetric function
algebra over <span class="math notranslate nohighlight">\(\QQ\)</span> (using the <code class="docutils literal notranslate"><span class="pre">corresponding_basis_over</span></code> hack)
from the case when it isn’t (in which case it transforms everything
into the Schur basis, which is slow).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.is_schur_positive">
<span class="sig-name descname"><span class="pre">is_schur_positive</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.is_schur_positive" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if and only if <code class="docutils literal notranslate"><span class="pre">self</span></code> is Schur positive.</p>
<p>If <span class="math notranslate nohighlight">\(s\)</span> is the space of Schur functions over <code class="docutils literal notranslate"><span class="pre">self</span></code>’s base ring, then
this is the same as <code class="docutils literal notranslate"><span class="pre">self._is_positive(s)</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">is_schur_positive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">is_schur_positive</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QQx</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQx</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">QQx</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">is_schur_positive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">is_schur_positive</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_schur_positive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">is_schur_positive</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor">
<span class="sig-name descname"><span class="pre">itensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="Permalink to this definition">#</a></dt>
<dd><p>Return the internal (tensor) product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> in the
basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The internal tensor product can be defined as the linear extension
of the definition on power sums
<span class="math notranslate nohighlight">\(p_{\lambda} \ast p_{\mu} = \delta_{\lambda,\mu} z_{\lambda}
p_{\lambda}\)</span>, where <span class="math notranslate nohighlight">\(z_{\lambda} = (1^{r_1} r_1!) (2^{r_2} r_2!)
\cdots\)</span> for <span class="math notranslate nohighlight">\(\lambda = (1^{r_1} 2^{r_2} \cdots )\)</span> and where <span class="math notranslate nohighlight">\(\ast\)</span>
denotes the internal tensor product.
The internal tensor product is also known as the Kronecker product,
or as the second multiplication on the ring of symmetric functions.</p>
<p>Note that the internal product of any two homogeneous symmetric
functions of equal degrees is a homogeneous symmetric function of the
same degree. On the other hand, the internal product of two homogeneous
symmetric functions of distinct degrees is <span class="math notranslate nohighlight">\(0\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The internal product is sometimes referred to as “inner product”
in the literature, but unfortunately this name is shared by a
different operation, namely the Hall inner product
(see <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scalar()</span></code></a>).</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the
same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the internal product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code> (an element of the
ring of symmetric functions in the same basis as <code class="docutils literal notranslate"><span class="pre">self</span></code>)</p></li>
</ul>
<p>The methods <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itensor()</span></code></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product()</span></code></a>,
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kronecker_product()</span></code></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">inner_tensor()</span></code></a> are all
synonyms.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">s[2, 1]</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">s[1, 1, 1, 1, 1, 1] + 2*s[2, 1, 1, 1, 1] + 3*s[2, 2, 1, 1] + 2*s[2, 2, 2]</span>
<span class="go"> + 4*s[3, 1, 1, 1] + 5*s[3, 2, 1] + 2*s[3, 3] + 4*s[4, 1, 1]</span>
<span class="go"> + 3*s[4, 2] + 2*s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>There are few quantitative results pertaining to Kronecker products
in general, which makes their computation so difficult. Let us test
a few of them in different bases.</p>
<p>The Kronecker product of any homogeneous symmetric function <span class="math notranslate nohighlight">\(f\)</span> of
degree <span class="math notranslate nohighlight">\(n\)</span> with the <span class="math notranslate nohighlight">\(n\)</span>-th complete homogeneous symmetric function
<code class="docutils literal notranslate"><span class="pre">h[n]</span></code> (a.k.a. <code class="docutils literal notranslate"><span class="pre">s[n]</span></code>) is <span class="math notranslate nohighlight">\(f\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product of a Schur function <span class="math notranslate nohighlight">\(s_{\lambda}\)</span> with the <span class="math notranslate nohighlight">\(n\)</span>-th
elementary symmetric function <code class="docutils literal notranslate"><span class="pre">e[n]</span></code>, where <span class="math notranslate nohighlight">\(n = \left| \lambda
\right|\)</span>, is <span class="math notranslate nohighlight">\(s_{\lambda'}\)</span> (where <span class="math notranslate nohighlight">\(\lambda'\)</span> is the conjugate
partition of <span class="math notranslate nohighlight">\(\lambda\)</span>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product is commutative:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">mq</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">mh</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">==</span> <span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>   <span class="c1"># long time</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us check (on examples) Proposition 5.2 of Gelfand, Krob, Lascoux, Leclerc,
Retakh, Thibon, “Noncommutative symmetric functions”, <a class="reference external" href="https://arxiv.org/abs/hep-th/9407124">arXiv hep-th/9407124</a>, for
<span class="math notranslate nohighlight">\(r = 2\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_copr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>  <span class="c1"># computes \mu ((u \otimes v) * \Delta(w)) with</span>
<span class="gp">....: </span>                           <span class="c1"># * meaning Kronecker product and \mu meaning the</span>
<span class="gp">....: </span>                           <span class="c1"># usual multiplication.</span>
<span class="gp">....: </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">partition_pair</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">w</span><span class="o">.</span><span class="n">coproduct</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">result</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">result</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_copr</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>   <span class="c1"># long time</span>
<span class="gp">....: </span>               <span class="o">==</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
<span class="gp">....: </span>               <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Some examples from Briand, Orellana, Rosas, “The stability of the Kronecker
products of Schur functions.” <a class="reference external" href="https://arxiv.org/abs/0907.4652">arXiv 0907.4652</a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[1, 1, 1, 1] + s[2, 2] + s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 1, 1, 1] + s[2, 2, 1] + s[3, 1, 1] + s[3, 2] + s[4, 1] + s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 2, 2] + s[3, 1, 1, 1] + 2*s[3, 2, 1] + s[4, 1, 1] + 2*s[4, 2] + s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>An example from p. 220 of Thibon, “Hopf algebras of symmetric functions
and tensor products of symmetric group representations”, International
Journal of Algebra and Computation, 1991:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQbar</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1] + s[2, 1] + s[3]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The currently existing implementation of this function is
technically unsatisfactory. It distinguishes the case when the
base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra (in which case the Kronecker product
can be easily computed using the power sum basis) from the case
where it isn’t. In the latter, it does a computation using
universal coefficients, again distinguishing the case when it is
able to compute the “corresponding” basis of the symmetric function
algebra over <span class="math notranslate nohighlight">\(\QQ\)</span> (using the <code class="docutils literal notranslate"><span class="pre">corresponding_basis_over</span></code> hack)
from the case when it isn’t (in which case it transforms everything
into the Schur basis, which is slow).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_coproduct">
<span class="sig-name descname"><span class="pre">kronecker_coproduct</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_coproduct" title="Permalink to this definition">#</a></dt>
<dd><p>Return the inner coproduct of <code class="docutils literal notranslate"><span class="pre">self</span></code> in the basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The inner coproduct (also known as the Kronecker coproduct, as the
internal coproduct, or as the second comultiplication on the ring of
symmetric functions) is a ring homomorphism <span class="math notranslate nohighlight">\(\Delta^\times\)</span> from the
ring of symmetric functions to the tensor product (over the base
ring) of this ring with itself. It is uniquely characterized by the
formula</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\Delta^{\times}(h_n) = \sum_{\lambda \vdash n} s_{\lambda}
\otimes s_{\lambda} = \sum_{\lambda \vdash n} h_{\lambda} \otimes
m_{\lambda} = \sum_{\lambda \vdash n} m_{\lambda} \otimes
h_{\lambda},\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\lambda \vdash n\)</span> means <span class="math notranslate nohighlight">\(\lambda\)</span> is a partition of <span class="math notranslate nohighlight">\(n\)</span>, and
<span class="math notranslate nohighlight">\(n\)</span> is any nonnegative integer. It also satisfies</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\Delta^\times (p_n) = p_n \otimes p_n\]</div>
</div>
<p>for any positive integer <span class="math notranslate nohighlight">\(n\)</span>. If the base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra, it
also satisfies</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\Delta^{\times}(h_n) = \sum_{\lambda \vdash n} z_{\lambda}^{-1}
p_{\lambda} \otimes p_{\lambda},\]</div>
</div>
<p>where</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[z_{\lambda} = \prod_{i=1}^\infty i^{m_i(\lambda)} m_i(\lambda)!\]</div>
</div>
<p>with <span class="math notranslate nohighlight">\(m_i(\lambda)\)</span> meaning the number of appearances of <span class="math notranslate nohighlight">\(i\)</span>
in <span class="math notranslate nohighlight">\(\lambda\)</span> (see <a class="reference internal" href="#sage.combinat.sf.sfa.zee" title="sage.combinat.sf.sfa.zee"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zee()</span></code></a>).</p>
<p>The method <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_coproduct" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_coproduct"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kronecker_coproduct()</span></code></a> is a synonym of
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_coproduct" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_coproduct"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_coproduct()</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="go">s[1, 1, 1] # s[2, 1] + s[2, 1] # s[1, 1, 1] + s[2, 1] # s[2, 1] + s[2, 1] # s[3] + s[3] # s[2, 1]</span>

<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="go">e[1, 1] # e[2] + e[2] # e[1, 1] - 2*e[2] # e[2]</span>
</pre></div>
</div>
<p>The internal coproduct is adjoint to the internal product with respect
to the Hall inner product: Any three symmetric functions <span class="math notranslate nohighlight">\(f\)</span>, <span class="math notranslate nohighlight">\(g\)</span> and
<span class="math notranslate nohighlight">\(h\)</span> satisfy <span class="math notranslate nohighlight">\(\langle f * g, h \rangle = \sum_i \langle f, h^{\prime}_i
\rangle \langle g, h^{\prime\prime}_i \rangle\)</span>, where we write
<span class="math notranslate nohighlight">\(\Delta^{\times}(h)\)</span> as <span class="math notranslate nohighlight">\(\sum_i h^{\prime}_i \otimes
h^{\prime\prime}_i\)</span>. Let us check this in degree <span class="math notranslate nohighlight">\(4\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_incopr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>  <span class="c1"># computes \sum_i \left&lt; f, h&#39;_i \right&gt; \left&lt; g, h&#39;&#39;_i \right&gt;</span>
<span class="gp">....: </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">partition_pair</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">result</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">h</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">h</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">result</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_incopr</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>  <span class="c1"># long time (10s on sage.math, 2013)</span>
<span class="gp">....: </span>               <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us check the formulas for <span class="math notranslate nohighlight">\(\Delta^{\times}(h_n)\)</span> and
<span class="math notranslate nohighlight">\(\Delta^{\times}(p_n)\)</span> given in the description of this method:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">h</span><span class="p">([</span><span class="n">n</span><span class="p">]))</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">tensor</span><span class="p">([</span><span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">),</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)])</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">tensor</span><span class="p">([</span><span class="n">h</span><span class="p">(</span><span class="n">lam</span><span class="p">),</span> <span class="n">h</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">))])</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">h</span><span class="p">([</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">lam</span><span class="o">.</span><span class="n">conjugacy_class_size</span><span class="p">()</span> <span class="o">*</span> <span class="n">tensor</span><span class="p">([</span><span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)),</span> <span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">))])</span>
<span class="gp">....: </span>             <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product">
<span class="sig-name descname"><span class="pre">kronecker_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product" title="Permalink to this definition">#</a></dt>
<dd><p>Return the internal (tensor) product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> in the
basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The internal tensor product can be defined as the linear extension
of the definition on power sums
<span class="math notranslate nohighlight">\(p_{\lambda} \ast p_{\mu} = \delta_{\lambda,\mu} z_{\lambda}
p_{\lambda}\)</span>, where <span class="math notranslate nohighlight">\(z_{\lambda} = (1^{r_1} r_1!) (2^{r_2} r_2!)
\cdots\)</span> for <span class="math notranslate nohighlight">\(\lambda = (1^{r_1} 2^{r_2} \cdots )\)</span> and where <span class="math notranslate nohighlight">\(\ast\)</span>
denotes the internal tensor product.
The internal tensor product is also known as the Kronecker product,
or as the second multiplication on the ring of symmetric functions.</p>
<p>Note that the internal product of any two homogeneous symmetric
functions of equal degrees is a homogeneous symmetric function of the
same degree. On the other hand, the internal product of two homogeneous
symmetric functions of distinct degrees is <span class="math notranslate nohighlight">\(0\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The internal product is sometimes referred to as “inner product”
in the literature, but unfortunately this name is shared by a
different operation, namely the Hall inner product
(see <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scalar()</span></code></a>).</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the
same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the internal product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code> (an element of the
ring of symmetric functions in the same basis as <code class="docutils literal notranslate"><span class="pre">self</span></code>)</p></li>
</ul>
<p>The methods <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itensor()</span></code></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product()</span></code></a>,
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kronecker_product()</span></code></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">inner_tensor()</span></code></a> are all
synonyms.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">s[2, 1]</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">s[1, 1, 1, 1, 1, 1] + 2*s[2, 1, 1, 1, 1] + 3*s[2, 2, 1, 1] + 2*s[2, 2, 2]</span>
<span class="go"> + 4*s[3, 1, 1, 1] + 5*s[3, 2, 1] + 2*s[3, 3] + 4*s[4, 1, 1]</span>
<span class="go"> + 3*s[4, 2] + 2*s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>There are few quantitative results pertaining to Kronecker products
in general, which makes their computation so difficult. Let us test
a few of them in different bases.</p>
<p>The Kronecker product of any homogeneous symmetric function <span class="math notranslate nohighlight">\(f\)</span> of
degree <span class="math notranslate nohighlight">\(n\)</span> with the <span class="math notranslate nohighlight">\(n\)</span>-th complete homogeneous symmetric function
<code class="docutils literal notranslate"><span class="pre">h[n]</span></code> (a.k.a. <code class="docutils literal notranslate"><span class="pre">s[n]</span></code>) is <span class="math notranslate nohighlight">\(f\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product of a Schur function <span class="math notranslate nohighlight">\(s_{\lambda}\)</span> with the <span class="math notranslate nohighlight">\(n\)</span>-th
elementary symmetric function <code class="docutils literal notranslate"><span class="pre">e[n]</span></code>, where <span class="math notranslate nohighlight">\(n = \left| \lambda
\right|\)</span>, is <span class="math notranslate nohighlight">\(s_{\lambda'}\)</span> (where <span class="math notranslate nohighlight">\(\lambda'\)</span> is the conjugate
partition of <span class="math notranslate nohighlight">\(\lambda\)</span>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product is commutative:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">mq</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">mh</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">==</span> <span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>   <span class="c1"># long time</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us check (on examples) Proposition 5.2 of Gelfand, Krob, Lascoux, Leclerc,
Retakh, Thibon, “Noncommutative symmetric functions”, <a class="reference external" href="https://arxiv.org/abs/hep-th/9407124">arXiv hep-th/9407124</a>, for
<span class="math notranslate nohighlight">\(r = 2\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_copr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>  <span class="c1"># computes \mu ((u \otimes v) * \Delta(w)) with</span>
<span class="gp">....: </span>                           <span class="c1"># * meaning Kronecker product and \mu meaning the</span>
<span class="gp">....: </span>                           <span class="c1"># usual multiplication.</span>
<span class="gp">....: </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">partition_pair</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">w</span><span class="o">.</span><span class="n">coproduct</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">result</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">result</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_copr</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>   <span class="c1"># long time</span>
<span class="gp">....: </span>               <span class="o">==</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
<span class="gp">....: </span>               <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Some examples from Briand, Orellana, Rosas, “The stability of the Kronecker
products of Schur functions.” <a class="reference external" href="https://arxiv.org/abs/0907.4652">arXiv 0907.4652</a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[1, 1, 1, 1] + s[2, 2] + s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 1, 1, 1] + s[2, 2, 1] + s[3, 1, 1] + s[3, 2] + s[4, 1] + s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 2, 2] + s[3, 1, 1, 1] + 2*s[3, 2, 1] + s[4, 1, 1] + 2*s[4, 2] + s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>An example from p. 220 of Thibon, “Hopf algebras of symmetric functions
and tensor products of symmetric group representations”, International
Journal of Algebra and Computation, 1991:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQbar</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1] + s[2, 1] + s[3]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The currently existing implementation of this function is
technically unsatisfactory. It distinguishes the case when the
base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra (in which case the Kronecker product
can be easily computed using the power sum basis) from the case
where it isn’t. In the latter, it does a computation using
universal coefficients, again distinguishing the case when it is
able to compute the “corresponding” basis of the symmetric function
algebra over <span class="math notranslate nohighlight">\(\QQ\)</span> (using the <code class="docutils literal notranslate"><span class="pre">corresponding_basis_over</span></code> hack)
from the case when it isn’t (in which case it transforms everything
into the Schur basis, which is slow).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.left_padded_kronecker_product">
<span class="sig-name descname"><span class="pre">left_padded_kronecker_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.left_padded_kronecker_product" title="Permalink to this definition">#</a></dt>
<dd><p>Return the left-padded Kronecker product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> in
the basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The left-padded Kronecker product is a bilinear map mapping two
symmetric functions to another, not necessarily preserving degree.
It can be defined as follows: Let <span class="math notranslate nohighlight">\(*\)</span> denote the Kronecker product
(<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itensor()</span></code></a>) on the space of symmetric functions. For any
partitions <span class="math notranslate nohighlight">\(\alpha\)</span>, <span class="math notranslate nohighlight">\(\beta\)</span>, <span class="math notranslate nohighlight">\(\gamma\)</span>, let
<span class="math notranslate nohighlight">\(g^{\gamma}_{\alpha, \beta}\)</span> denote the coefficient of the
complete homogeneous symmetric function <span class="math notranslate nohighlight">\(h_{\gamma}\)</span> in the
Kronecker product <span class="math notranslate nohighlight">\(h_{\alpha} * h_{\beta}\)</span>.
For every partition
<span class="math notranslate nohighlight">\(\lambda = (\lambda_1, \lambda_2, \lambda_3, \ldots)\)</span>
and every integer <span class="math notranslate nohighlight">\(n &gt; \left| \lambda \right| + \lambda_1\)</span>, let
<span class="math notranslate nohighlight">\(\lambda[n]\)</span> denote the <span class="math notranslate nohighlight">\(n\)</span>-completion of <span class="math notranslate nohighlight">\(\lambda\)</span> (this is the
partition
<span class="math notranslate nohighlight">\((n - \left| \lambda \right|, \lambda_1, \lambda_2, \lambda_3, \ldots)\)</span>;
see <a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.t_completion" title="sage.combinat.partition.Partition.t_completion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">t_completion()</span></code></a>).
Then, for any partitions <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> and every integer
<span class="math notranslate nohighlight">\(n \geq \left|\alpha\right| + \left|\beta\right| + \alpha_1 + \beta_1\)</span>,
we can write the Kronecker product <span class="math notranslate nohighlight">\(h_{\alpha[n]} * h_{\beta[n]}\)</span>
in the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[h_{\alpha[n]} * h_{\beta[n]} = \sum_{\gamma}
g^{\gamma[n]}_{\alpha[n], \beta[n]} h_{\gamma[n]}\]</div>
</div>
<p>with <span class="math notranslate nohighlight">\(\gamma\)</span> ranging over all partitions. The
coefficients <span class="math notranslate nohighlight">\(g^{\gamma[n]}_{\alpha[n], \beta[n]}\)</span>
are independent on <span class="math notranslate nohighlight">\(n\)</span>. These coefficients
<span class="math notranslate nohighlight">\(g^{\gamma[n]}_{\alpha[n], \beta[n]}\)</span> are denoted by
<span class="math notranslate nohighlight">\(\overline{g}^{\gamma}_{\alpha, \beta}\)</span>, and the symmetric
function</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\sum_{\gamma} \overline{g}^{\gamma}_{\alpha, \beta} h_{\gamma}\]</div>
</div>
<p>is said to be the <em>left-padded Kronecker product</em> of <span class="math notranslate nohighlight">\(h_{\alpha}\)</span>
and <span class="math notranslate nohighlight">\(h_{\beta}\)</span>. By bilinearity, this extends to a definition of a
left-padded Kronecker product of any two symmetric functions.</p>
<p>This notion of left-padded Kronecker product can be lifted to the
non-commutative symmetric functions
(<a class="reference internal" href="../ncsf_qsym/ncsf.html#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.left_padded_kronecker_product" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.left_padded_kronecker_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">left_padded_kronecker_product()</span></code></a>).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Do not mistake this product for the reduced Kronecker product
(<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.reduced_kronecker_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.reduced_kronecker_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reduced_kronecker_product()</span></code></a>), which uses the Schur
functions instead of the complete homogeneous functions in
its definition.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the
same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the left-padded Kronecker product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code> (an
element of the ring of symmetric functions in the same basis
as <code class="docutils literal notranslate"><span class="pre">self</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">h[1, 1, 1, 1] + h[2, 1] + h[2, 1, 1] + h[2, 1, 1, 1] + h[2, 2, 1] + h[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">h[1, 1, 1] + h[2, 1] + h[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">h[1, 1, 1] + h[2, 1] + h[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">h[1, 1] + 2*h[1, 1, 1] + h[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">h[1, 1, 1, 1] + 2*h[2, 1, 1] + h[2, 1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">h[2, 1] + h[2, 1, 1] + h[3, 2]</span>
</pre></div>
</div>
<p>Taking the left-padded Kronecker product with <span class="math notranslate nohighlight">\(1 = h_{\emptyset}\)</span>
is the identity map on the ring of symmetric functions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">[</span><span class="n">Partition</span><span class="p">([])]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">lam</span><span class="p">])</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">h</span><span class="p">[</span><span class="n">lam</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Here is a rule for the left-padded Kronecker product of <span class="math notranslate nohighlight">\(h_1\)</span>
(this is the same as <span class="math notranslate nohighlight">\(h_{(1)}\)</span>) with any complete homogeneous
function: Let <span class="math notranslate nohighlight">\(\lambda\)</span> be a partition. Then, the left-padded
Kronecker product of <span class="math notranslate nohighlight">\(h_1\)</span> and <span class="math notranslate nohighlight">\(h_{\lambda}\)</span> is
<span class="math notranslate nohighlight">\(\sum_{\mu} a_{\mu} h_{\mu}\)</span>, where the sum runs over all
partitions <span class="math notranslate nohighlight">\(\mu\)</span>, and the coefficient <span class="math notranslate nohighlight">\(a_{\mu}\)</span> is defined as the
number of ways to obtain <span class="math notranslate nohighlight">\(\mu\)</span> from <span class="math notranslate nohighlight">\(\lambda\)</span> by one of the
following two operations:</p>
<ul class="simple">
<li><p>Insert a <span class="math notranslate nohighlight">\(1\)</span> into <span class="math notranslate nohighlight">\(\lambda\)</span>.</p></li>
<li><p>Subtract <span class="math notranslate nohighlight">\(1\)</span> from one of the entries of <span class="math notranslate nohighlight">\(\lambda\)</span> (and remove
the entry if it thus becomes <span class="math notranslate nohighlight">\(0\)</span>), and insert a <span class="math notranslate nohighlight">\(1\)</span> into
<span class="math notranslate nohighlight">\(\lambda\)</span>.</p></li>
</ul>
<p>We check this for partitions of size <span class="math notranslate nohighlight">\(\leq 4\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">mults1</span><span class="p">(</span><span class="n">I</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="c1"># Left-padded Kronecker multiplication by h[1].</span>
<span class="gp">....: </span>    <span class="n">res</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">I</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">)):</span>
<span class="gp">....: </span>        <span class="n">I2</span> <span class="o">=</span> <span class="n">I</span><span class="p">[:]</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">I2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="n">I2</span> <span class="o">=</span> <span class="n">I2</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">I2</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="gp">....: </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="n">I2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="gp">....: </span>        <span class="n">res</span> <span class="o">+=</span> <span class="n">h</span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">I2</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">res</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">mults1</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">==</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">I</span><span class="p">])</span>
<span class="gp">....: </span>               <span class="o">==</span> <span class="n">h</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The left-padded Kronecker product is commutative:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">[</span><span class="n">lam</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">mu</span><span class="p">])</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">h</span><span class="p">[</span><span class="n">mu</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">lam</span><span class="p">])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.nabla">
<span class="sig-name descname"><span class="pre">nabla</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.nabla" title="Permalink to this definition">#</a></dt>
<dd><p>Return the value of the nabla operator applied to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The eigenvectors of the nabla operator are the Macdonald polynomials in
the Ht basis.</p>
<p>If the parameter <code class="docutils literal notranslate"><span class="pre">power</span></code> is an integer then it calculates
nabla to that integer.  The default value of <code class="docutils literal notranslate"><span class="pre">power</span></code> is 1.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code> – optional parameters (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>, in which
case <code class="docutils literal notranslate"><span class="pre">q</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code> are used)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">power</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">1</span></code>) an integer indicating how many times to
apply the operator <span class="math notranslate nohighlight">\(\nabla\)</span>.  Negative values of <code class="docutils literal notranslate"><span class="pre">power</span></code>
indicate powers of <span class="math notranslate nohighlight">\(\nabla^{-1}\)</span>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">power</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span>
<span class="go">(-1/2*q*t+1/2*q+1/2*t+1/2)*p[1, 1] + (1/2*q*t-1/2*q-1/2*t+1/2)*p[2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(-t-1)*p[1, 1, 1] + t*p[2, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(-t-1)*p[1, 1, 1] + t*p[2, 1]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span>
<span class="go">(-q^3*t-q^2*t^2-q*t^3)*s[1, 1, 1] + (-q^2*t-q*t^2)*s[2, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span>
<span class="go">(q^3+q^2*t+q*t^2+t^3+q*t)*s[1, 1, 1] + (q^2+q*t+t^2+q+t)*s[2, 1] + s[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(q^3+q^2+2*q+1)*s[1, 1, 1] + (q^2+2*q+2)*s[2, 1] + s[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span>
<span class="go">s[]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="n">power</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">((-q-t)/(q^2*t^2))*s[2, 1] + ((q^2+q*t+t^2)/(-q^3*t^3))*s[3]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span>
<span class="go">(-q*t)*s[1, 1] + (q^3*t^2+q^2*t^3)*s[1, 1, 1] + q^2*t^2*s[2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega">
<span class="sig-name descname"><span class="pre">omega</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega" title="Permalink to this definition">#</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the omega automorphism.</p>
<p>The <em>omega automorphism</em> is defined to be the unique algebra
endomorphism <span class="math notranslate nohighlight">\(\omega\)</span> of the ring of symmetric functions that
satisfies <span class="math notranslate nohighlight">\(\omega(e_k) = h_k\)</span> for all positive integers <span class="math notranslate nohighlight">\(k\)</span>
(where <span class="math notranslate nohighlight">\(e_k\)</span> stands for the <span class="math notranslate nohighlight">\(k\)</span>-th elementary symmetric
function, and <span class="math notranslate nohighlight">\(h_k\)</span> stands for the <span class="math notranslate nohighlight">\(k\)</span>-th complete homogeneous
symmetric function). It furthermore is a Hopf algebra
endomorphism and an involution, and it is also known as the
<em>omega involution</em>. It sends the power-sum symmetric function
<span class="math notranslate nohighlight">\(p_k\)</span> to <span class="math notranslate nohighlight">\((-1)^{k-1} p_k\)</span> for every positive integer <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>The images of some bases under the omega automorphism are given by</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\omega(e_{\lambda}) = h_{\lambda}, \qquad
\omega(h_{\lambda}) = e_{\lambda}, \qquad
\omega(p_{\lambda}) = (-1)^{|\lambda| - \ell(\lambda)}
p_{\lambda}, \qquad
\omega(s_{\lambda}) = s_{\lambda^{\prime}},\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\lambda\)</span> is any partition, where <span class="math notranslate nohighlight">\(\ell(\lambda)\)</span> denotes
the length (<a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.length" title="sage.combinat.partition.Partition.length"><code class="xref py py-meth docutils literal notranslate"><span class="pre">length()</span></code></a>)
of the partition <span class="math notranslate nohighlight">\(\lambda\)</span>, where <span class="math notranslate nohighlight">\(\lambda^{\prime}\)</span> denotes the
conjugate partition
(<a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.conjugate" title="sage.combinat.partition.Partition.conjugate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">conjugate()</span></code></a>) of
<span class="math notranslate nohighlight">\(\lambda\)</span>, and where the usual notations for bases are used
(<span class="math notranslate nohighlight">\(e\)</span> = elementary, <span class="math notranslate nohighlight">\(h\)</span> = complete homogeneous, <span class="math notranslate nohighlight">\(p\)</span> = powersum,
<span class="math notranslate nohighlight">\(s\)</span> = Schur).</p>
<p>The default implementation converts to the Schur basis, then
performs the automorphism and changes back.</p>
<p><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_involution" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">omega_involution()</span></code></a> is a synonym for the <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega"><code class="xref py py-meth docutils literal notranslate"><span class="pre">omega()</span></code></a> method.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">jack</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">P</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">J</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">J</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">JackP[2, 1] + JackP[3]</span>
<span class="gp">sage: </span><span class="n">J</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">J</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">JackP[]</span>
</pre></div>
</div>
<p>The forgotten symmetric functions are the images of the monomial
symmetric functions under omega:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">f</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_involution">
<span class="sig-name descname"><span class="pre">omega_involution</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_involution" title="Permalink to this definition">#</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the omega automorphism.</p>
<p>The <em>omega automorphism</em> is defined to be the unique algebra
endomorphism <span class="math notranslate nohighlight">\(\omega\)</span> of the ring of symmetric functions that
satisfies <span class="math notranslate nohighlight">\(\omega(e_k) = h_k\)</span> for all positive integers <span class="math notranslate nohighlight">\(k\)</span>
(where <span class="math notranslate nohighlight">\(e_k\)</span> stands for the <span class="math notranslate nohighlight">\(k\)</span>-th elementary symmetric
function, and <span class="math notranslate nohighlight">\(h_k\)</span> stands for the <span class="math notranslate nohighlight">\(k\)</span>-th complete homogeneous
symmetric function). It furthermore is a Hopf algebra
endomorphism and an involution, and it is also known as the
<em>omega involution</em>. It sends the power-sum symmetric function
<span class="math notranslate nohighlight">\(p_k\)</span> to <span class="math notranslate nohighlight">\((-1)^{k-1} p_k\)</span> for every positive integer <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>The images of some bases under the omega automorphism are given by</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\omega(e_{\lambda}) = h_{\lambda}, \qquad
\omega(h_{\lambda}) = e_{\lambda}, \qquad
\omega(p_{\lambda}) = (-1)^{|\lambda| - \ell(\lambda)}
p_{\lambda}, \qquad
\omega(s_{\lambda}) = s_{\lambda^{\prime}},\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\lambda\)</span> is any partition, where <span class="math notranslate nohighlight">\(\ell(\lambda)\)</span> denotes
the length (<a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.length" title="sage.combinat.partition.Partition.length"><code class="xref py py-meth docutils literal notranslate"><span class="pre">length()</span></code></a>)
of the partition <span class="math notranslate nohighlight">\(\lambda\)</span>, where <span class="math notranslate nohighlight">\(\lambda^{\prime}\)</span> denotes the
conjugate partition
(<a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.conjugate" title="sage.combinat.partition.Partition.conjugate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">conjugate()</span></code></a>) of
<span class="math notranslate nohighlight">\(\lambda\)</span>, and where the usual notations for bases are used
(<span class="math notranslate nohighlight">\(e\)</span> = elementary, <span class="math notranslate nohighlight">\(h\)</span> = complete homogeneous, <span class="math notranslate nohighlight">\(p\)</span> = powersum,
<span class="math notranslate nohighlight">\(s\)</span> = Schur).</p>
<p>The default implementation converts to the Schur basis, then
performs the automorphism and changes back.</p>
<p><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_involution" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">omega_involution()</span></code></a> is a synonym for the <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega"><code class="xref py py-meth docutils literal notranslate"><span class="pre">omega()</span></code></a> method.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">jack</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">P</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">J</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">J</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">JackP[2, 1] + JackP[3]</span>
<span class="gp">sage: </span><span class="n">J</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">J</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">JackP[]</span>
</pre></div>
</div>
<p>The forgotten symmetric functions are the images of the monomial
symmetric functions under omega:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">f</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_qt">
<span class="sig-name descname"><span class="pre">omega_qt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_qt" title="Permalink to this definition">#</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the <span class="math notranslate nohighlight">\(q,t\)</span>-deformed omega
automorphism which sends <span class="math notranslate nohighlight">\(p_k\)</span> to
<span class="math notranslate nohighlight">\((-1)^{k-1} \cdot \frac{1-q^k}{1-t^k} \cdot p_k\)</span> for all positive
integers <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>In general, this is well-defined outside of the powersum basis only
if the base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra.</p>
<p>If <span class="math notranslate nohighlight">\(q = t\)</span>, then this is the omega automorphism (<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega"><code class="xref py py-meth docutils literal notranslate"><span class="pre">omega()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code> – parameters (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>, in which case
<code class="docutils literal notranslate"><span class="pre">'q'</span></code> and <code class="docutils literal notranslate"><span class="pre">'t'</span></code> are used)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QQqt</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q,t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">q</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">QQqt</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQqt</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">()</span>
<span class="go">((-q^5+1)/(-t^5+1))*p[5]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">((-q^5+1)/(-t^5+1))*p[5]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">((q^2-1)/(-t^2+1))*p[2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">((-q^3+q^2+q-1)/(t^3-t^2-t+1))*p[2, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">q</span><span class="p">)</span>
<span class="go">-(2976/(q^5-q^3-q^2+1))*p[3, 2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">()</span>
<span class="go">p[]</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQqt</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">()</span>
<span class="go">((2*q^2-2*q*t-2*q+2*t)/(t^3-t^2-t+1))*McdH[1, 1] + ((q-1)/(t-1))*McdH[2]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">((2*q^2-2*q*t-2*q+2*t)/(t^3-t^2-t+1))*McdH[1, 1] + ((q-1)/(t-1))*McdH[2]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">)</span>
<span class="go">((-t^3+t^2+t-1)/(-q^3+q^2+q-1))*McdH[2]</span>
<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">()</span>
<span class="go">((q^2-q*t-q+t)/(t^3-t^2-t+1))*McdS[1, 1] + ((-q^2*t+q*t+q-1)/(-t^3+t^2+t-1))*McdS[2]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">S</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">())</span>
<span class="go">s[2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm">
<span class="sig-name descname"><span class="pre">plethysm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm" title="Permalink to this definition">#</a></dt>
<dd><p>Return the outer plethysm of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>This is implemented only over base rings which are
<span class="math notranslate nohighlight">\(\QQ\)</span>-algebras.  (To compute outer plethysms over general
binomial rings, change bases to the fraction field.)</p>
<p>The outer plethysm of <span class="math notranslate nohighlight">\(f\)</span> with <span class="math notranslate nohighlight">\(g\)</span> is commonly denoted by
<span class="math notranslate nohighlight">\(f \left[ g \right]\)</span> or by <span class="math notranslate nohighlight">\(f \circ g\)</span>. It is an algebra map
in <span class="math notranslate nohighlight">\(f\)</span>, but not (generally) in <span class="math notranslate nohighlight">\(g\)</span>.</p>
<p>By default, the degree one elements are taken to be the
generators for the <code class="docutils literal notranslate"><span class="pre">self</span></code>’s base ring. This setting can be
modified by specifying the <code class="docutils literal notranslate"><span class="pre">include</span></code> and <code class="docutils literal notranslate"><span class="pre">exclude</span></code> keywords.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – a symmetric function over the same base ring as
<code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">include</span></code> – a list of variables to be treated as
degree one elements instead of the default degree one elements</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exclude</span></code> – a list of variables to be excluded
from the default degree one elements</p></li>
</ul>
<p>OUTPUT:</p>
<p>An element in the parent of <code class="docutils literal notranslate"><span class="pre">x</span></code> or the base ring <span class="math notranslate nohighlight">\(R\)</span> of <code class="docutils literal notranslate"><span class="pre">self</span></code>
when <code class="docutils literal notranslate"><span class="pre">x</span></code> is in <span class="math notranslate nohighlight">\(R\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h3h2</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">](</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span> <span class="n">h3h2</span>
<span class="go">h[2, 2, 2] - 2*h[3, 2, 1] + h[3, 3] + h[4, 1, 1] - h[5, 1] + h[6]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">h3h2</span><span class="p">)</span>
<span class="go">s[2, 2, 2] + s[4, 2] + s[6]</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p3s21</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">](</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span> <span class="n">p3s21</span>
<span class="go">s[2, 2, 2, 1, 1, 1] - s[2, 2, 2, 2, 1] - s[3, 2, 1, 1, 1, 1]</span>
<span class="go"> + s[3, 2, 2, 2] + s[3, 3, 1, 1, 1] - s[3, 3, 2, 1] + 2*s[3, 3, 3]</span>
<span class="go"> + s[4, 1, 1, 1, 1, 1] - s[4, 3, 2] + s[4, 4, 1] - s[5, 1, 1, 1, 1]</span>
<span class="go"> + s[5, 2, 2] - s[5, 4] + s[6, 1, 1, 1] - s[6, 2, 1] + s[6, 3]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="n">p3s21</span><span class="p">)</span>
<span class="go">1/3*p[3, 3, 3] - 1/3*p[9]</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">](</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">e[3, 3] + e[4, 1, 1] - 2*e[4, 2] - e[5, 1] + e[6]</span>
</pre></div>
</div>
<p>Note that the output is in the basis of the input <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">](</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">h[4, 3, 2] - h[4, 4, 1] - h[5, 2, 2] + h[5, 3, 1] + h[5, 4]</span>
<span class="go"> + h[6, 2, 1] - 2*h[6, 3] - h[7, 1, 1] + h[7, 2] + h[8, 1] - h[9]</span>

<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">](</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">s[4, 3, 2] + s[4, 4, 1] + s[5, 2, 2] + s[5, 3, 1] + s[5, 4]</span>
<span class="go"> + s[6, 2, 1] + 2*s[6, 3] + 2*s[7, 2] + s[8, 1] + s[9]</span>
</pre></div>
</div>
<p>Examples over a polynomial ring:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">t</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">t^3*s[2, 2, 2] + t^3*s[4, 2] + t^3*s[6]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">t*s[4, 2] + t*s[6]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">s[]</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">x</span></code> is a constant, then it is returned as an element
of the base ring:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">](</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="n">R</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Sage also handles plethysm of tensor products of symmetric functions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">s</span><span class="p">[[]]])</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">([</span><span class="n">s</span><span class="p">[[]],</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">](</span><span class="n">X</span><span class="o">+</span><span class="n">Y</span><span class="p">)</span>
<span class="go">s[] # s[1, 1, 1] + s[1] # s[1, 1] + s[1, 1] # s[1] + s[1, 1, 1] # s[]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">](</span><span class="n">X</span><span class="o">*</span><span class="n">Y</span><span class="p">)</span>
<span class="go">s[1, 1, 1] # s[3] + s[2, 1] # s[2, 1] + s[3] # s[1, 1, 1]</span>
</pre></div>
</div>
<p>One can use this to work with symmetric functions in two sets of
commuting variables. For example, we verify the Cauchy identities
(in degree 5):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P5</span> <span class="o">=</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">mu</span><span class="p">](</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="n">mu</span><span class="p">](</span><span class="n">Y</span><span class="p">)</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">P5</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">mu</span><span class="p">](</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">h</span><span class="p">[</span><span class="n">mu</span><span class="p">](</span><span class="n">Y</span><span class="p">)</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">P5</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">mu</span><span class="p">](</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="n">mu</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()](</span><span class="n">Y</span><span class="p">)</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">P5</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">mu</span><span class="p">](</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">e</span><span class="p">[</span><span class="n">mu</span><span class="p">](</span><span class="n">Y</span><span class="p">)</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">P5</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Sage can also do the plethysm with an element in the completion:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">LazySymmetricFunctions</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">L</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">L</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span> <span class="n">g</span>
<span class="go">s[1] + (s[1,1]+s[2]) + (s[1,1,1]+2*s[2,1]+s[3])</span>
<span class="go"> + (s[1,1,1,1]+3*s[2,1,1]+2*s[2,2]+3*s[3,1]+s[4])</span>
<span class="go"> + (s[1,1,1,1,1]+4*s[2,1,1,1]+5*s[2,2,1]+6*s[3,1,1]+5*s[3,2]+4*s[4,1]+s[5])</span>
<span class="go"> + ... + O^8</span>
<span class="gp">sage: </span><span class="n">fog</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fog</span><span class="p">[:</span><span class="mi">8</span><span class="p">]</span>
<span class="go">[s[2, 1],</span>
<span class="go"> s[1, 1, 1, 1] + 3*s[2, 1, 1] + 2*s[2, 2] + 3*s[3, 1] + s[4],</span>
<span class="go"> 2*s[1, 1, 1, 1, 1] + 8*s[2, 1, 1, 1] + 10*s[2, 2, 1]</span>
<span class="go"> + 12*s[3, 1, 1] + 10*s[3, 2] + 8*s[4, 1] + 2*s[5],</span>
<span class="go"> 3*s[1, 1, 1, 1, 1, 1] + 17*s[2, 1, 1, 1, 1] + 30*s[2, 2, 1, 1]</span>
<span class="go"> + 16*s[2, 2, 2] + 33*s[3, 1, 1, 1] + 54*s[3, 2, 1] + 16*s[3, 3]</span>
<span class="go"> + 33*s[4, 1, 1] + 30*s[4, 2] + 17*s[5, 1] + 3*s[6],</span>
<span class="go"> 5*s[1, 1, 1, 1, 1, 1, 1] + 30*s[2, 1, 1, 1, 1, 1] + 70*s[2, 2, 1, 1, 1]</span>
<span class="go"> + 70*s[2, 2, 2, 1] + 75*s[3, 1, 1, 1, 1] + 175*s[3, 2, 1, 1]</span>
<span class="go"> + 105*s[3, 2, 2] + 105*s[3, 3, 1] + 100*s[4, 1, 1, 1] + 175*s[4, 2, 1]</span>
<span class="go"> + 70*s[4, 3] + 75*s[5, 1, 1] + 70*s[5, 2] + 30*s[6, 1] + 5*s[7]]</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">fog</span><span class="p">)</span>
<span class="go">Lazy completion of Symmetric Functions over Rational Field in the Schur basis</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius"><code class="xref py py-meth docutils literal notranslate"><span class="pre">frobenius()</span></code></a></p>
</div>
<div class="admonition-todo admonition" id="id10">
<p class="admonition-title">Todo</p>
<p>The implementation of plethysm in
<a class="reference external" href="../../../../data_structures/sage/data_structures/stream.html#sage.data_structures.stream.Stream_plethysm" title="(in Data Structures v10.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.data_structures.stream.Stream_plethysm</span></code></a> seems
to be faster.  This should be investigated.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.principal_specialization">
<span class="sig-name descname"><span class="pre">principal_specialization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">+Infinity</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.principal_specialization" title="Permalink to this definition">#</a></dt>
<dd><p>Return the principal specialization of a symmetric function.</p>
<p>The <em>principal specialization</em> of order <span class="math notranslate nohighlight">\(n\)</span> at <span class="math notranslate nohighlight">\(q\)</span>
is the ring homomorphism <span class="math notranslate nohighlight">\(ps_{n,q}\)</span> from the ring of
symmetric functions to another commutative ring <span class="math notranslate nohighlight">\(R\)</span>
given by <span class="math notranslate nohighlight">\(x_i \mapsto q^{i-1}\)</span> for <span class="math notranslate nohighlight">\(i \in \{1,\dots,n\}\)</span>
and <span class="math notranslate nohighlight">\(x_i \mapsto 0\)</span> for <span class="math notranslate nohighlight">\(i &gt; n\)</span>.
Here, <span class="math notranslate nohighlight">\(q\)</span> is a given element of <span class="math notranslate nohighlight">\(R\)</span>, and we assume that
the variables of our symmetric functions are
<span class="math notranslate nohighlight">\(x_1, x_2, x_3, \ldots\)</span>.
(To be more precise, <span class="math notranslate nohighlight">\(ps_{n,q}\)</span> is a <span class="math notranslate nohighlight">\(K\)</span>-algebra
homomorphism, where <span class="math notranslate nohighlight">\(K\)</span> is the base ring.)
See Section 7.8 of <a class="reference internal" href="../../../../references/index.html#enumcomb2" id="id11"><span>[EnumComb2]</span></a>.</p>
<p>The <em>stable principal specialization</em> at <span class="math notranslate nohighlight">\(q\)</span> is the ring
homomorphism <span class="math notranslate nohighlight">\(ps_q\)</span> from the ring of symmetric functions
to another commutative ring <span class="math notranslate nohighlight">\(R\)</span> given by
<span class="math notranslate nohighlight">\(x_i \mapsto q^{i-1}\)</span> for all <span class="math notranslate nohighlight">\(i\)</span>.
This is well-defined only if the resulting infinite sums
converge; thus, in particular, setting <span class="math notranslate nohighlight">\(q = 1\)</span> in the
stable principal specialization is an invalid operation.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> (default: <code class="docutils literal notranslate"><span class="pre">infinity</span></code>) – a nonnegative integer or
<code class="docutils literal notranslate"><span class="pre">infinity</span></code>, specifying whether to compute the principal
specialization of order <code class="docutils literal notranslate"><span class="pre">n</span></code> or the stable principal
specialization.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) – the value to use for <span class="math notranslate nohighlight">\(q\)</span>; the
default is to create a ring of polynomials in <code class="docutils literal notranslate"><span class="pre">q</span></code>
(or a field of rational functions in <code class="docutils literal notranslate"><span class="pre">q</span></code>) over the
given coefficient ring.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">principal_specialization</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">q^3 + q^2 + q</span>
</pre></div>
</div>
<p>By default we return a rational function in <code class="docutils literal notranslate"><span class="pre">q</span></code>.  Sometimes
it is better to obtain an element of the symbolic ring:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">principal_specialization</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">var</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">))</span>
<span class="go">1/((q^2 - 1)*(q - 1)) - 1/((q^3 - 1)*(q^2 - 1)*(q - 1))</span>
</pre></div>
</div>
<p>In case <code class="docutils literal notranslate"><span class="pre">q</span></code> is in the base ring, it must be passed explicitly:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q,t&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">Ht</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">Ht</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Ht</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">principal_specialization</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the variable q is in the base ring, pass it explicitly</span>

<span class="gp">sage: </span><span class="n">Ht</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">principal_specialization</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">R</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">))</span>
<span class="go">(q^2 + 1)/(q^3 - q^2 - q + 1)</span>
</pre></div>
</div>
<p>Note that the principal specialization can be obtained as a plethysm:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">one</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">principal_specialization</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="n">one</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">))</span><span class="o">.</span><span class="n">coefficient</span><span class="p">([])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">principal_specialization</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="n">one</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="o">^</span><span class="mi">4</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">))</span><span class="o">.</span><span class="n">coefficient</span><span class="p">([])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.reduced_kronecker_product">
<span class="sig-name descname"><span class="pre">reduced_kronecker_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.reduced_kronecker_product" title="Permalink to this definition">#</a></dt>
<dd><p>Return the reduced Kronecker product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> in the
basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The reduced Kronecker product is a bilinear map mapping two
symmetric functions to another, not necessarily preserving degree.
It can be defined as follows: Let <span class="math notranslate nohighlight">\(*\)</span> denote the Kronecker product
(<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itensor()</span></code></a>) on the space of symmetric functions. For any
partitions <span class="math notranslate nohighlight">\(\alpha\)</span>, <span class="math notranslate nohighlight">\(\beta\)</span>, <span class="math notranslate nohighlight">\(\gamma\)</span>, let
<span class="math notranslate nohighlight">\(g^{\gamma}_{\alpha, \beta}\)</span> denote the coefficient of the Schur
function <span class="math notranslate nohighlight">\(s_{\gamma}\)</span> in the Kronecker product
<span class="math notranslate nohighlight">\(s_{\alpha} * s_{\beta}\)</span> (this is called a Kronecker coefficient).
For every partition
<span class="math notranslate nohighlight">\(\lambda = (\lambda_1, \lambda_2, \lambda_3, \ldots)\)</span>
and every integer <span class="math notranslate nohighlight">\(n &gt; \left| \lambda \right| + \lambda_1\)</span>, let
<span class="math notranslate nohighlight">\(\lambda[n]\)</span> denote the <span class="math notranslate nohighlight">\(n\)</span>-completion of <span class="math notranslate nohighlight">\(\lambda\)</span> (this is the
partition
<span class="math notranslate nohighlight">\((n - \left| \lambda \right|, \lambda_1, \lambda_2, \lambda_3, \ldots)\)</span>;
see <a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.t_completion" title="sage.combinat.partition.Partition.t_completion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">t_completion()</span></code></a>).
Then, Theorem 1.2 of <a class="reference internal" href="../../../../references/index.html#bor2009" id="id12"><span>[BOR2009]</span></a> shows that for any partitions
<span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> and every integer
<span class="math notranslate nohighlight">\(n \geq \left|\alpha\right| + \left|\beta\right| + \alpha_1 + \beta_1\)</span>,
we can write the Kronecker product <span class="math notranslate nohighlight">\(s_{\alpha[n]} * s_{\beta[n]}\)</span>
in the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[s_{\alpha[n]} * s_{\beta[n]} = \sum_{\gamma} g^{\gamma[n]}_{\alpha[n], \beta[n]} s_{\gamma[n]}\]</div>
</div>
<p>with <span class="math notranslate nohighlight">\(\gamma\)</span> ranging over all partitions. The
coefficients <span class="math notranslate nohighlight">\(g^{\gamma[n]}_{\alpha[n], \beta[n]}\)</span>
are independent on <span class="math notranslate nohighlight">\(n\)</span>. These coefficients
<span class="math notranslate nohighlight">\(g^{\gamma[n]}_{\alpha[n], \beta[n]}\)</span> are denoted by
<span class="math notranslate nohighlight">\(\overline{g}^{\gamma}_{\alpha, \beta}\)</span>, and the symmetric
function</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\sum_{\gamma} \overline{g}^{\gamma}_{\alpha, \beta} s_{\gamma}\]</div>
</div>
<p>is said to be the <em>reduced Kronecker product</em> of <span class="math notranslate nohighlight">\(s_{\alpha}\)</span> and
<span class="math notranslate nohighlight">\(s_{\beta}\)</span>. By bilinearity, this extends to a definition of a
reduced Kronecker product of any two symmetric functions.</p>
<p>The definition of the reduced Kronecker product goes back to
Murnaghan, and has recently been studied in <a class="reference internal" href="../../../../references/index.html#bor2009" id="id13"><span>[BOR2009]</span></a>, <a class="reference internal" href="../../../../references/index.html#bdvo2012" id="id14"><span>[BdVO2012]</span></a>
and other places (our notation
<span class="math notranslate nohighlight">\(\overline{g}^{\gamma}_{\alpha, \beta}\)</span> appears in these two
sources).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the
same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the reduced Kronecker product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code> (an element
of the ring of symmetric functions in the same basis as
<code class="docutils literal notranslate"><span class="pre">self</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The example from page 2 of <a class="reference internal" href="../../../../references/index.html#bor2009" id="id15"><span>[BOR2009]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reduced_kronecker_product</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[] + s[1] + s[1, 1] + s[1, 1, 1] + 2*s[2] + 2*s[2, 1] + s[2, 2] + s[3] + s[3, 1] + s[4]</span>
</pre></div>
</div>
<p>Taking the reduced Kronecker product with <span class="math notranslate nohighlight">\(1 = s_{\emptyset}\)</span>
is the identity map on the ring of symmetric functions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">[</span><span class="n">Partition</span><span class="p">([])]</span><span class="o">.</span><span class="n">reduced_kronecker_product</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">lam</span><span class="p">])</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">lam</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>While reduced Kronecker products are hard to compute in general,
there is a rule for taking reduced Kronecker products with
<span class="math notranslate nohighlight">\(s_1\)</span>. Namely, for every partition <span class="math notranslate nohighlight">\(\lambda\)</span>, the reduced
Kronecker product of <span class="math notranslate nohighlight">\(s_{\lambda}\)</span> with <span class="math notranslate nohighlight">\(s_1\)</span> is
<span class="math notranslate nohighlight">\(\sum_{\mu} a_{\mu} s_{\mu}\)</span>, where the sum runs over all
partitions <span class="math notranslate nohighlight">\(\mu\)</span>, and the coefficient <span class="math notranslate nohighlight">\(a_{\mu}\)</span> is defined as the
number of ways to obtain <span class="math notranslate nohighlight">\(\mu\)</span> from <span class="math notranslate nohighlight">\(\lambda\)</span> by one of the
following three operations:</p>
<ul class="simple">
<li><p>Add an addable cell
(<a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.addable_cells" title="sage.combinat.partition.Partition.addable_cells"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addable_cells()</span></code></a>) to
<span class="math notranslate nohighlight">\(\lambda\)</span>.</p></li>
<li><p>Remove a removable cell
(<a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.removable_cells" title="sage.combinat.partition.Partition.removable_cells"><code class="xref py py-meth docutils literal notranslate"><span class="pre">removable_cells()</span></code></a>)
from <span class="math notranslate nohighlight">\(\lambda\)</span>.</p></li>
<li><p>First remove a removable cell from <span class="math notranslate nohighlight">\(\lambda\)</span>, then add an
addable cell to the resulting Young diagram.</p></li>
</ul>
<p>This is, in fact, Proposition 5.15 of <a class="reference internal" href="../../../../references/index.html#co2010" id="id16"><span>[CO2010]</span></a> in an elementary
wording. We check this for partitions of size <span class="math notranslate nohighlight">\(\leq 4\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">mults1</span><span class="p">(</span><span class="n">lam</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="c1"># Reduced Kronecker multiplication by s[1], according</span>
<span class="gp">....: </span>    <span class="c1"># to [CO2010]_.</span>
<span class="gp">....: </span>    <span class="n">res</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">lam</span><span class="o">.</span><span class="n">up_list</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">res</span> <span class="o">+=</span> <span class="n">s</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">lam</span><span class="o">.</span><span class="n">down_list</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">res</span> <span class="o">+=</span> <span class="n">s</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="n">mu</span><span class="o">.</span><span class="n">up_list</span><span class="p">():</span>
<span class="gp">....: </span>            <span class="n">res</span> <span class="o">+=</span> <span class="n">s</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">res</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">mults1</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reduced_kronecker_product</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">lam</span><span class="p">])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Here is the example on page 3 of Christian Gutschwager’s
<a class="reference external" href="https://arxiv.org/abs/0912.4411v3">arXiv 0912.4411v3</a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reduced_kronecker_product</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[1] + 2*s[1, 1] + s[1, 1, 1] + s[2] + 2*s[2, 1] + s[2, 1, 1] + s[3] + s[3, 1]</span>
</pre></div>
</div>
<p>Example 39 from F. D. Murnaghan, “The analysis of the Kronecker
product of irreducible representations of the symmetric group”,
American Journal of Mathematics, Vol. 60, No. 3, Jul. 1938:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">reduced_kronecker_product</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[1] + 2*s[1, 1] + 2*s[1, 1, 1] + s[1, 1, 1, 1] + 2*s[2] + 5*s[2, 1] + 4*s[2, 1, 1]</span>
<span class="go">+ s[2, 1, 1, 1] + 3*s[2, 2] + 2*s[2, 2, 1] + 2*s[3] + 5*s[3, 1] + 3*s[3, 1, 1]</span>
<span class="go">+ 3*s[3, 2] + s[3, 2, 1] + 2*s[4] + 3*s[4, 1] + s[4, 1, 1] + s[4, 2] + s[5]</span>
<span class="go">+ s[5, 1]</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="id17">
<p class="admonition-title">Todo</p>
<p>This implementation of the reduced Kronecker product is
painfully slow.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_degree">
<span class="sig-name descname"><span class="pre">restrict_degree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_degree" title="Permalink to this definition">#</a></dt>
<dd><p>Return the degree <code class="docutils literal notranslate"><span class="pre">d</span></code> component of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">d</span></code> – positive integer, degree of the terms to be returned</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exact</span></code> – boolean, if <code class="docutils literal notranslate"><span class="pre">True</span></code>, returns the terms of degree
exactly <code class="docutils literal notranslate"><span class="pre">d</span></code>, otherwise returns all terms of degree less than
or equal to <code class="docutils literal notranslate"><span class="pre">d</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the homogeneous component of <code class="docutils literal notranslate"><span class="pre">self</span></code> of degree <code class="docutils literal notranslate"><span class="pre">d</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_degree</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_degree</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">s[1]</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_degree</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">s[1, 1, 1] + s[2, 1]</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_degree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">s[1] + s[1, 1, 1] + s[2, 1]</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_degree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_partition_lengths">
<span class="sig-name descname"><span class="pre">restrict_partition_lengths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_partition_lengths" title="Permalink to this definition">#</a></dt>
<dd><p>Return the terms of <code class="docutils literal notranslate"><span class="pre">self</span></code> labelled by partitions of length <code class="docutils literal notranslate"><span class="pre">l</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> – nonnegative integer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exact</span></code> – boolean, defaulting to <code class="docutils literal notranslate"><span class="pre">True</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>if <code class="docutils literal notranslate"><span class="pre">True</span></code>, returns the terms labelled by
partitions of length precisely <code class="docutils literal notranslate"><span class="pre">l</span></code>; otherwise returns all terms
labelled by partitions of length less than or equal to <code class="docutils literal notranslate"><span class="pre">l</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_partition_lengths</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">s[2, 1]</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_partition_lengths</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_partition_lengths</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">exact</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">s[1] + s[2, 1] + s[4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_parts">
<span class="sig-name descname"><span class="pre">restrict_parts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_parts" title="Permalink to this definition">#</a></dt>
<dd><p>Return the terms of <code class="docutils literal notranslate"><span class="pre">self</span></code> labelled by partitions <span class="math notranslate nohighlight">\(\lambda\)</span> with
<span class="math notranslate nohighlight">\(\lambda_1 \leq n\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – positive integer, to restrict the parts of the partitions
of the terms to be returned</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_parts</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">s[1] + s[1, 1, 1] + s[2, 1]</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_parts</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">s[1] + s[1, 1, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar">
<span class="sig-name descname"><span class="pre">scalar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zee</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar" title="Permalink to this definition">#</a></dt>
<dd><p>Return the standard scalar product between <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>This is also known as the “Hall inner product” or the
“Hall scalar product”.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the
same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">zee</span></code> – an optional function on partitions giving
the value for the scalar product between <span class="math notranslate nohighlight">\(p_{\mu}\)</span> and <span class="math notranslate nohighlight">\(p_{\mu}\)</span>
(default is to use the standard <a class="reference internal" href="#sage.combinat.sf.sfa.zee" title="sage.combinat.sf.sfa.zee"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zee()</span></code></a> function)</p></li>
</ul>
<p>This is the default implementation that converts both <code class="docutils literal notranslate"><span class="pre">self</span></code> and
<code class="docutils literal notranslate"><span class="pre">x</span></code> into either Schur functions (if <code class="docutils literal notranslate"><span class="pre">zee</span></code> is not specified) or
power-sum functions (if <code class="docutils literal notranslate"><span class="pre">zee</span></code> is specified) and performs the scalar
product in that basis.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p4</span> <span class="o">=</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([</span> <span class="p">[</span><span class="n">e</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">])</span>
<span class="go">[ 0  0  0  0  1]</span>
<span class="go">[ 0  0  0  1  4]</span>
<span class="go">[ 0  0  1  2  6]</span>
<span class="go">[ 0  1  2  5 12]</span>
<span class="go">[ 1  4  6 12 24]</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([</span> <span class="p">[</span><span class="n">h</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">])</span>
<span class="go">[ 0  0  0  0  1]</span>
<span class="go">[ 0  0  0  1  4]</span>
<span class="go">[ 0  0  1  2  6]</span>
<span class="go">[ 0  1  2  5 12]</span>
<span class="go">[ 1  4  6 12 24]</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([</span> <span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">])</span>
<span class="go">[-1  2  1 -3  1]</span>
<span class="go">[ 0  1  0 -2  1]</span>
<span class="go">[ 0  0  1 -2  1]</span>
<span class="go">[ 0  0  0 -1  1]</span>
<span class="go">[ 0  0  0  0  1]</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([</span> <span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">])</span>
<span class="go">[1 0 0 0 0]</span>
<span class="go">[0 1 0 0 0]</span>
<span class="go">[0 0 1 0 0]</span>
<span class="go">[0 0 0 1 0]</span>
<span class="go">[0 0 0 0 1]</span>

<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">zee</span><span class="o">=</span><span class="k">lambda</span> <span class="n">mu</span><span class="p">:</span> <span class="mi">2</span><span class="o">**</span><span class="n">mu</span><span class="o">.</span><span class="n">length</span><span class="p">())</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">mu</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">zee</span><span class="o">=</span><span class="k">lambda</span> <span class="n">mu</span><span class="p">:</span> <span class="mi">2</span><span class="o">**</span><span class="n">mu</span><span class="o">.</span><span class="n">length</span><span class="p">())</span>
<span class="go">2/3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_hl">
<span class="sig-name descname"><span class="pre">scalar_hl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_hl" title="Permalink to this definition">#</a></dt>
<dd><p>Return the <span class="math notranslate nohighlight">\(t\)</span>-deformed standard Hall-Littlewood scalar product of
<code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the same
base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – parameter (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>, in which case <code class="docutils literal notranslate"><span class="pre">t</span></code> is used)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">sp</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">scalar_t</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">sp</span>
<span class="go">(-t^2 - 1)/(t^5 - 2*t^4 + t^3 - t^2 + 2*t - 1)</span>
<span class="gp">sage: </span><span class="n">sp</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Fraction Field of Univariate Polynomial Ring in t over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_jack">
<span class="sig-name descname"><span class="pre">scalar_jack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_jack" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Jack-scalar product between <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>This scalar product is defined so that the power sum elements
<span class="math notranslate nohighlight">\(p_{\mu}\)</span> are orthogonal and <span class="math notranslate nohighlight">\(\langle p_{\mu}, p_{\mu} \rangle =
z_{\mu} t^{\ell(\mu)}\)</span>, where <span class="math notranslate nohighlight">\(\ell(\mu)\)</span> denotes the length of
<span class="math notranslate nohighlight">\(\mu\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the
same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – an optional parameter (default: <code class="docutils literal notranslate"><span class="pre">None</span></code> in which
case <code class="docutils literal notranslate"><span class="pre">t</span></code> is used)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">power</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([[</span><span class="n">p</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_jack</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">nu</span><span class="p">))</span> <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)])</span>
<span class="go">[   4*t      0      0      0      0]</span>
<span class="go">[     0  3*t^2      0      0      0]</span>
<span class="go">[     0      0  8*t^2      0      0]</span>
<span class="go">[     0      0      0  4*t^3      0]</span>
<span class="go">[     0      0      0      0 24*t^4]</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([[</span><span class="n">p</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_jack</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">nu</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)])</span>
<span class="go">[  8   0   0   0   0]</span>
<span class="go">[  0  12   0   0   0]</span>
<span class="go">[  0   0  32   0   0]</span>
<span class="go">[  0   0   0  32   0]</span>
<span class="go">[  0   0   0   0 384]</span>
<span class="gp">sage: </span><span class="n">JQ</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span><span class="o">.</span><span class="n">jack</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([[</span><span class="n">JQ</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_jack</span><span class="p">(</span><span class="n">JQ</span><span class="p">(</span><span class="n">nu</span><span class="p">))</span> <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
<span class="go">[(1/3*t^2 + 1/2*t + 1/6)/t^3                           0                           0]</span>
<span class="go">[                          0 (1/2*t + 1)/(t^3 + 1/2*t^2)                           0]</span>
<span class="go">[                          0                           0       6/(t^3 + 3*t^2 + 2*t)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_qt">
<span class="sig-name descname"><span class="pre">scalar_qt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_qt" title="Permalink to this definition">#</a></dt>
<dd><p>Return the <span class="math notranslate nohighlight">\(q,t\)</span>-deformed standard Hall-Littlewood scalar product of
<code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the same
base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code> – parameters (default: <code class="docutils literal notranslate"><span class="pre">None</span></code> in which case <code class="docutils literal notranslate"><span class="pre">q</span></code>
and <code class="docutils literal notranslate"><span class="pre">t</span></code> are used)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">sp</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">factor</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
<span class="go">(t - 1)^-3 * (q - 1) * (t^2 + t + 1)^-1 * (q^2*t^2 - q*t^2 + q^2 - 2*q*t + t^2 - q + 1)</span>
<span class="gp">sage: </span><span class="n">sp</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">q</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">(-t^2 - 1)/(t^5 - 2*t^4 + t^3 - t^2 + 2*t - 1)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">-q^3 + 2*q^2 - 2*q + 1</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span> <span class="c1"># q=5 and t=7</span>
<span class="go">490/1539</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;x,y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">q</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
<span class="go">1/3*(x^3 - 1)/(y^3 - 1) + 2/3*(x - 1)^3/(y - 1)^3</span>
<span class="gp">sage: </span><span class="n">Rn</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">Rn</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Mac</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">Rn</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">y</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="n">z</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">Mac</span><span class="o">.</span><span class="n">_sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">(</span><span class="n">Mac</span><span class="o">.</span><span class="n">P</span><span class="p">()(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">Mac</span><span class="o">.</span><span class="n">Q</span><span class="p">()(</span><span class="n">a</span><span class="p">),</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">))</span>
<span class="go">(t - 1)^-3 * (q - 1) * (t^2 + t + 1)^-1 * (q^2*t^2 - q*t^2 + q^2 - 2*q*t + t^2 - q + 1)</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">(</span><span class="n">Mac</span><span class="o">.</span><span class="n">P</span><span class="p">()(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">Mac</span><span class="o">.</span><span class="n">Q</span><span class="p">()(</span><span class="n">a</span><span class="p">)))</span>
<span class="go">(z - 1)^-3 * (y - 1) * (z^2 + z + 1)^-1 * (y^2*z^2 - y*z^2 + y^2 - 2*y*z + z^2 - y + 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_t">
<span class="sig-name descname"><span class="pre">scalar_t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_t" title="Permalink to this definition">#</a></dt>
<dd><p>Return the <span class="math notranslate nohighlight">\(t\)</span>-deformed standard Hall-Littlewood scalar product of
<code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the same
base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – parameter (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>, in which case <code class="docutils literal notranslate"><span class="pre">t</span></code> is used)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">sp</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">scalar_t</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">sp</span>
<span class="go">(-t^2 - 1)/(t^5 - 2*t^4 + t^3 - t^2 + 2*t - 1)</span>
<span class="gp">sage: </span><span class="n">sp</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Fraction Field of Univariate Polynomial Ring in t over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.skew_by">
<span class="sig-name descname"><span class="pre">skew_by</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.skew_by" title="Permalink to this definition">#</a></dt>
<dd><p>Return the result of skewing <code class="docutils literal notranslate"><span class="pre">self</span></code> by <code class="docutils literal notranslate"><span class="pre">x</span></code>. (Skewing by <code class="docutils literal notranslate"><span class="pre">x</span></code> is
the endomorphism (as additive group) of the ring of symmetric
functions adjoint to multiplication by <code class="docutils literal notranslate"><span class="pre">x</span></code> with respect to the
Hall inner product.)</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the same
base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">s[2, 1] + s[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[1, 1, 1] + 2*s[2, 1] + s[3]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">powersum</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">4*p[4, 3, 3, 2]</span>
<span class="gp">sage: </span><span class="n">zee</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">sf</span><span class="o">.</span><span class="n">sfa</span><span class="o">.</span><span class="n">zee</span>
<span class="gp">sage: </span><span class="n">zee</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">zee</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">([]))</span>
<span class="go">s[]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.theta">
<span class="sig-name descname"><span class="pre">theta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.theta" title="Permalink to this definition">#</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the theta endomorphism which sends
<span class="math notranslate nohighlight">\(p_k\)</span> to <span class="math notranslate nohighlight">\(a \cdot p_k\)</span> for every positive integer <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>In general, this is well-defined outside of the powersum basis only
if the base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code> – an element of the base ring</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">theta</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2*s[1, 1, 1] + 6*s[2, 1] + 2*s[3]</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">theta</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2*p[2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">theta</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">theta</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">p[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.theta_qt">
<span class="sig-name descname"><span class="pre">theta_qt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.theta_qt" title="Permalink to this definition">#</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the <span class="math notranslate nohighlight">\(q,t\)</span>-deformed theta
endomorphism which sends <span class="math notranslate nohighlight">\(p_k\)</span> to <span class="math notranslate nohighlight">\(\frac{1-q^k}{1-t^k} \cdot p_k\)</span>
for all positive integers <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>In general, this is well-defined outside of the powersum basis only
if the base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code> – parameters (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>, in which case ‘q’
and ‘t’ are used)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QQqt</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q,t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">q</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">QQqt</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQqt</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">((-q^2+1)/(-t^2+1))*p[2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">((q^3-q^2-q+1)/(t^3-t^2-t+1))*p[2, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3/16*p[2, 1]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">realization_of</span><span class="p">()</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span>
<span class="go">t^3*s[1, 1, 1] + (t^2+t)*s[2, 1] + s[3]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">()</span>
<span class="go">p[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung">
<span class="sig-name descname"><span class="pre">verschiebung</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="Permalink to this definition">#</a></dt>
<dd><p>Return the image of the symmetric function <code class="docutils literal notranslate"><span class="pre">self</span></code> under the
<span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator.</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator <span class="math notranslate nohighlight">\(\mathbf{V}_n\)</span> is defined to be
the unique algebra endomorphism <span class="math notranslate nohighlight">\(V\)</span> of the ring of symmetric
functions that satisfies <span class="math notranslate nohighlight">\(V(h_r) = h_{r/n}\)</span> for every positive
integer <span class="math notranslate nohighlight">\(r\)</span> divisible by <span class="math notranslate nohighlight">\(n\)</span>, and satisfies <span class="math notranslate nohighlight">\(V(h_r) = 0\)</span> for
every positive integer <span class="math notranslate nohighlight">\(r\)</span> not divisible by <span class="math notranslate nohighlight">\(n\)</span>. This operator
<span class="math notranslate nohighlight">\(\mathbf{V}_n\)</span> is a Hopf algebra endomorphism. For every
nonnegative integer <span class="math notranslate nohighlight">\(r\)</span> with <span class="math notranslate nohighlight">\(n \mid r\)</span>, it satisfies</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathbf{V}_n(h_r) = h_{r/n},
\quad \mathbf{V}_n(p_r) = n p_{r/n},
\quad \mathbf{V}_n(e_r) = (-1)^{r - r/n} e_{r/n}\]</div>
</div>
<p>(where <span class="math notranslate nohighlight">\(h\)</span> is the complete homogeneous basis, <span class="math notranslate nohighlight">\(p\)</span> is the
powersum basis, and <span class="math notranslate nohighlight">\(e\)</span> is the elementary basis). For every
nonnegative integer <span class="math notranslate nohighlight">\(r\)</span> with <span class="math notranslate nohighlight">\(n \nmid r\)</span>, it satisfes</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathbf{V}_n(h_r) = \mathbf{V}_n(p_r) = \mathbf{V}_n(e_r) = 0.\]</div>
</div>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator is also called the <span class="math notranslate nohighlight">\(n\)</span>-th
Verschiebung endomorphism. Its name derives from the Verschiebung
(German for “shift”) endomorphism of the Witt vectors.</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator is adjoint to the <span class="math notranslate nohighlight">\(n\)</span>-th
Frobenius operator (see <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius"><code class="xref py py-meth docutils literal notranslate"><span class="pre">frobenius()</span></code></a> for its definition)
with respect to the Hall scalar product (<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scalar()</span></code></a>).</p>
<p>The action of the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator on the Schur basis
can also be computed explicitly. The following (probably clumsier
than necessary) description can be obtained by solving exercise
7.61 in Stanley’s <a class="reference internal" href="sf.html#sta" id="id18"><span>[STA]</span></a>.</p>
<p>Let <span class="math notranslate nohighlight">\(\lambda\)</span> be a partition. Let <span class="math notranslate nohighlight">\(n\)</span> be a positive integer. If
the <span class="math notranslate nohighlight">\(n\)</span>-core of <span class="math notranslate nohighlight">\(\lambda\)</span> is nonempty, then
<span class="math notranslate nohighlight">\(\mathbf{V}_n(s_\lambda) = 0\)</span>. Otherwise, the following method
computes <span class="math notranslate nohighlight">\(\mathbf{V}_n(s_\lambda)\)</span>: Write the partition <span class="math notranslate nohighlight">\(\lambda\)</span>
in the form <span class="math notranslate nohighlight">\((\lambda_1, \lambda_2, \ldots, \lambda_{ns})\)</span> for some
nonnegative integer <span class="math notranslate nohighlight">\(s\)</span>. (If <span class="math notranslate nohighlight">\(n\)</span> does not divide the length of
<span class="math notranslate nohighlight">\(\lambda\)</span>, then this is achieved by adding trailing zeroes to
<span class="math notranslate nohighlight">\(\lambda\)</span>.) Set <span class="math notranslate nohighlight">\(\beta_i = \lambda_i + ns - i\)</span> for every
<span class="math notranslate nohighlight">\(s \in \{ 1, 2, \ldots, ns \}\)</span>. Then,
<span class="math notranslate nohighlight">\((\beta_1, \beta_2, \ldots, \beta_{ns})\)</span> is a strictly decreasing
sequence of nonnegative integers. Stably sort the list
<span class="math notranslate nohighlight">\((1, 2, \ldots, ns)\)</span> in order of (weakly) increasing remainder of
<span class="math notranslate nohighlight">\(-1 - \beta_i\)</span> modulo <span class="math notranslate nohighlight">\(n\)</span>. Let <span class="math notranslate nohighlight">\(\xi\)</span> be the sign of the
permutation that is used for this sorting. Let <span class="math notranslate nohighlight">\(\psi\)</span> be the sign
of the permutation that is used to stably sort the list
<span class="math notranslate nohighlight">\((1, 2, \ldots, ns)\)</span> in order of (weakly) increasing remainder of
<span class="math notranslate nohighlight">\(i - 1\)</span> modulo <span class="math notranslate nohighlight">\(n\)</span>. (Notice that <span class="math notranslate nohighlight">\(\psi = (-1)^{n(n-1)s(s-1)/4}\)</span>.)
Then, <span class="math notranslate nohighlight">\(\mathbf{V}_n(s_\lambda) = \xi \psi \prod_{i = 0}^{n - 1}
s_{\lambda^{(i)}}\)</span>, where
<span class="math notranslate nohighlight">\((\lambda^{(0)}, \lambda^{(1)}, \ldots, \lambda^{(n - 1)})\)</span>
is the <span class="math notranslate nohighlight">\(n\)</span>-quotient of <span class="math notranslate nohighlight">\(\lambda\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a positive integer</p></li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator (on the ring of
symmetric functions) to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">s[1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3*p[1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">-18*m[1, 1] - 3*m[2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">h[2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2*p[1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">12*m[1]</span>
</pre></div>
</div>
<p>The Verschiebung endomorphisms are multiplicative:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">....: </span>          <span class="o">==</span> <span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Being Hopf algebra endomorphisms, the Verschiebung operators
commute with the antipode:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Testing the adjointness between the Frobenius operators
<span class="math notranslate nohighlight">\(\mathbf{f}_n\)</span> and the Verschiebung operators
<span class="math notranslate nohighlight">\(\mathbf{V}_n\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
<span class="gp">....: </span>          <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionsBases">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.sf.sfa.</span></span><span class="sig-name descname"><span class="pre">SymmetricFunctionsBases</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parent_with_realization</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/realizations.html#sage.categories.realizations.Category_realization_of_parent" title="(in Category Framework v10.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Category_realization_of_parent</span></code></a></p>
<p>The category of bases of the ring of symmetric functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self</span></code> – a category of bases for the symmetric functions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">base</span></code> – ring of symmetric functions</p></li>
</ul>
<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ParentMethods</span></span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.Eulerian">
<span class="sig-name descname"><span class="pre">Eulerian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.Eulerian" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Eulerian symmetric function <span class="math notranslate nohighlight">\(Q_{n,j}\)</span> (with <span class="math notranslate nohighlight">\(n\)</span>
either an integer or a partition) or <span class="math notranslate nohighlight">\(Q_{n,j,k}\)</span> (if the
optional argument <code class="docutils literal notranslate"><span class="pre">k</span></code> is specified) in terms of the basis
<code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>It is known that the Eulerian quasisymmetric functions are
in fact symmetric functions <a class="reference internal" href="../ncsf_qsym/qsym.html#sw2010" id="id19"><span>[SW2010]</span></a>. For more information,
see <a class="reference internal" href="../ncsf_qsym/qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Fundamental.Eulerian" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Fundamental.Eulerian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">QuasiSymmetricFunctions.Fundamental.Eulerian()</span></code></a>,
which accepts the same syntax as this method.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – the nonnegative integer <span class="math notranslate nohighlight">\(n\)</span> or a partition</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">j</span></code> – the number of excedances</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – (optional) if specified, determines the number of fixed
points of the permutations which are being summed over</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">4*m[1, 1, 1] + 3*m[2, 1] + 2*m[3]</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">h[2, 2] + h[3, 1] + h[4]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">s[2, 2, 1] + s[3, 1, 1] + 5*s[3, 2] + 6*s[4, 1] + 6*s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">s[2, 2, 1] + s[3, 2] + s[4, 1] + s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">s[3, 2] + s[4, 1] + s[5]</span>
</pre></div>
</div>
<p>We check Equation (5.4) in <a class="reference internal" href="../ncsf_qsym/qsym.html#sw2010" id="id20"><span>[SW2010]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">h[3, 2, 1] - h[4, 1, 1] + 2*h[4, 2] + h[5, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">s[3, 2, 1] + s[3, 3] + 3*s[4, 2] + 3*s[5, 1] + 3*s[6]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.carlitz_shareshian_wachs">
<span class="sig-name descname"><span class="pre">carlitz_shareshian_wachs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comparison</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.carlitz_shareshian_wachs" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Carlitz-Shareshian-Wachs symmetric function
<span class="math notranslate nohighlight">\(X_{n, d, s}\)</span> (if <code class="docutils literal notranslate"><span class="pre">comparison</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>), or
<span class="math notranslate nohighlight">\(U_{n, d, s}\)</span> (if <code class="docutils literal notranslate"><span class="pre">comparison</span></code> is <code class="docutils literal notranslate"><span class="pre">-1</span></code>), or
<span class="math notranslate nohighlight">\(V_{n, d, s}\)</span> (if <code class="docutils literal notranslate"><span class="pre">comparison</span></code> is <code class="docutils literal notranslate"><span class="pre">0</span></code>), or
<span class="math notranslate nohighlight">\(W_{n, d, s}\)</span> (if <code class="docutils literal notranslate"><span class="pre">comparison</span></code> is <code class="docutils literal notranslate"><span class="pre">1</span></code>) written in the
basis <code class="docutils literal notranslate"><span class="pre">self</span></code>. These functions are defined below.</p>
<p>The Carlitz-Shareshian-Wachs symmetric functions have been
introduced in <a class="reference internal" href="../../../../references/index.html#grirei18" id="id21"><span>[GriRei18]</span></a>, Exercise 2.9.11, as
refinements of a certain particular case of chromatic
quasisymmetric functions defined by Shareshian and Wachs.
Their definitions are as follows:</p>
<p>Let <span class="math notranslate nohighlight">\(n\)</span>, <span class="math notranslate nohighlight">\(d\)</span> and <span class="math notranslate nohighlight">\(s\)</span> be three nonnegative integers. Let
<span class="math notranslate nohighlight">\(W(n, d, s)\)</span> denote the set of all <span class="math notranslate nohighlight">\(n\)</span>-tuples
<span class="math notranslate nohighlight">\((w_1, w_2, \ldots, w_n)\)</span> of positive integers having the
property that there exist precisely <span class="math notranslate nohighlight">\(d\)</span> elements <span class="math notranslate nohighlight">\(i\)</span>
of <span class="math notranslate nohighlight">\(\left\{ 1, 2, \ldots, n-1 \right\}\)</span> satisfying
<span class="math notranslate nohighlight">\(w_i &gt; w_{i+1}\)</span>, and precisely <span class="math notranslate nohighlight">\(s\)</span> elements <span class="math notranslate nohighlight">\(i\)</span> of
<span class="math notranslate nohighlight">\(\left\{ 1, 2, \ldots, n-1 \right\}\)</span> satisfying
<span class="math notranslate nohighlight">\(w_i = w_{i+1}\)</span>. For every
<span class="math notranslate nohighlight">\(w = (w_1, w_2, \ldots, w_n) \in W(n, d, s)\)</span>, let <span class="math notranslate nohighlight">\(x_w\)</span>
be the monomial <span class="math notranslate nohighlight">\(x_{w_1} x_{w_2} \cdots x_{w_n}\)</span>. We then
define the power series <span class="math notranslate nohighlight">\(X_{n, d, s}\)</span> by</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[X_{n, d, s} = \sum_{w \in W(n, d, s)} x_w .\]</div>
</div>
<p>This is a symmetric function (according to
<a class="reference internal" href="../../../../references/index.html#grirei18" id="id22"><span>[GriRei18]</span></a>, Exercise 2.9.11(b)), and for <span class="math notranslate nohighlight">\(s = 0\)</span> equals
the <span class="math notranslate nohighlight">\(t^d\)</span>-coefficient of the descent enumerator of Smirnov
words of length <span class="math notranslate nohighlight">\(n\)</span> (an example of a chromatic
quasisymmetric function which happens to be symmetric –
see <a class="reference internal" href="#shawach2014" id="id23"><span>[ShaWach2014]</span></a>, Example 2.5).</p>
<p>Assume that <span class="math notranslate nohighlight">\(n &gt; 0\)</span>. Then, we can define three further
power series as follows:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[U_{n, d, s} = \sum_{w_1 &lt; w_n} x_w ; \qquad
V_{n, d, s} = \sum_{w_1 = w_n} x_w ; \qquad
W_{n, d, s} = \sum_{w_1 &gt; w_n} x_w ,\]</div>
</div>
<p>where all three sums range over
<span class="math notranslate nohighlight">\(w = (w_1, w_2, \ldots, w_n) \in W(n, d, s)\)</span>. These
three power series <span class="math notranslate nohighlight">\(U_{n, d, s}\)</span>, <span class="math notranslate nohighlight">\(V_{n, d, s}\)</span> and
<span class="math notranslate nohighlight">\(W_{n, d, s}\)</span> are symmetric functions as well
(<a class="reference internal" href="../../../../references/index.html#grirei18" id="id24"><span>[GriRei18]</span></a>, Exercise 2.9.11(c)). Their sum is
<span class="math notranslate nohighlight">\(X_{n, d, s}\)</span>.</p>
<p>REFERENCES:</p>
<div role="list" class="citation-list">
<div class="citation" id="shawach2014" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id23">ShaWach2014</a><span class="fn-bracket">]</span></span>
<p>John Shareshian, Michelle L. Wachs.
<em>Chromatic quasisymmetric functions</em>.
<a class="reference external" href="https://arxiv.org/abs/1405.4629v2">arXiv 1405.4629v2</a>.</p>
</div>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a nonnegative integer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">d</span></code> – a nonnegative integer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> – a nonnegative integer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">comparison</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) – a variable
which can take the forms <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">-1</span></code>, <code class="docutils literal notranslate"><span class="pre">0</span></code>
and <code class="docutils literal notranslate"><span class="pre">1</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<p>The Carlitz-Shareshian-Wachs symmetric function
<span class="math notranslate nohighlight">\(X_{n, d, s}\)</span> (if <code class="docutils literal notranslate"><span class="pre">comparison</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>), or
<span class="math notranslate nohighlight">\(U_{n, d, s}\)</span> (if <code class="docutils literal notranslate"><span class="pre">comparison</span></code> is <code class="docutils literal notranslate"><span class="pre">-1</span></code>), or
<span class="math notranslate nohighlight">\(V_{n, d, s}\)</span> (if <code class="docutils literal notranslate"><span class="pre">comparison</span></code> is <code class="docutils literal notranslate"><span class="pre">0</span></code>), or
<span class="math notranslate nohighlight">\(W_{n, d, s}\)</span> (if <code class="docutils literal notranslate"><span class="pre">comparison</span></code> is <code class="docutils literal notranslate"><span class="pre">1</span></code>) written in the
basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<p>The power series <span class="math notranslate nohighlight">\(X_{n, d, s}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">m[2, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">m[3]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">4*m[1, 1, 1] + m[2, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">m[2, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">m[2, 2, 1] + m[3, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">m[1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">m[]</span>
</pre></div>
</div>
<p>The power series <span class="math notranslate nohighlight">\(U_{n, d, s}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">2*m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">m[2, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">3*m[1, 1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>The power series <span class="math notranslate nohighlight">\(V_{n, d, s}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">m[3]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">m[2, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">m[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">m[1]</span>
</pre></div>
</div>
<p>The power series <span class="math notranslate nohighlight">\(W_{n, d, s}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">m[2, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">2*m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">m[2, 2, 1] + m[3, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">8*m[1, 1, 1, 1] + 2*m[2, 1, 1] + m[2, 2]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.corresponding_basis_over">
<span class="sig-name descname"><span class="pre">corresponding_basis_over</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.corresponding_basis_over" title="Permalink to this definition">#</a></dt>
<dd><p>Return the realization of symmetric functions corresponding to
<code class="docutils literal notranslate"><span class="pre">self</span></code> but over the base ring <code class="docutils literal notranslate"><span class="pre">R</span></code>. Only works when <code class="docutils literal notranslate"><span class="pre">self</span></code>
is one of the classical bases, not one of the <span class="math notranslate nohighlight">\(q,t\)</span>-dependent
ones. In the latter case, <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned instead.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">R</span></code> – a commutative ring</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Symmetric Functions over Integer Ring in the monomial basis</span>

<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">Integers</span><span class="p">(</span><span class="mi">13</span><span class="p">))</span>
<span class="go">Symmetric Functions over Ring of integers modulo 13 in the Schur basis</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mj</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">J</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">mj</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">Integers</span><span class="p">(</span><span class="mi">13</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="id25">
<p class="admonition-title">Todo</p>
<p>This function is an ugly hack using strings. It should be
rewritten as soon as the bases of <code class="docutils literal notranslate"><span class="pre">SymmetricFunctions</span></code> are
put on a more robust and systematic footing.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.degree_on_basis">
<span class="sig-name descname"><span class="pre">degree_on_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.degree_on_basis" title="Permalink to this definition">#</a></dt>
<dd><p>Return the degree of the basis element indexed by <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self</span></code> – a basis of the symmetric functions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> – a partition</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q,t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">degree_on_basis</span><span class="p">(</span><span class="n">Partition</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">P</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">degree_on_basis</span><span class="p">(</span><span class="n">Partition</span><span class="p">([]))</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.formal_series_ring">
<span class="sig-name descname"><span class="pre">formal_series_ring</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.formal_series_ring" title="Permalink to this definition">#</a></dt>
<dd><p>Return the completion of all formal linear combinations of
<code class="docutils literal notranslate"><span class="pre">self</span></code> with finite linear combinations in each homogeneous
degree (computed lazily).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">formal_series_ring</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span>
<span class="go">Lazy completion of Symmetric Functions over Integer Ring in the Schur basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.gessel_reutenauer">
<span class="sig-name descname"><span class="pre">gessel_reutenauer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lam</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.gessel_reutenauer" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Gessel-Reutenauer symmetric function
corresponding to the partition <code class="docutils literal notranslate"><span class="pre">lam</span></code> written in the basis
<code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(\lambda\)</span> be a partition. The <em>Gessel-Reutenauer
symmetric function</em> <span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> corresponding to
<span class="math notranslate nohighlight">\(\lambda\)</span> is the symmetric function denoted <span class="math notranslate nohighlight">\(L_\lambda\)</span> in
<a class="reference internal" href="../../../../references/index.html#gr1993" id="id26"><span>[GR1993]</span></a> and in Exercise 7.89 of <a class="reference internal" href="sf.html#sta" id="id27"><span>[STA]</span></a> and denoted
<span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> in Definition 6.6.34 of <a class="reference internal" href="../../../../references/index.html#grirei18" id="id28"><span>[GriRei18]</span></a>.
It is also called the <em>higher Lie character</em>, for instance
in <a class="reference internal" href="../../../../references/index.html#sch2003b" id="id29"><span>[Sch2003b]</span></a>.
It can be defined in several ways:</p>
<ul>
<li><p>It is the sum of the monomials <span class="math notranslate nohighlight">\(\mathbf{x}_w\)</span> over all
words <span class="math notranslate nohighlight">\(w\)</span> over the alphabet
<span class="math notranslate nohighlight">\(\left\{ 1, 2, 3, \ldots \right\}\)</span> which have CFL type
<span class="math notranslate nohighlight">\(\lambda\)</span>. Here, the monomial <span class="math notranslate nohighlight">\(\mathbf{x}_w\)</span> for a word
<span class="math notranslate nohighlight">\(w = \left(w_1, w_2, \ldots, w_k\right)\)</span> is defined as
<span class="math notranslate nohighlight">\(x_{w_1} x_{w_2} \cdots x_{w_k}\)</span>, and the <em>CFL type</em> of
a word <span class="math notranslate nohighlight">\(w\)</span> is defined as the partition obtained by
sorting (in decreasing order) the lengths of the factors
in the Lyndon factorization
(<a class="reference internal" href="../words/finite_word.html#sage.combinat.words.finite_word.FiniteWord_class.lyndon_factorization" title="sage.combinat.words.finite_word.FiniteWord_class.lyndon_factorization"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lyndon_factorization()</span></code></a>)
of <span class="math notranslate nohighlight">\(w\)</span>. The fact that this power series
<span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> is symmetric is not obvious.</p></li>
<li><p>It is the sum of the fundamental quasisymmetric
functions <span class="math notranslate nohighlight">\(F_{\operatorname{Des} \sigma}\)</span> over all
permutations <span class="math notranslate nohighlight">\(\sigma\)</span> that have cycle type <span class="math notranslate nohighlight">\(\lambda\)</span>. See
<a class="reference internal" href="../ncsf_qsym/qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Fundamental" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Fundamental"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Fundamental</span></code></a>
for the definition of fundamental quasisymmetric functions,
and <a class="reference internal" href="../permutation.html#sage.combinat.permutation.Permutation.cycle_type" title="sage.combinat.permutation.Permutation.cycle_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cycle_type()</span></code></a>
for that of cycle type. For a permutation <span class="math notranslate nohighlight">\(\sigma\)</span>, we use
<span class="math notranslate nohighlight">\(\operatorname{Des} \sigma\)</span> to denote the descent composition
(<a class="reference internal" href="../permutation.html#sage.combinat.permutation.Permutation.descents_composition" title="sage.combinat.permutation.Permutation.descents_composition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">descents_composition()</span></code></a>)
of <span class="math notranslate nohighlight">\(\sigma\)</span>. Again, this definition does not make the
symmetry of <span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> obvious.</p></li>
<li><p>For every positive integer <span class="math notranslate nohighlight">\(n\)</span>, we have</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathbf{GR}_{\left(n\right)}
= \frac{1}{n} \sum_{d \mid n} \mu(d) p_d^{n/d},\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(p_d\)</span> denotes the <span class="math notranslate nohighlight">\(d\)</span>-th power-sum symmetric
function. This <span class="math notranslate nohighlight">\(\mathbf{GR}_{\left(n\right)}\)</span> is also
denoted by <span class="math notranslate nohighlight">\(L_n\)</span>, and is called the Lie character. Now,
the higher Lie character <span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> is defined as the product:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[h_{m_1} \left[L_1\right] \cdot h_{m_2} \left[L_2\right]
\cdot h_{m_3} \left[L_3\right] \cdots,\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(m_i\)</span> denotes the multiplicity of the part <span class="math notranslate nohighlight">\(i\)</span> in
<span class="math notranslate nohighlight">\(\lambda\)</span>, and where the square brackets stand for
plethysm (<code class="xref py py-meth docutils literal notranslate"><span class="pre">plethysm()</span></code>). This definition makes
the symmetry (but not the integrality!) of
<span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> obvious.</p>
</li>
</ul>
<p>The equivalences of these three definitions are proven in
<a class="reference internal" href="../../../../references/index.html#gr1993" id="id30"><span>[GR1993]</span></a> Sections 2-3. (See also <a class="reference internal" href="../../../../references/index.html#grirei18" id="id31"><span>[GriRei18]</span></a> Subsection
6.6.2 for the equivalence of the first two definitions and
further formulas.)</p>
<p><span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> has further significance in representations afforded
by the tensor algebra <span class="math notranslate nohighlight">\(T(V)\)</span> of a finite dimensional vector space.
The Poincaré-Birkhoff-Witt theorem describes the universal enveloping algebra
of a Lie algebra. It gives a decomposition of the degree-<span class="math notranslate nohighlight">\(n\)</span> component <span class="math notranslate nohighlight">\(T_n(V)\)</span>
of <span class="math notranslate nohighlight">\(T(V)\)</span> into <span class="math notranslate nohighlight">\(GL(V)\)</span> representations indexed by partitions.
The higher Lie characters are the symmetric group <span class="math notranslate nohighlight">\(S_n\)</span> characters corresponding
to this decomposition via Schur-Weyl duality.</p>
<p>Another important question, <em>Thrall’s problem</em> (see e.g. <a class="reference internal" href="../../../../references/index.html#sch2003b" id="id32"><span>[Sch2003b]</span></a>)
asks, for <span class="math notranslate nohighlight">\(\lambda\)</span> a partition of <span class="math notranslate nohighlight">\(n\)</span>, can we combinatorially interpret
the coefficients <span class="math notranslate nohighlight">\(\alpha_\mu^\lambda\)</span> in the Schur-expansion of
<span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span>:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathbf{GR}_\lambda = \sum_{\mu \vdash n} \alpha_\mu^\lambda s_\mu.\]</div>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">lam</span></code> – a partition or a positive integer (in the latter
case, it is understood to mean the partition <code class="docutils literal notranslate"><span class="pre">[lam]</span></code>)</p></li>
</ul>
<p>OUTPUT:</p>
<p>The Gessel-Reutenauer symmetric function
<span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span>, where <span class="math notranslate nohighlight">\(\lambda\)</span> is <code class="docutils literal notranslate"><span class="pre">lam</span></code>,
expanded in the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<p>The first few values of <span class="math notranslate nohighlight">\(\mathbf{GR}_{(n)} = L_n\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">h[1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">h[1, 1] - h[2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">h[2, 1] - h[3]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">h[2, 1, 1] - h[2, 2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">h[2, 1, 1, 1] - h[2, 2, 1] - h[3, 1, 1] + h[3, 2] + h[4, 1] - h[5]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">h[2, 1, 1, 1, 1] - h[2, 2, 1, 1] - h[2, 2, 2]</span>
<span class="go"> - 2*h[3, 1, 1, 1] + 5*h[3, 2, 1] - 2*h[3, 3] + h[4, 1, 1]</span>
<span class="go"> - h[4, 2] - h[5, 1] + h[6]</span>
</pre></div>
</div>
<p>Gessel-Reutenauer functions indexed by partitions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">h[1, 1, 1] - h[2, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">h[1, 1, 1, 1] - 3*h[2, 1, 1] + 2*h[2, 2] + h[3, 1] - h[4]</span>
</pre></div>
</div>
<p>The Gessel-Reutenauer functions are Schur-positive:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1] + s[2, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1, 1, 1] + s[2, 1, 1, 1] + s[2, 2, 1] + s[3, 2]</span>
</pre></div>
</div>
<p>They do not form a basis, as the following example (from
<a class="reference internal" href="../../../../references/index.html#gr1993" id="id33"><span>[GR1993]</span></a> p. 201) shows:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>They also go by the name <em>higher Lie character</em>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">higher_lie_character</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Of the above three equivalent definitions of
<span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span>, we use the third one for
computations. Let us check that the second one gives the
same results:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QSym</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QSym</span><span class="o">.</span><span class="n">F</span><span class="p">()</span> <span class="c1"># fundamental basis</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">GR_def2</span><span class="p">(</span><span class="n">lam</span><span class="p">):</span> <span class="c1"># `\mathbf{GR}_\lambda`</span>
<span class="gp">....: </span>    <span class="n">n</span> <span class="o">=</span> <span class="n">lam</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="n">r</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">sum_of_monomials</span><span class="p">([</span><span class="n">sigma</span><span class="o">.</span><span class="n">descents_composition</span><span class="p">()</span>
<span class="gp">....: </span>                            <span class="k">for</span> <span class="n">sigma</span> <span class="ow">in</span> <span class="n">Permutations</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">....: </span>                            <span class="k">if</span> <span class="n">sigma</span><span class="o">.</span><span class="n">cycle_type</span><span class="p">()</span> <span class="o">==</span> <span class="n">lam</span><span class="p">])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">GR_def2</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>And the first one, too (assuming symmetry):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">GR_def1</span><span class="p">(</span><span class="n">lam</span><span class="p">):</span> <span class="c1"># `\mathbf{GR}_\lambda`</span>
<span class="gp">....: </span>    <span class="n">n</span> <span class="o">=</span> <span class="n">lam</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="n">Permus_mset</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">permutation</span><span class="o">.</span><span class="n">Permutations_mset</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">coeff_of_m_mu_in_result</span><span class="p">(</span><span class="n">mu</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">words_to_check</span> <span class="o">=</span> <span class="n">Permus_mset</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
<span class="gp">....: </span>                                      <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">)])</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="mi">1</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">words_to_check</span> <span class="k">if</span>
<span class="gp">....: </span>                    <span class="n">Partition</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Word</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">lyndon_factorization</span><span class="p">()]))))</span>
<span class="gp">....: </span>                    <span class="o">==</span> <span class="n">lam</span><span class="p">))</span>
<span class="gp">....: </span>    <span class="n">r</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">sum_of_terms</span><span class="p">([(</span><span class="n">mu</span><span class="p">,</span> <span class="n">coeff_of_m_mu_in_result</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
<span class="gp">....: </span>                        <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)],</span>
<span class="gp">....: </span>                       <span class="n">distinct</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">r</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">GR_def1</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The currently existing implementation of this function is
technically unsatisfactory. It distinguishes the case when the
base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra from the case
where it isn’t. In the latter, it does a computation using
universal coefficients, again distinguishing the case when it is
able to compute the “corresponding” basis of the symmetric function
algebra over <span class="math notranslate nohighlight">\(\QQ\)</span> (using the <code class="docutils literal notranslate"><span class="pre">corresponding_basis_over</span></code> hack)
from the case when it isn’t (in which case it transforms everything
into the Schur basis, which is slow).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.higher_lie_character">
<span class="sig-name descname"><span class="pre">higher_lie_character</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lam</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.higher_lie_character" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Gessel-Reutenauer symmetric function
corresponding to the partition <code class="docutils literal notranslate"><span class="pre">lam</span></code> written in the basis
<code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(\lambda\)</span> be a partition. The <em>Gessel-Reutenauer
symmetric function</em> <span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> corresponding to
<span class="math notranslate nohighlight">\(\lambda\)</span> is the symmetric function denoted <span class="math notranslate nohighlight">\(L_\lambda\)</span> in
<a class="reference internal" href="../../../../references/index.html#gr1993" id="id34"><span>[GR1993]</span></a> and in Exercise 7.89 of <a class="reference internal" href="sf.html#sta" id="id35"><span>[STA]</span></a> and denoted
<span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> in Definition 6.6.34 of <a class="reference internal" href="../../../../references/index.html#grirei18" id="id36"><span>[GriRei18]</span></a>.
It is also called the <em>higher Lie character</em>, for instance
in <a class="reference internal" href="../../../../references/index.html#sch2003b" id="id37"><span>[Sch2003b]</span></a>.
It can be defined in several ways:</p>
<ul>
<li><p>It is the sum of the monomials <span class="math notranslate nohighlight">\(\mathbf{x}_w\)</span> over all
words <span class="math notranslate nohighlight">\(w\)</span> over the alphabet
<span class="math notranslate nohighlight">\(\left\{ 1, 2, 3, \ldots \right\}\)</span> which have CFL type
<span class="math notranslate nohighlight">\(\lambda\)</span>. Here, the monomial <span class="math notranslate nohighlight">\(\mathbf{x}_w\)</span> for a word
<span class="math notranslate nohighlight">\(w = \left(w_1, w_2, \ldots, w_k\right)\)</span> is defined as
<span class="math notranslate nohighlight">\(x_{w_1} x_{w_2} \cdots x_{w_k}\)</span>, and the <em>CFL type</em> of
a word <span class="math notranslate nohighlight">\(w\)</span> is defined as the partition obtained by
sorting (in decreasing order) the lengths of the factors
in the Lyndon factorization
(<a class="reference internal" href="../words/finite_word.html#sage.combinat.words.finite_word.FiniteWord_class.lyndon_factorization" title="sage.combinat.words.finite_word.FiniteWord_class.lyndon_factorization"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lyndon_factorization()</span></code></a>)
of <span class="math notranslate nohighlight">\(w\)</span>. The fact that this power series
<span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> is symmetric is not obvious.</p></li>
<li><p>It is the sum of the fundamental quasisymmetric
functions <span class="math notranslate nohighlight">\(F_{\operatorname{Des} \sigma}\)</span> over all
permutations <span class="math notranslate nohighlight">\(\sigma\)</span> that have cycle type <span class="math notranslate nohighlight">\(\lambda\)</span>. See
<a class="reference internal" href="../ncsf_qsym/qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Fundamental" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Fundamental"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Fundamental</span></code></a>
for the definition of fundamental quasisymmetric functions,
and <a class="reference internal" href="../permutation.html#sage.combinat.permutation.Permutation.cycle_type" title="sage.combinat.permutation.Permutation.cycle_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cycle_type()</span></code></a>
for that of cycle type. For a permutation <span class="math notranslate nohighlight">\(\sigma\)</span>, we use
<span class="math notranslate nohighlight">\(\operatorname{Des} \sigma\)</span> to denote the descent composition
(<a class="reference internal" href="../permutation.html#sage.combinat.permutation.Permutation.descents_composition" title="sage.combinat.permutation.Permutation.descents_composition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">descents_composition()</span></code></a>)
of <span class="math notranslate nohighlight">\(\sigma\)</span>. Again, this definition does not make the
symmetry of <span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> obvious.</p></li>
<li><p>For every positive integer <span class="math notranslate nohighlight">\(n\)</span>, we have</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathbf{GR}_{\left(n\right)}
= \frac{1}{n} \sum_{d \mid n} \mu(d) p_d^{n/d},\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(p_d\)</span> denotes the <span class="math notranslate nohighlight">\(d\)</span>-th power-sum symmetric
function. This <span class="math notranslate nohighlight">\(\mathbf{GR}_{\left(n\right)}\)</span> is also
denoted by <span class="math notranslate nohighlight">\(L_n\)</span>, and is called the Lie character. Now,
the higher Lie character <span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> is defined as the product:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[h_{m_1} \left[L_1\right] \cdot h_{m_2} \left[L_2\right]
\cdot h_{m_3} \left[L_3\right] \cdots,\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(m_i\)</span> denotes the multiplicity of the part <span class="math notranslate nohighlight">\(i\)</span> in
<span class="math notranslate nohighlight">\(\lambda\)</span>, and where the square brackets stand for
plethysm (<code class="xref py py-meth docutils literal notranslate"><span class="pre">plethysm()</span></code>). This definition makes
the symmetry (but not the integrality!) of
<span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> obvious.</p>
</li>
</ul>
<p>The equivalences of these three definitions are proven in
<a class="reference internal" href="../../../../references/index.html#gr1993" id="id38"><span>[GR1993]</span></a> Sections 2-3. (See also <a class="reference internal" href="../../../../references/index.html#grirei18" id="id39"><span>[GriRei18]</span></a> Subsection
6.6.2 for the equivalence of the first two definitions and
further formulas.)</p>
<p><span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> has further significance in representations afforded
by the tensor algebra <span class="math notranslate nohighlight">\(T(V)\)</span> of a finite dimensional vector space.
The Poincaré-Birkhoff-Witt theorem describes the universal enveloping algebra
of a Lie algebra. It gives a decomposition of the degree-<span class="math notranslate nohighlight">\(n\)</span> component <span class="math notranslate nohighlight">\(T_n(V)\)</span>
of <span class="math notranslate nohighlight">\(T(V)\)</span> into <span class="math notranslate nohighlight">\(GL(V)\)</span> representations indexed by partitions.
The higher Lie characters are the symmetric group <span class="math notranslate nohighlight">\(S_n\)</span> characters corresponding
to this decomposition via Schur-Weyl duality.</p>
<p>Another important question, <em>Thrall’s problem</em> (see e.g. <a class="reference internal" href="../../../../references/index.html#sch2003b" id="id40"><span>[Sch2003b]</span></a>)
asks, for <span class="math notranslate nohighlight">\(\lambda\)</span> a partition of <span class="math notranslate nohighlight">\(n\)</span>, can we combinatorially interpret
the coefficients <span class="math notranslate nohighlight">\(\alpha_\mu^\lambda\)</span> in the Schur-expansion of
<span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span>:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathbf{GR}_\lambda = \sum_{\mu \vdash n} \alpha_\mu^\lambda s_\mu.\]</div>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">lam</span></code> – a partition or a positive integer (in the latter
case, it is understood to mean the partition <code class="docutils literal notranslate"><span class="pre">[lam]</span></code>)</p></li>
</ul>
<p>OUTPUT:</p>
<p>The Gessel-Reutenauer symmetric function
<span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span>, where <span class="math notranslate nohighlight">\(\lambda\)</span> is <code class="docutils literal notranslate"><span class="pre">lam</span></code>,
expanded in the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<p>The first few values of <span class="math notranslate nohighlight">\(\mathbf{GR}_{(n)} = L_n\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">h[1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">h[1, 1] - h[2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">h[2, 1] - h[3]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">h[2, 1, 1] - h[2, 2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">h[2, 1, 1, 1] - h[2, 2, 1] - h[3, 1, 1] + h[3, 2] + h[4, 1] - h[5]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">h[2, 1, 1, 1, 1] - h[2, 2, 1, 1] - h[2, 2, 2]</span>
<span class="go"> - 2*h[3, 1, 1, 1] + 5*h[3, 2, 1] - 2*h[3, 3] + h[4, 1, 1]</span>
<span class="go"> - h[4, 2] - h[5, 1] + h[6]</span>
</pre></div>
</div>
<p>Gessel-Reutenauer functions indexed by partitions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">h[1, 1, 1] - h[2, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">h[1, 1, 1, 1] - 3*h[2, 1, 1] + 2*h[2, 2] + h[3, 1] - h[4]</span>
</pre></div>
</div>
<p>The Gessel-Reutenauer functions are Schur-positive:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1] + s[2, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1, 1, 1] + s[2, 1, 1, 1] + s[2, 2, 1] + s[3, 2]</span>
</pre></div>
</div>
<p>They do not form a basis, as the following example (from
<a class="reference internal" href="../../../../references/index.html#gr1993" id="id41"><span>[GR1993]</span></a> p. 201) shows:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>They also go by the name <em>higher Lie character</em>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">higher_lie_character</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Of the above three equivalent definitions of
<span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span>, we use the third one for
computations. Let us check that the second one gives the
same results:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QSym</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QSym</span><span class="o">.</span><span class="n">F</span><span class="p">()</span> <span class="c1"># fundamental basis</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">GR_def2</span><span class="p">(</span><span class="n">lam</span><span class="p">):</span> <span class="c1"># `\mathbf{GR}_\lambda`</span>
<span class="gp">....: </span>    <span class="n">n</span> <span class="o">=</span> <span class="n">lam</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="n">r</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">sum_of_monomials</span><span class="p">([</span><span class="n">sigma</span><span class="o">.</span><span class="n">descents_composition</span><span class="p">()</span>
<span class="gp">....: </span>                            <span class="k">for</span> <span class="n">sigma</span> <span class="ow">in</span> <span class="n">Permutations</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">....: </span>                            <span class="k">if</span> <span class="n">sigma</span><span class="o">.</span><span class="n">cycle_type</span><span class="p">()</span> <span class="o">==</span> <span class="n">lam</span><span class="p">])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">GR_def2</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>And the first one, too (assuming symmetry):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">GR_def1</span><span class="p">(</span><span class="n">lam</span><span class="p">):</span> <span class="c1"># `\mathbf{GR}_\lambda`</span>
<span class="gp">....: </span>    <span class="n">n</span> <span class="o">=</span> <span class="n">lam</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="n">Permus_mset</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">permutation</span><span class="o">.</span><span class="n">Permutations_mset</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">coeff_of_m_mu_in_result</span><span class="p">(</span><span class="n">mu</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">words_to_check</span> <span class="o">=</span> <span class="n">Permus_mset</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
<span class="gp">....: </span>                                      <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">)])</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="mi">1</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">words_to_check</span> <span class="k">if</span>
<span class="gp">....: </span>                    <span class="n">Partition</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Word</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">lyndon_factorization</span><span class="p">()]))))</span>
<span class="gp">....: </span>                    <span class="o">==</span> <span class="n">lam</span><span class="p">))</span>
<span class="gp">....: </span>    <span class="n">r</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">sum_of_terms</span><span class="p">([(</span><span class="n">mu</span><span class="p">,</span> <span class="n">coeff_of_m_mu_in_result</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
<span class="gp">....: </span>                        <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)],</span>
<span class="gp">....: </span>                       <span class="n">distinct</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">r</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">GR_def1</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The currently existing implementation of this function is
technically unsatisfactory. It distinguishes the case when the
base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra from the case
where it isn’t. In the latter, it does a computation using
universal coefficients, again distinguishing the case when it is
able to compute the “corresponding” basis of the symmetric function
algebra over <span class="math notranslate nohighlight">\(\QQ\)</span> (using the <code class="docutils literal notranslate"><span class="pre">corresponding_basis_over</span></code> hack)
from the case when it isn’t (in which case it transforms everything
into the Schur basis, which is slow).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_commutative">
<span class="sig-name descname"><span class="pre">is_commutative</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_commutative" title="Permalink to this definition">#</a></dt>
<dd><p>Return whether this symmetric function algebra is commutative.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self</span></code> – a basis of the symmetric functions</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_field">
<span class="sig-name descname"><span class="pre">is_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">proof</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_field" title="Permalink to this definition">#</a></dt>
<dd><p>Return whether <code class="docutils literal notranslate"><span class="pre">self</span></code> is a field. (It is not.)</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self</span></code> – a basis of the symmetric functions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">proof</span></code> – an optional argument (default value: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">is_field</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_integral_domain">
<span class="sig-name descname"><span class="pre">is_integral_domain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">proof</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_integral_domain" title="Permalink to this definition">#</a></dt>
<dd><p>Return whether <code class="docutils literal notranslate"><span class="pre">self</span></code> is an integral domain. (It is if
and only if the base ring is an integral domain.)</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self</span></code> – a basis of the symmetric functions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">proof</span></code> – an optional argument (default value: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">is_integral_domain</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">Zmod</span><span class="p">(</span><span class="mi">14</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">is_integral_domain</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.lehrer_solomon">
<span class="sig-name descname"><span class="pre">lehrer_solomon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lam</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.lehrer_solomon" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Lehrer-Solomon symmetric function (also known as the
Whitney homology character) corresponding to the partition <code class="docutils literal notranslate"><span class="pre">lam</span></code>
written in the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(\lambda \vdash n\)</span> be a partition. The <em>Lehrer-Solomon
symmetric function</em> <span class="math notranslate nohighlight">\(\mathbf{LS}_\lambda\)</span> corresponding to
<span class="math notranslate nohighlight">\(\lambda\)</span> is the Frobenius characteristic of the representation
denoted <span class="math notranslate nohighlight">\(\operatorname{Ind}_{Z_\lambda}^{S_n}(\xi_\lambda)\)</span> in
Theorem 4.5 of <a class="reference internal" href="../../../../references/index.html#ls1986" id="id42"><span>[LS1986]</span></a> or <span class="math notranslate nohighlight">\(W_\lambda\)</span> in Theorem 2.7 of
<a class="reference internal" href="../../../../references/index.html#hr2017" id="id43"><span>[HR2017]</span></a>. It was first computed as a symmetric function in
<a class="reference internal" href="../../../../references/index.html#sun1994" id="id44"><span>[Sun1994]</span></a>.</p>
<p>It is the symmetric group representation corresponding to a
summand of the Whitney homology of the set partition lattice.
The summand comes from the orbit of set partitions with block
sizes corresponding to <span class="math notranslate nohighlight">\(\lambda\)</span> (after reordering appropriately).</p>
<p>It can be computed using Sundaram’s plethystic formula
(see <a class="reference internal" href="../../../../references/index.html#sun1994" id="id45"><span>[Sun1994]</span></a> Theorem 1.8):</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathbf{LS}_\lambda =
  \prod_{\text{odd } j \geq 1} h_{m_j}[\pi_j]
  \prod_{\text{even } j \geq 2} e_{m_j}[\pi_j],\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(h_{m_j}\)</span> are complete homogeneous symmetric functions,
<span class="math notranslate nohighlight">\(e_{m_j}\)</span> are elementary symmetric functions, and <span class="math notranslate nohighlight">\(\pi_j\)</span> are
the images of the Gessel-Reutenauer symmetric function
<span class="math notranslate nohighlight">\(\mathbf{GR}_{(j)}\)</span> (see <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.gessel_reutenauer" title="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.gessel_reutenauer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gessel_reutenauer()</span></code></a>) under the
involution <span class="math notranslate nohighlight">\(\omega\)</span> (i.e. <code class="xref py py-meth docutils literal notranslate"><span class="pre">omega_involution()</span></code>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pi_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pi_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">pi_2</span> <span class="o">*</span> <span class="n">pi_1</span> <span class="c1"># since h_1, e_1 are plethystic identities</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note that this also gives the <span class="math notranslate nohighlight">\(S_n\)</span>-equivariant structure of the
Orlik-Solomon algebra of the braid arrangement (also known as the
type-<span class="math notranslate nohighlight">\(A\)</span> reflection arrangement).</p>
<p>The representation corresponding to <span class="math notranslate nohighlight">\(\mathbf{LS}_\lambda\)</span> exhibits
representation stability <a class="reference internal" href="../../../../references/index.html#chu2012" id="id46"><span>[Chu2012]</span></a>, and a sharp bound is given
in <a class="reference internal" href="../../../../references/index.html#hr2017" id="id47"><span>[HR2017]</span></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">lam</span></code> – a partition or a positive integer (in the latter
case, it is understood to mean the partition <code class="docutils literal notranslate"><span class="pre">[lam]</span></code>)</p></li>
</ul>
<p>OUTPUT:</p>
<p>The Lehrer-Solomon symmetric function
<span class="math notranslate nohighlight">\(\mathbf{LS}_\lambda\)</span>, where <span class="math notranslate nohighlight">\(\lambda\)</span> is <code class="docutils literal notranslate"><span class="pre">lam</span></code>,
expanded in the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<p>The first few values of <span class="math notranslate nohighlight">\(\mathbf{LS}_{(n)}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">h[1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">h[2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">h[2, 1] - h[3]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">h[2, 1, 1] - h[2, 2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">h[2, 1, 1, 1] - h[2, 2, 1] - h[3, 1, 1] + h[3, 2] + h[4, 1] - h[5]</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.whitney_homology_character" title="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.whitney_homology_character"><code class="xref py py-meth docutils literal notranslate"><span class="pre">whitney_homology_character()</span></code></a> method is an alias:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">whitney_homology_character</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Lehrer-Solomon functions indexed by partitions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">h[2, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">h[3, 1] - h[4]</span>
</pre></div>
</div>
<p>The Lehrer-Solomon functions are Schur-positive:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">s[2, 1] + s[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">s[3, 1, 1] + s[3, 2] + s[4, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">s[2, 1, 1, 1] + s[2, 2, 1] + 2*s[3, 1, 1] + s[3, 2] + s[4, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.one_basis">
<span class="sig-name descname"><span class="pre">one_basis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.one_basis" title="Permalink to this definition">#</a></dt>
<dd><p>Return the empty partition, as per <code class="docutils literal notranslate"><span class="pre">AlgebrasWithBasis.ParentMethods.one_basis</span></code></p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self</span></code> – a basis of the ring of symmetric functions</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">one_basis</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">one_basis</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="id48">
<p class="admonition-title">Todo</p>
<p>generalize to Modules.Graded.Connected.ParentMethods</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.skew_schur">
<span class="sig-name descname"><span class="pre">skew_schur</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.skew_schur" title="Permalink to this definition">#</a></dt>
<dd><p>Return the skew Schur function indexed by <code class="docutils literal notranslate"><span class="pre">x</span></code> in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – a skew partition</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sp</span> <span class="o">=</span> <span class="n">SkewPartition</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">skew_schur</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
<span class="go">s[2, 2, 1, 1] + s[2, 2, 2] + s[3, 1, 1, 1] + 3*s[3, 2, 1]</span>
<span class="go"> + s[3, 3] + 2*s[4, 1, 1] + 2*s[4, 2] + s[5, 1]</span>

<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ess</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">skew_schur</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span> <span class="n">ess</span>
<span class="go">e[2, 1, 1, 1, 1] - e[2, 2, 1, 1] - e[3, 1, 1, 1] + e[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">ess</span> <span class="o">==</span> <span class="n">e</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">skew_schur</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.whitney_homology_character">
<span class="sig-name descname"><span class="pre">whitney_homology_character</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lam</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.whitney_homology_character" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Lehrer-Solomon symmetric function (also known as the
Whitney homology character) corresponding to the partition <code class="docutils literal notranslate"><span class="pre">lam</span></code>
written in the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(\lambda \vdash n\)</span> be a partition. The <em>Lehrer-Solomon
symmetric function</em> <span class="math notranslate nohighlight">\(\mathbf{LS}_\lambda\)</span> corresponding to
<span class="math notranslate nohighlight">\(\lambda\)</span> is the Frobenius characteristic of the representation
denoted <span class="math notranslate nohighlight">\(\operatorname{Ind}_{Z_\lambda}^{S_n}(\xi_\lambda)\)</span> in
Theorem 4.5 of <a class="reference internal" href="../../../../references/index.html#ls1986" id="id49"><span>[LS1986]</span></a> or <span class="math notranslate nohighlight">\(W_\lambda\)</span> in Theorem 2.7 of
<a class="reference internal" href="../../../../references/index.html#hr2017" id="id50"><span>[HR2017]</span></a>. It was first computed as a symmetric function in
<a class="reference internal" href="../../../../references/index.html#sun1994" id="id51"><span>[Sun1994]</span></a>.</p>
<p>It is the symmetric group representation corresponding to a
summand of the Whitney homology of the set partition lattice.
The summand comes from the orbit of set partitions with block
sizes corresponding to <span class="math notranslate nohighlight">\(\lambda\)</span> (after reordering appropriately).</p>
<p>It can be computed using Sundaram’s plethystic formula
(see <a class="reference internal" href="../../../../references/index.html#sun1994" id="id52"><span>[Sun1994]</span></a> Theorem 1.8):</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathbf{LS}_\lambda =
  \prod_{\text{odd } j \geq 1} h_{m_j}[\pi_j]
  \prod_{\text{even } j \geq 2} e_{m_j}[\pi_j],\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(h_{m_j}\)</span> are complete homogeneous symmetric functions,
<span class="math notranslate nohighlight">\(e_{m_j}\)</span> are elementary symmetric functions, and <span class="math notranslate nohighlight">\(\pi_j\)</span> are
the images of the Gessel-Reutenauer symmetric function
<span class="math notranslate nohighlight">\(\mathbf{GR}_{(j)}\)</span> (see <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.gessel_reutenauer" title="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.gessel_reutenauer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gessel_reutenauer()</span></code></a>) under the
involution <span class="math notranslate nohighlight">\(\omega\)</span> (i.e. <code class="xref py py-meth docutils literal notranslate"><span class="pre">omega_involution()</span></code>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pi_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pi_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">pi_2</span> <span class="o">*</span> <span class="n">pi_1</span> <span class="c1"># since h_1, e_1 are plethystic identities</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note that this also gives the <span class="math notranslate nohighlight">\(S_n\)</span>-equivariant structure of the
Orlik-Solomon algebra of the braid arrangement (also known as the
type-<span class="math notranslate nohighlight">\(A\)</span> reflection arrangement).</p>
<p>The representation corresponding to <span class="math notranslate nohighlight">\(\mathbf{LS}_\lambda\)</span> exhibits
representation stability <a class="reference internal" href="../../../../references/index.html#chu2012" id="id53"><span>[Chu2012]</span></a>, and a sharp bound is given
in <a class="reference internal" href="../../../../references/index.html#hr2017" id="id54"><span>[HR2017]</span></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">lam</span></code> – a partition or a positive integer (in the latter
case, it is understood to mean the partition <code class="docutils literal notranslate"><span class="pre">[lam]</span></code>)</p></li>
</ul>
<p>OUTPUT:</p>
<p>The Lehrer-Solomon symmetric function
<span class="math notranslate nohighlight">\(\mathbf{LS}_\lambda\)</span>, where <span class="math notranslate nohighlight">\(\lambda\)</span> is <code class="docutils literal notranslate"><span class="pre">lam</span></code>,
expanded in the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<p>The first few values of <span class="math notranslate nohighlight">\(\mathbf{LS}_{(n)}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">h[1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">h[2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">h[2, 1] - h[3]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">h[2, 1, 1] - h[2, 2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">h[2, 1, 1, 1] - h[2, 2, 1] - h[3, 1, 1] + h[3, 2] + h[4, 1] - h[5]</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.whitney_homology_character" title="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.whitney_homology_character"><code class="xref py py-meth docutils literal notranslate"><span class="pre">whitney_homology_character()</span></code></a> method is an alias:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">whitney_homology_character</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Lehrer-Solomon functions indexed by partitions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">h[2, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">h[3, 1] - h[4]</span>
</pre></div>
</div>
<p>The Lehrer-Solomon functions are Schur-positive:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">s[2, 1] + s[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">s[3, 1, 1] + s[3, 2] + s[4, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">lehrer_solomon</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">s[2, 1, 1, 1] + s[2, 2, 1] + 2*s[3, 1, 1] + s[3, 2] + s[4, 1]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.SymmetricFunctionsBases.super_categories">
<span class="sig-name descname"><span class="pre">super_categories</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.super_categories" title="Permalink to this definition">#</a></dt>
<dd><p>The super categories of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.sf.sfa</span> <span class="kn">import</span> <span class="n">SymmetricFunctionsBases</span>
<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bases</span> <span class="o">=</span> <span class="n">SymmetricFunctionsBases</span><span class="p">(</span><span class="n">Sym</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bases</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of realizations of Symmetric Functions over Rational Field,</span>
<span class="go"> Category of commutative hopf algebras with basis over Rational Field,</span>
<span class="go"> Join of Category of realizations of hopf algebras over Rational Field</span>
<span class="go">     and Category of graded algebras over Rational Field</span>
<span class="go">     and Category of graded coalgebras over Rational Field,</span>
<span class="go"> Category of unique factorization domains]</span>

<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">bases</span> <span class="o">=</span> <span class="n">SymmetricFunctionsBases</span><span class="p">(</span><span class="n">Sym</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bases</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of realizations of Symmetric Functions over Univariate Polynomial Ring in x over Integer Ring,</span>
<span class="go"> Category of commutative hopf algebras with basis over Univariate Polynomial Ring in x over Integer Ring,</span>
<span class="go"> Join of Category of realizations of hopf algebras over Univariate Polynomial Ring in x over Integer Ring</span>
<span class="go">     and Category of graded algebras over Univariate Polynomial Ring in x over Integer Ring</span>
<span class="go">     and Category of graded coalgebras over Univariate Polynomial Ring in x over Integer Ring]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.is_SymmetricFunction">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.sf.sfa.</span></span><span class="sig-name descname"><span class="pre">is_SymmetricFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.is_SymmetricFunction" title="Permalink to this definition">#</a></dt>
<dd><p>Checks whether <code class="docutils literal notranslate"><span class="pre">x</span></code> is a symmetric function.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.sf.sfa</span> <span class="kn">import</span> <span class="n">is_SymmetricFunction</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunction</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunction</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunction</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.is_SymmetricFunctionAlgebra">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.sf.sfa.</span></span><span class="sig-name descname"><span class="pre">is_SymmetricFunctionAlgebra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.is_SymmetricFunctionAlgebra" title="Permalink to this definition">#</a></dt>
<dd><p>Checks whether <code class="docutils literal notranslate"><span class="pre">x</span></code> is a symmetric function algebra.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.sf.sfa</span> <span class="kn">import</span> <span class="n">is_SymmetricFunctionAlgebra</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunctionAlgebra</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunctionAlgebra</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunctionAlgebra</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunctionAlgebra</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunctionAlgebra</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">P</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunctionAlgebra</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">P</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.sf.sfa.zee">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.sf.sfa.</span></span><span class="sig-name descname"><span class="pre">zee</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">part</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.zee" title="Permalink to this definition">#</a></dt>
<dd><p>Return the size of the centralizer of any permutation of cycle type
<code class="docutils literal notranslate"><span class="pre">part</span></code>.</p>
<p>Note that the size of the centralizer is the inner product between
<code class="docutils literal notranslate"><span class="pre">p(part)</span></code> and itself, where <span class="math notranslate nohighlight">\(p\)</span> is the power-sum symmetric
functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">part</span></code> – an integer partition (for example, <code class="docutils literal notranslate"><span class="pre">[2,1,1]</span></code>)</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the integer <span class="math notranslate nohighlight">\(\prod_{i} i^{m_i(part)} m_i(part)!\)</span> where <span class="math notranslate nohighlight">\(m_i(part)\)</span> is
the number of parts in the partition <code class="docutils literal notranslate"><span class="pre">part</span></code> equal to <span class="math notranslate nohighlight">\(i\)</span></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.sf.sfa</span> <span class="kn">import</span> <span class="n">zee</span>
<span class="gp">sage: </span><span class="n">zee</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="witt.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Witt symmetric functions</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="sf.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Symmetric functions, with their multiple realizations</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2005--2023, The Sage Development Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Symmetric Functions</a><ul>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.FilteredSymmetricFunctionsBases"><code class="docutils literal notranslate"><span class="pre">FilteredSymmetricFunctionsBases</span></code></a><ul>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.FilteredSymmetricFunctionsBases.super_categories"><code class="docutils literal notranslate"><span class="pre">super_categories()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases"><code class="docutils literal notranslate"><span class="pre">GradedSymmetricFunctionsBases</span></code></a><ul>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ElementMethods"><code class="docutils literal notranslate"><span class="pre">ElementMethods</span></code></a><ul>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ElementMethods.degree_negation"><code class="docutils literal notranslate"><span class="pre">degree_negation()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ElementMethods.degree_zero_coefficient"><code class="docutils literal notranslate"><span class="pre">degree_zero_coefficient()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ElementMethods.is_unit"><code class="docutils literal notranslate"><span class="pre">is_unit()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods"><code class="docutils literal notranslate"><span class="pre">ParentMethods</span></code></a><ul>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods.antipode_by_coercion"><code class="docutils literal notranslate"><span class="pre">antipode_by_coercion()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods.counit"><code class="docutils literal notranslate"><span class="pre">counit()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods.degree_negation"><code class="docutils literal notranslate"><span class="pre">degree_negation()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.super_categories"><code class="docutils literal notranslate"><span class="pre">super_categories()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic"><code class="docutils literal notranslate"><span class="pre">SymmetricFunctionAlgebra_generic</span></code></a><ul>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.Element"><code class="docutils literal notranslate"><span class="pre">Element</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.basis_name"><code class="docutils literal notranslate"><span class="pre">basis_name()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.coproduct_by_coercion"><code class="docutils literal notranslate"><span class="pre">coproduct_by_coercion()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.dual_basis"><code class="docutils literal notranslate"><span class="pre">dual_basis()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.from_polynomial"><code class="docutils literal notranslate"><span class="pre">from_polynomial()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.get_print_style"><code class="docutils literal notranslate"><span class="pre">get_print_style()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.prefix"><code class="docutils literal notranslate"><span class="pre">prefix()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.product_by_coercion"><code class="docutils literal notranslate"><span class="pre">product_by_coercion()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.set_print_style"><code class="docutils literal notranslate"><span class="pre">set_print_style()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.symmetric_function_ring"><code class="docutils literal notranslate"><span class="pre">symmetric_function_ring()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.transition_matrix"><code class="docutils literal notranslate"><span class="pre">transition_matrix()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element"><code class="docutils literal notranslate"><span class="pre">SymmetricFunctionAlgebra_generic_Element</span></code></a><ul>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.arithmetic_product"><code class="docutils literal notranslate"><span class="pre">arithmetic_product()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.bernstein_creation_operator"><code class="docutils literal notranslate"><span class="pre">bernstein_creation_operator()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.character_to_frobenius_image"><code class="docutils literal notranslate"><span class="pre">character_to_frobenius_image()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.degree"><code class="docutils literal notranslate"><span class="pre">degree()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.derivative_with_respect_to_p1"><code class="docutils literal notranslate"><span class="pre">derivative_with_respect_to_p1()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.eval_at_permutation_roots"><code class="docutils literal notranslate"><span class="pre">eval_at_permutation_roots()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.expand"><code class="docutils literal notranslate"><span class="pre">expand()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.exponential_specialization"><code class="docutils literal notranslate"><span class="pre">exponential_specialization()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.factor"><code class="docutils literal notranslate"><span class="pre">factor()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius"><code class="docutils literal notranslate"><span class="pre">frobenius()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.gcd"><code class="docutils literal notranslate"><span class="pre">gcd()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.hl_creation_operator"><code class="docutils literal notranslate"><span class="pre">hl_creation_operator()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_plethysm"><code class="docutils literal notranslate"><span class="pre">inner_plethysm()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor"><code class="docutils literal notranslate"><span class="pre">inner_tensor()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_coproduct"><code class="docutils literal notranslate"><span class="pre">internal_coproduct()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product"><code class="docutils literal notranslate"><span class="pre">internal_product()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.is_schur_positive"><code class="docutils literal notranslate"><span class="pre">is_schur_positive()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><code class="docutils literal notranslate"><span class="pre">itensor()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_coproduct"><code class="docutils literal notranslate"><span class="pre">kronecker_coproduct()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product"><code class="docutils literal notranslate"><span class="pre">kronecker_product()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.left_padded_kronecker_product"><code class="docutils literal notranslate"><span class="pre">left_padded_kronecker_product()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.nabla"><code class="docutils literal notranslate"><span class="pre">nabla()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega"><code class="docutils literal notranslate"><span class="pre">omega()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_involution"><code class="docutils literal notranslate"><span class="pre">omega_involution()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_qt"><code class="docutils literal notranslate"><span class="pre">omega_qt()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm"><code class="docutils literal notranslate"><span class="pre">plethysm()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.principal_specialization"><code class="docutils literal notranslate"><span class="pre">principal_specialization()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.reduced_kronecker_product"><code class="docutils literal notranslate"><span class="pre">reduced_kronecker_product()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_degree"><code class="docutils literal notranslate"><span class="pre">restrict_degree()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_partition_lengths"><code class="docutils literal notranslate"><span class="pre">restrict_partition_lengths()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_parts"><code class="docutils literal notranslate"><span class="pre">restrict_parts()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar"><code class="docutils literal notranslate"><span class="pre">scalar()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_hl"><code class="docutils literal notranslate"><span class="pre">scalar_hl()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_jack"><code class="docutils literal notranslate"><span class="pre">scalar_jack()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_qt"><code class="docutils literal notranslate"><span class="pre">scalar_qt()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_t"><code class="docutils literal notranslate"><span class="pre">scalar_t()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.skew_by"><code class="docutils literal notranslate"><span class="pre">skew_by()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.theta"><code class="docutils literal notranslate"><span class="pre">theta()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.theta_qt"><code class="docutils literal notranslate"><span class="pre">theta_qt()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><code class="docutils literal notranslate"><span class="pre">verschiebung()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases"><code class="docutils literal notranslate"><span class="pre">SymmetricFunctionsBases</span></code></a><ul>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods"><code class="docutils literal notranslate"><span class="pre">ParentMethods</span></code></a><ul>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.Eulerian"><code class="docutils literal notranslate"><span class="pre">Eulerian()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.carlitz_shareshian_wachs"><code class="docutils literal notranslate"><span class="pre">carlitz_shareshian_wachs()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.corresponding_basis_over"><code class="docutils literal notranslate"><span class="pre">corresponding_basis_over()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.degree_on_basis"><code class="docutils literal notranslate"><span class="pre">degree_on_basis()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.formal_series_ring"><code class="docutils literal notranslate"><span class="pre">formal_series_ring()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.gessel_reutenauer"><code class="docutils literal notranslate"><span class="pre">gessel_reutenauer()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.higher_lie_character"><code class="docutils literal notranslate"><span class="pre">higher_lie_character()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_commutative"><code class="docutils literal notranslate"><span class="pre">is_commutative()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_field"><code class="docutils literal notranslate"><span class="pre">is_field()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_integral_domain"><code class="docutils literal notranslate"><span class="pre">is_integral_domain()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.lehrer_solomon"><code class="docutils literal notranslate"><span class="pre">lehrer_solomon()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.one_basis"><code class="docutils literal notranslate"><span class="pre">one_basis()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.skew_schur"><code class="docutils literal notranslate"><span class="pre">skew_schur()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.whitney_homology_character"><code class="docutils literal notranslate"><span class="pre">whitney_homology_character()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.super_categories"><code class="docutils literal notranslate"><span class="pre">super_categories()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.is_SymmetricFunction"><code class="docutils literal notranslate"><span class="pre">is_SymmetricFunction()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.is_SymmetricFunctionAlgebra"><code class="docutils literal notranslate"><span class="pre">is_SymmetricFunctionAlgebra()</span></code></a></li>
<li><a class="reference internal" href="#sage.combinat.sf.sfa.zee"><code class="docutils literal notranslate"><span class="pre">zee()</span></code></a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../_static/scripts/furo.js"></script>
    <script src="../../../../_static/clipboard.min.js"></script>
    <script src="../../../../_static/copybutton.js"></script>
    <script src="../../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"ZZ": "\\Bold{Z}", "NN": "\\Bold{N}", "RR": "\\Bold{R}", "CC": "\\Bold{C}", "QQ": "\\Bold{Q}", "QQbar": "\\overline{\\QQ}", "GF": ["\\Bold{F}_{#1}", 1], "Zp": ["\\Bold{Z}_{#1}", 1], "Qp": ["\\Bold{Q}_{#1}", 1], "Zmod": ["\\ZZ/#1\\ZZ", 1], "CDF": "\\Bold{C}", "CIF": "\\Bold{C}", "CLF": "\\Bold{C}", "RDF": "\\Bold{R}", "RIF": "\\Bold{I} \\Bold{R}", "RLF": "\\Bold{R}", "SL": "\\mathrm{SL}", "PSL": "\\mathrm{PSL}", "Bold": ["\\mathbf{#1}", 1]}, "inlineMath": [["$", "$"], ["\\(", "\\)"]], "maxBuffer": 51200, "autoload": {"color": [], "colorv2": ["color"]}}}</script>
    <script defer="defer" src="../../../../_static/mathjax/tex-chtml.js"></script>
    </body>
</html>