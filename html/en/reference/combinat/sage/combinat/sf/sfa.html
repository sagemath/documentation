<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Symmetric Functions &mdash; Sage Reference Manual v6.7: Combinatorics</title>
    
    <link rel="stylesheet" href="../../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '6.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v6.7: Combinatorics" href="../../../index.html" />
    <link rel="up" title="Comprehensive Module list" href="../../../module_list.html" />
    <link rel="next" title="Witt symmetric functions" href="witt.html" />
    <link rel="prev" title="Symmetric functions, with their multiple realizations" href="sf.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="witt.html" title="Witt symmetric functions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="sf.html" title="Symmetric functions, with their multiple realizations"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../../index.html">Combinatorics</a> &raquo;</li>

          <li><a href="../../../module_list.html" accesskey="U">Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="symmetric-functions">
<span id="sage-combinat-sf-sfa"></span><h1>Symmetric Functions<a class="headerlink" href="#symmetric-functions" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.sf.sfa"></span><p>For a comprehensive tutorial on how to use symmetric functions in Sage</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="sf.html#sage.combinat.sf.sf.SymmetricFunctions" title="sage.combinat.sf.sf.SymmetricFunctions"><tt class="xref py py-func docutils literal"><span class="pre">SymmetricFunctions()</span></tt></a></p>
</div>
<p>We define the algebra of symmetric functions in the Schur and elementary bases:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">elementary</span><span class="p">()</span>
</pre></div>
</div>
<p>Each is actually a graded Hopf algebra whose basis is indexed by
integer partitions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of bases of Symmetric Functions over Rational Field</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">Partitions</span>
</pre></div>
</div>
<p>Let us compute with some elements in different bases:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f1</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span> <span class="n">f1</span>
<span class="go">s[2, 1]</span>
<span class="gp">sage: </span><span class="n">f2</span> <span class="o">=</span> <span class="n">e</span><span class="p">(</span><span class="n">f1</span><span class="p">);</span> <span class="n">f2</span> <span class="c"># basis conversion</span>
<span class="go">e[2, 1] - e[3]</span>
<span class="gp">sage: </span><span class="n">f1</span> <span class="o">==</span> <span class="n">f2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f1</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">,</span><span class="s">&#39;z&#39;</span><span class="p">])</span>
<span class="go">x^2*y + x*y^2 + x^2*z + 2*x*y*z + y^2*z + x*z^2 + y*z^2</span>
<span class="gp">sage: </span><span class="n">f2</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">,</span><span class="s">&#39;z&#39;</span><span class="p">])</span>
<span class="go">x^2*y + x*y^2 + x^2*z + 2*x*y*z + y^2*z + x*z^2 + y*z^2</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">m[3, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c"># This is the constant 4, not the partition 4.</span>
<span class="go">4*m[]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="c"># This is the partition 4.</span>
<span class="go">m[4]</span>
<span class="gp">sage: </span><span class="mi">3</span><span class="o">*</span><span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span>
<span class="go">3*m[3, 1] - 1/2*m[4]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">power</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">3*p[]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the powersum basis</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">+</span> <span class="n">p</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">3*p[] + p[3, 2]</span>
</pre></div>
</div>
<p>One can convert symmetric functions to symmetric polynomials and vice versa:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">powersum</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">homogeneous</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">poly</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">poly</span>
<span class="go">2*x0^4 + 2*x0^3*x1 + 2*x0*x1^3 + 2*x1^4 + 2*x0^3*x2 + 2*x1^3*x2 + 2*x0*x2^3 + 2*x1*x2^3 + 2*x2^4</span>
<span class="go">+ x0^3 + 2*x0^2*x1 + 2*x0*x1^2 + x1^3 + 2*x0^2*x2 + 3*x0*x1*x2 + 2*x1^2*x2 + 2*x0*x2^2 + 2*x1*x2^2 + x2^3</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">from_polynomial</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
<span class="go">3*m[1, 1, 1] + 2*m[2, 1] + m[3] + 2*m[3, 1] + 2*m[4]</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">from_polynomial</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">poly</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">from_polynomial</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">s[3, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">h[3, 1] - h[4]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1/8*p[1, 1, 1, 1] + 1/4*p[2, 1, 1] - 1/8*p[2, 2] - 1/4*p[4]</span>
<span class="gp">sage: </span><span class="n">e</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">e[2, 1, 1] - e[2, 2] - e[3, 1] + e[4]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3*m[1, 1, 1, 1] + 2*m[2, 1, 1] + m[2, 2] + m[3, 1]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">x0^3*x1 + x0^2*x1^2 + x0*x1^3 + x0^3*x2 + 2*x0^2*x1*x2 + 2*x0*x1^2*x2 + x1^3*x2 + x0^2*x2^2 + 2*x0*x1*x2^2 + x1^2*x2^2 + x0*x2^3 + x1*x2^3 + x0^3*x3 + 2*x0^2*x1*x3 + 2*x0*x1^2*x3 + x1^3*x3 + 2*x0^2*x2*x3 + 3*x0*x1*x2*x3 + 2*x1^2*x2*x3 + 2*x0*x2^2*x3 + 2*x1*x2^2*x3 + x2^3*x3 + x0^2*x3^2 + 2*x0*x1*x3^2 + x1^2*x3^2 + 2*x0*x2*x3^2 + 2*x1*x2*x3^2 + x2^2*x3^2 + x0*x3^3 + x1*x3^3 + x2*x3^3</span>
</pre></div>
</div>
<p>Here are further examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">h</span><span class="p">(</span><span class="n">m</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">h[1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span> <span class="n">m</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span><span class="n">m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>
<span class="go">h[2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span> <span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span> <span class="o">+</span> <span class="n">m</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>
<span class="go">h[3]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span> <span class="n">m</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="o">+</span> <span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">m</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">m</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>
<span class="go">h[4]</span>
<span class="gp">sage: </span><span class="n">k</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span> <span class="nb">sum</span><span class="p">([</span> <span class="n">m</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">k</span><span class="p">)])</span> <span class="p">)</span>
<span class="go">h[5]</span>
<span class="gp">sage: </span><span class="n">k</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span> <span class="nb">sum</span><span class="p">([</span> <span class="n">m</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">k</span><span class="p">)])</span> <span class="p">)</span>
<span class="go">h[10]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P3</span> <span class="o">=</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P3</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[3], [2, 1], [1, 1, 1]]</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">m</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">get_print_style</span><span class="p">()</span>
<span class="go">&#39;lex&#39;</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">m[1, 1, 1] + m[2, 1] + m[3]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s">&#39;length&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">m[3] + m[2, 1] + m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s">&#39;maximal_part&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">m[1, 1, 1] + m[2, 1] + m[3]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s">&#39;lex&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*m[3, 1, 1, 1] + m[3, 2, 1] + 2*m[4, 1, 1] + m[4, 2] + m[5, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[2, 1, 1, 1, 1] - s[2, 2, 2] - s[3, 3] + s[5, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">s[2, 1, 1, 1, 1] - s[2, 2, 2] - s[3, 3] + s[5, 1]</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span><span class="o">*</span><span class="n">e</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="n">e</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">e[4, 3, 1]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">coefficient</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">length</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
<span class="go">[[1, 1, 1], [2, 1]]</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Check that we can handle large integers properly (<a class="reference external" href="http://trac.sagemath.org/13413">trac ticket #13413</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">36</span><span class="p">))</span><span class="o">.</span><span class="n">coefficients</span><span class="p">())</span>  <span class="c"># long time (4s on sage.math, 2013)</span>
<span class="go">40971642983700000000</span>
</pre></div>
</div>
<p>BACKWARD INCOMPATIBLE CHANGES (<a class="reference external" href="http://trac.sagemath.org/5457">trac ticket #5457</a>):</p>
<p>The symmetric functions code has been refactored to take
advantage of the coercion systems. This introduced a couple of glitches:</p>
<ul>
<li><p class="first">On some bases changes, coefficients in Jack polynomials are not normalized</p>
</li>
<li><p class="first">Except in a few cases, conversions and coercions are only defined
between symmetric functions over the same coefficient ring. E.g.
the following does not work anymore:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span>  <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s2</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;t&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s2</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span> <span class="c"># todo: not implemented</span>
</pre></div>
</div>
<p>This feature will probably come back at some point through
improvements to the Sage coercion system.</p>
</li>
</ul>
<p>Backward compatibility should be essentially retained.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li>Mike Hansen (2007-06-15)</li>
<li>Nicolas M. Thiery (partial refactoring)</li>
<li>Mike Zabrocki, Anne Schilling (2012)</li>
<li>Darij Grinberg (2013) Sym over rings that are not characteristic 0</li>
</ul>
<dl class="function">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra">
<tt class="descclassname">sage.combinat.sf.sfa.</tt><tt class="descname">SymmetricFunctionAlgebra</tt><big>(</big><em>R</em>, <em>basis='schur'</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra" title="Permalink to this definition">¶</a></dt>
<dd><p>This is deprecated in <a class="reference external" href="http://trac.sagemath.org/15473">trac ticket #15473</a>. Use instead
<a class="reference internal" href="sf.html#sage.combinat.sf.sf.SymmetricFunctions" title="sage.combinat.sf.sf.SymmetricFunctions"><tt class="xref py py-class docutils literal"><span class="pre">SymmetricFunctions</span></tt></a> as <tt class="docutils literal"><span class="pre">SymmetricFunctions(R).basis()</span></tt></p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">R</span></tt> &#8211; ring with identity basis</li>
<li><tt class="docutils literal"><span class="pre">basis</span></tt> &#8211; a string for the name of the basis, must be one of
&#8216;schur&#8217;, &#8216;elementary&#8217;, &#8216;homogeneous&#8217;, &#8216;power&#8217;, &#8216;monomial&#8217; or their
abbreviations &#8216;s&#8217;, &#8216;e&#8217;, &#8216;h&#8217;, &#8216;p&#8217;, &#8216;m&#8217;</li>
</ul>
<p>OUTPUT: A SymmetricFunctionAlgebra</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">SymmetricFunctionAlgebra</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">doctest:...: DeprecationWarning: this function is deprecated. Use SymmetricFunctions(R).basis()</span>
<span class="go">See http://trac.sagemath.org/15473 for details.</span>
<span class="go">Symmetric Functions over Rational Field in the Schur basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic">
<em class="property">class </em><tt class="descclassname">sage.combinat.sf.sfa.</tt><tt class="descname">SymmetricFunctionAlgebra_generic</tt><big>(</big><em>Sym</em>, <em>basis_name=None</em>, <em>prefix=None</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></tt></a></p>
<p>Abstract base class for symmetric function algebras.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Most of the methods in this class are generic (manipulations of
morphisms, ...) and should be generalized (or removed)</p>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">m</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">-2*s[1, 1, 1] + s[2, 1]</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.Element">
<tt class="descname">Element</tt><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element"><tt class="xref py py-class docutils literal"><span class="pre">SymmetricFunctionAlgebra_generic_Element</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.basis_name">
<tt class="descname">basis_name</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.basis_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the basis of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This is used for output and, for the classical bases of
symmetric functions, to connect this basis with Symmetrica.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">basis_name</span><span class="p">()</span>
<span class="go">&#39;Schur&#39;</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">basis_name</span><span class="p">()</span>
<span class="go">&#39;powersum&#39;</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">basis_name</span><span class="p">()</span>
<span class="go">&#39;homogeneous&#39;</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">basis_name</span><span class="p">()</span>
<span class="go">&#39;elementary&#39;</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">basis_name</span><span class="p">()</span>
<span class="go">&#39;monomial&#39;</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">basis_name</span><span class="p">()</span>
<span class="go">&#39;forgotten&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.coproduct_by_coercion">
<tt class="descname">coproduct_by_coercion</tt><big>(</big><em>elt</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.coproduct_by_coercion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coproduct of the element <tt class="docutils literal"><span class="pre">elt</span></tt> by coercion to
the Schur basis.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">elt</span></tt> &#8211; an instance of this basis</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The image of <tt class="docutils literal"><span class="pre">elt</span></tt> under the comultiplication (=coproduct)
of the coalgebra of symmetric functions. The result is an
element of the tensor squared of the basis <tt class="docutils literal"><span class="pre">self</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">m[] # m[3, 1, 1] + m[1] # m[3, 1] + m[1, 1] # m[3] + m[3] # m[1, 1] + m[3, 1] # m[1] + m[3, 1, 1] # m[]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">coproduct_by_coercion</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">m[] # m[2, 1] + m[1] # m[2] + m[2] # m[1] + m[2, 1] # m[]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">coproduct_by_coercion</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">m</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">McdH</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;q&#39;</span><span class="p">,</span><span class="s">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">McdH</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">McdH[] # McdH[2, 1] + ((q^2*t-1)/(q*t-1))*McdH[1] # McdH[1, 1] + ((q*t^2-1)/(q*t-1))*McdH[1] # McdH[2] + ((q^2*t-1)/(q*t-1))*McdH[1, 1] # McdH[1] + ((q*t^2-1)/(q*t-1))*McdH[2] # McdH[1] + McdH[2, 1] # McdH[]</span>
<span class="gp">sage: </span><span class="n">HLQp</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">Qp</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">HLQp</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">HLQp[] # HLQp[2, 1] + HLQp[1] # HLQp[1, 1] + HLQp[1] # HLQp[2] + HLQp[1, 1] # HLQp[1] + HLQp[2] # HLQp[1] + HLQp[2, 1] # HLQp[]</span>
<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">LLT</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">llt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">LLT</span><span class="o">.</span><span class="n">cospin</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">(t+1)*m[] # m[1, 1] + m[] # m[2] + (t+1)*m[1] # m[1] + (t+1)*m[1, 1] # m[] + m[2] # m[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">f[] # f[3] + f[3] # f[]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">f[] # f[3, 2, 1] + f[1] # f[3, 2] + f[2] # f[3, 1] + f[2, 1] # f[3] + f[3] # f[2, 1] + f[3, 1] # f[2] + f[3, 2] # f[1] + f[3, 2, 1] # f[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.dual_basis">
<tt class="descname">dual_basis</tt><big>(</big><em>scalar=None</em>, <em>scalar_name=''</em>, <em>basis_name=None</em>, <em>prefix=None</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.dual_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual basis of <tt class="docutils literal"><span class="pre">self</span></tt> with respect to the scalar
product <tt class="docutils literal"><span class="pre">scalar</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">scalar</span></tt> &#8211; A function <tt class="docutils literal"><span class="pre">zee</span></tt> from partitions to the base ring
which specifies the scalar product by <span class="math">\(\langle p_{\lambda},
p_{\lambda} \rangle = \mathrm{zee}(\lambda)\)</span>. (Independently on the
function chosen, the power sum basis will always be orthogonal;
the function <tt class="docutils literal"><span class="pre">scalar</span></tt> only determines the norms of the basis
elements.) If <tt class="docutils literal"><span class="pre">scalar</span></tt> is None, then the standard (Hall) scalar
product is used.</li>
<li><tt class="docutils literal"><span class="pre">scalar_name</span></tt> &#8211; name of the scalar function</li>
<li><tt class="docutils literal"><span class="pre">prefix</span></tt> &#8211; prefix used to display the basis</li>
</ul>
<p>EXAMPLES:</p>
<p>The duals of the elementary symmetric functions with respect to the
Hall scalar product are the forgotten symmetric functions.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">dual_basis</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s">&#39;f&#39;</span><span class="p">);</span> <span class="n">f</span>
<span class="go">Dual basis to Symmetric Functions over Rational Field in the elementary basis with respect to the Hall scalar product</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span>
<span class="go">4*f[2, 2, 1, 1] + 6*f[2, 2, 2] + 2*f[3, 2, 1] + 2*f[3, 3] + 2*f[4, 1, 1] + f[4, 2]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">e</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">e</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Since the power-sum symmetric functions are orthogonal, their duals
with respect to the Hall scalar product are scalar multiples of
themselves.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">dual_basis</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s">&#39;q&#39;</span><span class="p">);</span> <span class="n">q</span>
<span class="go">Dual basis to Symmetric Functions over Rational Field in the powersum basis with respect to the Hall scalar product</span>
<span class="gp">sage: </span><span class="n">q</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span>
<span class="go">4*q[2, 2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">q</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">q</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.from_polynomial">
<tt class="descname">from_polynomial</tt><big>(</big><em>poly</em>, <em>check=True</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.from_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert polynomial to a symmetric function in the monomial basis
and then to the basis <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">poly</span></tt> &#8211; a symmetric polynomial</li>
<li><tt class="docutils literal"><span class="pre">check</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">True</span></tt>) boolean, specifies whether
the computation checks that the polynomial is indeed symmetric</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">homogeneous</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="p">([])</span> <span class="o">+</span> <span class="n">h</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">h</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">from_polynomial</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">h[] + h[2, 1] + h[3]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">([])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">g</span>
<span class="go">x0^2*x1 + x0*x1^2 + x0^2*x2 + 2*x0*x1*x2 + x1^2*x2 + x0*x2^2 + x1*x2^2 + 1</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">from_polynomial</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">s[] + s[2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.get_print_style">
<tt class="descname">get_print_style</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.get_print_style" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value of the current print style for <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">get_print_style</span><span class="p">()</span>
<span class="go">&#39;lex&#39;</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s">&#39;length&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">get_print_style</span><span class="p">()</span>
<span class="go">&#39;length&#39;</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s">&#39;lex&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.prefix">
<tt class="descname">prefix</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the prefix on the elements of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">schur</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">schur</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">schur</span><span class="o">.</span><span class="n">prefix</span><span class="p">()</span>
<span class="go">&#39;s&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.product_by_coercion">
<tt class="descname">product_by_coercion</tt><big>(</big><em>left</em>, <em>right</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.product_by_coercion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of elements <tt class="docutils literal"><span class="pre">left</span></tt> and <tt class="docutils literal"><span class="pre">right</span></tt> by coercion to
the Schur basis.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">left</span></tt>, <tt class="docutils literal"><span class="pre">right</span></tt> &#8211; instances of this basis</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the product of <tt class="docutils literal"><span class="pre">left</span></tt> and <tt class="docutils literal"><span class="pre">right</span></tt> expressed in the basis <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">product_by_coercion</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">p[3, 2, 2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">product_by_coercion</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.set_print_style">
<tt class="descname">set_print_style</tt><big>(</big><em>ps</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.set_print_style" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of the current print style to <tt class="docutils literal"><span class="pre">ps</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ps</span></tt> &#8211; a string specifying the printing style</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">get_print_style</span><span class="p">()</span>
<span class="go">&#39;lex&#39;</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s">&#39;length&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">get_print_style</span><span class="p">()</span>
<span class="go">&#39;length&#39;</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s">&#39;lex&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.symmetric_function_ring">
<tt class="descname">symmetric_function_ring</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.symmetric_function_ring" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the family of symmetric functions associated to the
basis <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>returns an instance of the ring of symmetric functions</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">schur</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">schur</span><span class="o">.</span><span class="n">symmetric_function_ring</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field</span>
<span class="gp">sage: </span><span class="n">power</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;t&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">power</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">power</span><span class="o">.</span><span class="n">symmetric_function_ring</span><span class="p">()</span>
<span class="go">Symmetric Functions over Univariate Polynomial Ring in t over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.transition_matrix">
<tt class="descname">transition_matrix</tt><big>(</big><em>basis</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.transition_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the transition matrix between <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">basis</span></tt> for the
homogeneous component of degree <tt class="docutils literal"><span class="pre">n</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">basis</span></tt> &#8211; a basis of the ring of symmetric functions</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; a nonnegative integer</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a matrix of coefficients giving the expansion of the
homogeneous degree-<span class="math">\(n\)</span> elements of <tt class="docutils literal"><span class="pre">self</span></tt> in the
degree-<span class="math">\(n\)</span> elements of <tt class="docutils literal"><span class="pre">basis</span></tt></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="go">[1 1 1 1 1 1 1]</span>
<span class="go">[0 1 1 2 2 3 4]</span>
<span class="go">[0 0 1 1 2 3 5]</span>
<span class="go">[0 0 0 1 1 3 6]</span>
<span class="go">[0 0 0 0 1 2 5]</span>
<span class="go">[0 0 0 0 0 1 4]</span>
<span class="go">[0 0 0 0 0 0 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[1]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">[ 1/4  1/3  1/8  1/4 1/24]</span>
<span class="go">[-1/4    0 -1/8  1/4  1/8]</span>
<span class="go">[   0 -1/3  1/4    0 1/12]</span>
<span class="go">[ 1/4    0 -1/8 -1/4  1/8]</span>
<span class="go">[-1/4  1/3  1/8 -1/4 1/24]</span>
<span class="gp">sage: </span><span class="n">StoP</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">5</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="n">s</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span>
<span class="go">5*s[1, 1, 1, 1] + s[3, 1] - s[4]</span>
<span class="gp">sage: </span><span class="n">mon</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">coeffs</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">coefficients</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">coeffs</span>
<span class="go">[5, 1, -1]</span>
<span class="gp">sage: </span><span class="n">mon</span>
<span class="go">[[1, 1, 1, 1], [3, 1], [4]]</span>
<span class="gp">sage: </span><span class="n">cm</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">cm</span> <span class="o">*</span> <span class="n">StoP</span>
<span class="go">[-7/4  4/3  3/8 -5/4 7/24]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">7/24*p[1, 1, 1, 1] - 5/4*p[2, 1, 1] + 3/8*p[2, 2] + 4/3*p[3, 1] - 7/4*p[4]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="n">e</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">[ 1 -1  0  1  0 -1  1]</span>
<span class="go">[ 1  0 -1  0  1  0 -1]</span>
<span class="go">[ 1 -1  1  0 -1  1 -1]</span>
<span class="go">[ 1  1 -1  0 -1  1  1]</span>
<span class="go">[ 1  0  1 -2  1  0  1]</span>
<span class="go">[ 1  2  1  0 -1 -2 -1]</span>
<span class="go">[ 1  4  5  6  5  4  1]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="n">e</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element">
<em class="property">class </em><tt class="descclassname">sage.combinat.sf.sfa.</tt><tt class="descname">SymmetricFunctionAlgebra_generic_Element</tt><big>(</big><em>M</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModuleElement" title="sage.combinat.free_module.CombinatorialFreeModuleElement"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.free_module.CombinatorialFreeModuleElement</span></tt></a></p>
<p>Class of generic elements for the symmetric function algebra.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">m</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s">&#39;lex&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">m[1, 1, 1] + m[2, 1] + m[3]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s">&#39;length&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">m[3] + m[2, 1] + m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s">&#39;maximal_part&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">m[1, 1, 1] + m[2, 1] + m[3]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s">&#39;lex&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.adams_operation">
<tt class="descname">adams_operation</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.adams_operation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the symmetric function <tt class="docutils literal"><span class="pre">self</span></tt> under the
<span class="math">\(n\)</span>-th Frobenius operator.</p>
<p>The <span class="math">\(n\)</span>-th Frobenius operator <span class="math">\(\mathbf{f}_n\)</span> is defined to be the
map from the ring of symmetric functions to itself that sends
every symmetric function <span class="math">\(P(x_1, x_2, x_3, \ldots)\)</span> to
<span class="math">\(P(x_1^n, x_2^n, x_3^n, \ldots)\)</span>. This operator <span class="math">\(\mathbf{f}_n\)</span>
is a Hopf algebra endomorphism, and satisfies</p>
<div class="math">
\[\mathbf{f}_n m_{(\lambda_1, \lambda_2, \lambda_3, \ldots)} =
m_{(n\lambda_1, n\lambda_2, n\lambda_3, \ldots)}\]</div>
<p>for every partition <span class="math">\((\lambda_1, \lambda_2, \lambda_3, \ldots)\)</span>
(where <span class="math">\(m\)</span> means the monomial basis). Moreover,
<span class="math">\(\mathbf{f}_n (p_r) = p_{nr}\)</span> for every positive integer <span class="math">\(r\)</span> (where
<span class="math">\(p_k\)</span> denotes the <span class="math">\(k\)</span>-th powersum symmetric function).</p>
<p>The <span class="math">\(n\)</span>-th Frobenius operator is also called the <span class="math">\(n\)</span>-th
Frobenius endomorphism. It is not related to the Frobenius map
which connects the ring of symmetric functions with the
representation theory of the symmetric group.</p>
<p>The <span class="math">\(n\)</span>-th Frobenius operator is also the <span class="math">\(n\)</span>-th Adams operator
of the <span class="math">\(\Lambda\)</span>-ring of symmetric functions over the integers.</p>
<p>The <span class="math">\(n\)</span>-th Frobenius operator can also be described via plethysm:
Every symmetric function <span class="math">\(P\)</span> satisfies
<span class="math">\(\mathbf{f}_n(P) = p_n \circ P = P \circ p_n\)</span>,
where <span class="math">\(p_n\)</span> is the <span class="math">\(n\)</span>-th powersum symmetric function, and <span class="math">\(\circ\)</span>
denotes (outer) plethysm.</p>
<p><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.adams_operation" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.adams_operation"><tt class="xref py py-meth docutils literal"><span class="pre">adams_operation()</span></tt></a> serves as alias for <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius"><tt class="xref py py-meth docutils literal"><span class="pre">frobenius()</span></tt></a>, since the
Frobenius operators are the Adams operations of the <span class="math">\(\Lambda\)</span>-ring
of symmetric functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; a positive integer</li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the <span class="math">\(n\)</span>-th Frobenius operator (on the ring of
symmetric functions) to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-s[3, 3] + s[4, 2] - s[5, 1] + s[6]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">m[12, 6, 3]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">p[12, 6, 3]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">h[4, 4] - 2*h[5, 3] + 2*h[6, 2] - 2*h[7, 1] + 2*h[8]</span>
</pre></div>
</div>
<p>The Frobenius endomorphisms are multiplicative:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c"># long time</span>
<span class="go">....:           == (s(lam) * s(mu)).frobenius(3)</span>
<span class="go">....:           for mu in Partitions(3) )</span>
<span class="go">....:      for lam in Partitions(3) )</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">....:           == (m(lam) * m(mu)).frobenius(2)</span>
<span class="go">....:           for mu in Partitions(4) )</span>
<span class="go">....:      for lam in Partitions(4) )</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">....:           == (p(lam) * p(mu)).frobenius(2)</span>
<span class="go">....:           for mu in Partitions(3) )</span>
<span class="go">....:      for lam in Partitions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Being Hopf algebra endomorphisms, the Frobenius operators
commute with the antipode:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">....:      == p(lam).antipode().frobenius(4)</span>
<span class="go">....:      for lam in Partitions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Testing the <span class="math">\(\mathbf{f}_n(P) = p_n \circ P = P \circ p_n\)</span>
equality (over <span class="math">\(\QQ\)</span>, since plethysm is currently not
defined over <span class="math">\(\ZZ\)</span> in Sage):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">plethysm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">....:      == s(p[3].plethysm(s(lam)))</span>
<span class="go">....:      for lam in Partitions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>By Exercise 7.61 in Stanley&#8217;s EC2 <a class="reference internal" href="sf.html#sta" id="id1">[STA]</a> (see the errata on his
website), <span class="math">\(\mathbf{f}_n(h_m)\)</span> is a linear combination of
Schur polynomials (of straight shapes) using coefficients <span class="math">\(0\)</span>,
<span class="math">\(1\)</span> and <span class="math">\(-1\)</span> only; moreover, all partitions whose Schur
polynomials occur with coefficient <span class="math">\(\neq 0\)</span> in this
combination have empty <span class="math">\(n\)</span>-cores. Let us check this on
examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="p">(</span><span class="n">coeff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">....:                and lam.core(n) == Partition([])</span>
<span class="go">....:                for lam, coeff in s([m]).frobenius(n) )</span>
<span class="go">....:           for n in range(2, 4) )</span>
<span class="go">....:      for m in range(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm"><tt class="xref py py-meth docutils literal"><span class="pre">plethysm()</span></tt></a></p>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">This method is fast on the monomial and the powersum
bases, while all other bases get converted to the
monomial basis. For most bases, this is probably the
quickest way to do, but at least the Schur basis should
have a better option. (Quoting from Stanley&#8217;s EC2 <a class="reference internal" href="sf.html#sta" id="id2">[STA]</a>:
&#8220;D. G. Duncan, J. London Math. Soc. 27 (1952), 235-236,
or Y. M. Chen, A. M. Garsia, and J. B. Remmel, Contemp.
Math. 34 (1984), 109-153&#8221;.)</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.arithmetic_product">
<tt class="descname">arithmetic_product</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.arithmetic_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the arithmetic product of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt> in the
basis of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The arithmetic product is a binary operation <span class="math">\(\boxdot\)</span> on the
ring of symmetric functions which is bilinear in its two
arguments and satisfies</p>
<div class="math">
\[p_{\lambda} \boxdot p_{\mu} = \prod\limits_{i \geq 1, j \geq 1}
p_{\mathrm{lcm}(\lambda_i, \mu_j)}^{\mathrm{gcd}(\lambda_i, \mu_j)}\]</div>
<p>for any two partitions <span class="math">\(\lambda = (\lambda_1, \lambda_2, \lambda_3,
\dots )\)</span> and <span class="math">\(\mu = (\mu_1, \mu_2, \mu_3, \dots )\)</span> (where <span class="math">\(p_{\nu}\)</span>
denotes the power-sum symmetric function indexed by the partition
<span class="math">\(\nu\)</span>, and <span class="math">\(p_i\)</span> denotes the <span class="math">\(i\)</span>-th power-sum symmetric function).
This is enough to define the arithmetic product if the base ring
is torsion-free as a <span class="math">\(\ZZ\)</span>-module; for all other cases the
arithmetic product is uniquely determined by requiring it to be
functorial in the base ring. See
<a class="reference external" href="http://mathoverflow.net/questions/138148/">http://mathoverflow.net/questions/138148/</a> for a discussion of
this arithmetic product.</p>
<p>If <span class="math">\(f\)</span> and <span class="math">\(g\)</span> are two symmetric functions which are homogeneous
of degrees <span class="math">\(a\)</span> and <span class="math">\(b\)</span>, respectively, then <span class="math">\(f \boxdot g\)</span> is
homogeneous of degree <span class="math">\(ab\)</span>.</p>
<p>The arithmetic product is commutative and associative and has
unity <span class="math">\(e_1 = p_1 = h_1\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; element of the ring of symmetric functions over the
same base ring as <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>OUTPUT:</p>
<p>Arithmetic product of <tt class="docutils literal"><span class="pre">self</span></tt> with <tt class="docutils literal"><span class="pre">x</span></tt>; this is a symmetric
function over the same base ring as <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">arithmetic_product</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">s[1, 1, 1, 1] + 2*s[2, 2] + s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">arithmetic_product</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[2, 1, 1] + s[3, 1]</span>
</pre></div>
</div>
<p>The symmetric function <tt class="docutils literal"><span class="pre">e[1]</span></tt> is the unity for the arithmetic
product:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">arithmetic_product</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">==</span> <span class="n">e</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The arithmetic product is commutative:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">arithmetic_product</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">arithmetic_product</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>  <span class="c"># long time (26s on sage.math, 2013)</span>
<span class="go">....:           for q in Partitions(4) )</span>
<span class="go">....:      for p in Partitions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The currently existing implementation of this function is
technically unsatisfactory. It distinguishes the case when the
base ring is a <span class="math">\(\QQ\)</span>-algebra (in which case the arithmetic product
can be easily computed using the power sum basis) from the case
where it isn&#8217;t. In the latter, it does a computation using
universal coefficients, again distinguishing the case when it is
able to compute the &#8220;corresponding&#8221; basis of the symmetric function
algebra over <span class="math">\(\QQ\)</span> (using the <tt class="docutils literal"><span class="pre">corresponding_basis_over</span></tt> hack)
from the case when it isn&#8217;t (in which case it transforms everything
into the Schur basis, which is slow).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.bernstein_creation_operator">
<tt class="descname">bernstein_creation_operator</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.bernstein_creation_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <tt class="docutils literal"><span class="pre">self</span></tt> under the <span class="math">\(n\)</span>-th Bernstein creation
operator.</p>
<p>Let <span class="math">\(n\)</span> be an integer. The <span class="math">\(n\)</span>-th Bernstein creation operator
<span class="math">\(\mathbf{B}_n\)</span> is defined as the endomorphism of the space
<span class="math">\(Sym\)</span> of symmetric functions which sends every <span class="math">\(f\)</span> to</p>
<div class="math">
\[\sum_{i \geq 0} (-1)^i h_{n+i} e_i^\perp,\]</div>
<p>where usual notations are in place (<span class="math">\(h\)</span> stands for the complete
homogeneous symmetric functions, <span class="math">\(e\)</span> for the elementary ones,
and <span class="math">\(e_i^\perp\)</span> means skewing (<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.skew_by" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.skew_by"><tt class="xref py py-meth docutils literal"><span class="pre">skew_by()</span></tt></a>) by <span class="math">\(e_i\)</span>).</p>
<p>This has been studied in <a class="reference internal" href="../ncsf_qsym/qsym.html#bbssz2012" id="id3">[BBSSZ2012]</a>, section 2.2, where the
following rule is given for computing <span class="math">\(\mathbf{B}_n\)</span> on a
Schur function: If <span class="math">\((\alpha_1, \alpha_2, \ldots, \alpha_n)\)</span> is
an <span class="math">\(n\)</span>-tuple of integers (positive or not), then</p>
<div class="math">
\[\mathbf{B}_n s_{(\alpha_1, \alpha_2, \ldots, \alpha_n)}
= s_{(n, \alpha_1, \alpha_2, \ldots, \alpha_n)}.\]</div>
<p>Here, <span class="math">\(s_{(\alpha_1, \alpha_2, \ldots, \alpha_n)}\)</span> is the
&#8220;Schur function&#8221; associated to the <span class="math">\(n\)</span>-tuple
<span class="math">\((\alpha_1, \alpha_2, \ldots, \alpha_n)\)</span>, and defined by
literally applying the Jacobi-Trudi identity, i.e., by</p>
<div class="math">
\[s_{(\alpha_1, \alpha_2, \ldots, \alpha_n)}
= \det \left( (h_{\alpha_i - i + j})_{i, j = 1, 2, \ldots, n} \right).\]</div>
<p>This notion of a Schur function clearly extends the classical
notion of Schur function corresponding to a partition, but is
easily reduced to the latter (in fact, for any <span class="math">\(n\)</span>-tuple
<span class="math">\(\alpha\)</span> of integers, one easily sees that <span class="math">\(s_\alpha\)</span> is
either <span class="math">\(0\)</span> or minus-plus a Schur function corresponding to a
partition; and it is easy to determine which of these is the
case and find the partition by a combinatorial algorithm).</p>
<p>EXAMPLES:</p>
<p>Let us check that what this method computes agrees with the
definition:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">bernstein_creation_by_def</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
<span class="go">....:     # `n`-th Bernstein creation operator applied to `f`</span>
<span class="go">....:     # computed according to its definition.</span>
<span class="go">....:     res = f.parent().zero()</span>
<span class="go">....:     if not f:</span>
<span class="go">....:         return res</span>
<span class="go">....:     max_degree = max(sum(m) for m, c in f)</span>
<span class="go">....:     for i in range(max_degree + 1):</span>
<span class="go">....:         if n + i &gt;= 0:</span>
<span class="go">....:             res += (-1) ** i * h[n + i] * f.skew_by(e[i])</span>
<span class="go">....:     return res</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">bernstein_creation_by_def</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">....:      for n in range(-2, 3) for l in Partitions(4) )</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">bernstein_creation_by_def</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">....:      for n in range(-3, 4) for l in Partitions(3) )</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">bernstein_creation_by_def</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="o">==</span> <span class="n">e</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">....:      for n in range(-3, 4) for k in range(3) for l in Partitions(k) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Some examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">s[3, 3, 2]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">-s[2, 2, 2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">h[2, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">h[2, 1, 1] - h[2, 2] - h[3, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">-h[3, 1, 1] + h[3, 2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">-h[2, 2, 2] + h[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-h[3, 3, 1] + h[4, 2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.degree">
<tt class="descname">degree</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degree of <tt class="docutils literal"><span class="pre">self</span></tt> (which is defined to be <span class="math">\(0\)</span>
for the zero element).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.derivative_with_respect_to_p1">
<tt class="descname">derivative_with_respect_to_p1</tt><big>(</big><em>n=1</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.derivative_with_respect_to_p1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the symmetric function obtained by taking the derivative of
<tt class="docutils literal"><span class="pre">self</span></tt> with respect to the power-sum symmetric function <span class="math">\(p_1\)</span>
when the expansion of <tt class="docutils literal"><span class="pre">self</span></tt> in the power-sum basis is considered
as a polynomial in <span class="math">\(p_k\)</span>&#8216;s (with <span class="math">\(k \geq 1\)</span>).</p>
<p>This is the same as skewing <tt class="docutils literal"><span class="pre">self</span></tt> by the first power-sum symmetric
function <span class="math">\(p_1\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; (default: 1) nonnegative integer which determines
which power of the derivative is taken</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">3*p[1, 1]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">3*p[1, 1]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">6*p[1]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">6*p[]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">s[2]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">s[1, 1] + s[2]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">s[1, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">s[]</span>
</pre></div>
</div>
<p>Let us check that taking the derivative with respect to <tt class="docutils literal"><span class="pre">p[1]</span></tt>
is equivalent to skewing by <tt class="docutils literal"><span class="pre">p[1]</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p1</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">....:      == s(lam).skew_by(p1) for lam in Partitions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.expand">
<tt class="descname">expand</tt><big>(</big><em>n</em>, <em>alphabet='x'</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand the symmetric function <tt class="docutils literal"><span class="pre">self</span></tt> as a symmetric polynomial
in <tt class="docutils literal"><span class="pre">n</span></tt> variables.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; a nonnegative integer</li>
<li><tt class="docutils literal"><span class="pre">alphabet</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">'x'</span></tt>) a variable for the expansion</li>
</ul>
<p>OUTPUT:</p>
<p>A monomial expansion of <tt class="docutils literal"><span class="pre">self</span></tt> in the <span class="math">\(n\)</span> variables
labelled <tt class="docutils literal"><span class="pre">x0</span></tt>, <tt class="docutils literal"><span class="pre">x1</span></tt>, ..., <tt class="docutils literal"><span class="pre">x{n-1}</span></tt> (or just <tt class="docutils literal"><span class="pre">x</span></tt>
if <span class="math">\(n = 1\)</span>), where <tt class="docutils literal"><span class="pre">x</span></tt> is <tt class="docutils literal"><span class="pre">alphabet</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">jack</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">J</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">J</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">4*x0^2*x1 + 4*x0*x1^2 + 4*x0^2*x2 + 6*x0*x1*x2 + 4*x1^2*x2 + 4*x0*x2^2 + 4*x1*x2^2</span>
<span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">J</span><span class="p">([</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">J</span><span class="p">([]))</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius">
<tt class="descname">frobenius</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the symmetric function <tt class="docutils literal"><span class="pre">self</span></tt> under the
<span class="math">\(n\)</span>-th Frobenius operator.</p>
<p>The <span class="math">\(n\)</span>-th Frobenius operator <span class="math">\(\mathbf{f}_n\)</span> is defined to be the
map from the ring of symmetric functions to itself that sends
every symmetric function <span class="math">\(P(x_1, x_2, x_3, \ldots)\)</span> to
<span class="math">\(P(x_1^n, x_2^n, x_3^n, \ldots)\)</span>. This operator <span class="math">\(\mathbf{f}_n\)</span>
is a Hopf algebra endomorphism, and satisfies</p>
<div class="math">
\[\mathbf{f}_n m_{(\lambda_1, \lambda_2, \lambda_3, \ldots)} =
m_{(n\lambda_1, n\lambda_2, n\lambda_3, \ldots)}\]</div>
<p>for every partition <span class="math">\((\lambda_1, \lambda_2, \lambda_3, \ldots)\)</span>
(where <span class="math">\(m\)</span> means the monomial basis). Moreover,
<span class="math">\(\mathbf{f}_n (p_r) = p_{nr}\)</span> for every positive integer <span class="math">\(r\)</span> (where
<span class="math">\(p_k\)</span> denotes the <span class="math">\(k\)</span>-th powersum symmetric function).</p>
<p>The <span class="math">\(n\)</span>-th Frobenius operator is also called the <span class="math">\(n\)</span>-th
Frobenius endomorphism. It is not related to the Frobenius map
which connects the ring of symmetric functions with the
representation theory of the symmetric group.</p>
<p>The <span class="math">\(n\)</span>-th Frobenius operator is also the <span class="math">\(n\)</span>-th Adams operator
of the <span class="math">\(\Lambda\)</span>-ring of symmetric functions over the integers.</p>
<p>The <span class="math">\(n\)</span>-th Frobenius operator can also be described via plethysm:
Every symmetric function <span class="math">\(P\)</span> satisfies
<span class="math">\(\mathbf{f}_n(P) = p_n \circ P = P \circ p_n\)</span>,
where <span class="math">\(p_n\)</span> is the <span class="math">\(n\)</span>-th powersum symmetric function, and <span class="math">\(\circ\)</span>
denotes (outer) plethysm.</p>
<p><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.adams_operation" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.adams_operation"><tt class="xref py py-meth docutils literal"><span class="pre">adams_operation()</span></tt></a> serves as alias for <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius"><tt class="xref py py-meth docutils literal"><span class="pre">frobenius()</span></tt></a>, since the
Frobenius operators are the Adams operations of the <span class="math">\(\Lambda\)</span>-ring
of symmetric functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; a positive integer</li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the <span class="math">\(n\)</span>-th Frobenius operator (on the ring of
symmetric functions) to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-s[3, 3] + s[4, 2] - s[5, 1] + s[6]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">m[12, 6, 3]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">p[12, 6, 3]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">h[4, 4] - 2*h[5, 3] + 2*h[6, 2] - 2*h[7, 1] + 2*h[8]</span>
</pre></div>
</div>
<p>The Frobenius endomorphisms are multiplicative:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c"># long time</span>
<span class="go">....:           == (s(lam) * s(mu)).frobenius(3)</span>
<span class="go">....:           for mu in Partitions(3) )</span>
<span class="go">....:      for lam in Partitions(3) )</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">....:           == (m(lam) * m(mu)).frobenius(2)</span>
<span class="go">....:           for mu in Partitions(4) )</span>
<span class="go">....:      for lam in Partitions(4) )</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">....:           == (p(lam) * p(mu)).frobenius(2)</span>
<span class="go">....:           for mu in Partitions(3) )</span>
<span class="go">....:      for lam in Partitions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Being Hopf algebra endomorphisms, the Frobenius operators
commute with the antipode:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">....:      == p(lam).antipode().frobenius(4)</span>
<span class="go">....:      for lam in Partitions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Testing the <span class="math">\(\mathbf{f}_n(P) = p_n \circ P = P \circ p_n\)</span>
equality (over <span class="math">\(\QQ\)</span>, since plethysm is currently not
defined over <span class="math">\(\ZZ\)</span> in Sage):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">plethysm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">....:      == s(p[3].plethysm(s(lam)))</span>
<span class="go">....:      for lam in Partitions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>By Exercise 7.61 in Stanley&#8217;s EC2 <a class="reference internal" href="sf.html#sta" id="id4">[STA]</a> (see the errata on his
website), <span class="math">\(\mathbf{f}_n(h_m)\)</span> is a linear combination of
Schur polynomials (of straight shapes) using coefficients <span class="math">\(0\)</span>,
<span class="math">\(1\)</span> and <span class="math">\(-1\)</span> only; moreover, all partitions whose Schur
polynomials occur with coefficient <span class="math">\(\neq 0\)</span> in this
combination have empty <span class="math">\(n\)</span>-cores. Let us check this on
examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="p">(</span><span class="n">coeff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">....:                and lam.core(n) == Partition([])</span>
<span class="go">....:                for lam, coeff in s([m]).frobenius(n) )</span>
<span class="go">....:           for n in range(2, 4) )</span>
<span class="go">....:      for m in range(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm"><tt class="xref py py-meth docutils literal"><span class="pre">plethysm()</span></tt></a></p>
</div>
<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">This method is fast on the monomial and the powersum
bases, while all other bases get converted to the
monomial basis. For most bases, this is probably the
quickest way to do, but at least the Schur basis should
have a better option. (Quoting from Stanley&#8217;s EC2 <a class="reference internal" href="sf.html#sta" id="id5">[STA]</a>:
&#8220;D. G. Duncan, J. London Math. Soc. 27 (1952), 235-236,
or Y. M. Chen, A. M. Garsia, and J. B. Remmel, Contemp.
Math. 34 (1984), 109-153&#8221;.)</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.hl_creation_operator">
<tt class="descname">hl_creation_operator</tt><big>(</big><em>nu</em>, <em>t=None</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.hl_creation_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the vertex operator that generalizes Jing&#8217;s operator.</p>
<p>It is a linear operator that raises the degree by
<span class="math">\(|\nu|\)</span>. This creation operator is a t-analogue of
multiplication by <tt class="docutils literal"><span class="pre">s(nu)</span></tt> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Proposition 5 in <a class="reference internal" href="#sz2001" id="id6">[SZ2001]</a>.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">nu</span></tt> &#8211; a partition</li>
<li><tt class="docutils literal"><span class="pre">t</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>, in which case <tt class="docutils literal"><span class="pre">t</span></tt> is used) a parameter</li>
</ul>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="sz2001" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[SZ2001]</a></td><td>M. Shimozono, M. Zabrocki,
Hall-Littlewood vertex operators and generalized Kostka polynomials.
Adv. Math. 158 (2001), no. 1, 66-85.</td></tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;t&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[3, 2, 2] + t*s[3, 3, 1] + t*s[4, 2, 1] + t^2*s[4, 3] + t^2*s[5, 2]</span>

<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">HLQp</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">Qp</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">HLQp</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">HLQp[3, 2, 2]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">t*s[2, 2, 2, 1] + t^2*s[3, 2, 1, 1] + t^2*s[3, 2, 2] + t^3*s[3, 3, 1] + t^3*s[4, 2, 1] + t^4*s[4, 3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">(t^2-t)*s[2, 2, 2, 2, 1] + t^3*s[3, 2, 2, 1, 1] + (t^3-t^2)*s[3, 2, 2, 2] + t^3*s[3, 3, 1, 1, 1] + t^4*s[3, 3, 2, 1] + t^3*s[4, 2, 1, 1, 1] + t^4*s[4, 2, 2, 1] + 2*t^4*s[4, 3, 1, 1] + t^5*s[4, 3, 2] + t^5*s[4, 4, 1] + t^4*s[5, 2, 1, 1] + t^5*s[5, 3, 1]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_plethysm">
<tt class="descname">inner_plethysm</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_plethysm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inner plethysm of <tt class="docutils literal"><span class="pre">self</span></tt> with <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>Whenever <span class="math">\(R\)</span> is a <span class="math">\(\QQ\)</span>-algebra, and <span class="math">\(f\)</span> and <span class="math">\(g\)</span> are two
symmetric functions over <span class="math">\(R\)</span> such that the constant term of <span class="math">\(f\)</span>
is zero, the inner plethysm of <span class="math">\(f\)</span> with <span class="math">\(g\)</span> is a symmetric
function over <span class="math">\(R\)</span>, and the degree of this symmetric function is
the same as the degree of <span class="math">\(g\)</span>. We will denote the inner plethysm
of <span class="math">\(f\)</span> with <span class="math">\(g\)</span> by <span class="math">\(f \{ g \}\)</span> (in contrast to the notation of
outer plethysm which is generally denoted <span class="math">\(f [ g ]\)</span>); in Sage
syntax, it is <tt class="docutils literal"><span class="pre">f.inner_plethysm(g)</span></tt>.</p>
<p>First we describe the axiomatic definition of the operation; see
below for a representation-theoretic interpretation.
In the following equations, we denote the outer product
(i.e., the standard product on the ring of symmetric functions,
<tt class="xref py py-meth docutils literal"><span class="pre">product()</span></tt>)
by <span class="math">\(\cdot\)</span> and the Kronecker product (<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><tt class="xref py py-meth docutils literal"><span class="pre">itensor()</span></tt></a>) by <span class="math">\(\ast\)</span>).</p>
<div class="math">
\[(f + g) \{ h \} = f \{ h \} + g \{ h \}\]\[(f \cdot g) \{ h \} = (f \{ h \}) \ast (g \{ h \})\]\[p_k \{ f + g \} = p_k \{ f \} + p_k \{ g \}\]</div>
<p>where <span class="math">\(p_k\)</span> is the <span class="math">\(k\)</span>-th power-sum symmetric function for every
<span class="math">\(k &gt; 0\)</span>.</p>
<p>Let <span class="math">\(\sigma\)</span> be a permutation of cycle type <span class="math">\(\mu\)</span> and let <span class="math">\(\mu^k\)</span>
be the cycle type of <span class="math">\(\sigma^k\)</span>. Then,</p>
<div class="math">
\[p_k \{ p_\mu/z_\mu \} = \sum_{\nu : \nu^k = \mu } p_{\nu}/z_{\nu}\]</div>
<p>Since <span class="math">\((p_\mu/z_\mu)_{\mu}\)</span> is a basis for the symmetric
functions, these four formulas define the symmetric function
operation <span class="math">\(f \{ g \}\)</span> for any symmetric functions <span class="math">\(f\)</span> and <span class="math">\(g\)</span>
(where <span class="math">\(f\)</span> has constant term <span class="math">\(0\)</span>) by expanding <span class="math">\(f\)</span> in the
power sum basis and <span class="math">\(g\)</span> in the dual basis <span class="math">\(p_\mu/z_\mu\)</span>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><tt class="xref py py-meth docutils literal"><span class="pre">itensor()</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">partition_power()</span></tt>,
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm"><tt class="xref py py-meth docutils literal"><span class="pre">plethysm()</span></tt></a></p>
</div>
<p>This operation admits a representation-theoretic interpretation
in the case where <span class="math">\(f\)</span> is a Schur function <span class="math">\(s_\lambda\)</span> and
<span class="math">\(g\)</span> is a homogeneous degree <span class="math">\(n\)</span> symmetric function with
nonnegative integral coefficients in the Schur basis.
The symmetric function <span class="math">\(f \{ g \}\)</span> is the Frobenius
image of the <span class="math">\(S_n\)</span>-representation constructed as follows.</p>
<p>The assumptions on <span class="math">\(g\)</span> imply that <span class="math">\(g\)</span> is the Frobenius image of a
representation <span class="math">\(\rho\)</span> of the symmetric group <span class="math">\(S_n\)</span>:</p>
<div class="math">
\[\rho : S_n \to GL_N.\]</div>
<p>If the degree <span class="math">\(N\)</span> of this representation is greater than or equal
to the number of parts of <span class="math">\(\lambda\)</span>, then <span class="math">\(f\)</span>, which denotes <span class="math">\(s_\lambda\)</span>,
corresponds to the character of some irreducible <span class="math">\(GL_N\)</span>-representation, say</p>
<div class="math">
\[\sigma : GL_N \to GL_M.\]</div>
<p>The composition <span class="math">\(\sigma \circ \rho : S_n \to GL_M\)</span> is a representation
of <span class="math">\(S_n\)</span> whose Frobenius image is precisely <span class="math">\(f \{ g \}\)</span>.</p>
<p>If <span class="math">\(N\)</span> is less than the number of parts of <span class="math">\(\lambda\)</span>,
then <span class="math">\(f \{ g \}\)</span> is <span class="math">\(0\)</span> by definition.</p>
<p>When <span class="math">\(f\)</span> is a symmetric function with constant term <span class="math">\(\neq 0\)</span>, the
inner plethysm <span class="math">\(f \{ g \}\)</span> isn&#8217;t well-defined in the ring of
symmetric functions. Indeed, it is not clear how to define
<span class="math">\(1 \{ g \}\)</span>. The most sensible way to get around this probably is
defining it as the infinite sum <span class="math">\(h_0 + h_1 + h_2 + \cdots\)</span> (where
<span class="math">\(h_i\)</span> means the <span class="math">\(i\)</span>-th complete homogeneous symmetric function)
in the completion of this ring with respect to its grading. This is
how <a class="reference internal" href="#schathi1994" id="id7">[SchaThi1994]</a> defines <span class="math">\(1 \{ g \}\)</span>. The present method,
however, sets it to be the sum of <span class="math">\(h_i\)</span> over all <span class="math">\(i\)</span> for which the
<span class="math">\(i\)</span>-th homogeneous component of <span class="math">\(g\)</span> is nonzero. This is rather a
hack than a reasonable definition. Use with caution!</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If a symmetric function <span class="math">\(g\)</span> is written in the form
<span class="math">\(g = g_0 + g_1 + g_2 + \cdots\)</span> with each <span class="math">\(g_i\)</span> homogeneous
of degree <span class="math">\(i\)</span>, then
<span class="math">\(f \{ g \} = f \{ g_0 \} + f \{ g_1 \} + f \{ g_2 \} + \cdots\)</span>
for every <span class="math">\(f\)</span> with constant term <span class="math">\(0\)</span>. But in general, inner
plethysm is not linear in the second variable.</p>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="king" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[King]</td><td>King, R. Branching rules for <span class="math">\(GL_m \supset \Sigma_n\)</span>
and the evaluation of inner plethysms.
J. Math. Phys. 15, 258 (1974) <a class="reference external" href="http://dx.doi.org/10.1063/1.1666632">doi:10.1063/1.1666632</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="schathi1994" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[SchaThi1994]</a></td><td>Thomas Scharf, Jean-Yves Thibon.
<em>A Hopf-algebra approach to inner plethysm</em>.
Advances in Mathematics 104 (1994), pp. 30-58.
<a class="reference external" href="ftp://ftp.mathe2.uni-bayreuth.de/axel/papers/scharf:a_hopf_algebra_approach_to_inner_plethysm.ps.gz">ftp://ftp.mathe2.uni-bayreuth.de/axel/papers/scharf:a_hopf_algebra_approach_to_inner_plethysm.ps.gz</a></td></tr>
</tbody>
</table>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; element of the ring of symmetric functions over the same
base ring as <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>an element of symmetric functions in the parent of <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">power</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[2, 1] + s[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">inner_tensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1] + s[2, 1] + s[3]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">s[1, 1, 1] + s[2, 1] + 4*s[2, 1, 1] + 4*s[2, 2] + s[3] + 4*s[3, 1] + 4*s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">)</span>
<span class="go">s[1, 1, 1] + s[2, 1] + 4*s[2, 1, 1] + 4*s[2, 2] + s[3] + 4*s[3, 1] + 4*s[4]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span><span class="p">([])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">s[2] + s[3]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">s</span><span class="p">([])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">la</span><span class="p">))</span> <span class="k">for</span> <span class="n">la</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
<span class="go">[s[4], s[4], s[4], s[4], s[4]]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">([]))</span>
<span class="go">s[]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[3]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">p[1, 1, 1] + 2*p[3]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">24</span><span class="p">)</span>
<span class="go">1/24*p[1, 1, 1, 1] + 1/4*p[2, 1, 1] + 1/8*p[2, 2] + 1/4*p[4]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">6*p[1, 1, 1] + 12*p[3]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">s[]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">2*s[]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">s[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor">
<tt class="descname">inner_tensor</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the internal (tensor) product of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt> in the
basis of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The internal tensor product can be defined as the linear extension
of the definition on power sums
<span class="math">\(p_{\lambda} \ast p_{\mu} = \delta_{\lambda,\mu} z_{\lambda}
p_{\lambda}\)</span>, where <span class="math">\(z_{\lambda} = (1^{r_1} r_1!) (2^{r_2} r_2!)
\cdots\)</span> for <span class="math">\(\lambda = (1^{r_1} 2^{r_2} \cdots )\)</span> and where <span class="math">\(\ast\)</span>
denotes the internal tensor product.
The internal tensor product is also known as the Kronecker product,
or as the second multiplication on the ring of symmetric functions.</p>
<p>Note that the internal product of any two homogeneous symmetric
functions of equal degrees is a homogeneous symmetric function of the
same degree. On the other hand, the internal product of two homogeneous
symmetric functions of distinct degrees is <span class="math">\(0\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The internal product is sometimes referred to as &#8220;inner product&#8221;
in the literature, but unfortunately this name is shared by a
different operation, namely the Hall inner product
(see <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar"><tt class="xref py py-meth docutils literal"><span class="pre">scalar()</span></tt></a>).</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; element of the ring of symmetric functions over the
same base ring as <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the internal product of <tt class="docutils literal"><span class="pre">self</span></tt> with <tt class="docutils literal"><span class="pre">x</span></tt> (an element of the
ring of symmetric functions in the same basis as <tt class="docutils literal"><span class="pre">self</span></tt>)</li>
</ul>
<p>The methods <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><tt class="xref py py-meth docutils literal"><span class="pre">itensor()</span></tt></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product"><tt class="xref py py-meth docutils literal"><span class="pre">internal_product()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product"><tt class="xref py py-meth docutils literal"><span class="pre">kronecker_product()</span></tt></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor"><tt class="xref py py-meth docutils literal"><span class="pre">inner_tensor()</span></tt></a> are all
synonyms.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">s[2, 1]</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">s[1, 1, 1, 1, 1, 1] + 2*s[2, 1, 1, 1, 1] + 3*s[2, 2, 1, 1] + 2*s[2, 2, 2]</span>
<span class="go"> + 4*s[3, 1, 1, 1] + 5*s[3, 2, 1] + 2*s[3, 3] + 4*s[4, 1, 1]</span>
<span class="go"> + 3*s[4, 2] + 2*s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>There are few quantitative results pertaining to Kronecker products
in general, which makes their computation so difficult. Let us test
a few of them in different bases.</p>
<p>The Kronecker product of any homogeneous symmetric function <span class="math">\(f\)</span> of
degree <span class="math">\(n\)</span> with the <span class="math">\(n\)</span>-th complete homogeneous symmetric function
<tt class="docutils literal"><span class="pre">h[n]</span></tt> (a.k.a. <tt class="docutils literal"><span class="pre">s[n]</span></tt>) is <span class="math">\(f\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product of a Schur function <span class="math">\(s_{\lambda}\)</span> with the <span class="math">\(n\)</span>-th
elementary symmetric function <tt class="docutils literal"><span class="pre">e[n]</span></tt>, where <span class="math">\(n = \left| \lambda
\right|\)</span>, is <span class="math">\(s_{\lambda'}\)</span> (where <span class="math">\(\lambda'\)</span> is the conjugate
partition of <span class="math">\(\lambda\)</span>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product is commutative:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">....:      for p in Partitions(4) )</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;q&#39;</span><span class="p">,</span><span class="s">&#39;t&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">mq</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">mh</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">==</span> <span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>   <span class="c"># long time</span>
<span class="go">....:           for r in Partitions(4) )</span>
<span class="go">....:      for p in Partitions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us check (on examples) Proposition 5.2 of Gelfand, Krob, Lascoux, Leclerc,
Retakh, Thibon, &#8220;Noncommutative symmetric functions&#8221;, <a class="reference external" href="http://arxiv.org/abs/hep-th/9407124">Arxiv hep-th/9407124</a>, for
<span class="math">\(r = 2\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_copr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>  <span class="c"># computes \mu ((u \otimes v) * \Delta(w)) with</span>
<span class="go">....:                            # * meaning Kronecker product and \mu meaning the</span>
<span class="go">....:                            # usual multiplication.</span>
<span class="go">....:     result = w.parent().zero()</span>
<span class="go">....:     for partition_pair, coeff in w.coproduct():</span>
<span class="go">....:         result += coeff * w.parent()(u).itensor(partition_pair[0]) * w.parent()(v).itensor(partition_pair[1])</span>
<span class="go">....:     return result</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_copr</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>   <span class="c"># long time</span>
<span class="go">....:                == (e[u] * s[v]).itensor(m[w])</span>
<span class="go">....:                for w in Partitions(5) )</span>
<span class="go">....:           for v in Partitions(2) )</span>
<span class="go">....:      for u in Partitions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Some examples from Briand, Orellana, Rosas, &#8220;The stability of the Kronecker
products of Schur functions.&#8221; <a class="reference external" href="http://arxiv.org/abs/0907.4652">Arxiv 0907.4652</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[1, 1, 1, 1] + s[2, 2] + s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 1, 1, 1] + s[2, 2, 1] + s[3, 1, 1] + s[3, 2] + s[4, 1] + s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 2, 2] + s[3, 1, 1, 1] + 2*s[3, 2, 1] + s[4, 1, 1] + 2*s[4, 2] + s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>An example from p. 220 of Thibon, &#8220;Hopf algebras of symmetric functions
and tensor products of symmetric group representations&#8221;, International
Journal of Algebra and Computation, 1991:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQbar</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1] + s[2, 1] + s[3]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c"># long time</span>
<span class="go">s[4, 4, 4, 4] + s[5, 5, 3, 3] + s[5, 5, 5, 1] + s[6, 4, 4, 2]</span>
<span class="go"> + s[6, 6, 2, 2] + s[6, 6, 4] + s[7, 3, 3, 3] + s[7, 5, 3, 1]</span>
<span class="go"> + s[7, 7, 1, 1] + s[8, 4, 2, 2] + s[8, 4, 4] + s[8, 6, 2]</span>
<span class="go"> + s[8, 8] + s[9, 3, 3, 1] + s[9, 5, 1, 1] + s[10, 2, 2, 2]</span>
<span class="go"> + s[10, 4, 2] + s[10, 6] + s[11, 3, 1, 1] + s[12, 2, 2]</span>
<span class="go"> + s[12, 4] + s[13, 1, 1, 1] + s[14, 2] + s[16]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">s[]</span>
</pre></div>
</div>
<p>Same over the ring of integers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c"># long time</span>
<span class="go">s[4, 4, 4, 4] + s[5, 5, 3, 3] + s[5, 5, 5, 1] + s[6, 4, 4, 2]</span>
<span class="go"> + s[6, 6, 2, 2] + s[6, 6, 4] + s[7, 3, 3, 3] + s[7, 5, 3, 1]</span>
<span class="go"> + s[7, 7, 1, 1] + s[8, 4, 2, 2] + s[8, 4, 4] + s[8, 6, 2]</span>
<span class="go"> + s[8, 8] + s[9, 3, 3, 1] + s[9, 5, 1, 1] + s[10, 2, 2, 2]</span>
<span class="go"> + s[10, 4, 2] + s[10, 6] + s[11, 3, 1, 1] + s[12, 2, 2]</span>
<span class="go"> + s[12, 4] + s[13, 1, 1, 1] + s[14, 2] + s[16]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">s[]</span>
</pre></div>
</div>
<p>Theorem 2.1 in Bessenrodt, van Willigenburg, <a class="reference external" href="http://arxiv.org/abs/1105.3170v2">Arxiv 1105.3170v2</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">max</span><span class="p">(</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">.</span><span class="n">monomial_coefficients</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="p">)</span>
<span class="go">....:           == sum( min(p[i], q.get_part(i)) for i in range(len(p)) )</span>
<span class="go">....:           for p in Partitions(4) )</span>
<span class="go">....:      for q in Partitions(4) )</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">max</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">.</span><span class="n">monomial_coefficients</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="p">)</span>
<span class="go">....:           == sum( min(p[i], q.conjugate().get_part(i)) for i in range(len(p)) )</span>
<span class="go">....:           for p in Partitions(4) )</span>
<span class="go">....:      for q in Partitions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Check that the basis and ground ring of <tt class="docutils literal"><span class="pre">self</span></tt> are preserved:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">e[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">s[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">Symmetric Functions over Cyclotomic Field of order 12 and degree 4 in the elementary basis</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">Symmetric Functions over Cyclotomic Field of order 12 and degree 4 in the Schur basis</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The currently existing implementation of this function is
technically unsatisfactory. It distinguishes the case when the
base ring is a <span class="math">\(\QQ\)</span>-algebra (in which case the Kronecker product
can be easily computed using the power sum basis) from the case
where it isn&#8217;t. In the latter, it does a computation using
universal coefficients, again distinguishing the case when it is
able to compute the &#8220;corresponding&#8221; basis of the symmetric function
algebra over <span class="math">\(\QQ\)</span> (using the <tt class="docutils literal"><span class="pre">corresponding_basis_over</span></tt> hack)
from the case when it isn&#8217;t (in which case it transforms everything
into the Schur basis, which is slow).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_coproduct">
<tt class="descname">internal_coproduct</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_coproduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inner coproduct of <tt class="docutils literal"><span class="pre">self</span></tt> in the basis of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The inner coproduct (also known as the Kronecker coproduct, as the
internal coproduct, or as the second comultiplication on the ring of
symmetric functions) is a ring homomorphism <span class="math">\(\Delta^\times\)</span> from the
ring of symmetric functions to the tensor product (over the base
ring) of this ring with itself. It is uniquely characterized by the
formula</p>
<div class="math">
\[\Delta^{\times}(h_n) = \sum_{\lambda \vdash n} s_{\lambda}
\otimes s_{\lambda} = \sum_{\lambda \vdash n} h_{\lambda} \otimes
m_{\lambda} = \sum_{\lambda \vdash n} m_{\lambda} \otimes
h_{\lambda},\]</div>
<p>where <span class="math">\(\lambda \vdash n\)</span> means <span class="math">\(\lambda\)</span> is a partition of <span class="math">\(n\)</span>, and
<span class="math">\(n\)</span> is any nonnegative integer. It also satisfies</p>
<div class="math">
\[\Delta^\times (p_n) = p_n \otimes p_n\]</div>
<p>for any positive integer <span class="math">\(n\)</span>. If the base ring is a <span class="math">\(\QQ\)</span>-algebra, it
also satisfies</p>
<div class="math">
\[\Delta^{\times}(h_n) = \sum_{\lambda \vdash n} z_{\lambda}^{-1}
p_{\lambda} \otimes p_{\lambda},\]</div>
<p>where</p>
<div class="math">
\[z_{\lambda} = \prod_{i=1}^\infty i^{m_i(\lambda)} m_i(\lambda)!\]</div>
<p>with <span class="math">\(m_i(\lambda)\)</span> meaning the number of appearances of <span class="math">\(i\)</span>
in <span class="math">\(\lambda\)</span> (see <a class="reference internal" href="#sage.combinat.sf.sfa.zee" title="sage.combinat.sf.sfa.zee"><tt class="xref py py-meth docutils literal"><span class="pre">zee()</span></tt></a>).</p>
<p>The method <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_coproduct" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_coproduct"><tt class="xref py py-meth docutils literal"><span class="pre">kronecker_coproduct()</span></tt></a> is a synonym of
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_coproduct" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_coproduct"><tt class="xref py py-meth docutils literal"><span class="pre">internal_coproduct()</span></tt></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="go">s[1, 1, 1] # s[2, 1] + s[2, 1] # s[1, 1, 1] + s[2, 1] # s[2, 1] + s[2, 1] # s[3] + s[3] # s[2, 1]</span>

<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="go">e[1, 1] # e[2] + e[2] # e[1, 1] - 2*e[2] # e[2]</span>
</pre></div>
</div>
<p>The internal coproduct is adjoint to the internal product with respect
to the Hall inner product: Any three symmetric functions <span class="math">\(f\)</span>, <span class="math">\(g\)</span> and
<span class="math">\(h\)</span> satisfy <span class="math">\(\langle f * g, h \rangle = \sum_i \langle f, h^{\prime}_i
\rangle \langle g, h^{\prime\prime}_i \rangle\)</span>, where we write
<span class="math">\(\Delta^{\times}(h)\)</span> as <span class="math">\(\sum_i h^{\prime}_i \otimes
h^{\prime\prime}_i\)</span>. Let us check this in degree <span class="math">\(4\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_incopr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>  <span class="c"># computes \sum_i \left&lt; f, h&#39;_i \right&gt; \left&lt; g, h&#39;&#39;_i \right&gt;</span>
<span class="go">....:     result = h.base_ring().zero()</span>
<span class="go">....:     for partition_pair, coeff in h.internal_coproduct():</span>
<span class="go">....:         result += coeff * h.parent()(f).scalar(partition_pair[0]) * h.parent()(g).scalar(partition_pair[1])</span>
<span class="go">....:     return result</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_incopr</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>  <span class="c"># long time (10s on sage.math, 2013)</span>
<span class="go">....:                for w in Partitions(5) )</span>
<span class="go">....:           for v in Partitions(2) )</span>
<span class="go">....:      for u in Partitions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us check the formulas for <span class="math">\(\Delta^{\times}(h_n)\)</span> and
<span class="math">\(\Delta^{\times}(p_n)\)</span> given in the description of this method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">h</span><span class="p">([</span><span class="n">n</span><span class="p">]))</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">tensor</span><span class="p">([</span><span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">),</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)])</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
<span class="go">....:      for n in range(6) )</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">tensor</span><span class="p">([</span><span class="n">h</span><span class="p">(</span><span class="n">lam</span><span class="p">),</span> <span class="n">h</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">))])</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
<span class="go">....:      for n in range(6) )</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">h</span><span class="p">([</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="go">....:      == sum([lam.conjugacy_class_size() * tensor([h(p(lam)), h(p(lam))])</span>
<span class="go">....:              for lam in Partitions(n)])</span>
<span class="go">....:      for n in range(6) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([])</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="go">s[] # s[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product">
<tt class="descname">internal_product</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the internal (tensor) product of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt> in the
basis of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The internal tensor product can be defined as the linear extension
of the definition on power sums
<span class="math">\(p_{\lambda} \ast p_{\mu} = \delta_{\lambda,\mu} z_{\lambda}
p_{\lambda}\)</span>, where <span class="math">\(z_{\lambda} = (1^{r_1} r_1!) (2^{r_2} r_2!)
\cdots\)</span> for <span class="math">\(\lambda = (1^{r_1} 2^{r_2} \cdots )\)</span> and where <span class="math">\(\ast\)</span>
denotes the internal tensor product.
The internal tensor product is also known as the Kronecker product,
or as the second multiplication on the ring of symmetric functions.</p>
<p>Note that the internal product of any two homogeneous symmetric
functions of equal degrees is a homogeneous symmetric function of the
same degree. On the other hand, the internal product of two homogeneous
symmetric functions of distinct degrees is <span class="math">\(0\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The internal product is sometimes referred to as &#8220;inner product&#8221;
in the literature, but unfortunately this name is shared by a
different operation, namely the Hall inner product
(see <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar"><tt class="xref py py-meth docutils literal"><span class="pre">scalar()</span></tt></a>).</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; element of the ring of symmetric functions over the
same base ring as <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the internal product of <tt class="docutils literal"><span class="pre">self</span></tt> with <tt class="docutils literal"><span class="pre">x</span></tt> (an element of the
ring of symmetric functions in the same basis as <tt class="docutils literal"><span class="pre">self</span></tt>)</li>
</ul>
<p>The methods <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><tt class="xref py py-meth docutils literal"><span class="pre">itensor()</span></tt></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product"><tt class="xref py py-meth docutils literal"><span class="pre">internal_product()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product"><tt class="xref py py-meth docutils literal"><span class="pre">kronecker_product()</span></tt></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor"><tt class="xref py py-meth docutils literal"><span class="pre">inner_tensor()</span></tt></a> are all
synonyms.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">s[2, 1]</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">s[1, 1, 1, 1, 1, 1] + 2*s[2, 1, 1, 1, 1] + 3*s[2, 2, 1, 1] + 2*s[2, 2, 2]</span>
<span class="go"> + 4*s[3, 1, 1, 1] + 5*s[3, 2, 1] + 2*s[3, 3] + 4*s[4, 1, 1]</span>
<span class="go"> + 3*s[4, 2] + 2*s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>There are few quantitative results pertaining to Kronecker products
in general, which makes their computation so difficult. Let us test
a few of them in different bases.</p>
<p>The Kronecker product of any homogeneous symmetric function <span class="math">\(f\)</span> of
degree <span class="math">\(n\)</span> with the <span class="math">\(n\)</span>-th complete homogeneous symmetric function
<tt class="docutils literal"><span class="pre">h[n]</span></tt> (a.k.a. <tt class="docutils literal"><span class="pre">s[n]</span></tt>) is <span class="math">\(f\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product of a Schur function <span class="math">\(s_{\lambda}\)</span> with the <span class="math">\(n\)</span>-th
elementary symmetric function <tt class="docutils literal"><span class="pre">e[n]</span></tt>, where <span class="math">\(n = \left| \lambda
\right|\)</span>, is <span class="math">\(s_{\lambda'}\)</span> (where <span class="math">\(\lambda'\)</span> is the conjugate
partition of <span class="math">\(\lambda\)</span>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product is commutative:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">....:      for p in Partitions(4) )</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;q&#39;</span><span class="p">,</span><span class="s">&#39;t&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">mq</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">mh</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">==</span> <span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>   <span class="c"># long time</span>
<span class="go">....:           for r in Partitions(4) )</span>
<span class="go">....:      for p in Partitions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us check (on examples) Proposition 5.2 of Gelfand, Krob, Lascoux, Leclerc,
Retakh, Thibon, &#8220;Noncommutative symmetric functions&#8221;, <a class="reference external" href="http://arxiv.org/abs/hep-th/9407124">Arxiv hep-th/9407124</a>, for
<span class="math">\(r = 2\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_copr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>  <span class="c"># computes \mu ((u \otimes v) * \Delta(w)) with</span>
<span class="go">....:                            # * meaning Kronecker product and \mu meaning the</span>
<span class="go">....:                            # usual multiplication.</span>
<span class="go">....:     result = w.parent().zero()</span>
<span class="go">....:     for partition_pair, coeff in w.coproduct():</span>
<span class="go">....:         result += coeff * w.parent()(u).itensor(partition_pair[0]) * w.parent()(v).itensor(partition_pair[1])</span>
<span class="go">....:     return result</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_copr</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>   <span class="c"># long time</span>
<span class="go">....:                == (e[u] * s[v]).itensor(m[w])</span>
<span class="go">....:                for w in Partitions(5) )</span>
<span class="go">....:           for v in Partitions(2) )</span>
<span class="go">....:      for u in Partitions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Some examples from Briand, Orellana, Rosas, &#8220;The stability of the Kronecker
products of Schur functions.&#8221; <a class="reference external" href="http://arxiv.org/abs/0907.4652">Arxiv 0907.4652</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[1, 1, 1, 1] + s[2, 2] + s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 1, 1, 1] + s[2, 2, 1] + s[3, 1, 1] + s[3, 2] + s[4, 1] + s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 2, 2] + s[3, 1, 1, 1] + 2*s[3, 2, 1] + s[4, 1, 1] + 2*s[4, 2] + s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>An example from p. 220 of Thibon, &#8220;Hopf algebras of symmetric functions
and tensor products of symmetric group representations&#8221;, International
Journal of Algebra and Computation, 1991:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQbar</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1] + s[2, 1] + s[3]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c"># long time</span>
<span class="go">s[4, 4, 4, 4] + s[5, 5, 3, 3] + s[5, 5, 5, 1] + s[6, 4, 4, 2]</span>
<span class="go"> + s[6, 6, 2, 2] + s[6, 6, 4] + s[7, 3, 3, 3] + s[7, 5, 3, 1]</span>
<span class="go"> + s[7, 7, 1, 1] + s[8, 4, 2, 2] + s[8, 4, 4] + s[8, 6, 2]</span>
<span class="go"> + s[8, 8] + s[9, 3, 3, 1] + s[9, 5, 1, 1] + s[10, 2, 2, 2]</span>
<span class="go"> + s[10, 4, 2] + s[10, 6] + s[11, 3, 1, 1] + s[12, 2, 2]</span>
<span class="go"> + s[12, 4] + s[13, 1, 1, 1] + s[14, 2] + s[16]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">s[]</span>
</pre></div>
</div>
<p>Same over the ring of integers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c"># long time</span>
<span class="go">s[4, 4, 4, 4] + s[5, 5, 3, 3] + s[5, 5, 5, 1] + s[6, 4, 4, 2]</span>
<span class="go"> + s[6, 6, 2, 2] + s[6, 6, 4] + s[7, 3, 3, 3] + s[7, 5, 3, 1]</span>
<span class="go"> + s[7, 7, 1, 1] + s[8, 4, 2, 2] + s[8, 4, 4] + s[8, 6, 2]</span>
<span class="go"> + s[8, 8] + s[9, 3, 3, 1] + s[9, 5, 1, 1] + s[10, 2, 2, 2]</span>
<span class="go"> + s[10, 4, 2] + s[10, 6] + s[11, 3, 1, 1] + s[12, 2, 2]</span>
<span class="go"> + s[12, 4] + s[13, 1, 1, 1] + s[14, 2] + s[16]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">s[]</span>
</pre></div>
</div>
<p>Theorem 2.1 in Bessenrodt, van Willigenburg, <a class="reference external" href="http://arxiv.org/abs/1105.3170v2">Arxiv 1105.3170v2</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">max</span><span class="p">(</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">.</span><span class="n">monomial_coefficients</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="p">)</span>
<span class="go">....:           == sum( min(p[i], q.get_part(i)) for i in range(len(p)) )</span>
<span class="go">....:           for p in Partitions(4) )</span>
<span class="go">....:      for q in Partitions(4) )</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">max</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">.</span><span class="n">monomial_coefficients</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="p">)</span>
<span class="go">....:           == sum( min(p[i], q.conjugate().get_part(i)) for i in range(len(p)) )</span>
<span class="go">....:           for p in Partitions(4) )</span>
<span class="go">....:      for q in Partitions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Check that the basis and ground ring of <tt class="docutils literal"><span class="pre">self</span></tt> are preserved:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">e[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">s[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">Symmetric Functions over Cyclotomic Field of order 12 and degree 4 in the elementary basis</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">Symmetric Functions over Cyclotomic Field of order 12 and degree 4 in the Schur basis</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The currently existing implementation of this function is
technically unsatisfactory. It distinguishes the case when the
base ring is a <span class="math">\(\QQ\)</span>-algebra (in which case the Kronecker product
can be easily computed using the power sum basis) from the case
where it isn&#8217;t. In the latter, it does a computation using
universal coefficients, again distinguishing the case when it is
able to compute the &#8220;corresponding&#8221; basis of the symmetric function
algebra over <span class="math">\(\QQ\)</span> (using the <tt class="docutils literal"><span class="pre">corresponding_basis_over</span></tt> hack)
from the case when it isn&#8217;t (in which case it transforms everything
into the Schur basis, which is slow).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.is_schur_positive">
<tt class="descname">is_schur_positive</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.is_schur_positive" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if and only if <tt class="docutils literal"><span class="pre">self</span></tt> is Schur positive.</p>
<p>If <span class="math">\(s\)</span> is the space of Schur functions over <tt class="docutils literal"><span class="pre">self</span></tt>&#8216;s base ring, then
this is the same as <tt class="docutils literal"><span class="pre">self._is_positive(s)</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">is_schur_positive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">is_schur_positive</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">QQx</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQx</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">QQx</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">is_schur_positive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">is_schur_positive</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_schur_positive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">is_schur_positive</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor">
<tt class="descname">itensor</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the internal (tensor) product of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt> in the
basis of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The internal tensor product can be defined as the linear extension
of the definition on power sums
<span class="math">\(p_{\lambda} \ast p_{\mu} = \delta_{\lambda,\mu} z_{\lambda}
p_{\lambda}\)</span>, where <span class="math">\(z_{\lambda} = (1^{r_1} r_1!) (2^{r_2} r_2!)
\cdots\)</span> for <span class="math">\(\lambda = (1^{r_1} 2^{r_2} \cdots )\)</span> and where <span class="math">\(\ast\)</span>
denotes the internal tensor product.
The internal tensor product is also known as the Kronecker product,
or as the second multiplication on the ring of symmetric functions.</p>
<p>Note that the internal product of any two homogeneous symmetric
functions of equal degrees is a homogeneous symmetric function of the
same degree. On the other hand, the internal product of two homogeneous
symmetric functions of distinct degrees is <span class="math">\(0\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The internal product is sometimes referred to as &#8220;inner product&#8221;
in the literature, but unfortunately this name is shared by a
different operation, namely the Hall inner product
(see <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar"><tt class="xref py py-meth docutils literal"><span class="pre">scalar()</span></tt></a>).</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; element of the ring of symmetric functions over the
same base ring as <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the internal product of <tt class="docutils literal"><span class="pre">self</span></tt> with <tt class="docutils literal"><span class="pre">x</span></tt> (an element of the
ring of symmetric functions in the same basis as <tt class="docutils literal"><span class="pre">self</span></tt>)</li>
</ul>
<p>The methods <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><tt class="xref py py-meth docutils literal"><span class="pre">itensor()</span></tt></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product"><tt class="xref py py-meth docutils literal"><span class="pre">internal_product()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product"><tt class="xref py py-meth docutils literal"><span class="pre">kronecker_product()</span></tt></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor"><tt class="xref py py-meth docutils literal"><span class="pre">inner_tensor()</span></tt></a> are all
synonyms.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">s[2, 1]</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">s[1, 1, 1, 1, 1, 1] + 2*s[2, 1, 1, 1, 1] + 3*s[2, 2, 1, 1] + 2*s[2, 2, 2]</span>
<span class="go"> + 4*s[3, 1, 1, 1] + 5*s[3, 2, 1] + 2*s[3, 3] + 4*s[4, 1, 1]</span>
<span class="go"> + 3*s[4, 2] + 2*s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>There are few quantitative results pertaining to Kronecker products
in general, which makes their computation so difficult. Let us test
a few of them in different bases.</p>
<p>The Kronecker product of any homogeneous symmetric function <span class="math">\(f\)</span> of
degree <span class="math">\(n\)</span> with the <span class="math">\(n\)</span>-th complete homogeneous symmetric function
<tt class="docutils literal"><span class="pre">h[n]</span></tt> (a.k.a. <tt class="docutils literal"><span class="pre">s[n]</span></tt>) is <span class="math">\(f\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product of a Schur function <span class="math">\(s_{\lambda}\)</span> with the <span class="math">\(n\)</span>-th
elementary symmetric function <tt class="docutils literal"><span class="pre">e[n]</span></tt>, where <span class="math">\(n = \left| \lambda
\right|\)</span>, is <span class="math">\(s_{\lambda'}\)</span> (where <span class="math">\(\lambda'\)</span> is the conjugate
partition of <span class="math">\(\lambda\)</span>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product is commutative:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">....:      for p in Partitions(4) )</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;q&#39;</span><span class="p">,</span><span class="s">&#39;t&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">mq</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">mh</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">==</span> <span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>   <span class="c"># long time</span>
<span class="go">....:           for r in Partitions(4) )</span>
<span class="go">....:      for p in Partitions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us check (on examples) Proposition 5.2 of Gelfand, Krob, Lascoux, Leclerc,
Retakh, Thibon, &#8220;Noncommutative symmetric functions&#8221;, <a class="reference external" href="http://arxiv.org/abs/hep-th/9407124">Arxiv hep-th/9407124</a>, for
<span class="math">\(r = 2\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_copr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>  <span class="c"># computes \mu ((u \otimes v) * \Delta(w)) with</span>
<span class="go">....:                            # * meaning Kronecker product and \mu meaning the</span>
<span class="go">....:                            # usual multiplication.</span>
<span class="go">....:     result = w.parent().zero()</span>
<span class="go">....:     for partition_pair, coeff in w.coproduct():</span>
<span class="go">....:         result += coeff * w.parent()(u).itensor(partition_pair[0]) * w.parent()(v).itensor(partition_pair[1])</span>
<span class="go">....:     return result</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_copr</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>   <span class="c"># long time</span>
<span class="go">....:                == (e[u] * s[v]).itensor(m[w])</span>
<span class="go">....:                for w in Partitions(5) )</span>
<span class="go">....:           for v in Partitions(2) )</span>
<span class="go">....:      for u in Partitions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Some examples from Briand, Orellana, Rosas, &#8220;The stability of the Kronecker
products of Schur functions.&#8221; <a class="reference external" href="http://arxiv.org/abs/0907.4652">Arxiv 0907.4652</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[1, 1, 1, 1] + s[2, 2] + s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 1, 1, 1] + s[2, 2, 1] + s[3, 1, 1] + s[3, 2] + s[4, 1] + s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 2, 2] + s[3, 1, 1, 1] + 2*s[3, 2, 1] + s[4, 1, 1] + 2*s[4, 2] + s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>An example from p. 220 of Thibon, &#8220;Hopf algebras of symmetric functions
and tensor products of symmetric group representations&#8221;, International
Journal of Algebra and Computation, 1991:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQbar</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1] + s[2, 1] + s[3]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c"># long time</span>
<span class="go">s[4, 4, 4, 4] + s[5, 5, 3, 3] + s[5, 5, 5, 1] + s[6, 4, 4, 2]</span>
<span class="go"> + s[6, 6, 2, 2] + s[6, 6, 4] + s[7, 3, 3, 3] + s[7, 5, 3, 1]</span>
<span class="go"> + s[7, 7, 1, 1] + s[8, 4, 2, 2] + s[8, 4, 4] + s[8, 6, 2]</span>
<span class="go"> + s[8, 8] + s[9, 3, 3, 1] + s[9, 5, 1, 1] + s[10, 2, 2, 2]</span>
<span class="go"> + s[10, 4, 2] + s[10, 6] + s[11, 3, 1, 1] + s[12, 2, 2]</span>
<span class="go"> + s[12, 4] + s[13, 1, 1, 1] + s[14, 2] + s[16]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">s[]</span>
</pre></div>
</div>
<p>Same over the ring of integers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c"># long time</span>
<span class="go">s[4, 4, 4, 4] + s[5, 5, 3, 3] + s[5, 5, 5, 1] + s[6, 4, 4, 2]</span>
<span class="go"> + s[6, 6, 2, 2] + s[6, 6, 4] + s[7, 3, 3, 3] + s[7, 5, 3, 1]</span>
<span class="go"> + s[7, 7, 1, 1] + s[8, 4, 2, 2] + s[8, 4, 4] + s[8, 6, 2]</span>
<span class="go"> + s[8, 8] + s[9, 3, 3, 1] + s[9, 5, 1, 1] + s[10, 2, 2, 2]</span>
<span class="go"> + s[10, 4, 2] + s[10, 6] + s[11, 3, 1, 1] + s[12, 2, 2]</span>
<span class="go"> + s[12, 4] + s[13, 1, 1, 1] + s[14, 2] + s[16]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">s[]</span>
</pre></div>
</div>
<p>Theorem 2.1 in Bessenrodt, van Willigenburg, <a class="reference external" href="http://arxiv.org/abs/1105.3170v2">Arxiv 1105.3170v2</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">max</span><span class="p">(</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">.</span><span class="n">monomial_coefficients</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="p">)</span>
<span class="go">....:           == sum( min(p[i], q.get_part(i)) for i in range(len(p)) )</span>
<span class="go">....:           for p in Partitions(4) )</span>
<span class="go">....:      for q in Partitions(4) )</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">max</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">.</span><span class="n">monomial_coefficients</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="p">)</span>
<span class="go">....:           == sum( min(p[i], q.conjugate().get_part(i)) for i in range(len(p)) )</span>
<span class="go">....:           for p in Partitions(4) )</span>
<span class="go">....:      for q in Partitions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Check that the basis and ground ring of <tt class="docutils literal"><span class="pre">self</span></tt> are preserved:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">e[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">s[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">Symmetric Functions over Cyclotomic Field of order 12 and degree 4 in the elementary basis</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">Symmetric Functions over Cyclotomic Field of order 12 and degree 4 in the Schur basis</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The currently existing implementation of this function is
technically unsatisfactory. It distinguishes the case when the
base ring is a <span class="math">\(\QQ\)</span>-algebra (in which case the Kronecker product
can be easily computed using the power sum basis) from the case
where it isn&#8217;t. In the latter, it does a computation using
universal coefficients, again distinguishing the case when it is
able to compute the &#8220;corresponding&#8221; basis of the symmetric function
algebra over <span class="math">\(\QQ\)</span> (using the <tt class="docutils literal"><span class="pre">corresponding_basis_over</span></tt> hack)
from the case when it isn&#8217;t (in which case it transforms everything
into the Schur basis, which is slow).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_coproduct">
<tt class="descname">kronecker_coproduct</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_coproduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inner coproduct of <tt class="docutils literal"><span class="pre">self</span></tt> in the basis of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The inner coproduct (also known as the Kronecker coproduct, as the
internal coproduct, or as the second comultiplication on the ring of
symmetric functions) is a ring homomorphism <span class="math">\(\Delta^\times\)</span> from the
ring of symmetric functions to the tensor product (over the base
ring) of this ring with itself. It is uniquely characterized by the
formula</p>
<div class="math">
\[\Delta^{\times}(h_n) = \sum_{\lambda \vdash n} s_{\lambda}
\otimes s_{\lambda} = \sum_{\lambda \vdash n} h_{\lambda} \otimes
m_{\lambda} = \sum_{\lambda \vdash n} m_{\lambda} \otimes
h_{\lambda},\]</div>
<p>where <span class="math">\(\lambda \vdash n\)</span> means <span class="math">\(\lambda\)</span> is a partition of <span class="math">\(n\)</span>, and
<span class="math">\(n\)</span> is any nonnegative integer. It also satisfies</p>
<div class="math">
\[\Delta^\times (p_n) = p_n \otimes p_n\]</div>
<p>for any positive integer <span class="math">\(n\)</span>. If the base ring is a <span class="math">\(\QQ\)</span>-algebra, it
also satisfies</p>
<div class="math">
\[\Delta^{\times}(h_n) = \sum_{\lambda \vdash n} z_{\lambda}^{-1}
p_{\lambda} \otimes p_{\lambda},\]</div>
<p>where</p>
<div class="math">
\[z_{\lambda} = \prod_{i=1}^\infty i^{m_i(\lambda)} m_i(\lambda)!\]</div>
<p>with <span class="math">\(m_i(\lambda)\)</span> meaning the number of appearances of <span class="math">\(i\)</span>
in <span class="math">\(\lambda\)</span> (see <a class="reference internal" href="#sage.combinat.sf.sfa.zee" title="sage.combinat.sf.sfa.zee"><tt class="xref py py-meth docutils literal"><span class="pre">zee()</span></tt></a>).</p>
<p>The method <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_coproduct" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_coproduct"><tt class="xref py py-meth docutils literal"><span class="pre">kronecker_coproduct()</span></tt></a> is a synonym of
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_coproduct" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_coproduct"><tt class="xref py py-meth docutils literal"><span class="pre">internal_coproduct()</span></tt></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="go">s[1, 1, 1] # s[2, 1] + s[2, 1] # s[1, 1, 1] + s[2, 1] # s[2, 1] + s[2, 1] # s[3] + s[3] # s[2, 1]</span>

<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="go">e[1, 1] # e[2] + e[2] # e[1, 1] - 2*e[2] # e[2]</span>
</pre></div>
</div>
<p>The internal coproduct is adjoint to the internal product with respect
to the Hall inner product: Any three symmetric functions <span class="math">\(f\)</span>, <span class="math">\(g\)</span> and
<span class="math">\(h\)</span> satisfy <span class="math">\(\langle f * g, h \rangle = \sum_i \langle f, h^{\prime}_i
\rangle \langle g, h^{\prime\prime}_i \rangle\)</span>, where we write
<span class="math">\(\Delta^{\times}(h)\)</span> as <span class="math">\(\sum_i h^{\prime}_i \otimes
h^{\prime\prime}_i\)</span>. Let us check this in degree <span class="math">\(4\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_incopr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>  <span class="c"># computes \sum_i \left&lt; f, h&#39;_i \right&gt; \left&lt; g, h&#39;&#39;_i \right&gt;</span>
<span class="go">....:     result = h.base_ring().zero()</span>
<span class="go">....:     for partition_pair, coeff in h.internal_coproduct():</span>
<span class="go">....:         result += coeff * h.parent()(f).scalar(partition_pair[0]) * h.parent()(g).scalar(partition_pair[1])</span>
<span class="go">....:     return result</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_incopr</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>  <span class="c"># long time (10s on sage.math, 2013)</span>
<span class="go">....:                for w in Partitions(5) )</span>
<span class="go">....:           for v in Partitions(2) )</span>
<span class="go">....:      for u in Partitions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us check the formulas for <span class="math">\(\Delta^{\times}(h_n)\)</span> and
<span class="math">\(\Delta^{\times}(p_n)\)</span> given in the description of this method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">h</span><span class="p">([</span><span class="n">n</span><span class="p">]))</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">tensor</span><span class="p">([</span><span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">),</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)])</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
<span class="go">....:      for n in range(6) )</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">tensor</span><span class="p">([</span><span class="n">h</span><span class="p">(</span><span class="n">lam</span><span class="p">),</span> <span class="n">h</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">))])</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
<span class="go">....:      for n in range(6) )</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">h</span><span class="p">([</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="go">....:      == sum([lam.conjugacy_class_size() * tensor([h(p(lam)), h(p(lam))])</span>
<span class="go">....:              for lam in Partitions(n)])</span>
<span class="go">....:      for n in range(6) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([])</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="go">s[] # s[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product">
<tt class="descname">kronecker_product</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the internal (tensor) product of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt> in the
basis of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The internal tensor product can be defined as the linear extension
of the definition on power sums
<span class="math">\(p_{\lambda} \ast p_{\mu} = \delta_{\lambda,\mu} z_{\lambda}
p_{\lambda}\)</span>, where <span class="math">\(z_{\lambda} = (1^{r_1} r_1!) (2^{r_2} r_2!)
\cdots\)</span> for <span class="math">\(\lambda = (1^{r_1} 2^{r_2} \cdots )\)</span> and where <span class="math">\(\ast\)</span>
denotes the internal tensor product.
The internal tensor product is also known as the Kronecker product,
or as the second multiplication on the ring of symmetric functions.</p>
<p>Note that the internal product of any two homogeneous symmetric
functions of equal degrees is a homogeneous symmetric function of the
same degree. On the other hand, the internal product of two homogeneous
symmetric functions of distinct degrees is <span class="math">\(0\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The internal product is sometimes referred to as &#8220;inner product&#8221;
in the literature, but unfortunately this name is shared by a
different operation, namely the Hall inner product
(see <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar"><tt class="xref py py-meth docutils literal"><span class="pre">scalar()</span></tt></a>).</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; element of the ring of symmetric functions over the
same base ring as <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the internal product of <tt class="docutils literal"><span class="pre">self</span></tt> with <tt class="docutils literal"><span class="pre">x</span></tt> (an element of the
ring of symmetric functions in the same basis as <tt class="docutils literal"><span class="pre">self</span></tt>)</li>
</ul>
<p>The methods <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><tt class="xref py py-meth docutils literal"><span class="pre">itensor()</span></tt></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product"><tt class="xref py py-meth docutils literal"><span class="pre">internal_product()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product"><tt class="xref py py-meth docutils literal"><span class="pre">kronecker_product()</span></tt></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor"><tt class="xref py py-meth docutils literal"><span class="pre">inner_tensor()</span></tt></a> are all
synonyms.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">s[2, 1]</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">s[1, 1, 1, 1, 1, 1] + 2*s[2, 1, 1, 1, 1] + 3*s[2, 2, 1, 1] + 2*s[2, 2, 2]</span>
<span class="go"> + 4*s[3, 1, 1, 1] + 5*s[3, 2, 1] + 2*s[3, 3] + 4*s[4, 1, 1]</span>
<span class="go"> + 3*s[4, 2] + 2*s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>There are few quantitative results pertaining to Kronecker products
in general, which makes their computation so difficult. Let us test
a few of them in different bases.</p>
<p>The Kronecker product of any homogeneous symmetric function <span class="math">\(f\)</span> of
degree <span class="math">\(n\)</span> with the <span class="math">\(n\)</span>-th complete homogeneous symmetric function
<tt class="docutils literal"><span class="pre">h[n]</span></tt> (a.k.a. <tt class="docutils literal"><span class="pre">s[n]</span></tt>) is <span class="math">\(f\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product of a Schur function <span class="math">\(s_{\lambda}\)</span> with the <span class="math">\(n\)</span>-th
elementary symmetric function <tt class="docutils literal"><span class="pre">e[n]</span></tt>, where <span class="math">\(n = \left| \lambda
\right|\)</span>, is <span class="math">\(s_{\lambda'}\)</span> (where <span class="math">\(\lambda'\)</span> is the conjugate
partition of <span class="math">\(\lambda\)</span>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product is commutative:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">....:      for p in Partitions(4) )</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;q&#39;</span><span class="p">,</span><span class="s">&#39;t&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">mq</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">mh</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">==</span> <span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>   <span class="c"># long time</span>
<span class="go">....:           for r in Partitions(4) )</span>
<span class="go">....:      for p in Partitions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us check (on examples) Proposition 5.2 of Gelfand, Krob, Lascoux, Leclerc,
Retakh, Thibon, &#8220;Noncommutative symmetric functions&#8221;, <a class="reference external" href="http://arxiv.org/abs/hep-th/9407124">Arxiv hep-th/9407124</a>, for
<span class="math">\(r = 2\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_copr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>  <span class="c"># computes \mu ((u \otimes v) * \Delta(w)) with</span>
<span class="go">....:                            # * meaning Kronecker product and \mu meaning the</span>
<span class="go">....:                            # usual multiplication.</span>
<span class="go">....:     result = w.parent().zero()</span>
<span class="go">....:     for partition_pair, coeff in w.coproduct():</span>
<span class="go">....:         result += coeff * w.parent()(u).itensor(partition_pair[0]) * w.parent()(v).itensor(partition_pair[1])</span>
<span class="go">....:     return result</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_copr</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>   <span class="c"># long time</span>
<span class="go">....:                == (e[u] * s[v]).itensor(m[w])</span>
<span class="go">....:                for w in Partitions(5) )</span>
<span class="go">....:           for v in Partitions(2) )</span>
<span class="go">....:      for u in Partitions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Some examples from Briand, Orellana, Rosas, &#8220;The stability of the Kronecker
products of Schur functions.&#8221; <a class="reference external" href="http://arxiv.org/abs/0907.4652">Arxiv 0907.4652</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[1, 1, 1, 1] + s[2, 2] + s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 1, 1, 1] + s[2, 2, 1] + s[3, 1, 1] + s[3, 2] + s[4, 1] + s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 2, 2] + s[3, 1, 1, 1] + 2*s[3, 2, 1] + s[4, 1, 1] + 2*s[4, 2] + s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>An example from p. 220 of Thibon, &#8220;Hopf algebras of symmetric functions
and tensor products of symmetric group representations&#8221;, International
Journal of Algebra and Computation, 1991:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQbar</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1] + s[2, 1] + s[3]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c"># long time</span>
<span class="go">s[4, 4, 4, 4] + s[5, 5, 3, 3] + s[5, 5, 5, 1] + s[6, 4, 4, 2]</span>
<span class="go"> + s[6, 6, 2, 2] + s[6, 6, 4] + s[7, 3, 3, 3] + s[7, 5, 3, 1]</span>
<span class="go"> + s[7, 7, 1, 1] + s[8, 4, 2, 2] + s[8, 4, 4] + s[8, 6, 2]</span>
<span class="go"> + s[8, 8] + s[9, 3, 3, 1] + s[9, 5, 1, 1] + s[10, 2, 2, 2]</span>
<span class="go"> + s[10, 4, 2] + s[10, 6] + s[11, 3, 1, 1] + s[12, 2, 2]</span>
<span class="go"> + s[12, 4] + s[13, 1, 1, 1] + s[14, 2] + s[16]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">s[]</span>
</pre></div>
</div>
<p>Same over the ring of integers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c"># long time</span>
<span class="go">s[4, 4, 4, 4] + s[5, 5, 3, 3] + s[5, 5, 5, 1] + s[6, 4, 4, 2]</span>
<span class="go"> + s[6, 6, 2, 2] + s[6, 6, 4] + s[7, 3, 3, 3] + s[7, 5, 3, 1]</span>
<span class="go"> + s[7, 7, 1, 1] + s[8, 4, 2, 2] + s[8, 4, 4] + s[8, 6, 2]</span>
<span class="go"> + s[8, 8] + s[9, 3, 3, 1] + s[9, 5, 1, 1] + s[10, 2, 2, 2]</span>
<span class="go"> + s[10, 4, 2] + s[10, 6] + s[11, 3, 1, 1] + s[12, 2, 2]</span>
<span class="go"> + s[12, 4] + s[13, 1, 1, 1] + s[14, 2] + s[16]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">s[]</span>
</pre></div>
</div>
<p>Theorem 2.1 in Bessenrodt, van Willigenburg, <a class="reference external" href="http://arxiv.org/abs/1105.3170v2">Arxiv 1105.3170v2</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">max</span><span class="p">(</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">.</span><span class="n">monomial_coefficients</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="p">)</span>
<span class="go">....:           == sum( min(p[i], q.get_part(i)) for i in range(len(p)) )</span>
<span class="go">....:           for p in Partitions(4) )</span>
<span class="go">....:      for q in Partitions(4) )</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">max</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">.</span><span class="n">monomial_coefficients</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="p">)</span>
<span class="go">....:           == sum( min(p[i], q.conjugate().get_part(i)) for i in range(len(p)) )</span>
<span class="go">....:           for p in Partitions(4) )</span>
<span class="go">....:      for q in Partitions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Check that the basis and ground ring of <tt class="docutils literal"><span class="pre">self</span></tt> are preserved:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">e[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">s[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">Symmetric Functions over Cyclotomic Field of order 12 and degree 4 in the elementary basis</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">Symmetric Functions over Cyclotomic Field of order 12 and degree 4 in the Schur basis</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The currently existing implementation of this function is
technically unsatisfactory. It distinguishes the case when the
base ring is a <span class="math">\(\QQ\)</span>-algebra (in which case the Kronecker product
can be easily computed using the power sum basis) from the case
where it isn&#8217;t. In the latter, it does a computation using
universal coefficients, again distinguishing the case when it is
able to compute the &#8220;corresponding&#8221; basis of the symmetric function
algebra over <span class="math">\(\QQ\)</span> (using the <tt class="docutils literal"><span class="pre">corresponding_basis_over</span></tt> hack)
from the case when it isn&#8217;t (in which case it transforms everything
into the Schur basis, which is slow).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.left_padded_kronecker_product">
<tt class="descname">left_padded_kronecker_product</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.left_padded_kronecker_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the left-padded Kronecker product of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt> in
the basis of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The left-padded Kronecker product is a bilinear map mapping two
symmetric functions to another, not necessarily preserving degree.
It can be defined as follows: Let <span class="math">\(*\)</span> denote the Kronecker product
(<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><tt class="xref py py-meth docutils literal"><span class="pre">itensor()</span></tt></a>) on the space of symmetric functions. For any
partitions <span class="math">\(\alpha\)</span>, <span class="math">\(\beta\)</span>, <span class="math">\(\gamma\)</span>, let
<span class="math">\(g^{\gamma}_{\alpha, \beta}\)</span> denote the coefficient of the
complete homogeneous symmetric function <span class="math">\(h_{\gamma}\)</span> in the
Kronecker product <span class="math">\(h_{\alpha} * h_{\beta}\)</span>.
For every partition
<span class="math">\(\lambda = (\lambda_1, \lambda_2, \lambda_3, \ldots)\)</span>
and every integer <span class="math">\(n &gt; \left| \lambda \right| + \lambda_1\)</span>, let
<span class="math">\(\lambda[n]\)</span> denote the <span class="math">\(n\)</span>-completion of <span class="math">\(\lambda\)</span> (this is the
partition
<span class="math">\((n - \left| \lambda \right|, \lambda_1, \lambda_2, \lambda_3, \ldots)\)</span>;
see <a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.t_completion" title="sage.combinat.partition.Partition.t_completion"><tt class="xref py py-meth docutils literal"><span class="pre">t_completion()</span></tt></a>).
Then, for any partitions <span class="math">\(\alpha\)</span> and <span class="math">\(\beta\)</span> and every integer
<span class="math">\(n \geq \left|\alpha\right| + \left|\beta\right| + \alpha_1 + \beta_1\)</span>,
we can write the Kronecker product <span class="math">\(h_{\alpha[n]} * h_{\beta[n]}\)</span>
in the form</p>
<div class="math">
\[h_{\alpha[n]} * h_{\beta[n]} = \sum_{\gamma}
g^{\gamma[n]}_{\alpha[n], \beta[n]} h_{\gamma[n]}\]</div>
<p>with <span class="math">\(\gamma\)</span> ranging over all partitions. The
coefficients <span class="math">\(g^{\gamma[n]}_{\alpha[n], \beta[n]}\)</span>
are independent on <span class="math">\(n\)</span>. These coefficients
<span class="math">\(g^{\gamma[n]}_{\alpha[n], \beta[n]}\)</span> are denoted by
<span class="math">\(\overline{g}^{\gamma}_{\alpha, \beta}\)</span>, and the symmetric
function</p>
<div class="math">
\[\sum_{\gamma} \overline{g}^{\gamma}_{\alpha, \beta} h_{\gamma}\]</div>
<p>is said to be the <em>left-padded Kronecker product</em> of <span class="math">\(h_{\alpha}\)</span>
and <span class="math">\(h_{\beta}\)</span>. By bilinearity, this extends to a definition of a
left-padded Kronecker product of any two symmetric functions.</p>
<p>This notion of left-padded Kronecker product can be lifted to the
non-commutative symmetric functions
(<tt class="xref py py-meth docutils literal"><span class="pre">left_padded_kronecker_product()</span></tt>).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Don&#8217;t mistake this product for the reduced Kronecker product
(<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.reduced_kronecker_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.reduced_kronecker_product"><tt class="xref py py-meth docutils literal"><span class="pre">reduced_kronecker_product()</span></tt></a>), which uses the Schur
functions instead of the complete homogeneous functions in
its definition.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; element of the ring of symmetric functions over the
same base ring as <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the left-padded Kronecker product of <tt class="docutils literal"><span class="pre">self</span></tt> with <tt class="docutils literal"><span class="pre">x</span></tt> (an
element of the ring of symmetric functions in the same basis
as <tt class="docutils literal"><span class="pre">self</span></tt>)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">h[1, 1, 1, 1] + h[2, 1] + h[2, 1, 1] + h[2, 1, 1, 1] + h[2, 2, 1] + h[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">h[1, 1, 1] + h[2, 1] + h[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">h[1, 1, 1] + h[2, 1] + h[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">h[1, 1] + 2*h[1, 1, 1] + h[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">h[1, 1, 1, 1] + 2*h[2, 1, 1] + h[2, 1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">h[2, 1] + h[2, 1, 1] + h[3, 2]</span>
</pre></div>
</div>
<p>Taking the left-padded Kronecker product with <span class="math">\(1 = h_{\empty}\)</span> is
the identity map on the ring of symmetric functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">[</span><span class="n">Partition</span><span class="p">([])]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">lam</span><span class="p">])</span>
<span class="go">....:      == h[lam] for i in range(4)</span>
<span class="go">....:      for lam in Partitions(i) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Here is a rule for the left-padded Kronecker product of <span class="math">\(h_1\)</span>
(this is the same as <span class="math">\(h_{(1)}\)</span>) with any complete homogeneous
function: Let <span class="math">\(\lambda\)</span> be a partition. Then, the left-padded
Kronecker product of <span class="math">\(h_1\)</span> and <span class="math">\(h_{\lambda}\)</span> is
<span class="math">\(\sum_{\mu} a_{\mu} h_{\mu}\)</span>, where the sum runs over all
partitions <span class="math">\(\mu\)</span>, and the coefficient <span class="math">\(a_{\mu}\)</span> is defined as the
number of ways to obtain <span class="math">\(\mu\)</span> from <span class="math">\(\lambda\)</span> by one of the
following two operations:</p>
<ul class="simple">
<li>Insert a <span class="math">\(1\)</span> into <span class="math">\(\lambda\)</span>.</li>
<li>Subtract <span class="math">\(1\)</span> from one of the entries of <span class="math">\(\lambda\)</span> (and remove
the entry if it thus becomes <span class="math">\(0\)</span>), and insert a <span class="math">\(1\)</span> into
<span class="math">\(\lambda\)</span>.</li>
</ul>
<p>We check this for partitions of size <span class="math">\(\leq 4\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">mults1</span><span class="p">(</span><span class="n">I</span><span class="p">):</span>
<span class="go">....:     # Left-padded Kronecker multiplication by h[1].</span>
<span class="go">....:     res = h[I[:] + [1]]</span>
<span class="go">....:     for k in range(len(I)):</span>
<span class="go">....:         I2 = I[:]</span>
<span class="go">....:         if I2[k] == 1:</span>
<span class="go">....:             I2 = I2[:k] + I2[k+1:]</span>
<span class="go">....:         else:</span>
<span class="go">....:             I2[k] -= 1</span>
<span class="go">....:         res += h[sorted(I2 + [1], reverse=True)]</span>
<span class="go">....:     return res</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">mults1</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">==</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">I</span><span class="p">])</span>
<span class="go">....:                == h[I].left_padded_kronecker_product(h[1])</span>
<span class="go">....:      for i in range(5) for I in Partitions(i) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The left-padded Kronecker product is commutative:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">[</span><span class="n">lam</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">mu</span><span class="p">])</span>
<span class="go">....:      == h[mu].left_padded_kronecker_product(h[lam])</span>
<span class="go">....:      for lam in Partitions(3) for mu in Partitions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">([]))</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">h</span><span class="p">([]))</span>
<span class="go">6*h[]</span>
</pre></div>
</div>
<p>Different bases and base rings:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">h[1, 1] + h[1, 1, 1] - h[2] + h[2, 1, 1] - h[2, 2]</span>

<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span> <span class="n">v</span>
<span class="go">e[1, 1] + e[1, 1, 1] + (-1)*e[2] + e[2, 2]</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">Symmetric Functions over Cyclotomic Field of order 12 and degree 4 in the elementary basis</span>

<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="n">parent</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">Symmetric Functions over Integer Ring in the Schur basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.nabla">
<tt class="descname">nabla</tt><big>(</big><em>q=None</em>, <em>t=None</em>, <em>power=1</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.nabla" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value of the nabla operator applied to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The eigenvectors of the nabla operator are the Macdonald polynomials in
the Ht basis.</p>
<p>If the parameter <tt class="docutils literal"><span class="pre">power</span></tt> is an integer then it calculates
nabla to that integer.  The default value of <tt class="docutils literal"><span class="pre">power</span></tt> is 1.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">q</span></tt>, <tt class="docutils literal"><span class="pre">t</span></tt> &#8211; optional parameters (default: <tt class="docutils literal"><span class="pre">None</span></tt>, in which
case <tt class="docutils literal"><span class="pre">q</span></tt> and <tt class="docutils literal"><span class="pre">t</span></tt> are used)</li>
<li><tt class="docutils literal"><span class="pre">power</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">1</span></tt>) an integer indicating how many times to
apply the operator <span class="math">\(\nabla\)</span>.  Negative values of <tt class="docutils literal"><span class="pre">power</span></tt>
indicate powers of <span class="math">\(\nabla^{-1}\)</span>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;q&#39;</span><span class="p">,</span><span class="s">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">power</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span>
<span class="go">(-1/2*q*t+1/2*q+1/2*t+1/2)*p[1, 1] + (1/2*q*t-1/2*q-1/2*t+1/2)*p[2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(-t-1)*p[1, 1, 1] + t*p[2, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(-t-1)*p[1, 1, 1] + t*p[2, 1]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span>
<span class="go">(-q^3*t-q^2*t^2-q*t^3)*s[1, 1, 1] + (-q^2*t-q*t^2)*s[2, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span>
<span class="go">(q^3+q^2*t+q*t^2+t^3+q*t)*s[1, 1, 1] + (q^2+q*t+t^2+q+t)*s[2, 1] + s[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(q^3+q^2+2*q+1)*s[1, 1, 1] + (q^2+2*q+2)*s[2, 1] + s[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span>
<span class="go">s[]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="n">power</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">((-q-t)/(q^2*t^2))*s[2, 1] + ((q^2+q*t+t^2)/(-q^3*t^3))*s[3]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span>
<span class="go">(-q*t)*s[1, 1] + (q^3*t^2+q^2*t^3)*s[1, 1, 1] + q^2*t^2*s[2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega">
<tt class="descname">omega</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <tt class="docutils literal"><span class="pre">self</span></tt> under the omega automorphism.</p>
<p>The <em>omega automorphism</em> is defined to be the unique algebra
endomorphism <span class="math">\(\omega\)</span> of the ring of symmetric functions that
satisfies <span class="math">\(\omega(e_k) = h_k\)</span> for all positive integers <span class="math">\(k\)</span>
(where <span class="math">\(e_k\)</span> stands for the <span class="math">\(k\)</span>-th elementary symmetric
function, and <span class="math">\(h_k\)</span> stands for the <span class="math">\(k\)</span>-th complete homogeneous
symmetric function). It furthermore is a Hopf algebra
endomorphism and an involution, and it is also known as the
<em>omega involution</em>. It sends the power-sum symmetric function
<span class="math">\(p_k\)</span> to <span class="math">\((-1)^{k-1} p_k\)</span> for every positive integer <span class="math">\(k\)</span>.</p>
<p>The images of some bases under the omega automorphism are given by</p>
<div class="math">
\[\omega(e_{\lambda}) = h_{\lambda}, \qquad
\omega(h_{\lambda}) = e_{\lambda}, \qquad
\omega(p_{\lambda}) = (-1)^{|\lambda| - \ell(\lambda)}
p_{\lambda}, \qquad
\omega(s_{\lambda}) = s_{\lambda^{\prime}},\]</div>
<p>where <span class="math">\(\lambda\)</span> is any partition, where <span class="math">\(\ell(\lambda)\)</span> denotes
the length (<a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.length" title="sage.combinat.partition.Partition.length"><tt class="xref py py-meth docutils literal"><span class="pre">length()</span></tt></a>)
of the partition <span class="math">\(\lambda\)</span>, where <span class="math">\(\lambda^{\prime}\)</span> denotes the
conjugate partition
(<a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.conjugate" title="sage.combinat.partition.Partition.conjugate"><tt class="xref py py-meth docutils literal"><span class="pre">conjugate()</span></tt></a>) of
<span class="math">\(\lambda\)</span>, and where the usual notations for bases are used
(<span class="math">\(e\)</span> = elementary, <span class="math">\(h\)</span> = complete homogeneous, <span class="math">\(p\)</span> = powersum,
<span class="math">\(s\)</span> = Schur).</p>
<p>The default implementation converts to the Schur basis, then
performs the automorphism and changes back.</p>
<p><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_involution" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_involution"><tt class="xref py py-meth docutils literal"><span class="pre">omega_involution()</span></tt></a> is a synonym for the <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega"><tt class="xref py py-meth docutils literal"><span class="pre">omega()</span></tt></a> method.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">jack</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">P</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">J</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">J</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">JackP[2, 1] + JackP[3]</span>
<span class="gp">sage: </span><span class="n">J</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">J</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">JackP[]</span>
</pre></div>
</div>
<p>The forgotten symmetric functions are the images of the monomial
symmetric functions under omega:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">f</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_involution">
<tt class="descname">omega_involution</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <tt class="docutils literal"><span class="pre">self</span></tt> under the omega automorphism.</p>
<p>The <em>omega automorphism</em> is defined to be the unique algebra
endomorphism <span class="math">\(\omega\)</span> of the ring of symmetric functions that
satisfies <span class="math">\(\omega(e_k) = h_k\)</span> for all positive integers <span class="math">\(k\)</span>
(where <span class="math">\(e_k\)</span> stands for the <span class="math">\(k\)</span>-th elementary symmetric
function, and <span class="math">\(h_k\)</span> stands for the <span class="math">\(k\)</span>-th complete homogeneous
symmetric function). It furthermore is a Hopf algebra
endomorphism and an involution, and it is also known as the
<em>omega involution</em>. It sends the power-sum symmetric function
<span class="math">\(p_k\)</span> to <span class="math">\((-1)^{k-1} p_k\)</span> for every positive integer <span class="math">\(k\)</span>.</p>
<p>The images of some bases under the omega automorphism are given by</p>
<div class="math">
\[\omega(e_{\lambda}) = h_{\lambda}, \qquad
\omega(h_{\lambda}) = e_{\lambda}, \qquad
\omega(p_{\lambda}) = (-1)^{|\lambda| - \ell(\lambda)}
p_{\lambda}, \qquad
\omega(s_{\lambda}) = s_{\lambda^{\prime}},\]</div>
<p>where <span class="math">\(\lambda\)</span> is any partition, where <span class="math">\(\ell(\lambda)\)</span> denotes
the length (<a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.length" title="sage.combinat.partition.Partition.length"><tt class="xref py py-meth docutils literal"><span class="pre">length()</span></tt></a>)
of the partition <span class="math">\(\lambda\)</span>, where <span class="math">\(\lambda^{\prime}\)</span> denotes the
conjugate partition
(<a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.conjugate" title="sage.combinat.partition.Partition.conjugate"><tt class="xref py py-meth docutils literal"><span class="pre">conjugate()</span></tt></a>) of
<span class="math">\(\lambda\)</span>, and where the usual notations for bases are used
(<span class="math">\(e\)</span> = elementary, <span class="math">\(h\)</span> = complete homogeneous, <span class="math">\(p\)</span> = powersum,
<span class="math">\(s\)</span> = Schur).</p>
<p>The default implementation converts to the Schur basis, then
performs the automorphism and changes back.</p>
<p><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_involution" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_involution"><tt class="xref py py-meth docutils literal"><span class="pre">omega_involution()</span></tt></a> is a synonym for the <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega"><tt class="xref py py-meth docutils literal"><span class="pre">omega()</span></tt></a> method.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">jack</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">P</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">J</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">J</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">JackP[2, 1] + JackP[3]</span>
<span class="gp">sage: </span><span class="n">J</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">J</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">JackP[]</span>
</pre></div>
</div>
<p>The forgotten symmetric functions are the images of the monomial
symmetric functions under omega:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">f</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_qt">
<tt class="descname">omega_qt</tt><big>(</big><em>q=None</em>, <em>t=None</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_qt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <tt class="docutils literal"><span class="pre">self</span></tt> under the <span class="math">\(q,t\)</span>-deformed omega
automorphism which sends <span class="math">\(p_k\)</span> to
<span class="math">\((-1)^{k-1} \cdot \frac{1-q^k}{1-t^k} \cdot p_k\)</span> for all positive
integers <span class="math">\(k\)</span>.</p>
<p>In general, this is well-defined outside of the powersum basis only
if the base ring is a <span class="math">\(\QQ\)</span>-algebra.</p>
<p>If <span class="math">\(q = t\)</span>, then this is the omega automorphism (<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega"><tt class="xref py py-meth docutils literal"><span class="pre">omega()</span></tt></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">q</span></tt>, <tt class="docutils literal"><span class="pre">t</span></tt> &#8211; parameters (default: <tt class="docutils literal"><span class="pre">None</span></tt>, in which case
<tt class="docutils literal"><span class="pre">'q'</span></tt> and <tt class="docutils literal"><span class="pre">'t'</span></tt> are used)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">QQqt</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s">&#39;q,t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">q</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">QQqt</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQqt</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">()</span>
<span class="go">((-q^5+1)/(-t^5+1))*p[5]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">((-q^5+1)/(-t^5+1))*p[5]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">((q^2-1)/(-t^2+1))*p[2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">((-q^3+q^2+q-1)/(t^3-t^2-t+1))*p[2, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">q</span><span class="p">)</span>
<span class="go">-(2976/(q^5-q^3-q^2+1))*p[3, 2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">()</span>
<span class="go">p[]</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQqt</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">()</span>
<span class="go">((2*q^2-2*q*t-2*q+2*t)/(t^3-t^2-t+1))*McdH[1, 1] + ((q-1)/(t-1))*McdH[2]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">((2*q^2-2*q*t-2*q+2*t)/(t^3-t^2-t+1))*McdH[1, 1] + ((q-1)/(t-1))*McdH[2]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">)</span>
<span class="go">((-t^3+t^2+t-1)/(-q^3+q^2+q-1))*McdH[2]</span>
<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;q&#39;</span><span class="p">,</span><span class="s">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">()</span>
<span class="go">((q^2-q*t-q+t)/(t^3-t^2-t+1))*McdS[1, 1] + ((-q^2*t+q*t+q-1)/(-t^3+t^2+t-1))*McdS[2]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">S</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">())</span>
<span class="go">s[2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm">
<tt class="descname">plethysm</tt><big>(</big><em>x</em>, <em>include=None</em>, <em>exclude=None</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the outer plethysm of <tt class="docutils literal"><span class="pre">self</span></tt> with <tt class="docutils literal"><span class="pre">x</span></tt>. This is
implemented only over base rings which are <span class="math">\(\QQ\)</span>-algebras.
(To compute outer plethysms over general binomial rings, change
bases to the fraction field.)</p>
<p>The outer plethysm of <span class="math">\(f\)</span> with <span class="math">\(g\)</span> is commonly denoted by
<span class="math">\(f \left[ g \right]\)</span> or by <span class="math">\(f \circ g\)</span>. It is an algebra map
in <span class="math">\(f\)</span>, but not (generally) in <span class="math">\(g\)</span>.</p>
<p>By default, the degree one elements are taken to be the
generators for the <tt class="docutils literal"><span class="pre">self</span></tt>&#8216;s base ring. This setting can be
modified by specifying the <tt class="docutils literal"><span class="pre">include</span></tt> and <tt class="docutils literal"><span class="pre">exclude</span></tt> keywords.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; a symmetric function over the same base ring as
<tt class="docutils literal"><span class="pre">self</span></tt></li>
<li><tt class="docutils literal"><span class="pre">include</span></tt> &#8211; a list of variables to be treated as
degree one elements instead of the default degree one elements</li>
<li><tt class="docutils literal"><span class="pre">exclude</span></tt> &#8211; a list of variables to be excluded
from the default degree one elements</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="mi">3</span><span class="p">])(</span> <span class="n">h</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span> <span class="p">)</span> <span class="p">)</span>
<span class="go">s[2, 2, 2] + s[4, 2] + s[6]</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">3</span><span class="p">])(</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>
<span class="go">1/3*p[3, 3, 3] - 1/3*p[9]</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="p">([</span><span class="mi">3</span><span class="p">])(</span> <span class="n">e</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span> <span class="p">)</span>
<span class="go">e[3, 3] + e[4, 1, 1] - 2*e[4, 2] - e[5, 1] + e[6]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">t</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">t^3*s[2, 2, 2] + t^3*s[4, 2] + t^3*s[6]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">t*s[4, 2] + t*s[6]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">s[]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius"><tt class="xref py py-meth docutils literal"><span class="pre">frobenius()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.reduced_kronecker_product">
<tt class="descname">reduced_kronecker_product</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.reduced_kronecker_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the reduced Kronecker product of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt> in the
basis of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The reduced Kronecker product is a bilinear map mapping two
symmetric functions to another, not necessarily preserving degree.
It can be defined as follows: Let <span class="math">\(*\)</span> denote the Kronecker product
(<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><tt class="xref py py-meth docutils literal"><span class="pre">itensor()</span></tt></a>) on the space of symmetric functions. For any
partitions <span class="math">\(\alpha\)</span>, <span class="math">\(\beta\)</span>, <span class="math">\(\gamma\)</span>, let
<span class="math">\(g^{\gamma}_{\alpha, \beta}\)</span> denote the coefficient of the Schur
function <span class="math">\(s_{\gamma}\)</span> in the Kronecker product
<span class="math">\(s_{\alpha} * s_{\beta}\)</span> (this is called a Kronecker coefficient).
For every partition
<span class="math">\(\lambda = (\lambda_1, \lambda_2, \lambda_3, \ldots)\)</span>
and every integer <span class="math">\(n &gt; \left| \lambda \right| + \lambda_1\)</span>, let
<span class="math">\(\lambda[n]\)</span> denote the <span class="math">\(n\)</span>-completion of <span class="math">\(\lambda\)</span> (this is the
partition
<span class="math">\((n - \left| \lambda \right|, \lambda_1, \lambda_2, \lambda_3, \ldots)\)</span>;
see <a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.t_completion" title="sage.combinat.partition.Partition.t_completion"><tt class="xref py py-meth docutils literal"><span class="pre">t_completion()</span></tt></a>).
Then, Theorem 1.2 of <a class="reference internal" href="../partition.html#bor09" id="id8">[BOR09]</a> shows that for any partitions
<span class="math">\(\alpha\)</span> and <span class="math">\(\beta\)</span> and every integer
<span class="math">\(n \geq \left|\alpha\right| + \left|\beta\right| + \alpha_1 + \beta_1\)</span>,
we can write the Kronecker product <span class="math">\(s_{\alpha[n]} * s_{\beta[n]}\)</span>
in the form</p>
<div class="math">
\[s_{\alpha[n]} * s_{\beta[n]} = \sum_{\gamma} g^{\gamma[n]}_{\alpha[n], \beta[n]} s_{\gamma[n]}\]</div>
<p>with <span class="math">\(\gamma\)</span> ranging over all partitions. The
coefficients <span class="math">\(g^{\gamma[n]}_{\alpha[n], \beta[n]}\)</span>
are independent on <span class="math">\(n\)</span>. These coefficients
<span class="math">\(g^{\gamma[n]}_{\alpha[n], \beta[n]}\)</span> are denoted by
<span class="math">\(\overline{g}^{\gamma}_{\alpha, \beta}\)</span>, and the symmetric
function</p>
<div class="math">
\[\sum_{\gamma} \overline{g}^{\gamma}_{\alpha, \beta} s_{\gamma}\]</div>
<p>is said to be the <em>reduced Kronecker product</em> of <span class="math">\(s_{\alpha}\)</span> and
<span class="math">\(s_{\beta}\)</span>. By bilinearity, this extends to a definition of a
reduced Kronecker product of any two symmetric functions.</p>
<p>The definition of the reduced Kronecker product goes back to
Murnaghan, and has recently been studied in <a class="reference internal" href="../partition.html#bor09" id="id9">[BOR09]</a>, <a class="reference internal" href="../partition.html#bdvo12" id="id10">[BdVO12]</a>
and other places (our notation
<span class="math">\(\overline{g}^{\gamma}_{\alpha, \beta}\)</span> appears in these two
sources).</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; element of the ring of symmetric functions over the
same base ring as <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the reduced Kronecker product of <tt class="docutils literal"><span class="pre">self</span></tt> with <tt class="docutils literal"><span class="pre">x</span></tt> (an element
of the ring of symmetric functions in the same basis as
<tt class="docutils literal"><span class="pre">self</span></tt>)</li>
</ul>
<p>EXAMPLES:</p>
<p>The example from page 2 of <a class="reference internal" href="../partition.html#bor09" id="id11">[BOR09]</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reduced_kronecker_product</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[] + s[1] + s[1, 1] + s[1, 1, 1] + 2*s[2] + 2*s[2, 1] + s[2, 2] + s[3] + s[3, 1] + s[4]</span>
</pre></div>
</div>
<p>Taking the reduced Kronecker product with <span class="math">\(1 = s_{\empty}\)</span> is the
identity map on the ring of symmetric functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">[</span><span class="n">Partition</span><span class="p">([])]</span><span class="o">.</span><span class="n">reduced_kronecker_product</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">lam</span><span class="p">])</span>
<span class="go">....:      == s[lam] for i in range(4)</span>
<span class="go">....:      for lam in Partitions(i) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>While reduced Kronecker products are hard to compute in general,
there is a rule for taking reduced Kronecker products with
<span class="math">\(s_1\)</span>. Namely, for every partition <span class="math">\(\lambda\)</span>, the reduced
Kronecker product of <span class="math">\(s_{\lambda}\)</span> with <span class="math">\(s_1\)</span> is
<span class="math">\(\sum_{\mu} a_{\mu} s_{\mu}\)</span>, where the sum runs over all
partitions <span class="math">\(\mu\)</span>, and the coefficient <span class="math">\(a_{\mu}\)</span> is defined as the
number of ways to obtain <span class="math">\(\mu\)</span> from <span class="math">\(\lambda\)</span> by one of the
following three operations:</p>
<ul class="simple">
<li>Add an addable cell
(<a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.addable_cells" title="sage.combinat.partition.Partition.addable_cells"><tt class="xref py py-meth docutils literal"><span class="pre">addable_cells()</span></tt></a>) to
<span class="math">\(\lambda\)</span>.</li>
<li>Remove a removable cell
(<a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.removable_cells" title="sage.combinat.partition.Partition.removable_cells"><tt class="xref py py-meth docutils literal"><span class="pre">removable_cells()</span></tt></a>)
from <span class="math">\(\lambda\)</span>.</li>
<li>First remove a removable cell from <span class="math">\(\lambda\)</span>, then add an
addable cell to the resulting Young diagram.</li>
</ul>
<p>This is, in fact, Proposition 5.15 of <a class="reference internal" href="../partition.html#co10" id="id12">[CO10]</a> in an elementary
wording. We check this for partitions of size <span class="math">\(\leq 4\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">mults1</span><span class="p">(</span><span class="n">lam</span><span class="p">):</span>
<span class="go">....:     # Reduced Kronecker multiplication by s[1], according</span>
<span class="go">....:     # to [CO10]_.</span>
<span class="go">....:     res = s.zero()</span>
<span class="go">....:     for mu in lam.up_list():</span>
<span class="go">....:         res += s(mu)</span>
<span class="go">....:     for mu in lam.down_list():</span>
<span class="go">....:         res += s(mu)</span>
<span class="go">....:         for nu in mu.up_list():</span>
<span class="go">....:             res += s(nu)</span>
<span class="go">....:     return res</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">mults1</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reduced_kronecker_product</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">lam</span><span class="p">])</span>
<span class="go">....:      for i in range(5) for lam in Partitions(i) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Here is the example on page 3 of Christian Gutschwager&#8217;s
<a class="reference external" href="http://arxiv.org/abs/0912.4411v3">Arxiv 0912.4411v3</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reduced_kronecker_product</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[1] + 2*s[1, 1] + s[1, 1, 1] + s[2] + 2*s[2, 1] + s[2, 1, 1] + s[3] + s[3, 1]</span>
</pre></div>
</div>
<p>Example 39 from F. D. Murnaghan, &#8220;The analysis of the Kronecker
product of irreducible representations of the symmetric group&#8221;,
American Journal of Mathematics, Vol. 60, No. 3, Jul. 1938:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">reduced_kronecker_product</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[1] + 2*s[1, 1] + 2*s[1, 1, 1] + s[1, 1, 1, 1] + 2*s[2] + 5*s[2, 1] + 4*s[2, 1, 1]</span>
<span class="go">+ s[2, 1, 1, 1] + 3*s[2, 2] + 2*s[2, 2, 1] + 2*s[3] + 5*s[3, 1] + 3*s[3, 1, 1]</span>
<span class="go">+ 3*s[3, 2] + s[3, 2, 1] + 2*s[4] + 3*s[4, 1] + s[4, 1, 1] + s[4, 2] + s[5]</span>
<span class="go">+ s[5, 1]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">([]))</span><span class="o">.</span><span class="n">reduced_kronecker_product</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">h</span><span class="p">([]))</span>
<span class="go">6*h[]</span>
</pre></div>
</div>
<p>Different bases and base rings:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reduced_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">h[1] + 2*h[1, 1] + h[1, 1, 1] - h[2] + h[2, 1, 1] - h[2, 2]</span>

<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reduced_kronecker_product</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span> <span class="n">v</span>
<span class="go">e[] + e[1] + 2*e[1, 1] + e[1, 1, 1] + (-1)*e[2] + e[2, 2]</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">Symmetric Functions over Cyclotomic Field of order 12 and degree 4 in the elementary basis</span>

<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reduced_kronecker_product</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="n">parent</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">Symmetric Functions over Integer Ring in the Schur basis</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-3">
<p class="first admonition-title">Todo</p>
<p class="last">This implementation of the reduced Kronecker product is
painfully slow.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_degree">
<tt class="descname">restrict_degree</tt><big>(</big><em>d</em>, <em>exact=True</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degree <tt class="docutils literal"><span class="pre">d</span></tt> component of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">d</span></tt> &#8211; positive integer, degree of the terms to be returned</li>
<li><tt class="docutils literal"><span class="pre">exact</span></tt> &#8211; boolean, if <tt class="docutils literal"><span class="pre">True</span></tt>, returns the terms of degree
exactly <tt class="docutils literal"><span class="pre">d</span></tt>, otherwise returns all terms of degree less than
or equal to <tt class="docutils literal"><span class="pre">d</span></tt></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the homogeneous component of <tt class="docutils literal"><span class="pre">self</span></tt> of degree <tt class="docutils literal"><span class="pre">d</span></tt></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_degree</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_degree</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">s[1]</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_degree</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">s[1, 1, 1] + s[2, 1]</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_degree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">s[1] + s[1, 1, 1] + s[2, 1]</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_degree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_partition_lengths">
<tt class="descname">restrict_partition_lengths</tt><big>(</big><em>l</em>, <em>exact=True</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_partition_lengths" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the terms of <tt class="docutils literal"><span class="pre">self</span></tt> labelled by partitions of length <tt class="docutils literal"><span class="pre">l</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">l</span></tt> &#8211; nonnegative integer</li>
<li><tt class="docutils literal"><span class="pre">exact</span></tt> &#8211; boolean, defaulting to <tt class="docutils literal"><span class="pre">True</span></tt></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>if <tt class="docutils literal"><span class="pre">True</span></tt>, returns the terms labelled by
partitions of length precisely <tt class="docutils literal"><span class="pre">l</span></tt>; otherwise returns all terms
labelled by partitions of length less than or equal to <tt class="docutils literal"><span class="pre">l</span></tt></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_partition_lengths</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">s[2, 1]</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_partition_lengths</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_partition_lengths</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">exact</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="go">s[1] + s[2, 1] + s[4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_parts">
<tt class="descname">restrict_parts</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_parts" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the terms of <tt class="docutils literal"><span class="pre">self</span></tt> labelled by partitions <span class="math">\(\lambda\)</span> with
<span class="math">\(\lambda_1 \leq n\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; positive integer, to restrict the parts of the partitions
of the terms to be returned</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_parts</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">s[1] + s[1, 1, 1] + s[2, 1]</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_parts</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">s[1] + s[1, 1, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar">
<tt class="descname">scalar</tt><big>(</big><em>x</em>, <em>zee=None</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the standard scalar product between <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; element of the ring of symmetric functions over the
same base ring as <tt class="docutils literal"><span class="pre">self</span></tt></li>
<li><tt class="docutils literal"><span class="pre">zee</span></tt> &#8211; an optional function on partitions giving
the value for the scalar product between <span class="math">\(p_{\mu}\)</span> and <span class="math">\(p_{\mu}\)</span>
(default is to use the standard <a class="reference internal" href="#sage.combinat.sf.sfa.zee" title="sage.combinat.sf.sfa.zee"><tt class="xref py py-meth docutils literal"><span class="pre">zee()</span></tt></a> function)</li>
</ul>
<p>This is the default implementation that converts both <tt class="docutils literal"><span class="pre">self</span></tt> and
<tt class="docutils literal"><span class="pre">x</span></tt> into either Schur functions (if <tt class="docutils literal"><span class="pre">zee</span></tt> is not specified) or
power-sum functions (if <tt class="docutils literal"><span class="pre">zee</span></tt> is specified) and performs the scalar
product in that basis.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p4</span> <span class="o">=</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([</span> <span class="p">[</span><span class="n">e</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">])</span>
<span class="go">[ 0  0  0  0  1]</span>
<span class="go">[ 0  0  0  1  4]</span>
<span class="go">[ 0  0  1  2  6]</span>
<span class="go">[ 0  1  2  5 12]</span>
<span class="go">[ 1  4  6 12 24]</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([</span> <span class="p">[</span><span class="n">h</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">])</span>
<span class="go">[ 0  0  0  0  1]</span>
<span class="go">[ 0  0  0  1  4]</span>
<span class="go">[ 0  0  1  2  6]</span>
<span class="go">[ 0  1  2  5 12]</span>
<span class="go">[ 1  4  6 12 24]</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([</span> <span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">])</span>
<span class="go">[-1  2  1 -3  1]</span>
<span class="go">[ 0  1  0 -2  1]</span>
<span class="go">[ 0  0  1 -2  1]</span>
<span class="go">[ 0  0  0 -1  1]</span>
<span class="go">[ 0  0  0  0  1]</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([</span> <span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">])</span>
<span class="go">[1 0 0 0 0]</span>
<span class="go">[0 1 0 0 0]</span>
<span class="go">[0 0 1 0 0]</span>
<span class="go">[0 0 0 1 0]</span>
<span class="go">[0 0 0 0 1]</span>

<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">zee</span><span class="o">=</span><span class="k">lambda</span> <span class="n">mu</span><span class="p">:</span> <span class="mi">2</span><span class="o">**</span><span class="n">mu</span><span class="o">.</span><span class="n">length</span><span class="p">())</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">mu</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">zee</span><span class="o">=</span><span class="k">lambda</span> <span class="n">mu</span><span class="p">:</span> <span class="mi">2</span><span class="o">**</span><span class="n">mu</span><span class="o">.</span><span class="n">length</span><span class="p">())</span>
<span class="go">2/3</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Over the integers, too (as long as <tt class="docutils literal"><span class="pre">zee</span></tt> is not set):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">m</span><span class="p">([</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_hl">
<tt class="descname">scalar_hl</tt><big>(</big><em>x</em>, <em>t=None</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_hl" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <span class="math">\(t\)</span>-deformed standard Hall-Littlewood scalar product of
<tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; element of the ring of symmetric functions over the same
base ring as <tt class="docutils literal"><span class="pre">self</span></tt></li>
<li><tt class="docutils literal"><span class="pre">t</span></tt> &#8211; parameter (default: <tt class="docutils literal"><span class="pre">None</span></tt>, in which case <tt class="docutils literal"><span class="pre">t</span></tt> is used)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">sp</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">scalar_t</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">sp</span>
<span class="go">(-t^2 - 1)/(t^5 - 2*t^4 + t^3 - t^2 + 2*t - 1)</span>
<span class="gp">sage: </span><span class="n">sp</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Fraction Field of Univariate Polynomial Ring in t over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_jack">
<tt class="descname">scalar_jack</tt><big>(</big><em>x</em>, <em>t=None</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_jack" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Jack-scalar product beween <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>This scalar product is defined so that the power sum elements
<span class="math">\(p_{\mu}\)</span> are orthogonal and <span class="math">\(\langle p_{\mu}, p_{\mu} \rangle =
z_{\mu} t^{\ell(\mu)}\)</span>, where <span class="math">\(\ell(\mu)\)</span> denotes the length of
<span class="math">\(\mu\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; element of the ring of symmetric functions over the
same base ring as <tt class="docutils literal"><span class="pre">self</span></tt></li>
<li><tt class="docutils literal"><span class="pre">t</span></tt> &#8211; an optional parameter (default: <tt class="docutils literal"><span class="pre">None</span></tt> in which
case <tt class="docutils literal"><span class="pre">t</span></tt> is used)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;t&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">power</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([[</span><span class="n">p</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_jack</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">nu</span><span class="p">))</span> <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)])</span>
<span class="go">[   4*t      0      0      0      0]</span>
<span class="go">[     0  3*t^2      0      0      0]</span>
<span class="go">[     0      0  8*t^2      0      0]</span>
<span class="go">[     0      0      0  4*t^3      0]</span>
<span class="go">[     0      0      0      0 24*t^4]</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([[</span><span class="n">p</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_jack</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">nu</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)])</span>
<span class="go">[  8   0   0   0   0]</span>
<span class="go">[  0  12   0   0   0]</span>
<span class="go">[  0   0  32   0   0]</span>
<span class="go">[  0   0   0  32   0]</span>
<span class="go">[  0   0   0   0 384]</span>
<span class="gp">sage: </span><span class="n">JQ</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span><span class="o">.</span><span class="n">jack</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([[</span><span class="n">JQ</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_jack</span><span class="p">(</span><span class="n">JQ</span><span class="p">(</span><span class="n">nu</span><span class="p">))</span> <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
<span class="go">[(2*t^2 + 3*t + 1)/(6*t^3)                         0                         0]</span>
<span class="go">[                        0     (t + 2)/(2*t^3 + t^2)                         0]</span>
<span class="go">[                        0                         0     6/(t^3 + 3*t^2 + 2*t)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_qt">
<tt class="descname">scalar_qt</tt><big>(</big><em>x</em>, <em>q=None</em>, <em>t=None</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_qt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <span class="math">\(q,t\)</span>-deformed standard Hall-Littlewood scalar product of
<tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; element of the ring of symmetric functions over the same
base ring as <tt class="docutils literal"><span class="pre">self</span></tt></li>
<li><tt class="docutils literal"><span class="pre">q</span></tt>, <tt class="docutils literal"><span class="pre">t</span></tt> &#8211; parameters (default: <tt class="docutils literal"><span class="pre">None</span></tt> in which case <tt class="docutils literal"><span class="pre">q</span></tt>
and <tt class="docutils literal"><span class="pre">t</span></tt> are used)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">sp</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">factor</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
<span class="go">(t - 1)^-3 * (q - 1) * (t^2 + t + 1)^-1 * (q^2*t^2 - q*t^2 + q^2 - 2*q*t + t^2 - q + 1)</span>
<span class="gp">sage: </span><span class="n">sp</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">q</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">(-t^2 - 1)/(t^5 - 2*t^4 + t^3 - t^2 + 2*t - 1)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">-q^3 + 2*q^2 - 2*q + 1</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span> <span class="c"># q=5 and t=7</span>
<span class="go">490/1539</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s">&#39;x,y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">q</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
<span class="go">1/3*(x^3 - 1)/(y^3 - 1) + 2/3*(x - 1)^3/(y - 1)^3</span>
<span class="gp">sage: </span><span class="n">Rn</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s">&#39;q&#39;</span><span class="p">,</span><span class="s">&#39;t&#39;</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">,</span><span class="s">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">Rn</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Mac</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">Rn</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">y</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="n">z</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">Mac</span><span class="o">.</span><span class="n">_sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">(</span><span class="n">Mac</span><span class="o">.</span><span class="n">P</span><span class="p">()(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">Mac</span><span class="o">.</span><span class="n">Q</span><span class="p">()(</span><span class="n">a</span><span class="p">),</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">))</span>
<span class="go">(t - 1)^-3 * (q - 1) * (t^2 + t + 1)^-1 * (q^2*t^2 - q*t^2 + q^2 - 2*q*t + t^2 - q + 1)</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">(</span><span class="n">Mac</span><span class="o">.</span><span class="n">P</span><span class="p">()(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">Mac</span><span class="o">.</span><span class="n">Q</span><span class="p">()(</span><span class="n">a</span><span class="p">)))</span>
<span class="go">(z - 1)^-3 * (y - 1) * (z^2 + z + 1)^-1 * (y^2*z^2 - y*z^2 + y^2 - 2*y*z + z^2 - y + 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_t">
<tt class="descname">scalar_t</tt><big>(</big><em>x</em>, <em>t=None</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <span class="math">\(t\)</span>-deformed standard Hall-Littlewood scalar product of
<tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; element of the ring of symmetric functions over the same
base ring as <tt class="docutils literal"><span class="pre">self</span></tt></li>
<li><tt class="docutils literal"><span class="pre">t</span></tt> &#8211; parameter (default: <tt class="docutils literal"><span class="pre">None</span></tt>, in which case <tt class="docutils literal"><span class="pre">t</span></tt> is used)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">sp</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">scalar_t</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">sp</span>
<span class="go">(-t^2 - 1)/(t^5 - 2*t^4 + t^3 - t^2 + 2*t - 1)</span>
<span class="gp">sage: </span><span class="n">sp</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Fraction Field of Univariate Polynomial Ring in t over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.skew_by">
<tt class="descname">skew_by</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.skew_by" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of skewing <tt class="docutils literal"><span class="pre">self</span></tt> by <tt class="docutils literal"><span class="pre">x</span></tt>. (Skewing by <tt class="docutils literal"><span class="pre">x</span></tt> is
the endomorphism (as additive group) of the ring of symmetric
functions adjoint to multiplication by <tt class="docutils literal"><span class="pre">x</span></tt> with respect to the
Hall inner product.)</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; element of the ring of symmetric functions over the same
base ring as <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">s[2, 1] + s[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[1, 1, 1] + 2*s[2, 1] + s[3]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">powersum</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">4*p[4, 3, 3, 2]</span>
<span class="gp">sage: </span><span class="n">zee</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">sf</span><span class="o">.</span><span class="n">sfa</span><span class="o">.</span><span class="n">zee</span>
<span class="gp">sage: </span><span class="n">zee</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">zee</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">([]))</span>
<span class="go">s[]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">skew_by</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">x needs to be a symmetric function</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.theta">
<tt class="descname">theta</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <tt class="docutils literal"><span class="pre">self</span></tt> under the theta endomorphism which sends
<span class="math">\(p_k\)</span> to <span class="math">\(a \cdot p_k\)</span> for every positive integer <span class="math">\(k\)</span>.</p>
<p>In general, this is well-defined outside of the powersum basis only
if the base ring is a <span class="math">\(\QQ\)</span>-algebra.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span></tt> &#8211; an element of the base ring</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">theta</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2*s[1, 1, 1] + 6*s[2, 1] + 2*s[3]</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">theta</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2*p[2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">theta</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">theta</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">p[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.theta_qt">
<tt class="descname">theta_qt</tt><big>(</big><em>q=None</em>, <em>t=None</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.theta_qt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <tt class="docutils literal"><span class="pre">self</span></tt> under the <span class="math">\(q,t\)</span>-deformed theta
endomorphism which sends <span class="math">\(p_k\)</span> to <span class="math">\(\frac{1-q^k}{1-t^k} \cdot p_k\)</span>
for all positive integers <span class="math">\(k\)</span>.</p>
<p>In general, this is well-defined outside of the powersum basis only
if the base ring is a <span class="math">\(\QQ\)</span>-algebra.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">q</span></tt>, <tt class="docutils literal"><span class="pre">t</span></tt> &#8211; parameters (default: <tt class="docutils literal"><span class="pre">None</span></tt>, in which case &#8216;q&#8217;
and &#8216;t&#8217; are used)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">QQqt</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s">&#39;q,t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">q</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">QQqt</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQqt</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">((-q^2+1)/(-t^2+1))*p[2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">((q^3-q^2-q+1)/(t^3-t^2-t+1))*p[2, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3/16*p[2, 1]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">realization_of</span><span class="p">()</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span>
<span class="go">t^3*s[1, 1, 1] + (t^2+t)*s[2, 1] + s[3]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">()</span>
<span class="go">p[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung">
<tt class="descname">verschiebung</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the symmetric function <tt class="docutils literal"><span class="pre">self</span></tt> under the
<span class="math">\(n\)</span>-th Verschiebung operator.</p>
<p>The <span class="math">\(n\)</span>-th Verschiebung operator <span class="math">\(\mathbf{V}_n\)</span> is defined to be
the unique algebra endomorphism <span class="math">\(V\)</span> of the ring of symmetric
functions that satisfies <span class="math">\(V(h_r) = h_{r/n}\)</span> for every positive
integer <span class="math">\(r\)</span> divisible by <span class="math">\(n\)</span>, and satisfies <span class="math">\(V(h_r) = 0\)</span> for
every positive integer <span class="math">\(r\)</span> not divisible by <span class="math">\(n\)</span>. This operator
<span class="math">\(\mathbf{V}_n\)</span> is a Hopf algebra endomorphism. For every
nonnegative integer <span class="math">\(r\)</span> with <span class="math">\(n \mid r\)</span>, it satisfies</p>
<div class="math">
\[\mathbf{V}_n(h_r) = h_{r/n},
\quad \mathbf{V}_n(p_r) = n p_{r/n},
\quad \mathbf{V}_n(e_r) = (-1)^{r - r/n} e_{r/n}\]</div>
<p>(where <span class="math">\(h\)</span> is the complete homogeneous basis, <span class="math">\(p\)</span> is the
powersum basis, and <span class="math">\(e\)</span> is the elementary basis). For every
nonnegative integer <span class="math">\(r\)</span> with <span class="math">\(n \nmid r\)</span>, it satisfes</p>
<div class="math">
\[\mathbf{V}_n(h_r) = \mathbf{V}_n(p_r) = \mathbf{V}_n(e_r) = 0.\]</div>
<p>The <span class="math">\(n\)</span>-th Verschiebung operator is also called the <span class="math">\(n\)</span>-th
Verschiebung endomorphism. Its name derives from the Verschiebung
(German for &#8220;shift&#8221;) endomorphism of the Witt vectors.</p>
<p>The <span class="math">\(n\)</span>-th Verschiebung operator is adjoint to the <span class="math">\(n\)</span>-th
Frobenius operator (see <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius"><tt class="xref py py-meth docutils literal"><span class="pre">frobenius()</span></tt></a> for its definition)
with respect to the Hall scalar product (<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar"><tt class="xref py py-meth docutils literal"><span class="pre">scalar()</span></tt></a>).</p>
<p>The action of the <span class="math">\(n\)</span>-th Verschiebung operator on the Schur basis
can also be computed explicitly. The following (probably clumsier
than necessary) description can be obtained by solving exercise
7.61 in Stanley&#8217;s <a class="reference internal" href="sf.html#sta" id="id13">[STA]</a>.</p>
<p>Let <span class="math">\(\lambda\)</span> be a partition. Let <span class="math">\(n\)</span> be a positive integer. If
the <span class="math">\(n\)</span>-core of <span class="math">\(\lambda\)</span> is nonempty, then
<span class="math">\(\mathbf{V}_n(s_\lambda) = 0\)</span>. Otherwise, the following method
computes <span class="math">\(\mathbf{V}_n(s_\lambda)\)</span>: Write the partition <span class="math">\(\lambda\)</span>
in the form <span class="math">\((\lambda_1, \lambda_2, \ldots, \lambda_{ns})\)</span> for some
nonnegative integer <span class="math">\(s\)</span>. (If <span class="math">\(n\)</span> does not divide the length of
<span class="math">\(\lambda\)</span>, then this is achieved by adding trailing zeroes to
<span class="math">\(\lambda\)</span>.) Set <span class="math">\(\beta_i = \lambda_i + ns - i\)</span> for every
<span class="math">\(s \in \{ 1, 2, \ldots, ns \}\)</span>. Then,
<span class="math">\((\beta_1, \beta_2, \ldots, \beta_{ns})\)</span> is a strictly decreasing
sequence of nonnegative integers. Stably sort the list
<span class="math">\((1, 2, \ldots, ns)\)</span> in order of (weakly) increasing remainder of
<span class="math">\(-1 - \beta_i\)</span> modulo <span class="math">\(n\)</span>. Let <span class="math">\(\xi\)</span> be the sign of the
permutation that is used for this sorting. Let <span class="math">\(\psi\)</span> be the sign
of the permutation that is used to stably sort the list
<span class="math">\((1, 2, \ldots, ns)\)</span> in order of (weakly) increasing remainder of
<span class="math">\(i - 1\)</span> modulo <span class="math">\(n\)</span>. (Notice that <span class="math">\(\psi = (-1)^{n(n-1)s(s-1)/4}\)</span>.)
Then, <span class="math">\(\mathbf{V}_n(s_\lambda) = \xi \psi \prod_{i = 0}^{n - 1}
s_{\lambda^{(i)}}\)</span>, where
<span class="math">\((\lambda^{(0)}, \lambda^{(1)}, \ldots, \lambda^{(n - 1)})\)</span>
is the <span class="math">\(n\)</span>-quotient of <span class="math">\(\lambda\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; a positive integer</li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the <span class="math">\(n\)</span>-th Verschiebung operator (on the ring of
symmetric functions) to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">s[1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3*p[1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">-18*m[1, 1] - 3*m[2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">h[2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2*p[1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">12*m[1]</span>
</pre></div>
</div>
<p>The Verschiebung endomorphisms are multiplicative:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">....:           == (s(lam) * s(mu)).verschiebung(2)</span>
<span class="go">....:           for mu in Partitions(4) )</span>
<span class="go">....:      for lam in Partitions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Being Hopf algebra endomorphisms, the Verschiebung operators
commute with the antipode:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">....:      == p(lam).antipode().verschiebung(3)</span>
<span class="go">....:      for lam in Partitions(6) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Testing the adjointness between the Frobenius operators
<span class="math">\(\mathbf{f}_n\)</span> and the Verschiebung operators
<span class="math">\(\mathbf{V}_n\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
<span class="go">....:           == s(lam).scalar(p(mu).frobenius(2))</span>
<span class="go">....:           for mu in Partitions(3) )</span>
<span class="go">....:      for lam in Partitions(6) )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases">
<em class="property">class </em><tt class="descclassname">sage.combinat.sf.sfa.</tt><tt class="descname">SymmetricFunctionsBases</tt><big>(</big><em>base</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/realizations.html#sage.categories.realizations.Category_realization_of_parent" title="(in Sage Reference Manual: Category Theory v6.7)"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.realizations.Category_realization_of_parent</span></tt></a></p>
<p>The category of bases of the ring of symmetric functions.</p>
<dl class="class">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ElementMethods">
<em class="property">class </em><tt class="descname">ElementMethods</tt><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ElementMethods" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ElementMethods.degree_negation">
<tt class="descname">degree_negation</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ElementMethods.degree_negation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <tt class="docutils literal"><span class="pre">self</span></tt> under the degree negation
automorphism of the ring of symmetric functions.</p>
<p>The degree negation is the automorphism which scales every
homogeneous element of degree <span class="math">\(k\)</span> by <span class="math">\((-1)^k\)</span> (for all <span class="math">\(k\)</span>).</p>
<p>Calling <tt class="docutils literal"><span class="pre">degree_negation(self)</span></tt> is equivalent to calling
<tt class="docutils literal"><span class="pre">self.parent().degree_negation(self)</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">m</span><span class="p">[[]]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">()</span>
<span class="go">-3*m[] + 5*m[1] + 4*m[1, 1] - 2*m[2, 1]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">();</span> <span class="n">x</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">m</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ElementMethods.degree_zero_coefficient">
<tt class="descname">degree_zero_coefficient</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ElementMethods.degree_zero_coefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the degree zero coefficient of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; an element of the symmetric functions</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">m</span><span class="p">[[]]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">degree_zero_coefficient</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods">
<em class="property">class </em><tt class="descclassname">SymmetricFunctionsBases.</tt><tt class="descname">ParentMethods</tt><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.Eulerian">
<tt class="descname">Eulerian</tt><big>(</big><em>n</em>, <em>j</em>, <em>k=None</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.Eulerian" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Eulerian symmetric function <span class="math">\(Q_{n,j}\)</span> (with <span class="math">\(n\)</span>
either an integer or a partition) or <span class="math">\(Q_{n,j,k}\)</span> (if the
optional argument <tt class="docutils literal"><span class="pre">k</span></tt> is specified) in terms of the basis
<tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>It is known that the Eulerian quasisymmetric functions are
in fact symmetric functions <a class="reference internal" href="../ncsf_qsym/qsym.html#sw2010" id="id14">[SW2010]</a>. For more information,
see <a class="reference internal" href="../ncsf_qsym/qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Fundamental.Eulerian" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Fundamental.Eulerian"><tt class="xref py py-meth docutils literal"><span class="pre">QuasiSymmetricFunctions.Fundamental.Eulerian()</span></tt></a>,
which accepts the same syntax as this method.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; the nonnegative integer <span class="math">\(n\)</span> or a partition</li>
<li><tt class="docutils literal"><span class="pre">j</span></tt> &#8211; the number of excedances</li>
<li><tt class="docutils literal"><span class="pre">k</span></tt> &#8211; (optional) if specified, determines the number of fixed
points of the permutations which are being summed over</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">4*m[1, 1, 1] + 3*m[2, 1] + 2*m[3]</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">h[2, 2] + h[3, 1] + h[4]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">s[2, 2, 1] + s[3, 1, 1] + 5*s[3, 2] + 6*s[4, 1] + 6*s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">s[2, 2, 1] + s[3, 2] + s[4, 1] + s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">s[3, 2] + s[4, 1] + s[5]</span>
</pre></div>
</div>
<p>We check Equation (5.4) in <a class="reference internal" href="../ncsf_qsym/qsym.html#sw2010" id="id15">[SW2010]</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">h[3, 2, 1] - h[4, 1, 1] + 2*h[4, 2] + h[5, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">s[3, 2, 1] + s[3, 3] + 3*s[4, 2] + 3*s[5, 1] + 3*s[6]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.antipode_by_coercion">
<tt class="descname">antipode_by_coercion</tt><big>(</big><em>element</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.antipode_by_coercion" title="Permalink to this definition">¶</a></dt>
<dd><p>The antipode of <tt class="docutils literal"><span class="pre">element</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">element</span></tt> &#8211; element in a basis of the ring of symmetric functions</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">h</span><span class="p">([])</span> <span class="o">+</span> <span class="n">h</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="c"># indirect doctest</span>
<span class="go">h[] - h[1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">s</span><span class="p">([])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">s[] - s[1] + s[1, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">p</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">-p[2] - p[3]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">e</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">e</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">e[1, 1] - e[1, 1, 1] - e[2] + 2*e[2, 1] - e[3]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">-f[3, 2, 1] - 4*f[3, 3] - 2*f[4, 2] - 2*f[5, 1] - 6*f[6]</span>
</pre></div>
</div>
<p>The antipode is an involution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The antipode is an algebra homomorphism:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">23</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">....:           for u in Partitions(3) )</span>
<span class="go">....:      for v in Partitions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Everything works over <span class="math">\(\ZZ\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">h</span><span class="p">([])</span> <span class="o">+</span> <span class="n">h</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="c"># indirect doctest</span>
<span class="go">h[] - h[1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">s</span><span class="p">([])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">s[] - s[1] + s[1, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">p</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">-p[2] - p[3]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">e</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">e</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">e[1, 1] - e[1, 1, 1] - e[2] + 2*e[2, 1] - e[3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.carlitz_shareshian_wachs">
<tt class="descname">carlitz_shareshian_wachs</tt><big>(</big><em>n</em>, <em>d</em>, <em>s</em>, <em>comparison=None</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.carlitz_shareshian_wachs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Carlitz-Shareshian-Wachs symmetric function
<span class="math">\(X_{n, d, s}\)</span> (if <tt class="docutils literal"><span class="pre">comparison</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt>), or
<span class="math">\(U_{n, d, s}\)</span> (if <tt class="docutils literal"><span class="pre">comparison</span></tt> is <tt class="docutils literal"><span class="pre">-1</span></tt>), or
<span class="math">\(V_{n, d, s}\)</span> (if <tt class="docutils literal"><span class="pre">comparison</span></tt> is <tt class="docutils literal"><span class="pre">0</span></tt>), or
<span class="math">\(W_{n, d, s}\)</span> (if <tt class="docutils literal"><span class="pre">comparison</span></tt> is <tt class="docutils literal"><span class="pre">1</span></tt>) written in the
basis <tt class="docutils literal"><span class="pre">self</span></tt>. These functions are defined below.</p>
<p>The Carlitz-Shareshian-Wachs symmetric functions have been
introduced in <a class="reference internal" href="../ncsf_qsym/qsym.html#grirei2014" id="id16">[GriRei2014]</a>, Exercise 2.84, as
refinements of a certain particular case of chromatic
quasisymmetric functions defined by Shareshian and Wachs.
Their definitions are as follows:</p>
<p>Let <span class="math">\(n\)</span>, <span class="math">\(d\)</span> and <span class="math">\(s\)</span> be three nonnegative integers. Let
<span class="math">\(W(n, d, s)\)</span> denote the set of all <span class="math">\(n\)</span>-tuples
<span class="math">\((w_1, w_2, \ldots, w_n)\)</span> of positive integers having the
property that there exist precisely <span class="math">\(d\)</span> elements <span class="math">\(i\)</span>
of <span class="math">\(\left\{ 1, 2, \ldots, n-1 \right\}\)</span> satisfying
<span class="math">\(w_i &gt; w_{i+1}\)</span>, and precisely <span class="math">\(s\)</span> elements <span class="math">\(i\)</span> of
<span class="math">\(\left\{ 1, 2, \ldots, n-1 \right\}\)</span> satisfying
<span class="math">\(w_i = w_{i+1}\)</span>. For every
<span class="math">\(w = (w_1, w_2, \ldots, w_n) \in W(n, d, s)\)</span>, let <span class="math">\(x_w\)</span>
be the monomial <span class="math">\(x_{w_1} x_{w_2} \cdots x_{w_n}\)</span>. We then
define the power series <span class="math">\(X_{n, d, s}\)</span> by</p>
<div class="math">
\[X_{n, d, s} = \sum_{w \in W(n, d, s)} x_w .\]</div>
<p>This is a symmetric function (according to
<a class="reference internal" href="../ncsf_qsym/qsym.html#grirei2014" id="id17">[GriRei2014]</a>, Exercise 2.84(b)), and for <span class="math">\(s = 0\)</span> equals
the <span class="math">\(t^d\)</span>-coefficient of the descent enumerator of Smirnov
words of length <span class="math">\(n\)</span> (an example of a chromatic
quasisymmetric function which happens to be symmetric &#8211;
see <a class="reference internal" href="#shawach2014" id="id18">[ShaWach2014]</a>, Example 2.5).</p>
<p>Assume that <span class="math">\(n &gt; 0\)</span>. Then, we can define three further
power series as follows:</p>
<div class="math">
\[\begin{split}U_{n, d, s} = \sum_{w_1 &lt; w_n} x_w ; \qquad
V_{n, d, s} = \sum_{w_1 = w_n} x_w ; \qquad
W_{n, d, s} = \sum_{w_1 &gt; w_n} x_w ,\end{split}\]</div>
<p>where all three sums range over
<span class="math">\(w = (w_1, w_2, \ldots, w_n) \in W(n, d, s)\)</span>. These
three power series <span class="math">\(U_{n, d, s}\)</span>, <span class="math">\(V_{n, d, s}\)</span> and
<span class="math">\(W_{n, d, s}\)</span> are symmetric functions as well
(<a class="reference internal" href="../ncsf_qsym/qsym.html#grirei2014" id="id19">[GriRei2014]</a>, Exercise 2.84(c)). Their sum is
<span class="math">\(X_{n, d, s}\)</span>.</p>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="shawach2014" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[ShaWach2014]</a></td><td>John Shareshian, Michelle L. Wachs.
<em>Chromatic quasisymmetric functions</em>.
<a class="reference external" href="http://arxiv.org/abs/1405.4629v1">Arxiv 1405.4629v1</a>.</td></tr>
</tbody>
</table>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; a nonnegative integer</li>
<li><tt class="docutils literal"><span class="pre">d</span></tt> &#8211; a nonnegative integer</li>
<li><tt class="docutils literal"><span class="pre">s</span></tt> &#8211; a nonnegative integer</li>
<li><tt class="docutils literal"><span class="pre">comparison</span></tt> (default: <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; a variable
which can take the forms <tt class="docutils literal"><span class="pre">None</span></tt>, <tt class="docutils literal"><span class="pre">-1</span></tt>, <tt class="docutils literal"><span class="pre">0</span></tt>
and <tt class="docutils literal"><span class="pre">1</span></tt></li>
</ul>
<p>OUTPUT:</p>
<p>The Carlitz-Shareshian-Wachs symmetric function
<span class="math">\(X_{n, d, s}\)</span> (if <tt class="docutils literal"><span class="pre">comparison</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt>), or
<span class="math">\(U_{n, d, s}\)</span> (if <tt class="docutils literal"><span class="pre">comparison</span></tt> is <tt class="docutils literal"><span class="pre">-1</span></tt>), or
<span class="math">\(V_{n, d, s}\)</span> (if <tt class="docutils literal"><span class="pre">comparison</span></tt> is <tt class="docutils literal"><span class="pre">0</span></tt>), or
<span class="math">\(W_{n, d, s}\)</span> (if <tt class="docutils literal"><span class="pre">comparison</span></tt> is <tt class="docutils literal"><span class="pre">1</span></tt>) written in the
basis <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<p>The power series <span class="math">\(X_{n, d, s}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">m[2, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">m[3]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">4*m[1, 1, 1] + m[2, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">m[2, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">m[2, 2, 1] + m[3, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">m[1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">m[]</span>
</pre></div>
</div>
<p>The power series <span class="math">\(U_{n, d, s}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">2*m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">m[2, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">3*m[1, 1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>The power series <span class="math">\(V_{n, d, s}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">m[3]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">m[2, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">m[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">m[1]</span>
</pre></div>
</div>
<p>The power series <span class="math">\(W_{n, d, s}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">m[2, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">2*m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">m[2, 2, 1] + m[3, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">8*m[1, 1, 1, 1] + 2*m[2, 1, 1] + m[2, 2]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>This works fine over other base rings:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;q&#39;</span><span class="p">,</span><span class="s">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">P</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">4*m[2, 1, 1] + 2*m[2, 2] + 2*m[3, 1]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">P</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.corresponding_basis_over">
<tt class="descname">corresponding_basis_over</tt><big>(</big><em>R</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.corresponding_basis_over" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the realization of symmetric functions corresponding to
<tt class="docutils literal"><span class="pre">self</span></tt> but over the base ring <tt class="docutils literal"><span class="pre">R</span></tt>. Only works when <tt class="docutils literal"><span class="pre">self</span></tt>
is one of the classical bases, not one of the <span class="math">\(q,t\)</span>-dependent
ones. In the latter case, <tt class="docutils literal"><span class="pre">None</span></tt> is returned instead.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">R</span></tt> &#8211; a commutative ring</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Symmetric Functions over Integer Ring in the monomial basis</span>

<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">Integers</span><span class="p">(</span><span class="mi">13</span><span class="p">))</span>
<span class="go">Symmetric Functions over Ring of integers modulo 13 in the Schur basis</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[</span><span class="s">&#39;q&#39;</span><span class="p">,</span><span class="s">&#39;t&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mj</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">J</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">mj</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">Integers</span><span class="p">(</span><span class="mi">13</span><span class="p">))</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Let&#8217;s check that this handles each of the bases properly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s">&#39;q&#39;</span><span class="p">,</span><span class="s">&#39;t&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">CyclotomicField</span><span class="p">()[</span><span class="s">&#39;q&#39;</span><span class="p">,</span><span class="s">&#39;t&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="go">Symmetric Functions over Universal Cyclotomic Field in the Schur basis</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="go">Symmetric Functions over Universal Cyclotomic Field in the powersum basis</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="go">Symmetric Functions over Universal Cyclotomic Field in the monomial basis</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="go">Symmetric Functions over Universal Cyclotomic Field in the elementary basis</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="go">Symmetric Functions over Universal Cyclotomic Field in the homogeneous basis</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">f</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="go">Symmetric Functions over Universal Cyclotomic Field in the forgotten basis</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">w</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="go">Symmetric Functions over Universal Cyclotomic Field in the Witt basis</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">P</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">J</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">Ht</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">S</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">P</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">P</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">Qp</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">P</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">jack</span><span class="p">()</span><span class="o">.</span><span class="n">J</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">jack</span><span class="p">()</span><span class="o">.</span><span class="n">P</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">jack</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">jack</span><span class="p">()</span><span class="o">.</span><span class="n">Qp</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">jack</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">J</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">zonal</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="go">Symmetric Functions over Universal Cyclotomic Field in the zonal basis</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">llt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">hspin</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">llt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">hcospin</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">llt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">hspin</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">llt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">hcospin</span><span class="p">()</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-4">
<p class="first admonition-title">Todo</p>
<p class="last">This function is an ugly hack using strings. It should be
rewritten as soon as the bases of <tt class="docutils literal"><span class="pre">SymmetricFunctions</span></tt> are
put on a more robust and systematic footing.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.counit">
<tt class="descname">counit</tt><big>(</big><em>element</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.counit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the counit of <tt class="docutils literal"><span class="pre">element</span></tt>.</p>
<p>The counit is the constant term of <tt class="docutils literal"><span class="pre">element</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">element</span></tt> &#8211; element in a basis of the ring of symmetric functions</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">m</span><span class="p">[[]]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">counit</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.degree_negation">
<tt class="descname">degree_negation</tt><big>(</big><em>element</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.degree_negation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <tt class="docutils literal"><span class="pre">element</span></tt> under the degree negation
automorphism of the ring of symmetric functions.</p>
<p>The degree negation is the automorphism which scales every
homogeneous element of degree <span class="math">\(k\)</span> by <span class="math">\((-1)^k\)</span> (for all <span class="math">\(k\)</span>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">element</span></tt> &#8211; symmetric function written in <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">m</span><span class="p">[[]]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">-3*m[] + 5*m[1] + 4*m[1, 1] - 2*m[2, 1]</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Using <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.degree_negation" title="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.degree_negation"><tt class="xref py py-meth docutils literal"><span class="pre">degree_negation()</span></tt></a> on an element of a different
basis works correctly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">elementary</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">-m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">-m[1, 1, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.degree_on_basis">
<tt class="descname">degree_on_basis</tt><big>(</big><em>b</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.degree_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degree of the basis element indexed by <tt class="docutils literal"><span class="pre">b</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; a basis of the symmetric functions</li>
<li><tt class="docutils literal"><span class="pre">b</span></tt> &#8211; a partition</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;q,t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">degree_on_basis</span><span class="p">(</span><span class="n">Partition</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">P</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">degree_on_basis</span><span class="p">(</span><span class="n">Partition</span><span class="p">([]))</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.gessel_reutenauer">
<tt class="descname">gessel_reutenauer</tt><big>(</big><em>lam</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.gessel_reutenauer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Gessel-Reutenauer symmetric function
corresponding to the partition <tt class="docutils literal"><span class="pre">lam</span></tt> written in the basis
<tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Let <span class="math">\(\lambda\)</span> be a partition. The <em>Gessel-Reutenauer
symmetric function</em> <span class="math">\(\mathbf{GR}_\lambda\)</span> corresponding to
<span class="math">\(\lambda\)</span> is the symmetric function denoted <span class="math">\(L_\lambda\)</span> in
<a class="reference internal" href="#gr1993" id="id20">[GR1993]</a> and in Exercise 7.89 of <a class="reference internal" href="sf.html#sta" id="id21">[STA]</a>. It can be defined
in several ways:</p>
<ul>
<li><p class="first">It is the sum of the monomials <span class="math">\(\mathbf{x}_w\)</span> over all
words <span class="math">\(w\)</span> over the alphabet
<span class="math">\(\left\{ 1, 2, 3, \ldots \right\}\)</span> which have CFL type
<span class="math">\(\lambda\)</span>. Here, the monomial <span class="math">\(\mathbf{x}_w\)</span> for a word
<span class="math">\(w = \left(w_1, w_2, \ldots, w_k\right)\)</span> is defined as
<span class="math">\(x_{w_1} x_{w_2} \cdots x_{w_k}\)</span>, and the <em>CFL type</em> of
a word <span class="math">\(w\)</span> is defined as the partition obtained by
sorting (in decreasing order) the lengths of the factors
in the Lyndon factorization
(<a class="reference internal" href="../words/finite_word.html#sage.combinat.words.finite_word.FiniteWord_class.lyndon_factorization" title="sage.combinat.words.finite_word.FiniteWord_class.lyndon_factorization"><tt class="xref py py-meth docutils literal"><span class="pre">lyndon_factorization()</span></tt></a>)
of <span class="math">\(w\)</span>. The fact that this power series
<span class="math">\(\mathbf{GR}_\lambda\)</span> is symmetric is not obvious.</p>
</li>
<li><p class="first">It is the sum of the fundamental quasisymmetric
functions <span class="math">\(F_{\operatorname{Des} \sigma}\)</span> over all
permutations <span class="math">\(\sigma\)</span> which have cycle type <span class="math">\(\lambda\)</span>. See
<a class="reference internal" href="../ncsf_qsym/qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Fundamental" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Fundamental"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Fundamental</span></tt></a>
for the definition of fundamental quasisymmetric functions,
and <a class="reference internal" href="../permutation.html#sage.combinat.permutation.Permutation.cycle_type" title="sage.combinat.permutation.Permutation.cycle_type"><tt class="xref py py-meth docutils literal"><span class="pre">cycle_type()</span></tt></a>
for that of cycle type. For a permutation <span class="math">\(\sigma\)</span>, we use
<span class="math">\(\operatorname{Des} \sigma\)</span> to denote the descent composition
(<a class="reference internal" href="../permutation.html#sage.combinat.permutation.Permutation.descents_composition" title="sage.combinat.permutation.Permutation.descents_composition"><tt class="xref py py-meth docutils literal"><span class="pre">descents_composition()</span></tt></a>)
of <span class="math">\(\sigma\)</span>. Again, this definition makes the symmetry
of <span class="math">\(\mathbf{GR}_\lambda\)</span> far from obvious.</p>
</li>
<li><p class="first">For every positive integer <span class="math">\(n\)</span>, we have</p>
<div class="math">
\[\mathbf{GR}_{\left(n\right)}
= \frac{1}{n} \sum_{d \mid n} \mu(d) p_d^{n/d},\]</div>
<p>where <span class="math">\(p_d\)</span> denotes the <span class="math">\(d\)</span>-th power-sum symmetric
function. This <span class="math">\(\mathbf{GR}_{\left(n\right)}\)</span> is also
denoted by <span class="math">\(L_n\)</span>. Now, <span class="math">\(\mathbf{GR}_\lambda\)</span> is defined
as the product:</p>
<div class="math">
\[h_{m_1} \left[L_1\right] \cdot h_{m_2} \left[L_2\right]
\cdot h_{m_3} \left[L_3\right] \cdots,\]</div>
<p>where <span class="math">\(m_i\)</span> denotes the multiplicity of the part <span class="math">\(i\)</span> in
<span class="math">\(\lambda\)</span>, and where the square brackets stand for
plethysm (<tt class="xref py py-meth docutils literal"><span class="pre">plethysm()</span></tt>). This definition makes
the symmetry (but not the integrality!) of
<span class="math">\(\mathbf{GR}_\lambda\)</span> obvious.</p>
</li>
</ul>
<p>The equivalences of these three definitions are proven in
<a class="reference internal" href="#gr1993" id="id22">[GR1993]</a> Sections 2-3.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">lam</span></tt> &#8211; a partition or a positive integer (in the latter
case, it is understood to mean the partition <tt class="docutils literal"><span class="pre">[lam]</span></tt>)</li>
</ul>
<p>OUTPUT:</p>
<p>The Gessel-Reutenauer symmetric function
<span class="math">\(\mathbf{GR}_\lambda\)</span>, where <span class="math">\(\lambda\)</span> is <tt class="docutils literal"><span class="pre">lam</span></tt>,
expanded in the basis <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="gr1993" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[GR1993]</td><td><em>(<a class="fn-backref" href="#id20">1</a>, <a class="fn-backref" href="#id22">2</a>, <a class="fn-backref" href="#id23">3</a>)</em> Ira M. Gessel, Christophe Reutenauer.
<em>Counting Permutations with Given Cycle Structure
and Descent Set</em>.
Journal of Combinatorial Theory, Series A, 64 (1993),
pp. 189&#8211;215.</td></tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<p>The first few values of <span class="math">\(\mathbf{GR}_{(n)} = L_n\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">h[1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">h[1, 1] - h[2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">h[2, 1] - h[3]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">h[2, 1, 1] - h[2, 2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">h[2, 1, 1, 1] - h[2, 2, 1] - h[3, 1, 1] + h[3, 2] + h[4, 1] - h[5]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">h[2, 1, 1, 1, 1] - h[2, 2, 1, 1] - h[2, 2, 2]</span>
<span class="go"> - 2*h[3, 1, 1, 1] + 5*h[3, 2, 1] - 2*h[3, 3] + h[4, 1, 1]</span>
<span class="go"> - h[4, 2] - h[5, 1] + h[6]</span>
</pre></div>
</div>
<p>Gessel-Reutenauer functions indexed by partitions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">h[1, 1, 1] - h[2, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">h[1, 1, 1, 1] - 3*h[2, 1, 1] + 2*h[2, 2] + h[3, 1] - h[4]</span>
</pre></div>
</div>
<p>The Gessel-Reutenauer functions are Schur-postive:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1] + s[2, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1, 1, 1] + s[2, 1, 1, 1] + s[2, 2, 1] + s[3, 2]</span>
</pre></div>
</div>
<p>They do not form a basis, as the following example (from
<a class="reference internal" href="#gr1993" id="id23">[GR1993]</a> p. 201) shows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Of the above three equivalent definitions of
<span class="math">\(\mathbf{GR}_\lambda\)</span>, we use the third one for
computations. Let us check that the second one gives the
same results:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">QSym</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QSym</span><span class="o">.</span><span class="n">F</span><span class="p">()</span> <span class="c"># fundamental basis</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">GR_def2</span><span class="p">(</span><span class="n">lam</span><span class="p">):</span> <span class="c"># `\mathbf{GR}_\lambda`</span>
<span class="go">....:     n = lam.size()</span>
<span class="go">....:     r = F.sum_of_monomials([sigma.descents_composition()</span>
<span class="go">....:                             for sigma in Permutations(n)</span>
<span class="go">....:                             if sigma.cycle_type() == lam])</span>
<span class="go">....:     return r.to_symmetric_function()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">GR_def2</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>
<span class="go">....:      for n in range(5) for lam in Partitions(n) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>And the first one, too (assuming symmetry):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">GR_def1</span><span class="p">(</span><span class="n">lam</span><span class="p">):</span> <span class="c"># `\mathbf{GR}_\lambda`</span>
<span class="go">....:     n = lam.size()</span>
<span class="go">....:     Permus_mset = sage.combinat.permutation.Permutations_mset</span>
<span class="go">....:     def coeff_of_m_mu_in_result(mu):</span>
<span class="go">....:         words_to_check = Permus_mset([i for (i, l) in enumerate(mu)</span>
<span class="go">....:                                       for _ in range(l)])</span>
<span class="go">....:         return sum((1 for w in words_to_check if</span>
<span class="go">....:                     Partition(list(reversed(sorted([len(v) for v in Word(w).lyndon_factorization()]))))</span>
<span class="go">....:                     == lam))</span>
<span class="go">....:     r = m.sum_of_terms([(mu, coeff_of_m_mu_in_result(mu))</span>
<span class="go">....:                         for mu in Partitions(n)],</span>
<span class="go">....:                        distinct=True)</span>
<span class="go">....:     return r</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">GR_def1</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>
<span class="go">....:      for n in range(5) for lam in Partitions(n) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>This works fine over other base rings:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;q&#39;</span><span class="p">,</span><span class="s">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">P</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">P</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The currently existing implementation of this function is
technically unsatisfactory. It distinguishes the case when the
base ring is a <span class="math">\(\QQ\)</span>-algebra from the case
where it isn&#8217;t. In the latter, it does a computation using
universal coefficients, again distinguishing the case when it is
able to compute the &#8220;corresponding&#8221; basis of the symmetric function
algebra over <span class="math">\(\QQ\)</span> (using the <tt class="docutils literal"><span class="pre">corresponding_basis_over</span></tt> hack)
from the case when it isn&#8217;t (in which case it transforms everything
into the Schur basis, which is slow).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_commutative">
<tt class="descname">is_commutative</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_commutative" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether this symmetric function algebra is commutative.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; a basis of the symmetric functions</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_field">
<tt class="descname">is_field</tt><big>(</big><em>proof=True</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether <tt class="docutils literal"><span class="pre">self</span></tt> is a field. (It is not.)</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; a basis of the symmetric functions</li>
<li><tt class="docutils literal"><span class="pre">proof</span></tt> &#8211; an optional argument (default value: <tt class="docutils literal"><span class="pre">True</span></tt>)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">is_field</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_integral_domain">
<tt class="descname">is_integral_domain</tt><big>(</big><em>proof=True</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_integral_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether <tt class="docutils literal"><span class="pre">self</span></tt> is an integral domain. (It is if
and only if the base ring is an integral domain.)</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; a basis of the symmetric functions</li>
<li><tt class="docutils literal"><span class="pre">proof</span></tt> &#8211; an optional argument (default value: <tt class="docutils literal"><span class="pre">True</span></tt>)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">is_integral_domain</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The following doctest is disabled pending <a class="reference external" href="http://trac.sagemath.org/15475">trac ticket #15475</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">Zmod</span><span class="p">(</span><span class="mi">14</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span> <span class="c"># not tested</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">is_integral_domain</span><span class="p">()</span> <span class="c"># not tested</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.one_basis">
<tt class="descname">one_basis</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.one_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the empty partition, as per <tt class="docutils literal"><span class="pre">AlgebrasWithBasis.ParentMethods.one_basis</span></tt></p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; a basis of the ring of symmetric functions</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">one_basis</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">one_basis</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-5">
<p class="first admonition-title">Todo</p>
<p class="last">generalize to Modules.Graded.Connected.ParentMethods</p>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.super_categories">
<tt class="descclassname">SymmetricFunctionsBases.</tt><tt class="descname">super_categories</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>The super categories of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; a category of bases for the symmetric functions</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.sf.sfa</span> <span class="kn">import</span> <span class="n">SymmetricFunctionsBases</span>
<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bases</span> <span class="o">=</span> <span class="n">SymmetricFunctionsBases</span><span class="p">(</span><span class="n">Sym</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bases</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of commutative graded hopf algebras with basis over Rational Field,</span>
<span class="go"> Category of realizations of Symmetric Functions over Rational Field]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.combinat.sf.sfa.is_SymmetricFunction">
<tt class="descclassname">sage.combinat.sf.sfa.</tt><tt class="descname">is_SymmetricFunction</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.is_SymmetricFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether <tt class="docutils literal"><span class="pre">x</span></tt> is a symmetric function.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.sf.sfa</span> <span class="kn">import</span> <span class="n">is_SymmetricFunction</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunction</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunction</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunction</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.sf.sfa.is_SymmetricFunctionAlgebra">
<tt class="descclassname">sage.combinat.sf.sfa.</tt><tt class="descname">is_SymmetricFunctionAlgebra</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.is_SymmetricFunctionAlgebra" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether <tt class="docutils literal"><span class="pre">x</span></tt> is a symmetric function algebra.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.sf.sfa</span> <span class="kn">import</span> <span class="n">is_SymmetricFunctionAlgebra</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunctionAlgebra</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunctionAlgebra</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunctionAlgebra</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunctionAlgebra</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunctionAlgebra</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">P</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunctionAlgebra</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s">&#39;q&#39;</span><span class="p">,</span><span class="s">&#39;t&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">P</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.sf.sfa.zee">
<tt class="descclassname">sage.combinat.sf.sfa.</tt><tt class="descname">zee</tt><big>(</big><em>part</em><big>)</big><a class="headerlink" href="#sage.combinat.sf.sfa.zee" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of the centralizer of any permutation of cycle type
<tt class="docutils literal"><span class="pre">part</span></tt>.</p>
<p>Note that the size of the centralizer is the inner product between
<tt class="docutils literal"><span class="pre">p(part)</span></tt> and itself, where <span class="math">\(p\)</span> is the power-sum symmetric
functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">part</span></tt> &#8211; an integer partition (for example, <tt class="docutils literal"><span class="pre">[2,1,1]</span></tt>)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the integer <span class="math">\(\prod_{i} i^{m_i(part)} m_i(part)!\)</span> where <span class="math">\(m_i(part)\)</span> is
the number of parts in the partition <tt class="docutils literal"><span class="pre">part</span></tt> equal to <span class="math">\(i\)</span></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.sf.sfa</span> <span class="kn">import</span> <span class="n">zee</span>
<span class="gp">sage: </span><span class="n">zee</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="sf.html"
                                  title="previous chapter">Symmetric functions, with their multiple realizations</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="witt.html"
                                  title="next chapter">Witt symmetric functions</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../../_sources/sage/combinat/sf/sfa.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="witt.html" title="Witt symmetric functions"
             >next</a> |</li>
        <li class="right" >
          <a href="sf.html" title="Symmetric functions, with their multiple realizations"
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../../index.html">Combinatorics</a> &raquo;</li>

          <li><a href="../../../module_list.html" >Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2015, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>