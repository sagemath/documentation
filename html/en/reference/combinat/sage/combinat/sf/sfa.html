
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="viewport" content="width=600, initial-scale=1">
    <title>Symmetric Functions &#8212; Sage 9.3 Reference Manual: Combinatorics</title>
    <link rel="stylesheet" href="../../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/language_data.js"></script>
    <script async="async" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Witt symmetric functions" href="witt.html" />
    <link rel="prev" title="Symmetric functions, with their multiple realizations" href="sf.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="witt.html" title="Witt symmetric functions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="sf.html" title="Symmetric functions, with their multiple realizations"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Sage 9.3 Reference Manual: Combinatorics</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../../module_list.html" accesskey="U">Comprehensive Module list</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Symmetric Functions</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="symmetric-functions">
<span id="sage-combinat-sf-sfa"></span><h1>Symmetric Functions<a class="headerlink" href="#symmetric-functions" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.sf.sfa"></span><p>For a comprehensive tutorial on how to use symmetric functions in Sage</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="sf.html#sage.combinat.sf.sf.SymmetricFunctions" title="sage.combinat.sf.sf.SymmetricFunctions"><code class="xref py py-func docutils literal notranslate"><span class="pre">SymmetricFunctions()</span></code></a></p>
</div>
<p>We define the algebra of symmetric functions in the Schur and elementary bases:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">elementary</span><span class="p">()</span>
</pre></div>
</div>
<p>Each is actually a graded Hopf algebra whose basis is indexed by
integer partitions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of graded bases of Symmetric Functions over Rational Field</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">Partitions</span>
</pre></div>
</div>
<p>Let us compute with some elements in different bases:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f1</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span> <span class="n">f1</span>
<span class="go">s[2, 1]</span>
<span class="gp">sage: </span><span class="n">f2</span> <span class="o">=</span> <span class="n">e</span><span class="p">(</span><span class="n">f1</span><span class="p">);</span> <span class="n">f2</span> <span class="c1"># basis conversion</span>
<span class="go">e[2, 1] - e[3]</span>
<span class="gp">sage: </span><span class="n">f1</span> <span class="o">==</span> <span class="n">f2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f1</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">])</span>
<span class="go">x^2*y + x*y^2 + x^2*z + 2*x*y*z + y^2*z + x*z^2 + y*z^2</span>
<span class="gp">sage: </span><span class="n">f2</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">])</span>
<span class="go">x^2*y + x*y^2 + x^2*z + 2*x*y*z + y^2*z + x*z^2 + y*z^2</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">m[3, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># This is the constant 4, not the partition 4.</span>
<span class="go">4*m[]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="c1"># This is the partition 4.</span>
<span class="go">m[4]</span>
<span class="gp">sage: </span><span class="mi">3</span><span class="o">*</span><span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span>
<span class="go">3*m[3, 1] - 1/2*m[4]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">power</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">3*p[]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the powersum basis</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">+</span> <span class="n">p</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">3*p[] + p[3, 2]</span>
</pre></div>
</div>
<p>One can convert symmetric functions to symmetric polynomials and vice versa:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">powersum</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">homogeneous</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">poly</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">poly</span>
<span class="go">2*x0^4 + 2*x0^3*x1 + 2*x0*x1^3 + 2*x1^4 + 2*x0^3*x2 + 2*x1^3*x2 + 2*x0*x2^3 + 2*x1*x2^3 + 2*x2^4</span>
<span class="go">+ x0^3 + 2*x0^2*x1 + 2*x0*x1^2 + x1^3 + 2*x0^2*x2 + 3*x0*x1*x2 + 2*x1^2*x2 + 2*x0*x2^2 + 2*x1*x2^2 + x2^3</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">from_polynomial</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
<span class="go">3*m[1, 1, 1] + 2*m[2, 1] + m[3] + 2*m[3, 1] + 2*m[4]</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">from_polynomial</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">poly</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">from_polynomial</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">s[3, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">h[3, 1] - h[4]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1/8*p[1, 1, 1, 1] + 1/4*p[2, 1, 1] - 1/8*p[2, 2] - 1/4*p[4]</span>
<span class="gp">sage: </span><span class="n">e</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">e[2, 1, 1] - e[2, 2] - e[3, 1] + e[4]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3*m[1, 1, 1, 1] + 2*m[2, 1, 1] + m[2, 2] + m[3, 1]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">x0^3*x1 + x0^2*x1^2 + x0*x1^3 + x0^3*x2 + 2*x0^2*x1*x2 + 2*x0*x1^2*x2 + x1^3*x2 + x0^2*x2^2 + 2*x0*x1*x2^2 + x1^2*x2^2 + x0*x2^3 + x1*x2^3 + x0^3*x3 + 2*x0^2*x1*x3 + 2*x0*x1^2*x3 + x1^3*x3 + 2*x0^2*x2*x3 + 3*x0*x1*x2*x3 + 2*x1^2*x2*x3 + 2*x0*x2^2*x3 + 2*x1*x2^2*x3 + x2^3*x3 + x0^2*x3^2 + 2*x0*x1*x3^2 + x1^2*x3^2 + 2*x0*x2*x3^2 + 2*x1*x2*x3^2 + x2^2*x3^2 + x0*x3^3 + x1*x3^3 + x2*x3^3</span>
</pre></div>
</div>
<p>Here are further examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span><span class="p">(</span><span class="n">m</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">h[1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span> <span class="n">m</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span><span class="n">m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>
<span class="go">h[2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span> <span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span> <span class="o">+</span> <span class="n">m</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>
<span class="go">h[3]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span> <span class="n">m</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="o">+</span> <span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">m</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">m</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>
<span class="go">h[4]</span>
<span class="gp">sage: </span><span class="n">k</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span> <span class="nb">sum</span><span class="p">([</span> <span class="n">m</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">k</span><span class="p">)])</span> <span class="p">)</span>
<span class="go">h[5]</span>
<span class="gp">sage: </span><span class="n">k</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span> <span class="nb">sum</span><span class="p">([</span> <span class="n">m</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">k</span><span class="p">)])</span> <span class="p">)</span>
<span class="go">h[10]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P3</span> <span class="o">=</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P3</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[3], [2, 1], [1, 1, 1]]</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">m</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">get_print_style</span><span class="p">()</span>
<span class="go">&#39;lex&#39;</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">m[1, 1, 1] + m[2, 1] + m[3]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s1">&#39;length&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">m[3] + m[2, 1] + m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s1">&#39;maximal_part&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">m[1, 1, 1] + m[2, 1] + m[3]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s1">&#39;lex&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*m[3, 1, 1, 1] + m[3, 2, 1] + 2*m[4, 1, 1] + m[4, 2] + m[5, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[2, 1, 1, 1, 1] - s[2, 2, 2] - s[3, 3] + s[5, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">m</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">s[2, 1, 1, 1, 1] - s[2, 2, 2] - s[3, 3] + s[5, 1]</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span><span class="o">*</span><span class="n">e</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="n">e</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">e[4, 3, 1]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">coefficient</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">length</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">support</span><span class="p">())</span>
<span class="go">[[1, 1, 1], [2, 1]]</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>AUTHORS:</p>
<ul class="simple">
<li><p>Mike Hansen (2007-06-15)</p></li>
<li><p>Nicolas M. Thiery (partial refactoring)</p></li>
<li><p>Mike Zabrocki, Anne Schilling (2012)</p></li>
<li><p>Darij Grinberg (2013) Sym over rings that are not characteristic 0</p></li>
</ul>
<dl class="py class">
<dt id="sage.combinat.sf.sfa.FilteredSymmetricFunctionsBases">
<em class="property">class </em><code class="sig-prename descclassname">sage.combinat.sf.sfa.</code><code class="sig-name descname">FilteredSymmetricFunctionsBases</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parent_with_realization</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.FilteredSymmetricFunctionsBases" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/realizations.html#sage.categories.realizations.Category_realization_of_parent" title="(in Sage 9.3 Reference Manual: Category Framework v9.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.realizations.Category_realization_of_parent</span></code></a></p>
<p>The category of filtered bases of the ring of symmetric functions.</p>
<dl class="py method">
<dt id="sage.combinat.sf.sfa.FilteredSymmetricFunctionsBases.super_categories">
<code class="sig-name descname">super_categories</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.FilteredSymmetricFunctionsBases.super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>The super categories of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.sf.sfa</span> <span class="kn">import</span> <span class="n">FilteredSymmetricFunctionsBases</span>
<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bases</span> <span class="o">=</span> <span class="n">FilteredSymmetricFunctionsBases</span><span class="p">(</span><span class="n">Sym</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bases</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of bases of Symmetric Functions over Rational Field,</span>
<span class="go"> Category of commutative filtered hopf algebras with basis over Rational Field]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sage.combinat.sf.sfa.GradedSymmetricFunctionsBases">
<em class="property">class </em><code class="sig-prename descclassname">sage.combinat.sf.sfa.</code><code class="sig-name descname">GradedSymmetricFunctionsBases</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parent_with_realization</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/realizations.html#sage.categories.realizations.Category_realization_of_parent" title="(in Sage 9.3 Reference Manual: Category Framework v9.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.realizations.Category_realization_of_parent</span></code></a></p>
<p>The category of graded bases of the ring of symmetric functions.</p>
<p>These are further required to have the property that the basis element
indexed by the empty partition is <span class="math notranslate nohighlight">\(1\)</span>.</p>
<dl class="py class">
<dt id="sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ElementMethods">
<em class="property">class </em><code class="sig-name descname">ElementMethods</code><a class="headerlink" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ElementMethods" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt id="sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ElementMethods.degree_negation">
<code class="sig-name descname">degree_negation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ElementMethods.degree_negation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the degree negation
automorphism of the ring of symmetric functions.</p>
<p>The degree negation is the automorphism which scales every
homogeneous element of degree <span class="math notranslate nohighlight">\(k\)</span> by <span class="math notranslate nohighlight">\((-1)^k\)</span> (for all <span class="math notranslate nohighlight">\(k\)</span>).</p>
<p>Calling <code class="docutils literal notranslate"><span class="pre">degree_negation(self)</span></code> is equivalent to calling
<code class="docutils literal notranslate"><span class="pre">self.parent().degree_negation(self)</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">m</span><span class="p">[[]]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">()</span>
<span class="go">-3*m[] + 5*m[1] + 4*m[1, 1] - 2*m[2, 1]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">();</span> <span class="n">x</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">m</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ElementMethods.degree_zero_coefficient">
<code class="sig-name descname">degree_zero_coefficient</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ElementMethods.degree_zero_coefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degree zero coefficient of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">m</span><span class="p">[[]]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">degree_zero_coefficient</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods">
<em class="property">class </em><code class="sig-name descname">ParentMethods</code><a class="headerlink" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt id="sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods.antipode_by_coercion">
<code class="sig-name descname">antipode_by_coercion</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">element</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods.antipode_by_coercion" title="Permalink to this definition">¶</a></dt>
<dd><p>The antipode of <code class="docutils literal notranslate"><span class="pre">element</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">element</span></code> – element in a basis of the ring of symmetric functions</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">h</span><span class="p">([])</span> <span class="o">+</span> <span class="n">h</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="c1"># indirect doctest</span>
<span class="go">h[] - h[1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">s</span><span class="p">([])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">s[] - s[1] + s[1, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">p</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">-p[2] - p[3]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">e</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">e</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">e[1, 1] - e[1, 1, 1] - e[2] + 2*e[2, 1] - e[3]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">-f[3, 2, 1] - 4*f[3, 3] - 2*f[4, 2] - 2*f[5, 1] - 6*f[6]</span>
</pre></div>
</div>
<p>The antipode is an involution:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The antipode is an algebra homomorphism:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">23</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods.counit">
<code class="sig-name descname">counit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">element</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods.counit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the counit of <code class="docutils literal notranslate"><span class="pre">element</span></code>.</p>
<p>The counit is the constant term of <code class="docutils literal notranslate"><span class="pre">element</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">element</span></code> – element in a basis of the ring of symmetric functions</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">m</span><span class="p">[[]]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">counit</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods.degree_negation">
<code class="sig-name descname">degree_negation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">element</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.ParentMethods.degree_negation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">element</span></code> under the degree negation
automorphism of the ring of symmetric functions.</p>
<p>The degree negation is the automorphism which scales every
homogeneous element of degree <span class="math notranslate nohighlight">\(k\)</span> by <span class="math notranslate nohighlight">\((-1)^k\)</span> (for all <span class="math notranslate nohighlight">\(k\)</span>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">element</span></code> – symmetric function written in <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">m</span><span class="p">[[]]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">-3*m[] + 5*m[1] + 4*m[1, 1] - 2*m[2, 1]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.super_categories">
<code class="sig-name descname">super_categories</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.GradedSymmetricFunctionsBases.super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>The super categories of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.sf.sfa</span> <span class="kn">import</span> <span class="n">GradedSymmetricFunctionsBases</span>
<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bases</span> <span class="o">=</span> <span class="n">GradedSymmetricFunctionsBases</span><span class="p">(</span><span class="n">Sym</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bases</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of filtered bases of Symmetric Functions over Rational Field,</span>
<span class="go"> Category of commutative graded hopf algebras with basis over Rational Field]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic">
<em class="property">class </em><code class="sig-prename descclassname">sage.combinat.sf.sfa.</code><code class="sig-name descname">SymmetricFunctionAlgebra_generic</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Sym</span></em>, <em class="sig-param"><span class="n">basis_name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">prefix</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">graded</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></code></a></p>
<p>Abstract base class for symmetric function algebras.</p>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>Most of the methods in this class are generic (manipulations of
morphisms, …) and should be generalized (or removed)</p>
</div>
<dl class="py attribute">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.Element">
<code class="sig-name descname">Element</code><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricFunctionAlgebra_generic_Element</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.basis_name">
<code class="sig-name descname">basis_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.basis_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This is used for output and, for the classical bases of
symmetric functions, to connect this basis with Symmetrica.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">basis_name</span><span class="p">()</span>
<span class="go">&#39;Schur&#39;</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">basis_name</span><span class="p">()</span>
<span class="go">&#39;powersum&#39;</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">basis_name</span><span class="p">()</span>
<span class="go">&#39;homogeneous&#39;</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">basis_name</span><span class="p">()</span>
<span class="go">&#39;elementary&#39;</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">basis_name</span><span class="p">()</span>
<span class="go">&#39;monomial&#39;</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">basis_name</span><span class="p">()</span>
<span class="go">&#39;forgotten&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.coproduct_by_coercion">
<code class="sig-name descname">coproduct_by_coercion</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">elt</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.coproduct_by_coercion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coproduct of the element <code class="docutils literal notranslate"><span class="pre">elt</span></code> by coercion to
the Schur basis.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elt</span></code> – an instance of this basis</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The image of <code class="docutils literal notranslate"><span class="pre">elt</span></code> under the comultiplication (=coproduct)
of the coalgebra of symmetric functions. The result is an
element of the tensor squared of the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">m[] # m[3, 1, 1] + m[1] # m[3, 1] + m[1, 1] # m[3] + m[3] # m[1, 1] + m[3, 1] # m[1] + m[3, 1, 1] # m[]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">coproduct_by_coercion</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">m[] # m[2, 1] + m[1] # m[2] + m[2] # m[1] + m[2, 1] # m[]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">coproduct_by_coercion</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">m</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">McdH</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">McdH</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">McdH[] # McdH[2, 1] + ((q^2*t-1)/(q*t-1))*McdH[1] # McdH[1, 1] + ((q*t^2-1)/(q*t-1))*McdH[1] # McdH[2] + ((q^2*t-1)/(q*t-1))*McdH[1, 1] # McdH[1] + ((q*t^2-1)/(q*t-1))*McdH[2] # McdH[1] + McdH[2, 1] # McdH[]</span>
<span class="gp">sage: </span><span class="n">HLQp</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">Qp</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">HLQp</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">HLQp[] # HLQp[2, 1] + HLQp[1] # HLQp[1, 1] + HLQp[1] # HLQp[2] + HLQp[1, 1] # HLQp[1] + HLQp[2] # HLQp[1] + HLQp[2, 1] # HLQp[]</span>
<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">LLT</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">llt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">LLT</span><span class="o">.</span><span class="n">cospin</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">(t+1)*m[] # m[1, 1] + m[] # m[2] + (t+1)*m[1] # m[1] + (t+1)*m[1, 1] # m[] + m[2] # m[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">f[] # f[3] + f[3] # f[]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">f[] # f[3, 2, 1] + f[1] # f[3, 2] + f[2] # f[3, 1] + f[2, 1] # f[3] + f[3] # f[2, 1] + f[3, 1] # f[2] + f[3, 2] # f[1] + f[3, 2, 1] # f[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.dual_basis">
<code class="sig-name descname">dual_basis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">scalar</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">scalar_name</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">basis_name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">prefix</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.dual_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual basis of <code class="docutils literal notranslate"><span class="pre">self</span></code> with respect to the scalar
product <code class="docutils literal notranslate"><span class="pre">scalar</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">scalar</span></code> – A function <code class="docutils literal notranslate"><span class="pre">zee</span></code> from partitions to the base ring
which specifies the scalar product by <span class="math notranslate nohighlight">\(\langle p_{\lambda},
p_{\lambda} \rangle = \mathrm{zee}(\lambda)\)</span>. (Independently on the
function chosen, the power sum basis will always be orthogonal;
the function <code class="docutils literal notranslate"><span class="pre">scalar</span></code> only determines the norms of the basis
elements.) If <code class="docutils literal notranslate"><span class="pre">scalar</span></code> is None, then the standard (Hall) scalar
product is used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">scalar_name</span></code> – name of the scalar function</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prefix</span></code> – prefix used to display the basis</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The duals of the elementary symmetric functions with respect to the
Hall scalar product are the forgotten symmetric functions.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">dual_basis</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">);</span> <span class="n">f</span>
<span class="go">Dual basis to Symmetric Functions over Rational Field in the elementary basis with respect to the Hall scalar product</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span>
<span class="go">4*f[2, 2, 1, 1] + 6*f[2, 2, 2] + 2*f[3, 2, 1] + 2*f[3, 3] + 2*f[4, 1, 1] + f[4, 2]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">e</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">e</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Since the power-sum symmetric functions are orthogonal, their duals
with respect to the Hall scalar product are scalar multiples of
themselves.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">dual_basis</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;q&#39;</span><span class="p">);</span> <span class="n">q</span>
<span class="go">Dual basis to Symmetric Functions over Rational Field in the powersum basis with respect to the Hall scalar product</span>
<span class="gp">sage: </span><span class="n">q</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="mi">2</span>
<span class="go">4*q[2, 2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">q</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">q</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.from_polynomial">
<code class="sig-name descname">from_polynomial</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">poly</span></em>, <em class="sig-param"><span class="n">check</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.from_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert polynomial to a symmetric function in the monomial basis
and then to the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">poly</span></code> – a symmetric polynomial</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) boolean, specifies whether
the computation checks that the polynomial is indeed symmetric</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">homogeneous</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="p">([])</span> <span class="o">+</span> <span class="n">h</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">h</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">from_polynomial</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">h[] + h[2, 1] + h[3]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">([])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">g</span>
<span class="go">x0^2*x1 + x0*x1^2 + x0^2*x2 + 2*x0*x1*x2 + x1^2*x2 + x0*x2^2 + x1*x2^2 + 1</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">from_polynomial</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">s[] + s[2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.get_print_style">
<code class="sig-name descname">get_print_style</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.get_print_style" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value of the current print style for <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">get_print_style</span><span class="p">()</span>
<span class="go">&#39;lex&#39;</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s1">&#39;length&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">get_print_style</span><span class="p">()</span>
<span class="go">&#39;length&#39;</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s1">&#39;lex&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.prefix">
<code class="sig-name descname">prefix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the prefix on the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">schur</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">schur</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">schur</span><span class="o">.</span><span class="n">prefix</span><span class="p">()</span>
<span class="go">&#39;s&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.product_by_coercion">
<code class="sig-name descname">product_by_coercion</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">left</span></em>, <em class="sig-param"><span class="n">right</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.product_by_coercion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of elements <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> by coercion to
the Schur basis.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">left</span></code>, <code class="docutils literal notranslate"><span class="pre">right</span></code> – instances of this basis</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the product of <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> expressed in the basis <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">product_by_coercion</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">p[3, 2, 2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">product_by_coercion</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.set_print_style">
<code class="sig-name descname">set_print_style</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ps</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.set_print_style" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of the current print style to <code class="docutils literal notranslate"><span class="pre">ps</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ps</span></code> – a string specifying the printing style</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">get_print_style</span><span class="p">()</span>
<span class="go">&#39;lex&#39;</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s1">&#39;length&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">get_print_style</span><span class="p">()</span>
<span class="go">&#39;length&#39;</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">set_print_style</span><span class="p">(</span><span class="s1">&#39;lex&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.symmetric_function_ring">
<code class="sig-name descname">symmetric_function_ring</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.symmetric_function_ring" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the family of symmetric functions associated to the
basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>returns an instance of the ring of symmetric functions</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">schur</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">schur</span><span class="o">.</span><span class="n">symmetric_function_ring</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field</span>
<span class="gp">sage: </span><span class="n">power</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">power</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">power</span><span class="o">.</span><span class="n">symmetric_function_ring</span><span class="p">()</span>
<span class="go">Symmetric Functions over Univariate Polynomial Ring in t over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.transition_matrix">
<code class="sig-name descname">transition_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">basis</span></em>, <em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic.transition_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the transition matrix between <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">basis</span></code> for the
homogeneous component of degree <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">basis</span></code> – a basis of the ring of symmetric functions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a nonnegative integer</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>a matrix of coefficients giving the expansion of the
homogeneous degree-<span class="math notranslate nohighlight">\(n\)</span> elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> in the
degree-<span class="math notranslate nohighlight">\(n\)</span> elements of <code class="docutils literal notranslate"><span class="pre">basis</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="go">[1 1 1 1 1 1 1]</span>
<span class="go">[0 1 1 2 2 3 4]</span>
<span class="go">[0 0 1 1 2 3 5]</span>
<span class="go">[0 0 0 1 1 3 6]</span>
<span class="go">[0 0 0 0 1 2 5]</span>
<span class="go">[0 0 0 0 0 1 4]</span>
<span class="go">[0 0 0 0 0 0 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[1]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">[ 1/4  1/3  1/8  1/4 1/24]</span>
<span class="go">[-1/4    0 -1/8  1/4  1/8]</span>
<span class="go">[   0 -1/3  1/4    0 1/12]</span>
<span class="go">[ 1/4    0 -1/8 -1/4  1/8]</span>
<span class="go">[-1/4  1/3  1/8 -1/4 1/24]</span>
<span class="gp">sage: </span><span class="n">StoP</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">5</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="n">s</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span>
<span class="go">5*s[1, 1, 1, 1] + s[3, 1] - s[4]</span>
<span class="gp">sage: </span><span class="n">mon</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">support</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mon</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">coeffs</span>
<span class="go">[5, 1, -1]</span>
<span class="gp">sage: </span><span class="n">mon</span>
<span class="go">[[1, 1, 1, 1], [3, 1], [4]]</span>
<span class="gp">sage: </span><span class="n">cm</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">cm</span> <span class="o">*</span> <span class="n">StoP</span>
<span class="go">[-7/4  4/3  3/8 -5/4 7/24]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">7/24*p[1, 1, 1, 1] - 5/4*p[2, 1, 1] + 3/8*p[2, 2] + 4/3*p[3, 1] - 7/4*p[4]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="n">e</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">[ 1 -1  0  1  0 -1  1]</span>
<span class="go">[ 1  0 -1  0  1  0 -1]</span>
<span class="go">[ 1 -1  1  0 -1  1 -1]</span>
<span class="go">[ 1  1 -1  0 -1  1  1]</span>
<span class="go">[ 1  0  1 -2  1  0  1]</span>
<span class="go">[ 1  2  1  0 -1 -2 -1]</span>
<span class="go">[ 1  4  5  6  5  4  1]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="n">e</span><span class="o">.</span><span class="n">transition_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element">
<em class="property">class </em><code class="sig-prename descclassname">sage.combinat.sf.sfa.</code><code class="sig-name descname">SymmetricFunctionAlgebra_generic_Element</code><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sage.modules.with_basis.indexed_element.IndexedFreeModuleElement</span></code></p>
<p>Class of generic elements for the symmetric function algebra.</p>
<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.arithmetic_product">
<code class="sig-name descname">arithmetic_product</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.arithmetic_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the arithmetic product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> in the
basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The arithmetic product is a binary operation <span class="math notranslate nohighlight">\(\boxdot\)</span> on the
ring of symmetric functions which is bilinear in its two
arguments and satisfies</p>
<div class="math notranslate nohighlight">
\[p_{\lambda} \boxdot p_{\mu} = \prod\limits_{i \geq 1, j \geq 1}
p_{\mathrm{lcm}(\lambda_i, \mu_j)}^{\mathrm{gcd}(\lambda_i, \mu_j)}\]</div>
<p>for any two partitions <span class="math notranslate nohighlight">\(\lambda = (\lambda_1, \lambda_2, \lambda_3,
\dots )\)</span> and <span class="math notranslate nohighlight">\(\mu = (\mu_1, \mu_2, \mu_3, \dots )\)</span> (where <span class="math notranslate nohighlight">\(p_{\nu}\)</span>
denotes the power-sum symmetric function indexed by the partition
<span class="math notranslate nohighlight">\(\nu\)</span>, and <span class="math notranslate nohighlight">\(p_i\)</span> denotes the <span class="math notranslate nohighlight">\(i\)</span>-th power-sum symmetric function).
This is enough to define the arithmetic product if the base ring
is torsion-free as a <span class="math notranslate nohighlight">\(\ZZ\)</span>-module; for all other cases the
arithmetic product is uniquely determined by requiring it to be
functorial in the base ring. See
<a class="reference external" href="http://mathoverflow.net/questions/138148/">http://mathoverflow.net/questions/138148/</a> for a discussion of
this arithmetic product.</p>
<p>If <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are two symmetric functions which are homogeneous
of degrees <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>, respectively, then <span class="math notranslate nohighlight">\(f \boxdot g\)</span> is
homogeneous of degree <span class="math notranslate nohighlight">\(ab\)</span>.</p>
<p>The arithmetic product is commutative and associative and has
unity <span class="math notranslate nohighlight">\(e_1 = p_1 = h_1\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the
same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<p>Arithmetic product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code>; this is a symmetric
function over the same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">arithmetic_product</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">s[1, 1, 1, 1] + 2*s[2, 2] + s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">arithmetic_product</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[2, 1, 1] + s[3, 1]</span>
</pre></div>
</div>
<p>The symmetric function <code class="docutils literal notranslate"><span class="pre">e[1]</span></code> is the unity for the arithmetic
product:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">arithmetic_product</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">==</span> <span class="n">e</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The arithmetic product is commutative:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">arithmetic_product</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">arithmetic_product</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>  <span class="c1"># long time (26s on sage.math, 2013)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The currently existing implementation of this function is
technically unsatisfactory. It distinguishes the case when the
base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra (in which case the arithmetic product
can be easily computed using the power sum basis) from the case
where it isn’t. In the latter, it does a computation using
universal coefficients, again distinguishing the case when it is
able to compute the “corresponding” basis of the symmetric function
algebra over <span class="math notranslate nohighlight">\(\QQ\)</span> (using the <code class="docutils literal notranslate"><span class="pre">corresponding_basis_over</span></code> hack)
from the case when it isn’t (in which case it transforms everything
into the Schur basis, which is slow).</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.bernstein_creation_operator">
<code class="sig-name descname">bernstein_creation_operator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.bernstein_creation_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the <span class="math notranslate nohighlight">\(n\)</span>-th Bernstein creation
operator.</p>
<p>Let <span class="math notranslate nohighlight">\(n\)</span> be an integer. The <span class="math notranslate nohighlight">\(n\)</span>-th Bernstein creation operator
<span class="math notranslate nohighlight">\(\mathbf{B}_n\)</span> is defined as the endomorphism of the space
<span class="math notranslate nohighlight">\(Sym\)</span> of symmetric functions which sends every <span class="math notranslate nohighlight">\(f\)</span> to</p>
<div class="math notranslate nohighlight">
\[\sum_{i \geq 0} (-1)^i h_{n+i} e_i^\perp,\]</div>
<p>where usual notations are in place (<span class="math notranslate nohighlight">\(h\)</span> stands for the complete
homogeneous symmetric functions, <span class="math notranslate nohighlight">\(e\)</span> for the elementary ones,
and <span class="math notranslate nohighlight">\(e_i^\perp\)</span> means skewing (<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.skew_by" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.skew_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">skew_by()</span></code></a>) by <span class="math notranslate nohighlight">\(e_i\)</span>).</p>
<p>This has been studied in <a class="reference internal" href="../ncsf_qsym/qsym.html#bbssz2012" id="id2"><span>[BBSSZ2012]</span></a>, section 2.2, where the
following rule is given for computing <span class="math notranslate nohighlight">\(\mathbf{B}_n\)</span> on a
Schur function: If <span class="math notranslate nohighlight">\((\alpha_1, \alpha_2, \ldots, \alpha_n)\)</span> is
an <span class="math notranslate nohighlight">\(n\)</span>-tuple of integers (positive or not), then</p>
<div class="math notranslate nohighlight">
\[\mathbf{B}_n s_{(\alpha_1, \alpha_2, \ldots, \alpha_n)}
= s_{(n, \alpha_1, \alpha_2, \ldots, \alpha_n)}.\]</div>
<p>Here, <span class="math notranslate nohighlight">\(s_{(\alpha_1, \alpha_2, \ldots, \alpha_n)}\)</span> is the
“Schur function” associated to the <span class="math notranslate nohighlight">\(n\)</span>-tuple
<span class="math notranslate nohighlight">\((\alpha_1, \alpha_2, \ldots, \alpha_n)\)</span>, and defined by
literally applying the Jacobi-Trudi identity, i.e., by</p>
<div class="math notranslate nohighlight">
\[s_{(\alpha_1, \alpha_2, \ldots, \alpha_n)}
= \det \left( (h_{\alpha_i - i + j})_{i, j = 1, 2, \ldots, n} \right).\]</div>
<p>This notion of a Schur function clearly extends the classical
notion of Schur function corresponding to a partition, but is
easily reduced to the latter (in fact, for any <span class="math notranslate nohighlight">\(n\)</span>-tuple
<span class="math notranslate nohighlight">\(\alpha\)</span> of integers, one easily sees that <span class="math notranslate nohighlight">\(s_\alpha\)</span> is
either <span class="math notranslate nohighlight">\(0\)</span> or minus-plus a Schur function corresponding to a
partition; and it is easy to determine which of these is the
case and find the partition by a combinatorial algorithm).</p>
<p>EXAMPLES:</p>
<p>Let us check that what this method computes agrees with the
definition:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">bernstein_creation_by_def</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="c1"># `n`-th Bernstein creation operator applied to `f`</span>
<span class="gp">....: </span>    <span class="c1"># computed according to its definition.</span>
<span class="gp">....: </span>    <span class="n">res</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="n">res</span>
<span class="gp">....: </span>    <span class="n">max_degree</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">n</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="n">res</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">i</span> <span class="o">*</span> <span class="n">h</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">res</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">bernstein_creation_by_def</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">bernstein_creation_by_def</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">bernstein_creation_by_def</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="o">==</span> <span class="n">e</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Some examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">s[3, 3, 2]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">-s[2, 2, 2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">h[2, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">h[2, 1, 1] - h[2, 2] - h[3, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">-h[3, 1, 1] + h[3, 2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">-h[2, 2, 2] + h[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-h[3, 3, 1] + h[4, 2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.character_to_frobenius_image">
<code class="sig-name descname">character_to_frobenius_image</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.character_to_frobenius_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret <code class="docutils literal notranslate"><span class="pre">self</span></code> as a <span class="math notranslate nohighlight">\(GL_n\)</span> character and then take the Frobenius
image of this character of the permutation matrices <span class="math notranslate nohighlight">\(S_n\)</span> which
naturally sit inside of <span class="math notranslate nohighlight">\(GL_n\)</span>.</p>
<p>To know the value of this character at a permutation of cycle structure
<span class="math notranslate nohighlight">\(\rho\)</span> the symmetric function <code class="docutils literal notranslate"><span class="pre">self</span></code> is evaluated at the
eigenvalues of a permutation of cycle structure <span class="math notranslate nohighlight">\(\rho\)</span>.  The
Frobenius image is then defined as
<span class="math notranslate nohighlight">\(\sum_{\rho \vdash n} f[ \Xi_\rho ] p_\rho/z_\rho\)</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.eval_at_permutation_roots" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.eval_at_permutation_roots"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eval_at_permutation_roots()</span></code></a></p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a non-negative integer to interpret <code class="docutils literal notranslate"><span class="pre">self</span></code> as
a character of <span class="math notranslate nohighlight">\(GL_n\)</span></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>a symmetric function of degree <code class="docutils literal notranslate"><span class="pre">n</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">s[3, 1, 1] + s[4, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">s[2, 2, 1] + 2*s[3, 1, 1] + 2*s[3, 2] + 3*s[4, 1] + s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">s[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">s[2, 2] + 2*s[3, 1] + 2*s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">2*s[2, 2, 1] + s[3, 1, 1] + 4*s[3, 2] + 3*s[4, 1] + 2*s[5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.degree">
<code class="sig-name descname">degree</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degree of <code class="docutils literal notranslate"><span class="pre">self</span></code> (which is defined to be <span class="math notranslate nohighlight">\(0\)</span>
for the zero element).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.derivative_with_respect_to_p1">
<code class="sig-name descname">derivative_with_respect_to_p1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.derivative_with_respect_to_p1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the symmetric function obtained by taking the derivative of
<code class="docutils literal notranslate"><span class="pre">self</span></code> with respect to the power-sum symmetric function <span class="math notranslate nohighlight">\(p_1\)</span>
when the expansion of <code class="docutils literal notranslate"><span class="pre">self</span></code> in the power-sum basis is considered
as a polynomial in <span class="math notranslate nohighlight">\(p_k\)</span>’s (with <span class="math notranslate nohighlight">\(k \geq 1\)</span>).</p>
<p>This is the same as skewing <code class="docutils literal notranslate"><span class="pre">self</span></code> by the first power-sum symmetric
function <span class="math notranslate nohighlight">\(p_1\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – (default: 1) nonnegative integer which determines
which power of the derivative is taken</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">3*p[1, 1]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">3*p[1, 1]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">6*p[1]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">6*p[]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">s[2]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">s[1, 1] + s[2]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">s[1, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="go">s[]</span>
</pre></div>
</div>
<p>Let us check that taking the derivative with respect to <code class="docutils literal notranslate"><span class="pre">p[1]</span></code>
is equivalent to skewing by <code class="docutils literal notranslate"><span class="pre">p[1]</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p1</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">derivative_with_respect_to_p1</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.eval_at_permutation_roots">
<code class="sig-name descname">eval_at_permutation_roots</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rho</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.eval_at_permutation_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate at eigenvalues of a permutation matrix.</p>
<p>Evaluate a symmetric function at the eigenvalues of a permutation
matrix whose cycle structure is <code class="docutils literal notranslate"><span class="pre">rho</span></code>.  This computation is
computed by coercing to the power sum basis where the value may
be computed on the generators.</p>
<p>This function evaluates an element at the roots of unity</p>
<div class="math notranslate nohighlight">
\[\Xi_{\rho_1},\Xi_{\rho_2},\ldots,\Xi_{\rho_\ell}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\Xi_{m} = 1,\zeta_m,\zeta_m^2,\ldots,\zeta_m^{m-1}\]</div>
<p>and <span class="math notranslate nohighlight">\(\zeta_m\)</span> is an <span class="math notranslate nohighlight">\(m\)</span> root of unity.
These roots of unity represent the eigenvalues of permutation
matrix with cycle structure <span class="math notranslate nohighlight">\(\rho\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rho</span></code> – a partition or a list of non-negative integers</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>an element of the base ring</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">eval_at_permutation_roots</span><span class="p">([</span><span class="mi">6</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">eval_at_permutation_roots</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">eval_at_permutation_roots</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">eval_at_permutation_roots</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">eval_at_permutation_roots</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">175</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">eval_at_permutation_roots</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.expand">
<code class="sig-name descname">expand</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">alphabet</span><span class="o">=</span><span class="default_value">'x'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand the symmetric function <code class="docutils literal notranslate"><span class="pre">self</span></code> as a symmetric polynomial
in <code class="docutils literal notranslate"><span class="pre">n</span></code> variables.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a nonnegative integer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alphabet</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'x'</span></code>) a variable for the expansion</p></li>
</ul>
<p>OUTPUT:</p>
<p>A monomial expansion of <code class="docutils literal notranslate"><span class="pre">self</span></code> in the <span class="math notranslate nohighlight">\(n\)</span> variables
labelled <code class="docutils literal notranslate"><span class="pre">x0</span></code>, <code class="docutils literal notranslate"><span class="pre">x1</span></code>, …, <code class="docutils literal notranslate"><span class="pre">x{n-1}</span></code> (or just <code class="docutils literal notranslate"><span class="pre">x</span></code>
if <span class="math notranslate nohighlight">\(n = 1\)</span>), where <code class="docutils literal notranslate"><span class="pre">x</span></code> is <code class="docutils literal notranslate"><span class="pre">alphabet</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">jack</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">J</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">J</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">4*x0^2*x1 + 4*x0*x1^2 + 4*x0^2*x2 + 6*x0*x1*x2 + 4*x1^2*x2 + 4*x0*x2^2 + 4*x1*x2^2</span>
<span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">J</span><span class="p">([</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">J</span><span class="p">([]))</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.exponential_specialization">
<code class="sig-name descname">exponential_specialization</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">q</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.exponential_specialization" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the exponential specialization of a
symmetric function (when <span class="math notranslate nohighlight">\(q = 1\)</span>), or the
<span class="math notranslate nohighlight">\(q\)</span>-exponential specialization (when <span class="math notranslate nohighlight">\(q \neq 1\)</span>).</p>
<p>The <em>exponential specialization</em> <span class="math notranslate nohighlight">\(ex\)</span> at <span class="math notranslate nohighlight">\(t\)</span> is a
<span class="math notranslate nohighlight">\(K\)</span>-algebra homomorphism from the <span class="math notranslate nohighlight">\(K\)</span>-algebra of
symmetric functions to another <span class="math notranslate nohighlight">\(K\)</span>-algebra <span class="math notranslate nohighlight">\(R\)</span>.
It is defined whenever the base ring <span class="math notranslate nohighlight">\(K\)</span> is a
<span class="math notranslate nohighlight">\(\QQ\)</span>-algebra and <span class="math notranslate nohighlight">\(t\)</span> is an element of <span class="math notranslate nohighlight">\(R\)</span>.
The easiest way to define it is by specifying its
values on the powersum symmetric functions to be
<span class="math notranslate nohighlight">\(p_1 = t\)</span> and <span class="math notranslate nohighlight">\(p_n = 0\)</span> for <span class="math notranslate nohighlight">\(n &gt; 1\)</span>.
Equivalently, on the homogeneous functions it is
given by <span class="math notranslate nohighlight">\(ex(h_n) = t^n / n!\)</span>; see Proposition 7.8.4 of
<a class="reference internal" href="../../../../references/index.html#enumcomb2" id="id3"><span>[EnumComb2]</span></a>.</p>
<p>By analogy, the <span class="math notranslate nohighlight">\(q\)</span>-exponential specialization is a
<span class="math notranslate nohighlight">\(K\)</span>-algebra homomorphism from the <span class="math notranslate nohighlight">\(K\)</span>-algebra of
symmetric functions to another <span class="math notranslate nohighlight">\(K\)</span>-algebra <span class="math notranslate nohighlight">\(R\)</span> that
depends on two elements <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(q\)</span> of <span class="math notranslate nohighlight">\(R\)</span> for which
the elements <span class="math notranslate nohighlight">\(1 - q^i\)</span> for all positive integers <span class="math notranslate nohighlight">\(i\)</span>
are invertible.
It can be defined by specifying its values on the
complete homogeneous symmetric functions to be</p>
<div class="math notranslate nohighlight">
\[ex_q(h_n) = t^n / [n]_q!,\]</div>
<p>where <span class="math notranslate nohighlight">\([n]_q!\)</span> is the <span class="math notranslate nohighlight">\(q\)</span>-factorial.  Equivalently, for
<span class="math notranslate nohighlight">\(q \neq 1\)</span> and a homogeneous symmetric function <span class="math notranslate nohighlight">\(f\)</span> of
degree <span class="math notranslate nohighlight">\(n\)</span>, we have</p>
<div class="math notranslate nohighlight">
\[ex_q(f) = (1-q)^n t^n ps_q(f),\]</div>
<p>where <span class="math notranslate nohighlight">\(ps_q(f)\)</span> is the stable principal specialization of <span class="math notranslate nohighlight">\(f\)</span>
(see <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.principal_specialization" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.principal_specialization"><code class="xref py py-meth docutils literal notranslate"><span class="pre">principal_specialization()</span></code></a>).
(See (7.29) in <a class="reference internal" href="../../../../references/index.html#enumcomb2" id="id4"><span>[EnumComb2]</span></a>.)</p>
<p>The limit of <span class="math notranslate nohighlight">\(ex_q\)</span> as <span class="math notranslate nohighlight">\(q \to 1\)</span> is <span class="math notranslate nohighlight">\(ex\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) – the value to use for <span class="math notranslate nohighlight">\(t\)</span>;
the default is to create a ring of polynomials in <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> (default: <span class="math notranslate nohighlight">\(1\)</span>) – the value to use for <span class="math notranslate nohighlight">\(q\)</span>.  If
<code class="docutils literal notranslate"><span class="pre">q</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, then a ring (or fraction field) of
polynomials in <code class="docutils literal notranslate"><span class="pre">q</span></code> is created.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">exponential_specialization</span><span class="p">()</span>
<span class="go">1/2*t^2</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">exponential_specialization</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1/2*t^2</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">exponential_specialization</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="go">(q/(q + 1))*t^2</span>
<span class="gp">sage: </span><span class="n">Qq</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s2">&quot;q&quot;</span><span class="p">);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Qq</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">exponential_specialization</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">)</span>
<span class="go">(q/(q + 1))*t^2</span>
<span class="gp">sage: </span><span class="n">Qt</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s2">&quot;t&quot;</span><span class="p">);</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Qt</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">exponential_specialization</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
<span class="go">1/2*t^2</span>
<span class="gp">sage: </span><span class="n">Qqt</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="s2">&quot;t&quot;</span><span class="p">]);</span> <span class="n">q</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Qqt</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">exponential_specialization</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
<span class="go">q*t^2/(q + 1)</span>

<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">homogeneous_degree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s2">&quot;q t&quot;</span><span class="p">)</span>
<span class="go">(q, t)</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">principal_specialization</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">^</span><span class="n">d</span><span class="o">*</span><span class="n">t</span><span class="o">^</span><span class="n">d</span><span class="p">))</span>
<span class="go">t^3/((q^2 + q + 1)*(q + 1))</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">exponential_specialization</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">))</span>
<span class="go">t^3/((q^2 + q + 1)*(q + 1))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius">
<code class="sig-name descname">frobenius</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the symmetric function <code class="docutils literal notranslate"><span class="pre">self</span></code> under the
<span class="math notranslate nohighlight">\(n\)</span>-th Frobenius operator.</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Frobenius operator <span class="math notranslate nohighlight">\(\mathbf{f}_n\)</span> is defined to be the
map from the ring of symmetric functions to itself that sends
every symmetric function <span class="math notranslate nohighlight">\(P(x_1, x_2, x_3, \ldots)\)</span> to
<span class="math notranslate nohighlight">\(P(x_1^n, x_2^n, x_3^n, \ldots)\)</span>. This operator <span class="math notranslate nohighlight">\(\mathbf{f}_n\)</span>
is a Hopf algebra endomorphism, and satisfies</p>
<div class="math notranslate nohighlight">
\[\mathbf{f}_n m_{(\lambda_1, \lambda_2, \lambda_3, \ldots)} =
m_{(n\lambda_1, n\lambda_2, n\lambda_3, \ldots)}\]</div>
<p>for every partition <span class="math notranslate nohighlight">\((\lambda_1, \lambda_2, \lambda_3, \ldots)\)</span>
(where <span class="math notranslate nohighlight">\(m\)</span> means the monomial basis). Moreover,
<span class="math notranslate nohighlight">\(\mathbf{f}_n (p_r) = p_{nr}\)</span> for every positive integer <span class="math notranslate nohighlight">\(r\)</span> (where
<span class="math notranslate nohighlight">\(p_k\)</span> denotes the <span class="math notranslate nohighlight">\(k\)</span>-th powersum symmetric function).</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Frobenius operator is also called the <span class="math notranslate nohighlight">\(n\)</span>-th
Frobenius endomorphism. It is not related to the Frobenius map
which connects the ring of symmetric functions with the
representation theory of the symmetric group.</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Frobenius operator is also the <span class="math notranslate nohighlight">\(n\)</span>-th Adams operator
of the <span class="math notranslate nohighlight">\(\Lambda\)</span>-ring of symmetric functions over the integers.</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Frobenius operator can also be described via plethysm:
Every symmetric function <span class="math notranslate nohighlight">\(P\)</span> satisfies
<span class="math notranslate nohighlight">\(\mathbf{f}_n(P) = p_n \circ P = P \circ p_n\)</span>,
where <span class="math notranslate nohighlight">\(p_n\)</span> is the <span class="math notranslate nohighlight">\(n\)</span>-th powersum symmetric function, and <span class="math notranslate nohighlight">\(\circ\)</span>
denotes (outer) plethysm.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a positive integer</p></li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the <span class="math notranslate nohighlight">\(n\)</span>-th Frobenius operator (on the ring of
symmetric functions) to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-s[3, 3] + s[4, 2] - s[5, 1] + s[6]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">m[12, 6, 3]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">p[12, 6, 3]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">h[4, 4] - 2*h[5, 3] + 2*h[6, 2] - 2*h[7, 1] + 2*h[8]</span>
</pre></div>
</div>
<p>The Frobenius endomorphisms are multiplicative:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># long time</span>
<span class="gp">....: </span>          <span class="o">==</span> <span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">....: </span>          <span class="o">==</span> <span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">....: </span>          <span class="o">==</span> <span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Being Hopf algebra endomorphisms, the Frobenius operators
commute with the antipode:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Testing the <span class="math notranslate nohighlight">\(\mathbf{f}_n(P) = p_n \circ P = P \circ p_n\)</span>
equality (over <span class="math notranslate nohighlight">\(\QQ\)</span>, since plethysm is currently not
defined over <span class="math notranslate nohighlight">\(\ZZ\)</span> in Sage):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">plethysm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)))</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>By Exercise 7.61 in Stanley’s EC2 <a class="reference internal" href="sf.html#sta" id="id5"><span>[STA]</span></a> (see the errata on his
website), <span class="math notranslate nohighlight">\(\mathbf{f}_n(h_m)\)</span> is a linear combination of
Schur polynomials (of straight shapes) using coefficients <span class="math notranslate nohighlight">\(0\)</span>,
<span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(-1\)</span> only; moreover, all partitions whose Schur
polynomials occur with coefficient <span class="math notranslate nohighlight">\(\neq 0\)</span> in this
combination have empty <span class="math notranslate nohighlight">\(n\)</span>-cores. Let us check this on
examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="p">(</span><span class="n">coeff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">....: </span>               <span class="ow">and</span> <span class="n">lam</span><span class="o">.</span><span class="n">core</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">Partition</span><span class="p">([])</span>
<span class="gp">....: </span>               <span class="k">for</span> <span class="n">lam</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">s</span><span class="p">([</span><span class="n">m</span><span class="p">])</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plethysm()</span></code></a></p>
</div>
<div class="admonition-todo admonition" id="id7">
<p class="admonition-title">Todo</p>
<p>This method is fast on the monomial and the powersum
bases, while all other bases get converted to the
monomial basis. For most bases, this is probably the
quickest way to do, but at least the Schur basis should
have a better option. (Quoting from Stanley’s EC2 <a class="reference internal" href="sf.html#sta" id="id6"><span>[STA]</span></a>:
“D. G. Duncan, J. London Math. Soc. 27 (1952), 235-236,
or Y. M. Chen, A. M. Garsia, and J. B. Remmel, Contemp.
Math. 34 (1984), 109-153”.)</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.hl_creation_operator">
<code class="sig-name descname">hl_creation_operator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nu</span></em>, <em class="sig-param"><span class="n">t</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.hl_creation_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the vertex operator that generalizes Jing’s operator.</p>
<p>It is a linear operator that raises the degree by
<span class="math notranslate nohighlight">\(|\nu|\)</span>. This creation operator is a t-analogue of
multiplication by <code class="docutils literal notranslate"><span class="pre">s(nu)</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Proposition 5 in <a class="reference internal" href="#sz2001" id="id8"><span>[SZ2001]</span></a>.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nu</span></code> – a partition or a list of integers</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>, in which case <code class="docutils literal notranslate"><span class="pre">t</span></code> is used) an element
of the base ring</p></li>
</ul>
<p>REFERENCES:</p>
<dl class="citation">
<dt class="label" id="sz2001"><span class="brackets"><a class="fn-backref" href="#id8">SZ2001</a></span></dt>
<dd><p>M. Shimozono, M. Zabrocki,
Hall-Littlewood vertex operators and generalized Kostka polynomials.
Adv. Math. 158 (2001), no. 1, 66-85.</p>
</dd>
</dl>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[3, 2, 2] + t*s[3, 3, 1] + t*s[4, 2, 1] + t^2*s[4, 3] + t^2*s[5, 2]</span>

<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">HLQp</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">Qp</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">HLQp</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">HLQp[3, 2, 2]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">t*s[2, 2, 2, 1] + t^2*s[3, 2, 1, 1] + t^2*s[3, 2, 2] + t^3*s[3, 3, 1] + t^3*s[4, 2, 1] + t^4*s[4, 3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">(t^2-t)*s[2, 2, 2, 2, 1] + t^3*s[3, 2, 2, 1, 1]</span>
<span class="go"> + (t^3-t^2)*s[3, 2, 2, 2] + t^3*s[3, 3, 1, 1, 1]</span>
<span class="go"> + t^4*s[3, 3, 2, 1] + t^3*s[4, 2, 1, 1, 1] + t^4*s[4, 2, 2, 1]</span>
<span class="go"> + 2*t^4*s[4, 3, 1, 1] + t^5*s[4, 3, 2] + t^5*s[4, 4, 1]</span>
<span class="go"> + t^4*s[5, 2, 1, 1] + t^5*s[5, 3, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="go">(-t^2+t)*s[1, 1, 1] + (-t^2+1)*s[2, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: nu must be a list of integers</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">hl_creation_operator</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">s[3, 2] + t*s[4, 1] + t^2*s[5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_plethysm">
<code class="sig-name descname">inner_plethysm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_plethysm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inner plethysm of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>Whenever <span class="math notranslate nohighlight">\(R\)</span> is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra, and <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are two
symmetric functions over <span class="math notranslate nohighlight">\(R\)</span> such that the constant term of <span class="math notranslate nohighlight">\(f\)</span>
is zero, the inner plethysm of <span class="math notranslate nohighlight">\(f\)</span> with <span class="math notranslate nohighlight">\(g\)</span> is a symmetric
function over <span class="math notranslate nohighlight">\(R\)</span>, and the degree of this symmetric function is
the same as the degree of <span class="math notranslate nohighlight">\(g\)</span>. We will denote the inner plethysm
of <span class="math notranslate nohighlight">\(f\)</span> with <span class="math notranslate nohighlight">\(g\)</span> by <span class="math notranslate nohighlight">\(f \{ g \}\)</span> (in contrast to the notation of
outer plethysm which is generally denoted <span class="math notranslate nohighlight">\(f [ g ]\)</span>); in Sage
syntax, it is <code class="docutils literal notranslate"><span class="pre">f.inner_plethysm(g)</span></code>.</p>
<p>First we describe the axiomatic definition of the operation; see
below for a representation-theoretic interpretation.
In the following equations, we denote the outer product
(i.e., the standard product on the ring of symmetric functions,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">product()</span></code>)
by <span class="math notranslate nohighlight">\(\cdot\)</span> and the Kronecker product (<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itensor()</span></code></a>) by <span class="math notranslate nohighlight">\(\ast\)</span>).</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}(f + g) \{ h \} = f \{ h \} + g \{ h \}\\(f \cdot g) \{ h \} = (f \{ h \}) \ast (g \{ h \})\\p_k \{ f + g \} = p_k \{ f \} + p_k \{ g \}\end{aligned}\end{align} \]</div>
<p>where <span class="math notranslate nohighlight">\(p_k\)</span> is the <span class="math notranslate nohighlight">\(k\)</span>-th power-sum symmetric function for every
<span class="math notranslate nohighlight">\(k &gt; 0\)</span>.</p>
<p>Let <span class="math notranslate nohighlight">\(\sigma\)</span> be a permutation of cycle type <span class="math notranslate nohighlight">\(\mu\)</span> and let <span class="math notranslate nohighlight">\(\mu^k\)</span>
be the cycle type of <span class="math notranslate nohighlight">\(\sigma^k\)</span>. Then,</p>
<div class="math notranslate nohighlight">
\[p_k \{ p_\mu/z_\mu \} = \sum_{\nu : \nu^k = \mu } p_{\nu}/z_{\nu}\]</div>
<p>Since <span class="math notranslate nohighlight">\((p_\mu/z_\mu)_{\mu}\)</span> is a basis for the symmetric
functions, these four formulas define the symmetric function
operation <span class="math notranslate nohighlight">\(f \{ g \}\)</span> for any symmetric functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>
(where <span class="math notranslate nohighlight">\(f\)</span> has constant term <span class="math notranslate nohighlight">\(0\)</span>) by expanding <span class="math notranslate nohighlight">\(f\)</span> in the
power sum basis and <span class="math notranslate nohighlight">\(g\)</span> in the dual basis <span class="math notranslate nohighlight">\(p_\mu/z_\mu\)</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itensor()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">partition_power()</span></code>,
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plethysm()</span></code></a></p>
</div>
<p>This operation admits a representation-theoretic interpretation
in the case where <span class="math notranslate nohighlight">\(f\)</span> is a Schur function <span class="math notranslate nohighlight">\(s_\lambda\)</span> and
<span class="math notranslate nohighlight">\(g\)</span> is a homogeneous degree <span class="math notranslate nohighlight">\(n\)</span> symmetric function with
nonnegative integral coefficients in the Schur basis.
The symmetric function <span class="math notranslate nohighlight">\(f \{ g \}\)</span> is the Frobenius
image of the <span class="math notranslate nohighlight">\(S_n\)</span>-representation constructed as follows.</p>
<p>The assumptions on <span class="math notranslate nohighlight">\(g\)</span> imply that <span class="math notranslate nohighlight">\(g\)</span> is the Frobenius image of a
representation <span class="math notranslate nohighlight">\(\rho\)</span> of the symmetric group <span class="math notranslate nohighlight">\(S_n\)</span>:</p>
<div class="math notranslate nohighlight">
\[\rho : S_n \to GL_N.\]</div>
<p>If the degree <span class="math notranslate nohighlight">\(N\)</span> of this representation is greater than or equal
to the number of parts of <span class="math notranslate nohighlight">\(\lambda\)</span>, then <span class="math notranslate nohighlight">\(f\)</span>, which denotes <span class="math notranslate nohighlight">\(s_\lambda\)</span>,
corresponds to the character of some irreducible <span class="math notranslate nohighlight">\(GL_N\)</span>-representation, say</p>
<div class="math notranslate nohighlight">
\[\sigma : GL_N \to GL_M.\]</div>
<p>The composition <span class="math notranslate nohighlight">\(\sigma \circ \rho : S_n \to GL_M\)</span> is a representation
of <span class="math notranslate nohighlight">\(S_n\)</span> whose Frobenius image is precisely <span class="math notranslate nohighlight">\(f \{ g \}\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(N\)</span> is less than the number of parts of <span class="math notranslate nohighlight">\(\lambda\)</span>,
then <span class="math notranslate nohighlight">\(f \{ g \}\)</span> is <span class="math notranslate nohighlight">\(0\)</span> by definition.</p>
<p>When <span class="math notranslate nohighlight">\(f\)</span> is a symmetric function with constant term <span class="math notranslate nohighlight">\(\neq 0\)</span>, the
inner plethysm <span class="math notranslate nohighlight">\(f \{ g \}\)</span> isn’t well-defined in the ring of
symmetric functions. Indeed, it is not clear how to define
<span class="math notranslate nohighlight">\(1 \{ g \}\)</span>. The most sensible way to get around this probably is
defining it as the infinite sum <span class="math notranslate nohighlight">\(h_0 + h_1 + h_2 + \cdots\)</span> (where
<span class="math notranslate nohighlight">\(h_i\)</span> means the <span class="math notranslate nohighlight">\(i\)</span>-th complete homogeneous symmetric function)
in the completion of this ring with respect to its grading. This is
how <a class="reference internal" href="#schathi1994" id="id9"><span>[SchaThi1994]</span></a> defines <span class="math notranslate nohighlight">\(1 \{ g \}\)</span>. The present method,
however, sets it to be the sum of <span class="math notranslate nohighlight">\(h_i\)</span> over all <span class="math notranslate nohighlight">\(i\)</span> for which the
<span class="math notranslate nohighlight">\(i\)</span>-th homogeneous component of <span class="math notranslate nohighlight">\(g\)</span> is nonzero. This is rather a
hack than a reasonable definition. Use with caution!</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If a symmetric function <span class="math notranslate nohighlight">\(g\)</span> is written in the form
<span class="math notranslate nohighlight">\(g = g_0 + g_1 + g_2 + \cdots\)</span> with each <span class="math notranslate nohighlight">\(g_i\)</span> homogeneous
of degree <span class="math notranslate nohighlight">\(i\)</span>, then
<span class="math notranslate nohighlight">\(f \{ g \} = f \{ g_0 \} + f \{ g_1 \} + f \{ g_2 \} + \cdots\)</span>
for every <span class="math notranslate nohighlight">\(f\)</span> with constant term <span class="math notranslate nohighlight">\(0\)</span>. But in general, inner
plethysm is not linear in the second variable.</p>
</div>
<p>REFERENCES:</p>
<dl class="citation">
<dt class="label" id="king"><span class="brackets">King</span></dt>
<dd><p>King, R. Branching rules for <span class="math notranslate nohighlight">\(GL_m \supset \Sigma_n\)</span>
and the evaluation of inner plethysms.
J. Math. Phys. 15, 258 (1974) <a class="reference external" href="https://doi.org/10.1063/1.1666632">doi:10.1063/1.1666632</a></p>
</dd>
<dt class="label" id="schathi1994"><span class="brackets"><a class="fn-backref" href="#id9">SchaThi1994</a></span></dt>
<dd><p>Thomas Scharf, Jean-Yves Thibon.
<em>A Hopf-algebra approach to inner plethysm</em>.
Advances in Mathematics 104 (1994), pp. 30-58.
<a class="reference external" href="ftp://ftp.mathe2.uni-bayreuth.de/axel/papers/scharf:a_hopf_algebra_approach_to_inner_plethysm.ps.gz">ftp://ftp.mathe2.uni-bayreuth.de/axel/papers/scharf:a_hopf_algebra_approach_to_inner_plethysm.ps.gz</a></p>
</dd>
</dl>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the same
base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>an element of symmetric functions in the parent of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">power</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[2, 1] + s[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">inner_tensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1] + s[2, 1] + s[3]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">s[1, 1, 1] + s[2, 1] + 4*s[2, 1, 1] + 4*s[2, 2] + s[3] + 4*s[3, 1] + 4*s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">)</span>
<span class="go">s[1, 1, 1] + s[2, 1] + 4*s[2, 1, 1] + 4*s[2, 2] + s[3] + 4*s[3, 1] + 4*s[4]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="p">([])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">s[2] + s[3]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">s</span><span class="p">([])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">la</span><span class="p">))</span> <span class="k">for</span> <span class="n">la</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
<span class="go">[s[4], s[4], s[4], s[4], s[4]]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">([]))</span>
<span class="go">s[]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[3]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">p[1, 1, 1] + 2*p[3]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">24</span><span class="p">)</span>
<span class="go">1/24*p[1, 1, 1, 1] + 1/4*p[2, 1, 1] + 1/8*p[2, 2] + 1/4*p[4]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">6*p[1, 1, 1] + 12*p[3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor">
<code class="sig-name descname">inner_tensor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the internal (tensor) product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> in the
basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The internal tensor product can be defined as the linear extension
of the definition on power sums
<span class="math notranslate nohighlight">\(p_{\lambda} \ast p_{\mu} = \delta_{\lambda,\mu} z_{\lambda}
p_{\lambda}\)</span>, where <span class="math notranslate nohighlight">\(z_{\lambda} = (1^{r_1} r_1!) (2^{r_2} r_2!)
\cdots\)</span> for <span class="math notranslate nohighlight">\(\lambda = (1^{r_1} 2^{r_2} \cdots )\)</span> and where <span class="math notranslate nohighlight">\(\ast\)</span>
denotes the internal tensor product.
The internal tensor product is also known as the Kronecker product,
or as the second multiplication on the ring of symmetric functions.</p>
<p>Note that the internal product of any two homogeneous symmetric
functions of equal degrees is a homogeneous symmetric function of the
same degree. On the other hand, the internal product of two homogeneous
symmetric functions of distinct degrees is <span class="math notranslate nohighlight">\(0\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The internal product is sometimes referred to as “inner product”
in the literature, but unfortunately this name is shared by a
different operation, namely the Hall inner product
(see <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scalar()</span></code></a>).</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the
same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the internal product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code> (an element of the
ring of symmetric functions in the same basis as <code class="docutils literal notranslate"><span class="pre">self</span></code>)</p></li>
</ul>
<p>The methods <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itensor()</span></code></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product()</span></code></a>,
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kronecker_product()</span></code></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">inner_tensor()</span></code></a> are all
synonyms.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">s[2, 1]</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">s[1, 1, 1, 1, 1, 1] + 2*s[2, 1, 1, 1, 1] + 3*s[2, 2, 1, 1] + 2*s[2, 2, 2]</span>
<span class="go"> + 4*s[3, 1, 1, 1] + 5*s[3, 2, 1] + 2*s[3, 3] + 4*s[4, 1, 1]</span>
<span class="go"> + 3*s[4, 2] + 2*s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>There are few quantitative results pertaining to Kronecker products
in general, which makes their computation so difficult. Let us test
a few of them in different bases.</p>
<p>The Kronecker product of any homogeneous symmetric function <span class="math notranslate nohighlight">\(f\)</span> of
degree <span class="math notranslate nohighlight">\(n\)</span> with the <span class="math notranslate nohighlight">\(n\)</span>-th complete homogeneous symmetric function
<code class="docutils literal notranslate"><span class="pre">h[n]</span></code> (a.k.a. <code class="docutils literal notranslate"><span class="pre">s[n]</span></code>) is <span class="math notranslate nohighlight">\(f\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product of a Schur function <span class="math notranslate nohighlight">\(s_{\lambda}\)</span> with the <span class="math notranslate nohighlight">\(n\)</span>-th
elementary symmetric function <code class="docutils literal notranslate"><span class="pre">e[n]</span></code>, where <span class="math notranslate nohighlight">\(n = \left| \lambda
\right|\)</span>, is <span class="math notranslate nohighlight">\(s_{\lambda'}\)</span> (where <span class="math notranslate nohighlight">\(\lambda'\)</span> is the conjugate
partition of <span class="math notranslate nohighlight">\(\lambda\)</span>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product is commutative:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">mq</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">mh</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">==</span> <span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>   <span class="c1"># long time</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us check (on examples) Proposition 5.2 of Gelfand, Krob, Lascoux, Leclerc,
Retakh, Thibon, “Noncommutative symmetric functions”, <a class="reference external" href="https://arxiv.org/abs/hep-th/9407124">arXiv hep-th/9407124</a>, for
<span class="math notranslate nohighlight">\(r = 2\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_copr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>  <span class="c1"># computes \mu ((u \otimes v) * \Delta(w)) with</span>
<span class="gp">....: </span>                           <span class="c1"># * meaning Kronecker product and \mu meaning the</span>
<span class="gp">....: </span>                           <span class="c1"># usual multiplication.</span>
<span class="gp">....: </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">partition_pair</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">w</span><span class="o">.</span><span class="n">coproduct</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">result</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">result</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_copr</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>   <span class="c1"># long time</span>
<span class="gp">....: </span>               <span class="o">==</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
<span class="gp">....: </span>               <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Some examples from Briand, Orellana, Rosas, “The stability of the Kronecker
products of Schur functions.” <a class="reference external" href="https://arxiv.org/abs/0907.4652">arXiv 0907.4652</a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[1, 1, 1, 1] + s[2, 2] + s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 1, 1, 1] + s[2, 2, 1] + s[3, 1, 1] + s[3, 2] + s[4, 1] + s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 2, 2] + s[3, 1, 1, 1] + 2*s[3, 2, 1] + s[4, 1, 1] + 2*s[4, 2] + s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>An example from p. 220 of Thibon, “Hopf algebras of symmetric functions
and tensor products of symmetric group representations”, International
Journal of Algebra and Computation, 1991:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQbar</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1] + s[2, 1] + s[3]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The currently existing implementation of this function is
technically unsatisfactory. It distinguishes the case when the
base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra (in which case the Kronecker product
can be easily computed using the power sum basis) from the case
where it isn’t. In the latter, it does a computation using
universal coefficients, again distinguishing the case when it is
able to compute the “corresponding” basis of the symmetric function
algebra over <span class="math notranslate nohighlight">\(\QQ\)</span> (using the <code class="docutils literal notranslate"><span class="pre">corresponding_basis_over</span></code> hack)
from the case when it isn’t (in which case it transforms everything
into the Schur basis, which is slow).</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_coproduct">
<code class="sig-name descname">internal_coproduct</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_coproduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inner coproduct of <code class="docutils literal notranslate"><span class="pre">self</span></code> in the basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The inner coproduct (also known as the Kronecker coproduct, as the
internal coproduct, or as the second comultiplication on the ring of
symmetric functions) is a ring homomorphism <span class="math notranslate nohighlight">\(\Delta^\times\)</span> from the
ring of symmetric functions to the tensor product (over the base
ring) of this ring with itself. It is uniquely characterized by the
formula</p>
<div class="math notranslate nohighlight">
\[\Delta^{\times}(h_n) = \sum_{\lambda \vdash n} s_{\lambda}
\otimes s_{\lambda} = \sum_{\lambda \vdash n} h_{\lambda} \otimes
m_{\lambda} = \sum_{\lambda \vdash n} m_{\lambda} \otimes
h_{\lambda},\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda \vdash n\)</span> means <span class="math notranslate nohighlight">\(\lambda\)</span> is a partition of <span class="math notranslate nohighlight">\(n\)</span>, and
<span class="math notranslate nohighlight">\(n\)</span> is any nonnegative integer. It also satisfies</p>
<div class="math notranslate nohighlight">
\[\Delta^\times (p_n) = p_n \otimes p_n\]</div>
<p>for any positive integer <span class="math notranslate nohighlight">\(n\)</span>. If the base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra, it
also satisfies</p>
<div class="math notranslate nohighlight">
\[\Delta^{\times}(h_n) = \sum_{\lambda \vdash n} z_{\lambda}^{-1}
p_{\lambda} \otimes p_{\lambda},\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[z_{\lambda} = \prod_{i=1}^\infty i^{m_i(\lambda)} m_i(\lambda)!\]</div>
<p>with <span class="math notranslate nohighlight">\(m_i(\lambda)\)</span> meaning the number of appearances of <span class="math notranslate nohighlight">\(i\)</span>
in <span class="math notranslate nohighlight">\(\lambda\)</span> (see <a class="reference internal" href="#sage.combinat.sf.sfa.zee" title="sage.combinat.sf.sfa.zee"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zee()</span></code></a>).</p>
<p>The method <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_coproduct" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_coproduct"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kronecker_coproduct()</span></code></a> is a synonym of
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_coproduct" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_coproduct"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_coproduct()</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="go">s[1, 1, 1] # s[2, 1] + s[2, 1] # s[1, 1, 1] + s[2, 1] # s[2, 1] + s[2, 1] # s[3] + s[3] # s[2, 1]</span>

<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="go">e[1, 1] # e[2] + e[2] # e[1, 1] - 2*e[2] # e[2]</span>
</pre></div>
</div>
<p>The internal coproduct is adjoint to the internal product with respect
to the Hall inner product: Any three symmetric functions <span class="math notranslate nohighlight">\(f\)</span>, <span class="math notranslate nohighlight">\(g\)</span> and
<span class="math notranslate nohighlight">\(h\)</span> satisfy <span class="math notranslate nohighlight">\(\langle f * g, h \rangle = \sum_i \langle f, h^{\prime}_i
\rangle \langle g, h^{\prime\prime}_i \rangle\)</span>, where we write
<span class="math notranslate nohighlight">\(\Delta^{\times}(h)\)</span> as <span class="math notranslate nohighlight">\(\sum_i h^{\prime}_i \otimes
h^{\prime\prime}_i\)</span>. Let us check this in degree <span class="math notranslate nohighlight">\(4\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_incopr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>  <span class="c1"># computes \sum_i \left&lt; f, h&#39;_i \right&gt; \left&lt; g, h&#39;&#39;_i \right&gt;</span>
<span class="gp">....: </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">partition_pair</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">result</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">h</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">h</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">result</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_incopr</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>  <span class="c1"># long time (10s on sage.math, 2013)</span>
<span class="gp">....: </span>               <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us check the formulas for <span class="math notranslate nohighlight">\(\Delta^{\times}(h_n)\)</span> and
<span class="math notranslate nohighlight">\(\Delta^{\times}(p_n)\)</span> given in the description of this method:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">h</span><span class="p">([</span><span class="n">n</span><span class="p">]))</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">tensor</span><span class="p">([</span><span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">),</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)])</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">tensor</span><span class="p">([</span><span class="n">h</span><span class="p">(</span><span class="n">lam</span><span class="p">),</span> <span class="n">h</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">))])</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">h</span><span class="p">([</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">lam</span><span class="o">.</span><span class="n">conjugacy_class_size</span><span class="p">()</span> <span class="o">*</span> <span class="n">tensor</span><span class="p">([</span><span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)),</span> <span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">))])</span>
<span class="gp">....: </span>             <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product">
<code class="sig-name descname">internal_product</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the internal (tensor) product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> in the
basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The internal tensor product can be defined as the linear extension
of the definition on power sums
<span class="math notranslate nohighlight">\(p_{\lambda} \ast p_{\mu} = \delta_{\lambda,\mu} z_{\lambda}
p_{\lambda}\)</span>, where <span class="math notranslate nohighlight">\(z_{\lambda} = (1^{r_1} r_1!) (2^{r_2} r_2!)
\cdots\)</span> for <span class="math notranslate nohighlight">\(\lambda = (1^{r_1} 2^{r_2} \cdots )\)</span> and where <span class="math notranslate nohighlight">\(\ast\)</span>
denotes the internal tensor product.
The internal tensor product is also known as the Kronecker product,
or as the second multiplication on the ring of symmetric functions.</p>
<p>Note that the internal product of any two homogeneous symmetric
functions of equal degrees is a homogeneous symmetric function of the
same degree. On the other hand, the internal product of two homogeneous
symmetric functions of distinct degrees is <span class="math notranslate nohighlight">\(0\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The internal product is sometimes referred to as “inner product”
in the literature, but unfortunately this name is shared by a
different operation, namely the Hall inner product
(see <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scalar()</span></code></a>).</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the
same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the internal product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code> (an element of the
ring of symmetric functions in the same basis as <code class="docutils literal notranslate"><span class="pre">self</span></code>)</p></li>
</ul>
<p>The methods <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itensor()</span></code></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product()</span></code></a>,
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kronecker_product()</span></code></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">inner_tensor()</span></code></a> are all
synonyms.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">s[2, 1]</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">s[1, 1, 1, 1, 1, 1] + 2*s[2, 1, 1, 1, 1] + 3*s[2, 2, 1, 1] + 2*s[2, 2, 2]</span>
<span class="go"> + 4*s[3, 1, 1, 1] + 5*s[3, 2, 1] + 2*s[3, 3] + 4*s[4, 1, 1]</span>
<span class="go"> + 3*s[4, 2] + 2*s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>There are few quantitative results pertaining to Kronecker products
in general, which makes their computation so difficult. Let us test
a few of them in different bases.</p>
<p>The Kronecker product of any homogeneous symmetric function <span class="math notranslate nohighlight">\(f\)</span> of
degree <span class="math notranslate nohighlight">\(n\)</span> with the <span class="math notranslate nohighlight">\(n\)</span>-th complete homogeneous symmetric function
<code class="docutils literal notranslate"><span class="pre">h[n]</span></code> (a.k.a. <code class="docutils literal notranslate"><span class="pre">s[n]</span></code>) is <span class="math notranslate nohighlight">\(f\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product of a Schur function <span class="math notranslate nohighlight">\(s_{\lambda}\)</span> with the <span class="math notranslate nohighlight">\(n\)</span>-th
elementary symmetric function <code class="docutils literal notranslate"><span class="pre">e[n]</span></code>, where <span class="math notranslate nohighlight">\(n = \left| \lambda
\right|\)</span>, is <span class="math notranslate nohighlight">\(s_{\lambda'}\)</span> (where <span class="math notranslate nohighlight">\(\lambda'\)</span> is the conjugate
partition of <span class="math notranslate nohighlight">\(\lambda\)</span>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product is commutative:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">mq</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">mh</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">==</span> <span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>   <span class="c1"># long time</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us check (on examples) Proposition 5.2 of Gelfand, Krob, Lascoux, Leclerc,
Retakh, Thibon, “Noncommutative symmetric functions”, <a class="reference external" href="https://arxiv.org/abs/hep-th/9407124">arXiv hep-th/9407124</a>, for
<span class="math notranslate nohighlight">\(r = 2\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_copr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>  <span class="c1"># computes \mu ((u \otimes v) * \Delta(w)) with</span>
<span class="gp">....: </span>                           <span class="c1"># * meaning Kronecker product and \mu meaning the</span>
<span class="gp">....: </span>                           <span class="c1"># usual multiplication.</span>
<span class="gp">....: </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">partition_pair</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">w</span><span class="o">.</span><span class="n">coproduct</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">result</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">result</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_copr</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>   <span class="c1"># long time</span>
<span class="gp">....: </span>               <span class="o">==</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
<span class="gp">....: </span>               <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Some examples from Briand, Orellana, Rosas, “The stability of the Kronecker
products of Schur functions.” <a class="reference external" href="https://arxiv.org/abs/0907.4652">arXiv 0907.4652</a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[1, 1, 1, 1] + s[2, 2] + s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 1, 1, 1] + s[2, 2, 1] + s[3, 1, 1] + s[3, 2] + s[4, 1] + s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 2, 2] + s[3, 1, 1, 1] + 2*s[3, 2, 1] + s[4, 1, 1] + 2*s[4, 2] + s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>An example from p. 220 of Thibon, “Hopf algebras of symmetric functions
and tensor products of symmetric group representations”, International
Journal of Algebra and Computation, 1991:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQbar</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1] + s[2, 1] + s[3]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The currently existing implementation of this function is
technically unsatisfactory. It distinguishes the case when the
base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra (in which case the Kronecker product
can be easily computed using the power sum basis) from the case
where it isn’t. In the latter, it does a computation using
universal coefficients, again distinguishing the case when it is
able to compute the “corresponding” basis of the symmetric function
algebra over <span class="math notranslate nohighlight">\(\QQ\)</span> (using the <code class="docutils literal notranslate"><span class="pre">corresponding_basis_over</span></code> hack)
from the case when it isn’t (in which case it transforms everything
into the Schur basis, which is slow).</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.is_schur_positive">
<code class="sig-name descname">is_schur_positive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.is_schur_positive" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if and only if <code class="docutils literal notranslate"><span class="pre">self</span></code> is Schur positive.</p>
<p>If <span class="math notranslate nohighlight">\(s\)</span> is the space of Schur functions over <code class="docutils literal notranslate"><span class="pre">self</span></code>’s base ring, then
this is the same as <code class="docutils literal notranslate"><span class="pre">self._is_positive(s)</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">is_schur_positive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">is_schur_positive</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QQx</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQx</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">QQx</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">is_schur_positive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">is_schur_positive</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_schur_positive</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">is_schur_positive</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor">
<code class="sig-name descname">itensor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the internal (tensor) product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> in the
basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The internal tensor product can be defined as the linear extension
of the definition on power sums
<span class="math notranslate nohighlight">\(p_{\lambda} \ast p_{\mu} = \delta_{\lambda,\mu} z_{\lambda}
p_{\lambda}\)</span>, where <span class="math notranslate nohighlight">\(z_{\lambda} = (1^{r_1} r_1!) (2^{r_2} r_2!)
\cdots\)</span> for <span class="math notranslate nohighlight">\(\lambda = (1^{r_1} 2^{r_2} \cdots )\)</span> and where <span class="math notranslate nohighlight">\(\ast\)</span>
denotes the internal tensor product.
The internal tensor product is also known as the Kronecker product,
or as the second multiplication on the ring of symmetric functions.</p>
<p>Note that the internal product of any two homogeneous symmetric
functions of equal degrees is a homogeneous symmetric function of the
same degree. On the other hand, the internal product of two homogeneous
symmetric functions of distinct degrees is <span class="math notranslate nohighlight">\(0\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The internal product is sometimes referred to as “inner product”
in the literature, but unfortunately this name is shared by a
different operation, namely the Hall inner product
(see <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scalar()</span></code></a>).</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the
same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the internal product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code> (an element of the
ring of symmetric functions in the same basis as <code class="docutils literal notranslate"><span class="pre">self</span></code>)</p></li>
</ul>
<p>The methods <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itensor()</span></code></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product()</span></code></a>,
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kronecker_product()</span></code></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">inner_tensor()</span></code></a> are all
synonyms.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">s[2, 1]</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">s[1, 1, 1, 1, 1, 1] + 2*s[2, 1, 1, 1, 1] + 3*s[2, 2, 1, 1] + 2*s[2, 2, 2]</span>
<span class="go"> + 4*s[3, 1, 1, 1] + 5*s[3, 2, 1] + 2*s[3, 3] + 4*s[4, 1, 1]</span>
<span class="go"> + 3*s[4, 2] + 2*s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>There are few quantitative results pertaining to Kronecker products
in general, which makes their computation so difficult. Let us test
a few of them in different bases.</p>
<p>The Kronecker product of any homogeneous symmetric function <span class="math notranslate nohighlight">\(f\)</span> of
degree <span class="math notranslate nohighlight">\(n\)</span> with the <span class="math notranslate nohighlight">\(n\)</span>-th complete homogeneous symmetric function
<code class="docutils literal notranslate"><span class="pre">h[n]</span></code> (a.k.a. <code class="docutils literal notranslate"><span class="pre">s[n]</span></code>) is <span class="math notranslate nohighlight">\(f\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product of a Schur function <span class="math notranslate nohighlight">\(s_{\lambda}\)</span> with the <span class="math notranslate nohighlight">\(n\)</span>-th
elementary symmetric function <code class="docutils literal notranslate"><span class="pre">e[n]</span></code>, where <span class="math notranslate nohighlight">\(n = \left| \lambda
\right|\)</span>, is <span class="math notranslate nohighlight">\(s_{\lambda'}\)</span> (where <span class="math notranslate nohighlight">\(\lambda'\)</span> is the conjugate
partition of <span class="math notranslate nohighlight">\(\lambda\)</span>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product is commutative:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">mq</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">mh</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">==</span> <span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>   <span class="c1"># long time</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us check (on examples) Proposition 5.2 of Gelfand, Krob, Lascoux, Leclerc,
Retakh, Thibon, “Noncommutative symmetric functions”, <a class="reference external" href="https://arxiv.org/abs/hep-th/9407124">arXiv hep-th/9407124</a>, for
<span class="math notranslate nohighlight">\(r = 2\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_copr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>  <span class="c1"># computes \mu ((u \otimes v) * \Delta(w)) with</span>
<span class="gp">....: </span>                           <span class="c1"># * meaning Kronecker product and \mu meaning the</span>
<span class="gp">....: </span>                           <span class="c1"># usual multiplication.</span>
<span class="gp">....: </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">partition_pair</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">w</span><span class="o">.</span><span class="n">coproduct</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">result</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">result</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_copr</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>   <span class="c1"># long time</span>
<span class="gp">....: </span>               <span class="o">==</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
<span class="gp">....: </span>               <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Some examples from Briand, Orellana, Rosas, “The stability of the Kronecker
products of Schur functions.” <a class="reference external" href="https://arxiv.org/abs/0907.4652">arXiv 0907.4652</a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[1, 1, 1, 1] + s[2, 2] + s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 1, 1, 1] + s[2, 2, 1] + s[3, 1, 1] + s[3, 2] + s[4, 1] + s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 2, 2] + s[3, 1, 1, 1] + 2*s[3, 2, 1] + s[4, 1, 1] + 2*s[4, 2] + s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>An example from p. 220 of Thibon, “Hopf algebras of symmetric functions
and tensor products of symmetric group representations”, International
Journal of Algebra and Computation, 1991:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQbar</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1] + s[2, 1] + s[3]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The currently existing implementation of this function is
technically unsatisfactory. It distinguishes the case when the
base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra (in which case the Kronecker product
can be easily computed using the power sum basis) from the case
where it isn’t. In the latter, it does a computation using
universal coefficients, again distinguishing the case when it is
able to compute the “corresponding” basis of the symmetric function
algebra over <span class="math notranslate nohighlight">\(\QQ\)</span> (using the <code class="docutils literal notranslate"><span class="pre">corresponding_basis_over</span></code> hack)
from the case when it isn’t (in which case it transforms everything
into the Schur basis, which is slow).</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_coproduct">
<code class="sig-name descname">kronecker_coproduct</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_coproduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inner coproduct of <code class="docutils literal notranslate"><span class="pre">self</span></code> in the basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The inner coproduct (also known as the Kronecker coproduct, as the
internal coproduct, or as the second comultiplication on the ring of
symmetric functions) is a ring homomorphism <span class="math notranslate nohighlight">\(\Delta^\times\)</span> from the
ring of symmetric functions to the tensor product (over the base
ring) of this ring with itself. It is uniquely characterized by the
formula</p>
<div class="math notranslate nohighlight">
\[\Delta^{\times}(h_n) = \sum_{\lambda \vdash n} s_{\lambda}
\otimes s_{\lambda} = \sum_{\lambda \vdash n} h_{\lambda} \otimes
m_{\lambda} = \sum_{\lambda \vdash n} m_{\lambda} \otimes
h_{\lambda},\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda \vdash n\)</span> means <span class="math notranslate nohighlight">\(\lambda\)</span> is a partition of <span class="math notranslate nohighlight">\(n\)</span>, and
<span class="math notranslate nohighlight">\(n\)</span> is any nonnegative integer. It also satisfies</p>
<div class="math notranslate nohighlight">
\[\Delta^\times (p_n) = p_n \otimes p_n\]</div>
<p>for any positive integer <span class="math notranslate nohighlight">\(n\)</span>. If the base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra, it
also satisfies</p>
<div class="math notranslate nohighlight">
\[\Delta^{\times}(h_n) = \sum_{\lambda \vdash n} z_{\lambda}^{-1}
p_{\lambda} \otimes p_{\lambda},\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[z_{\lambda} = \prod_{i=1}^\infty i^{m_i(\lambda)} m_i(\lambda)!\]</div>
<p>with <span class="math notranslate nohighlight">\(m_i(\lambda)\)</span> meaning the number of appearances of <span class="math notranslate nohighlight">\(i\)</span>
in <span class="math notranslate nohighlight">\(\lambda\)</span> (see <a class="reference internal" href="#sage.combinat.sf.sfa.zee" title="sage.combinat.sf.sfa.zee"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zee()</span></code></a>).</p>
<p>The method <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_coproduct" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_coproduct"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kronecker_coproduct()</span></code></a> is a synonym of
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_coproduct" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_coproduct"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_coproduct()</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="go">s[1, 1, 1] # s[2, 1] + s[2, 1] # s[1, 1, 1] + s[2, 1] # s[2, 1] + s[2, 1] # s[3] + s[3] # s[2, 1]</span>

<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="go">e[1, 1] # e[2] + e[2] # e[1, 1] - 2*e[2] # e[2]</span>
</pre></div>
</div>
<p>The internal coproduct is adjoint to the internal product with respect
to the Hall inner product: Any three symmetric functions <span class="math notranslate nohighlight">\(f\)</span>, <span class="math notranslate nohighlight">\(g\)</span> and
<span class="math notranslate nohighlight">\(h\)</span> satisfy <span class="math notranslate nohighlight">\(\langle f * g, h \rangle = \sum_i \langle f, h^{\prime}_i
\rangle \langle g, h^{\prime\prime}_i \rangle\)</span>, where we write
<span class="math notranslate nohighlight">\(\Delta^{\times}(h)\)</span> as <span class="math notranslate nohighlight">\(\sum_i h^{\prime}_i \otimes
h^{\prime\prime}_i\)</span>. Let us check this in degree <span class="math notranslate nohighlight">\(4\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_incopr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>  <span class="c1"># computes \sum_i \left&lt; f, h&#39;_i \right&gt; \left&lt; g, h&#39;&#39;_i \right&gt;</span>
<span class="gp">....: </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">partition_pair</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">result</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">h</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">h</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">result</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_incopr</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>  <span class="c1"># long time (10s on sage.math, 2013)</span>
<span class="gp">....: </span>               <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us check the formulas for <span class="math notranslate nohighlight">\(\Delta^{\times}(h_n)\)</span> and
<span class="math notranslate nohighlight">\(\Delta^{\times}(p_n)\)</span> given in the description of this method:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">h</span><span class="p">([</span><span class="n">n</span><span class="p">]))</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">tensor</span><span class="p">([</span><span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">),</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)])</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">tensor</span><span class="p">([</span><span class="n">h</span><span class="p">(</span><span class="n">lam</span><span class="p">),</span> <span class="n">h</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">))])</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">h</span><span class="p">([</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">lam</span><span class="o">.</span><span class="n">conjugacy_class_size</span><span class="p">()</span> <span class="o">*</span> <span class="n">tensor</span><span class="p">([</span><span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)),</span> <span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">))])</span>
<span class="gp">....: </span>             <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product">
<code class="sig-name descname">kronecker_product</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the internal (tensor) product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> in the
basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The internal tensor product can be defined as the linear extension
of the definition on power sums
<span class="math notranslate nohighlight">\(p_{\lambda} \ast p_{\mu} = \delta_{\lambda,\mu} z_{\lambda}
p_{\lambda}\)</span>, where <span class="math notranslate nohighlight">\(z_{\lambda} = (1^{r_1} r_1!) (2^{r_2} r_2!)
\cdots\)</span> for <span class="math notranslate nohighlight">\(\lambda = (1^{r_1} 2^{r_2} \cdots )\)</span> and where <span class="math notranslate nohighlight">\(\ast\)</span>
denotes the internal tensor product.
The internal tensor product is also known as the Kronecker product,
or as the second multiplication on the ring of symmetric functions.</p>
<p>Note that the internal product of any two homogeneous symmetric
functions of equal degrees is a homogeneous symmetric function of the
same degree. On the other hand, the internal product of two homogeneous
symmetric functions of distinct degrees is <span class="math notranslate nohighlight">\(0\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The internal product is sometimes referred to as “inner product”
in the literature, but unfortunately this name is shared by a
different operation, namely the Hall inner product
(see <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scalar()</span></code></a>).</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the
same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the internal product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code> (an element of the
ring of symmetric functions in the same basis as <code class="docutils literal notranslate"><span class="pre">self</span></code>)</p></li>
</ul>
<p>The methods <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itensor()</span></code></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.internal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product()</span></code></a>,
<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.kronecker_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kronecker_product()</span></code></a>, <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.inner_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">inner_tensor()</span></code></a> are all
synonyms.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">s[2, 1]</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">s[1, 1, 1, 1, 1, 1] + 2*s[2, 1, 1, 1, 1] + 3*s[2, 2, 1, 1] + 2*s[2, 2, 2]</span>
<span class="go"> + 4*s[3, 1, 1, 1] + 5*s[3, 2, 1] + 2*s[3, 3] + 4*s[4, 1, 1]</span>
<span class="go"> + 3*s[4, 2] + 2*s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>There are few quantitative results pertaining to Kronecker products
in general, which makes their computation so difficult. Let us test
a few of them in different bases.</p>
<p>The Kronecker product of any homogeneous symmetric function <span class="math notranslate nohighlight">\(f\)</span> of
degree <span class="math notranslate nohighlight">\(n\)</span> with the <span class="math notranslate nohighlight">\(n\)</span>-th complete homogeneous symmetric function
<code class="docutils literal notranslate"><span class="pre">h[n]</span></code> (a.k.a. <code class="docutils literal notranslate"><span class="pre">s[n]</span></code>) is <span class="math notranslate nohighlight">\(f\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">h</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product of a Schur function <span class="math notranslate nohighlight">\(s_{\lambda}\)</span> with the <span class="math notranslate nohighlight">\(n\)</span>-th
elementary symmetric function <code class="docutils literal notranslate"><span class="pre">e[n]</span></code>, where <span class="math notranslate nohighlight">\(n = \left| \lambda
\right|\)</span>, is <span class="math notranslate nohighlight">\(s_{\lambda'}\)</span> (where <span class="math notranslate nohighlight">\(\lambda'\)</span> is the conjugate
partition of <span class="math notranslate nohighlight">\(\lambda\)</span>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Kronecker product is commutative:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">mq</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">mh</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">==</span> <span class="n">mh</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">mq</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>   <span class="c1"># long time</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us check (on examples) Proposition 5.2 of Gelfand, Krob, Lascoux, Leclerc,
Retakh, Thibon, “Noncommutative symmetric functions”, <a class="reference external" href="https://arxiv.org/abs/hep-th/9407124">arXiv hep-th/9407124</a>, for
<span class="math notranslate nohighlight">\(r = 2\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_copr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>  <span class="c1"># computes \mu ((u \otimes v) * \Delta(w)) with</span>
<span class="gp">....: </span>                           <span class="c1"># * meaning Kronecker product and \mu meaning the</span>
<span class="gp">....: </span>                           <span class="c1"># usual multiplication.</span>
<span class="gp">....: </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">partition_pair</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">w</span><span class="o">.</span><span class="n">coproduct</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">result</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">parent</span><span class="p">()(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">result</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_copr</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>   <span class="c1"># long time</span>
<span class="gp">....: </span>               <span class="o">==</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
<span class="gp">....: </span>               <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Some examples from Briand, Orellana, Rosas, “The stability of the Kronecker
products of Schur functions.” <a class="reference external" href="https://arxiv.org/abs/0907.4652">arXiv 0907.4652</a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[1, 1, 1, 1] + s[2, 2] + s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 1, 1, 1] + s[2, 2, 1] + s[3, 1, 1] + s[3, 2] + s[4, 1] + s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 2, 2] + s[3, 1, 1, 1] + 2*s[3, 2, 1] + s[4, 1, 1] + 2*s[4, 2] + s[5, 1] + s[6]</span>
</pre></div>
</div>
<p>An example from p. 220 of Thibon, “Hopf algebras of symmetric functions
and tensor products of symmetric group representations”, International
Journal of Algebra and Computation, 1991:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQbar</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1] + s[2, 1] + s[3]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The currently existing implementation of this function is
technically unsatisfactory. It distinguishes the case when the
base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra (in which case the Kronecker product
can be easily computed using the power sum basis) from the case
where it isn’t. In the latter, it does a computation using
universal coefficients, again distinguishing the case when it is
able to compute the “corresponding” basis of the symmetric function
algebra over <span class="math notranslate nohighlight">\(\QQ\)</span> (using the <code class="docutils literal notranslate"><span class="pre">corresponding_basis_over</span></code> hack)
from the case when it isn’t (in which case it transforms everything
into the Schur basis, which is slow).</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.left_padded_kronecker_product">
<code class="sig-name descname">left_padded_kronecker_product</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.left_padded_kronecker_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the left-padded Kronecker product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> in
the basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The left-padded Kronecker product is a bilinear map mapping two
symmetric functions to another, not necessarily preserving degree.
It can be defined as follows: Let <span class="math notranslate nohighlight">\(*\)</span> denote the Kronecker product
(<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itensor()</span></code></a>) on the space of symmetric functions. For any
partitions <span class="math notranslate nohighlight">\(\alpha\)</span>, <span class="math notranslate nohighlight">\(\beta\)</span>, <span class="math notranslate nohighlight">\(\gamma\)</span>, let
<span class="math notranslate nohighlight">\(g^{\gamma}_{\alpha, \beta}\)</span> denote the coefficient of the
complete homogeneous symmetric function <span class="math notranslate nohighlight">\(h_{\gamma}\)</span> in the
Kronecker product <span class="math notranslate nohighlight">\(h_{\alpha} * h_{\beta}\)</span>.
For every partition
<span class="math notranslate nohighlight">\(\lambda = (\lambda_1, \lambda_2, \lambda_3, \ldots)\)</span>
and every integer <span class="math notranslate nohighlight">\(n &gt; \left| \lambda \right| + \lambda_1\)</span>, let
<span class="math notranslate nohighlight">\(\lambda[n]\)</span> denote the <span class="math notranslate nohighlight">\(n\)</span>-completion of <span class="math notranslate nohighlight">\(\lambda\)</span> (this is the
partition
<span class="math notranslate nohighlight">\((n - \left| \lambda \right|, \lambda_1, \lambda_2, \lambda_3, \ldots)\)</span>;
see <a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.t_completion" title="sage.combinat.partition.Partition.t_completion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">t_completion()</span></code></a>).
Then, for any partitions <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> and every integer
<span class="math notranslate nohighlight">\(n \geq \left|\alpha\right| + \left|\beta\right| + \alpha_1 + \beta_1\)</span>,
we can write the Kronecker product <span class="math notranslate nohighlight">\(h_{\alpha[n]} * h_{\beta[n]}\)</span>
in the form</p>
<div class="math notranslate nohighlight">
\[h_{\alpha[n]} * h_{\beta[n]} = \sum_{\gamma}
g^{\gamma[n]}_{\alpha[n], \beta[n]} h_{\gamma[n]}\]</div>
<p>with <span class="math notranslate nohighlight">\(\gamma\)</span> ranging over all partitions. The
coefficients <span class="math notranslate nohighlight">\(g^{\gamma[n]}_{\alpha[n], \beta[n]}\)</span>
are independent on <span class="math notranslate nohighlight">\(n\)</span>. These coefficients
<span class="math notranslate nohighlight">\(g^{\gamma[n]}_{\alpha[n], \beta[n]}\)</span> are denoted by
<span class="math notranslate nohighlight">\(\overline{g}^{\gamma}_{\alpha, \beta}\)</span>, and the symmetric
function</p>
<div class="math notranslate nohighlight">
\[\sum_{\gamma} \overline{g}^{\gamma}_{\alpha, \beta} h_{\gamma}\]</div>
<p>is said to be the <em>left-padded Kronecker product</em> of <span class="math notranslate nohighlight">\(h_{\alpha}\)</span>
and <span class="math notranslate nohighlight">\(h_{\beta}\)</span>. By bilinearity, this extends to a definition of a
left-padded Kronecker product of any two symmetric functions.</p>
<p>This notion of left-padded Kronecker product can be lifted to the
non-commutative symmetric functions
(<a class="reference internal" href="../ncsf_qsym/ncsf.html#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.left_padded_kronecker_product" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.left_padded_kronecker_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">left_padded_kronecker_product()</span></code></a>).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Do not mistake this product for the reduced Kronecker product
(<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.reduced_kronecker_product" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.reduced_kronecker_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reduced_kronecker_product()</span></code></a>), which uses the Schur
functions instead of the complete homogeneous functions in
its definition.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the
same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the left-padded Kronecker product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code> (an
element of the ring of symmetric functions in the same basis
as <code class="docutils literal notranslate"><span class="pre">self</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">h[1, 1, 1, 1] + h[2, 1] + h[2, 1, 1] + h[2, 1, 1, 1] + h[2, 2, 1] + h[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">h[1, 1, 1] + h[2, 1] + h[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">h[1, 1, 1] + h[2, 1] + h[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">h[1, 1] + 2*h[1, 1, 1] + h[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">h[1, 1, 1, 1] + 2*h[2, 1, 1] + h[2, 1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">h[2, 1] + h[2, 1, 1] + h[3, 2]</span>
</pre></div>
</div>
<p>Taking the left-padded Kronecker product with <span class="math notranslate nohighlight">\(1 = h_{\emptyset}\)</span>
is the identity map on the ring of symmetric functions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">[</span><span class="n">Partition</span><span class="p">([])]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">lam</span><span class="p">])</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">h</span><span class="p">[</span><span class="n">lam</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Here is a rule for the left-padded Kronecker product of <span class="math notranslate nohighlight">\(h_1\)</span>
(this is the same as <span class="math notranslate nohighlight">\(h_{(1)}\)</span>) with any complete homogeneous
function: Let <span class="math notranslate nohighlight">\(\lambda\)</span> be a partition. Then, the left-padded
Kronecker product of <span class="math notranslate nohighlight">\(h_1\)</span> and <span class="math notranslate nohighlight">\(h_{\lambda}\)</span> is
<span class="math notranslate nohighlight">\(\sum_{\mu} a_{\mu} h_{\mu}\)</span>, where the sum runs over all
partitions <span class="math notranslate nohighlight">\(\mu\)</span>, and the coefficient <span class="math notranslate nohighlight">\(a_{\mu}\)</span> is defined as the
number of ways to obtain <span class="math notranslate nohighlight">\(\mu\)</span> from <span class="math notranslate nohighlight">\(\lambda\)</span> by one of the
following two operations:</p>
<ul class="simple">
<li><p>Insert a <span class="math notranslate nohighlight">\(1\)</span> into <span class="math notranslate nohighlight">\(\lambda\)</span>.</p></li>
<li><p>Subtract <span class="math notranslate nohighlight">\(1\)</span> from one of the entries of <span class="math notranslate nohighlight">\(\lambda\)</span> (and remove
the entry if it thus becomes <span class="math notranslate nohighlight">\(0\)</span>), and insert a <span class="math notranslate nohighlight">\(1\)</span> into
<span class="math notranslate nohighlight">\(\lambda\)</span>.</p></li>
</ul>
<p>We check this for partitions of size <span class="math notranslate nohighlight">\(\leq 4\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">mults1</span><span class="p">(</span><span class="n">I</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="c1"># Left-padded Kronecker multiplication by h[1].</span>
<span class="gp">....: </span>    <span class="n">res</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">I</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">)):</span>
<span class="gp">....: </span>        <span class="n">I2</span> <span class="o">=</span> <span class="n">I</span><span class="p">[:]</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">I2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="n">I2</span> <span class="o">=</span> <span class="n">I2</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">I2</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="gp">....: </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="n">I2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="gp">....: </span>        <span class="n">res</span> <span class="o">+=</span> <span class="n">h</span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">I2</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)]</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">res</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">mults1</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">==</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">I</span><span class="p">])</span>
<span class="gp">....: </span>               <span class="o">==</span> <span class="n">h</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The left-padded Kronecker product is commutative:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">h</span><span class="p">[</span><span class="n">lam</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">mu</span><span class="p">])</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">h</span><span class="p">[</span><span class="n">mu</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">lam</span><span class="p">])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.nabla">
<code class="sig-name descname">nabla</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">q</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">power</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.nabla" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value of the nabla operator applied to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The eigenvectors of the nabla operator are the Macdonald polynomials in
the Ht basis.</p>
<p>If the parameter <code class="docutils literal notranslate"><span class="pre">power</span></code> is an integer then it calculates
nabla to that integer.  The default value of <code class="docutils literal notranslate"><span class="pre">power</span></code> is 1.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code> – optional parameters (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>, in which
case <code class="docutils literal notranslate"><span class="pre">q</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code> are used)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">power</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">1</span></code>) an integer indicating how many times to
apply the operator <span class="math notranslate nohighlight">\(\nabla\)</span>.  Negative values of <code class="docutils literal notranslate"><span class="pre">power</span></code>
indicate powers of <span class="math notranslate nohighlight">\(\nabla^{-1}\)</span>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">power</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span>
<span class="go">(-1/2*q*t+1/2*q+1/2*t+1/2)*p[1, 1] + (1/2*q*t-1/2*q-1/2*t+1/2)*p[2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(-t-1)*p[1, 1, 1] + t*p[2, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(-t-1)*p[1, 1, 1] + t*p[2, 1]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span>
<span class="go">(-q^3*t-q^2*t^2-q*t^3)*s[1, 1, 1] + (-q^2*t-q*t^2)*s[2, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span>
<span class="go">(q^3+q^2*t+q*t^2+t^3+q*t)*s[1, 1, 1] + (q^2+q*t+t^2+q+t)*s[2, 1] + s[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(q^3+q^2+2*q+1)*s[1, 1, 1] + (q^2+2*q+2)*s[2, 1] + s[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span>
<span class="go">s[]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="n">power</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">((-q-t)/(q^2*t^2))*s[2, 1] + ((q^2+q*t+t^2)/(-q^3*t^3))*s[3]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span>
<span class="go">(-q*t)*s[1, 1] + (q^3*t^2+q^2*t^3)*s[1, 1, 1] + q^2*t^2*s[2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega">
<code class="sig-name descname">omega</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the omega automorphism.</p>
<p>The <em>omega automorphism</em> is defined to be the unique algebra
endomorphism <span class="math notranslate nohighlight">\(\omega\)</span> of the ring of symmetric functions that
satisfies <span class="math notranslate nohighlight">\(\omega(e_k) = h_k\)</span> for all positive integers <span class="math notranslate nohighlight">\(k\)</span>
(where <span class="math notranslate nohighlight">\(e_k\)</span> stands for the <span class="math notranslate nohighlight">\(k\)</span>-th elementary symmetric
function, and <span class="math notranslate nohighlight">\(h_k\)</span> stands for the <span class="math notranslate nohighlight">\(k\)</span>-th complete homogeneous
symmetric function). It furthermore is a Hopf algebra
endomorphism and an involution, and it is also known as the
<em>omega involution</em>. It sends the power-sum symmetric function
<span class="math notranslate nohighlight">\(p_k\)</span> to <span class="math notranslate nohighlight">\((-1)^{k-1} p_k\)</span> for every positive integer <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>The images of some bases under the omega automorphism are given by</p>
<div class="math notranslate nohighlight">
\[\omega(e_{\lambda}) = h_{\lambda}, \qquad
\omega(h_{\lambda}) = e_{\lambda}, \qquad
\omega(p_{\lambda}) = (-1)^{|\lambda| - \ell(\lambda)}
p_{\lambda}, \qquad
\omega(s_{\lambda}) = s_{\lambda^{\prime}},\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda\)</span> is any partition, where <span class="math notranslate nohighlight">\(\ell(\lambda)\)</span> denotes
the length (<a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.length" title="sage.combinat.partition.Partition.length"><code class="xref py py-meth docutils literal notranslate"><span class="pre">length()</span></code></a>)
of the partition <span class="math notranslate nohighlight">\(\lambda\)</span>, where <span class="math notranslate nohighlight">\(\lambda^{\prime}\)</span> denotes the
conjugate partition
(<a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.conjugate" title="sage.combinat.partition.Partition.conjugate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">conjugate()</span></code></a>) of
<span class="math notranslate nohighlight">\(\lambda\)</span>, and where the usual notations for bases are used
(<span class="math notranslate nohighlight">\(e\)</span> = elementary, <span class="math notranslate nohighlight">\(h\)</span> = complete homogeneous, <span class="math notranslate nohighlight">\(p\)</span> = powersum,
<span class="math notranslate nohighlight">\(s\)</span> = Schur).</p>
<p>The default implementation converts to the Schur basis, then
performs the automorphism and changes back.</p>
<p><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_involution" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">omega_involution()</span></code></a> is a synonym for the <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega"><code class="xref py py-meth docutils literal notranslate"><span class="pre">omega()</span></code></a> method.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">jack</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">P</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">J</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">J</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">JackP[2, 1] + JackP[3]</span>
<span class="gp">sage: </span><span class="n">J</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">J</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">JackP[]</span>
</pre></div>
</div>
<p>The forgotten symmetric functions are the images of the monomial
symmetric functions under omega:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">f</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_involution">
<code class="sig-name descname">omega_involution</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the omega automorphism.</p>
<p>The <em>omega automorphism</em> is defined to be the unique algebra
endomorphism <span class="math notranslate nohighlight">\(\omega\)</span> of the ring of symmetric functions that
satisfies <span class="math notranslate nohighlight">\(\omega(e_k) = h_k\)</span> for all positive integers <span class="math notranslate nohighlight">\(k\)</span>
(where <span class="math notranslate nohighlight">\(e_k\)</span> stands for the <span class="math notranslate nohighlight">\(k\)</span>-th elementary symmetric
function, and <span class="math notranslate nohighlight">\(h_k\)</span> stands for the <span class="math notranslate nohighlight">\(k\)</span>-th complete homogeneous
symmetric function). It furthermore is a Hopf algebra
endomorphism and an involution, and it is also known as the
<em>omega involution</em>. It sends the power-sum symmetric function
<span class="math notranslate nohighlight">\(p_k\)</span> to <span class="math notranslate nohighlight">\((-1)^{k-1} p_k\)</span> for every positive integer <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>The images of some bases under the omega automorphism are given by</p>
<div class="math notranslate nohighlight">
\[\omega(e_{\lambda}) = h_{\lambda}, \qquad
\omega(h_{\lambda}) = e_{\lambda}, \qquad
\omega(p_{\lambda}) = (-1)^{|\lambda| - \ell(\lambda)}
p_{\lambda}, \qquad
\omega(s_{\lambda}) = s_{\lambda^{\prime}},\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda\)</span> is any partition, where <span class="math notranslate nohighlight">\(\ell(\lambda)\)</span> denotes
the length (<a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.length" title="sage.combinat.partition.Partition.length"><code class="xref py py-meth docutils literal notranslate"><span class="pre">length()</span></code></a>)
of the partition <span class="math notranslate nohighlight">\(\lambda\)</span>, where <span class="math notranslate nohighlight">\(\lambda^{\prime}\)</span> denotes the
conjugate partition
(<a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.conjugate" title="sage.combinat.partition.Partition.conjugate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">conjugate()</span></code></a>) of
<span class="math notranslate nohighlight">\(\lambda\)</span>, and where the usual notations for bases are used
(<span class="math notranslate nohighlight">\(e\)</span> = elementary, <span class="math notranslate nohighlight">\(h\)</span> = complete homogeneous, <span class="math notranslate nohighlight">\(p\)</span> = powersum,
<span class="math notranslate nohighlight">\(s\)</span> = Schur).</p>
<p>The default implementation converts to the Schur basis, then
performs the automorphism and changes back.</p>
<p><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_involution" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">omega_involution()</span></code></a> is a synonym for the <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega"><code class="xref py py-meth docutils literal notranslate"><span class="pre">omega()</span></code></a> method.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">jack</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">P</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">J</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">J</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">JackP[2, 1] + JackP[3]</span>
<span class="gp">sage: </span><span class="n">J</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">J</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">JackP[]</span>
</pre></div>
</div>
<p>The forgotten symmetric functions are the images of the monomial
symmetric functions under omega:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">f</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">m</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_qt">
<code class="sig-name descname">omega_qt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">q</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega_qt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the <span class="math notranslate nohighlight">\(q,t\)</span>-deformed omega
automorphism which sends <span class="math notranslate nohighlight">\(p_k\)</span> to
<span class="math notranslate nohighlight">\((-1)^{k-1} \cdot \frac{1-q^k}{1-t^k} \cdot p_k\)</span> for all positive
integers <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>In general, this is well-defined outside of the powersum basis only
if the base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra.</p>
<p>If <span class="math notranslate nohighlight">\(q = t\)</span>, then this is the omega automorphism (<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.omega"><code class="xref py py-meth docutils literal notranslate"><span class="pre">omega()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code> – parameters (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>, in which case
<code class="docutils literal notranslate"><span class="pre">'q'</span></code> and <code class="docutils literal notranslate"><span class="pre">'t'</span></code> are used)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QQqt</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q,t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">q</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">QQqt</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQqt</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">()</span>
<span class="go">((-q^5+1)/(-t^5+1))*p[5]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">((-q^5+1)/(-t^5+1))*p[5]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">((q^2-1)/(-t^2+1))*p[2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">((-q^3+q^2+q-1)/(t^3-t^2-t+1))*p[2, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">q</span><span class="p">)</span>
<span class="go">-(2976/(q^5-q^3-q^2+1))*p[3, 2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">()</span>
<span class="go">p[]</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQqt</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">()</span>
<span class="go">((2*q^2-2*q*t-2*q+2*t)/(t^3-t^2-t+1))*McdH[1, 1] + ((q-1)/(t-1))*McdH[2]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">((2*q^2-2*q*t-2*q+2*t)/(t^3-t^2-t+1))*McdH[1, 1] + ((q-1)/(t-1))*McdH[2]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">)</span>
<span class="go">((-t^3+t^2+t-1)/(-q^3+q^2+q-1))*McdH[2]</span>
<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">()</span>
<span class="go">((q^2-q*t-q+t)/(t^3-t^2-t+1))*McdS[1, 1] + ((-q^2*t+q*t+q-1)/(-t^3+t^2+t-1))*McdS[2]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">S</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_qt</span><span class="p">())</span>
<span class="go">s[2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm">
<code class="sig-name descname">plethysm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">include</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the outer plethysm of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>This is implemented only over base rings which are
<span class="math notranslate nohighlight">\(\QQ\)</span>-algebras.  (To compute outer plethysms over general
binomial rings, change bases to the fraction field.)</p>
<p>The outer plethysm of <span class="math notranslate nohighlight">\(f\)</span> with <span class="math notranslate nohighlight">\(g\)</span> is commonly denoted by
<span class="math notranslate nohighlight">\(f \left[ g \right]\)</span> or by <span class="math notranslate nohighlight">\(f \circ g\)</span>. It is an algebra map
in <span class="math notranslate nohighlight">\(f\)</span>, but not (generally) in <span class="math notranslate nohighlight">\(g\)</span>.</p>
<p>By default, the degree one elements are taken to be the
generators for the <code class="docutils literal notranslate"><span class="pre">self</span></code>’s base ring. This setting can be
modified by specifying the <code class="docutils literal notranslate"><span class="pre">include</span></code> and <code class="docutils literal notranslate"><span class="pre">exclude</span></code> keywords.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – a symmetric function over the same base ring as
<code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">include</span></code> – a list of variables to be treated as
degree one elements instead of the default degree one elements</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exclude</span></code> – a list of variables to be excluded
from the default degree one elements</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="p">(</span> <span class="n">h</span><span class="p">([</span><span class="mi">3</span><span class="p">])(</span> <span class="n">h</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span> <span class="p">)</span> <span class="p">)</span>
<span class="go">s[2, 2, 2] + s[4, 2] + s[6]</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">3</span><span class="p">])(</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>
<span class="go">1/3*p[3, 3, 3] - 1/3*p[9]</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="p">([</span><span class="mi">3</span><span class="p">])(</span> <span class="n">e</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span> <span class="p">)</span>
<span class="go">e[3, 3] + e[4, 1, 1] - 2*e[4, 2] - e[5, 1] + e[6]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">t</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">t^3*s[2, 2, 2] + t^3*s[4, 2] + t^3*s[6]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">t*s[4, 2] + t*s[6]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">s[]</span>
</pre></div>
</div>
<p>Sage also handles plethysm of tensor products of symmetric functions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">s</span><span class="p">[[]]])</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">([</span><span class="n">s</span><span class="p">[[]],</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">](</span><span class="n">X</span><span class="o">+</span><span class="n">Y</span><span class="p">)</span>
<span class="go">s[] # s[1, 1, 1] + s[1] # s[1, 1] + s[1, 1] # s[1] + s[1, 1, 1] # s[]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">](</span><span class="n">X</span><span class="o">*</span><span class="n">Y</span><span class="p">)</span>
<span class="go">s[1, 1, 1] # s[3] + s[2, 1] # s[2, 1] + s[3] # s[1, 1, 1]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius"><code class="xref py py-meth docutils literal notranslate"><span class="pre">frobenius()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.principal_specialization">
<code class="sig-name descname">principal_specialization</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">+ Infinity</span></em>, <em class="sig-param"><span class="n">q</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.principal_specialization" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the principal specialization of a symmetric function.</p>
<p>The <em>principal specialization</em> of order <span class="math notranslate nohighlight">\(n\)</span> at <span class="math notranslate nohighlight">\(q\)</span>
is the ring homomorphism <span class="math notranslate nohighlight">\(ps_{n,q}\)</span> from the ring of
symmetric functions to another commutative ring <span class="math notranslate nohighlight">\(R\)</span>
given by <span class="math notranslate nohighlight">\(x_i \mapsto q^{i-1}\)</span> for <span class="math notranslate nohighlight">\(i \in \{1,\dots,n\}\)</span>
and <span class="math notranslate nohighlight">\(x_i \mapsto 0\)</span> for <span class="math notranslate nohighlight">\(i &gt; n\)</span>.
Here, <span class="math notranslate nohighlight">\(q\)</span> is a given element of <span class="math notranslate nohighlight">\(R\)</span>, and we assume that
the variables of our symmetric functions are
<span class="math notranslate nohighlight">\(x_1, x_2, x_3, \ldots\)</span>.
(To be more precise, <span class="math notranslate nohighlight">\(ps_{n,q}\)</span> is a <span class="math notranslate nohighlight">\(K\)</span>-algebra
homomorphism, where <span class="math notranslate nohighlight">\(K\)</span> is the base ring.)
See Section 7.8 of <a class="reference internal" href="../../../../references/index.html#enumcomb2" id="id10"><span>[EnumComb2]</span></a>.</p>
<p>The <em>stable principal specialization</em> at <span class="math notranslate nohighlight">\(q\)</span> is the ring
homomorphism <span class="math notranslate nohighlight">\(ps_q\)</span> from the ring of symmetric functions
to another commutative ring <span class="math notranslate nohighlight">\(R\)</span> given by
<span class="math notranslate nohighlight">\(x_i \mapsto q^{i-1}\)</span> for all <span class="math notranslate nohighlight">\(i\)</span>.
This is well-defined only if the resulting infinite sums
converge; thus, in particular, setting <span class="math notranslate nohighlight">\(q = 1\)</span> in the
stable principal specialization is an invalid operation.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> (default: <code class="docutils literal notranslate"><span class="pre">infinity</span></code>) – a nonnegative integer or
<code class="docutils literal notranslate"><span class="pre">infinity</span></code>, specifying whether to compute the principal
specialization of order <code class="docutils literal notranslate"><span class="pre">n</span></code> or the stable principal
specialization.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) – the value to use for <span class="math notranslate nohighlight">\(q\)</span>; the
default is to create a ring of polynomials in <code class="docutils literal notranslate"><span class="pre">q</span></code>
(or a field of rational functions in <code class="docutils literal notranslate"><span class="pre">q</span></code>) over the
given coefficient ring.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">principal_specialization</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">q^3 + q^2 + q</span>
</pre></div>
</div>
<p>By default we return a rational function in <code class="docutils literal notranslate"><span class="pre">q</span></code>.  Sometimes
it is better to obtain an element of the symbolic ring:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">principal_specialization</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">var</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">))</span>
<span class="go">1/((q^2 - 1)*(q - 1)) - 1/((q^3 - 1)*(q^2 - 1)*(q - 1))</span>
</pre></div>
</div>
<p>In case <code class="docutils literal notranslate"><span class="pre">q</span></code> is in the base ring, it must be passed explicitly:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q,t&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">Ht</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">Ht</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Ht</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">principal_specialization</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the variable q is in the base ring, pass it explicitly</span>

<span class="gp">sage: </span><span class="n">Ht</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">principal_specialization</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">R</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">))</span>
<span class="go">(q^2 + 1)/(q^3 - q^2 - q + 1)</span>
</pre></div>
</div>
<p>Note that the principal specialization can be obtained as a plethysm:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">one</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">principal_specialization</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="n">one</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">))</span><span class="o">.</span><span class="n">coefficient</span><span class="p">([])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">principal_specialization</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="n">one</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="o">^</span><span class="mi">4</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">))</span><span class="o">.</span><span class="n">coefficient</span><span class="p">([])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.reduced_kronecker_product">
<code class="sig-name descname">reduced_kronecker_product</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.reduced_kronecker_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the reduced Kronecker product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> in the
basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The reduced Kronecker product is a bilinear map mapping two
symmetric functions to another, not necessarily preserving degree.
It can be defined as follows: Let <span class="math notranslate nohighlight">\(*\)</span> denote the Kronecker product
(<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.itensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itensor()</span></code></a>) on the space of symmetric functions. For any
partitions <span class="math notranslate nohighlight">\(\alpha\)</span>, <span class="math notranslate nohighlight">\(\beta\)</span>, <span class="math notranslate nohighlight">\(\gamma\)</span>, let
<span class="math notranslate nohighlight">\(g^{\gamma}_{\alpha, \beta}\)</span> denote the coefficient of the Schur
function <span class="math notranslate nohighlight">\(s_{\gamma}\)</span> in the Kronecker product
<span class="math notranslate nohighlight">\(s_{\alpha} * s_{\beta}\)</span> (this is called a Kronecker coefficient).
For every partition
<span class="math notranslate nohighlight">\(\lambda = (\lambda_1, \lambda_2, \lambda_3, \ldots)\)</span>
and every integer <span class="math notranslate nohighlight">\(n &gt; \left| \lambda \right| + \lambda_1\)</span>, let
<span class="math notranslate nohighlight">\(\lambda[n]\)</span> denote the <span class="math notranslate nohighlight">\(n\)</span>-completion of <span class="math notranslate nohighlight">\(\lambda\)</span> (this is the
partition
<span class="math notranslate nohighlight">\((n - \left| \lambda \right|, \lambda_1, \lambda_2, \lambda_3, \ldots)\)</span>;
see <a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.t_completion" title="sage.combinat.partition.Partition.t_completion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">t_completion()</span></code></a>).
Then, Theorem 1.2 of <a class="reference internal" href="../../../../references/index.html#bor2009" id="id11"><span>[BOR2009]</span></a> shows that for any partitions
<span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> and every integer
<span class="math notranslate nohighlight">\(n \geq \left|\alpha\right| + \left|\beta\right| + \alpha_1 + \beta_1\)</span>,
we can write the Kronecker product <span class="math notranslate nohighlight">\(s_{\alpha[n]} * s_{\beta[n]}\)</span>
in the form</p>
<div class="math notranslate nohighlight">
\[s_{\alpha[n]} * s_{\beta[n]} = \sum_{\gamma} g^{\gamma[n]}_{\alpha[n], \beta[n]} s_{\gamma[n]}\]</div>
<p>with <span class="math notranslate nohighlight">\(\gamma\)</span> ranging over all partitions. The
coefficients <span class="math notranslate nohighlight">\(g^{\gamma[n]}_{\alpha[n], \beta[n]}\)</span>
are independent on <span class="math notranslate nohighlight">\(n\)</span>. These coefficients
<span class="math notranslate nohighlight">\(g^{\gamma[n]}_{\alpha[n], \beta[n]}\)</span> are denoted by
<span class="math notranslate nohighlight">\(\overline{g}^{\gamma}_{\alpha, \beta}\)</span>, and the symmetric
function</p>
<div class="math notranslate nohighlight">
\[\sum_{\gamma} \overline{g}^{\gamma}_{\alpha, \beta} s_{\gamma}\]</div>
<p>is said to be the <em>reduced Kronecker product</em> of <span class="math notranslate nohighlight">\(s_{\alpha}\)</span> and
<span class="math notranslate nohighlight">\(s_{\beta}\)</span>. By bilinearity, this extends to a definition of a
reduced Kronecker product of any two symmetric functions.</p>
<p>The definition of the reduced Kronecker product goes back to
Murnaghan, and has recently been studied in <a class="reference internal" href="../../../../references/index.html#bor2009" id="id12"><span>[BOR2009]</span></a>, <a class="reference internal" href="../../../../references/index.html#bdvo2012" id="id13"><span>[BdVO2012]</span></a>
and other places (our notation
<span class="math notranslate nohighlight">\(\overline{g}^{\gamma}_{\alpha, \beta}\)</span> appears in these two
sources).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the
same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the reduced Kronecker product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code> (an element
of the ring of symmetric functions in the same basis as
<code class="docutils literal notranslate"><span class="pre">self</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The example from page 2 of <a class="reference internal" href="../../../../references/index.html#bor2009" id="id14"><span>[BOR2009]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reduced_kronecker_product</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[] + s[1] + s[1, 1] + s[1, 1, 1] + 2*s[2] + 2*s[2, 1] + s[2, 2] + s[3] + s[3, 1] + s[4]</span>
</pre></div>
</div>
<p>Taking the reduced Kronecker product with <span class="math notranslate nohighlight">\(1 = s_{\emptyset}\)</span>
is the identity map on the ring of symmetric functions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">[</span><span class="n">Partition</span><span class="p">([])]</span><span class="o">.</span><span class="n">reduced_kronecker_product</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">lam</span><span class="p">])</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">lam</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>While reduced Kronecker products are hard to compute in general,
there is a rule for taking reduced Kronecker products with
<span class="math notranslate nohighlight">\(s_1\)</span>. Namely, for every partition <span class="math notranslate nohighlight">\(\lambda\)</span>, the reduced
Kronecker product of <span class="math notranslate nohighlight">\(s_{\lambda}\)</span> with <span class="math notranslate nohighlight">\(s_1\)</span> is
<span class="math notranslate nohighlight">\(\sum_{\mu} a_{\mu} s_{\mu}\)</span>, where the sum runs over all
partitions <span class="math notranslate nohighlight">\(\mu\)</span>, and the coefficient <span class="math notranslate nohighlight">\(a_{\mu}\)</span> is defined as the
number of ways to obtain <span class="math notranslate nohighlight">\(\mu\)</span> from <span class="math notranslate nohighlight">\(\lambda\)</span> by one of the
following three operations:</p>
<ul class="simple">
<li><p>Add an addable cell
(<a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.addable_cells" title="sage.combinat.partition.Partition.addable_cells"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addable_cells()</span></code></a>) to
<span class="math notranslate nohighlight">\(\lambda\)</span>.</p></li>
<li><p>Remove a removable cell
(<a class="reference internal" href="../partition.html#sage.combinat.partition.Partition.removable_cells" title="sage.combinat.partition.Partition.removable_cells"><code class="xref py py-meth docutils literal notranslate"><span class="pre">removable_cells()</span></code></a>)
from <span class="math notranslate nohighlight">\(\lambda\)</span>.</p></li>
<li><p>First remove a removable cell from <span class="math notranslate nohighlight">\(\lambda\)</span>, then add an
addable cell to the resulting Young diagram.</p></li>
</ul>
<p>This is, in fact, Proposition 5.15 of <a class="reference internal" href="../../../../references/index.html#co2010" id="id15"><span>[CO2010]</span></a> in an elementary
wording. We check this for partitions of size <span class="math notranslate nohighlight">\(\leq 4\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">mults1</span><span class="p">(</span><span class="n">lam</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="c1"># Reduced Kronecker multiplication by s[1], according</span>
<span class="gp">....: </span>    <span class="c1"># to [CO2010]_.</span>
<span class="gp">....: </span>    <span class="n">res</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">lam</span><span class="o">.</span><span class="n">up_list</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">res</span> <span class="o">+=</span> <span class="n">s</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">lam</span><span class="o">.</span><span class="n">down_list</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">res</span> <span class="o">+=</span> <span class="n">s</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="n">mu</span><span class="o">.</span><span class="n">up_list</span><span class="p">():</span>
<span class="gp">....: </span>            <span class="n">res</span> <span class="o">+=</span> <span class="n">s</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">res</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">mults1</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reduced_kronecker_product</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">lam</span><span class="p">])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Here is the example on page 3 of Christian Gutschwager’s
<a class="reference external" href="https://arxiv.org/abs/0912.4411v3">arXiv 0912.4411v3</a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reduced_kronecker_product</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[1] + 2*s[1, 1] + s[1, 1, 1] + s[2] + 2*s[2, 1] + s[2, 1, 1] + s[3] + s[3, 1]</span>
</pre></div>
</div>
<p>Example 39 from F. D. Murnaghan, “The analysis of the Kronecker
product of irreducible representations of the symmetric group”,
American Journal of Mathematics, Vol. 60, No. 3, Jul. 1938:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">reduced_kronecker_product</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">s[1] + 2*s[1, 1] + 2*s[1, 1, 1] + s[1, 1, 1, 1] + 2*s[2] + 5*s[2, 1] + 4*s[2, 1, 1]</span>
<span class="go">+ s[2, 1, 1, 1] + 3*s[2, 2] + 2*s[2, 2, 1] + 2*s[3] + 5*s[3, 1] + 3*s[3, 1, 1]</span>
<span class="go">+ 3*s[3, 2] + s[3, 2, 1] + 2*s[4] + 3*s[4, 1] + s[4, 1, 1] + s[4, 2] + s[5]</span>
<span class="go">+ s[5, 1]</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="id16">
<p class="admonition-title">Todo</p>
<p>This implementation of the reduced Kronecker product is
painfully slow.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_degree">
<code class="sig-name descname">restrict_degree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">exact</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degree <code class="docutils literal notranslate"><span class="pre">d</span></code> component of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">d</span></code> – positive integer, degree of the terms to be returned</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exact</span></code> – boolean, if <code class="docutils literal notranslate"><span class="pre">True</span></code>, returns the terms of degree
exactly <code class="docutils literal notranslate"><span class="pre">d</span></code>, otherwise returns all terms of degree less than
or equal to <code class="docutils literal notranslate"><span class="pre">d</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the homogeneous component of <code class="docutils literal notranslate"><span class="pre">self</span></code> of degree <code class="docutils literal notranslate"><span class="pre">d</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_degree</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_degree</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">s[1]</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_degree</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">s[1, 1, 1] + s[2, 1]</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_degree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">s[1] + s[1, 1, 1] + s[2, 1]</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_degree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_partition_lengths">
<code class="sig-name descname">restrict_partition_lengths</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">exact</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_partition_lengths" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the terms of <code class="docutils literal notranslate"><span class="pre">self</span></code> labelled by partitions of length <code class="docutils literal notranslate"><span class="pre">l</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> – nonnegative integer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exact</span></code> – boolean, defaulting to <code class="docutils literal notranslate"><span class="pre">True</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>if <code class="docutils literal notranslate"><span class="pre">True</span></code>, returns the terms labelled by
partitions of length precisely <code class="docutils literal notranslate"><span class="pre">l</span></code>; otherwise returns all terms
labelled by partitions of length less than or equal to <code class="docutils literal notranslate"><span class="pre">l</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_partition_lengths</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">s[2, 1]</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_partition_lengths</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_partition_lengths</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">exact</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="go">s[1] + s[2, 1] + s[4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_parts">
<code class="sig-name descname">restrict_parts</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.restrict_parts" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the terms of <code class="docutils literal notranslate"><span class="pre">self</span></code> labelled by partitions <span class="math notranslate nohighlight">\(\lambda\)</span> with
<span class="math notranslate nohighlight">\(\lambda_1 \leq n\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – positive integer, to restrict the parts of the partitions
of the terms to be returned</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_parts</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">s[1] + s[1, 1, 1] + s[2, 1]</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">restrict_parts</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">s[1] + s[1, 1, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar">
<code class="sig-name descname">scalar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">zee</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the standard scalar product between <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>This is also known as the “Hall inner product” or the
“Hall scalar product”.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the
same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">zee</span></code> – an optional function on partitions giving
the value for the scalar product between <span class="math notranslate nohighlight">\(p_{\mu}\)</span> and <span class="math notranslate nohighlight">\(p_{\mu}\)</span>
(default is to use the standard <a class="reference internal" href="#sage.combinat.sf.sfa.zee" title="sage.combinat.sf.sfa.zee"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zee()</span></code></a> function)</p></li>
</ul>
<p>This is the default implementation that converts both <code class="docutils literal notranslate"><span class="pre">self</span></code> and
<code class="docutils literal notranslate"><span class="pre">x</span></code> into either Schur functions (if <code class="docutils literal notranslate"><span class="pre">zee</span></code> is not specified) or
power-sum functions (if <code class="docutils literal notranslate"><span class="pre">zee</span></code> is specified) and performs the scalar
product in that basis.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p4</span> <span class="o">=</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([</span> <span class="p">[</span><span class="n">e</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">])</span>
<span class="go">[ 0  0  0  0  1]</span>
<span class="go">[ 0  0  0  1  4]</span>
<span class="go">[ 0  0  1  2  6]</span>
<span class="go">[ 0  1  2  5 12]</span>
<span class="go">[ 1  4  6 12 24]</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([</span> <span class="p">[</span><span class="n">h</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">])</span>
<span class="go">[ 0  0  0  0  1]</span>
<span class="go">[ 0  0  0  1  4]</span>
<span class="go">[ 0  0  1  2  6]</span>
<span class="go">[ 0  1  2  5 12]</span>
<span class="go">[ 1  4  6 12 24]</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([</span> <span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">])</span>
<span class="go">[-1  2  1 -3  1]</span>
<span class="go">[ 0  1  0 -2  1]</span>
<span class="go">[ 0  0  1 -2  1]</span>
<span class="go">[ 0  0  0 -1  1]</span>
<span class="go">[ 0  0  0  0  1]</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([</span> <span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">])</span>
<span class="go">[1 0 0 0 0]</span>
<span class="go">[0 1 0 0 0]</span>
<span class="go">[0 0 1 0 0]</span>
<span class="go">[0 0 0 1 0]</span>
<span class="go">[0 0 0 0 1]</span>

<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">zee</span><span class="o">=</span><span class="k">lambda</span> <span class="n">mu</span><span class="p">:</span> <span class="mi">2</span><span class="o">**</span><span class="n">mu</span><span class="o">.</span><span class="n">length</span><span class="p">())</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">mu</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">zee</span><span class="o">=</span><span class="k">lambda</span> <span class="n">mu</span><span class="p">:</span> <span class="mi">2</span><span class="o">**</span><span class="n">mu</span><span class="o">.</span><span class="n">length</span><span class="p">())</span>
<span class="go">2/3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_hl">
<code class="sig-name descname">scalar_hl</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">t</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_hl" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <span class="math notranslate nohighlight">\(t\)</span>-deformed standard Hall-Littlewood scalar product of
<code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the same
base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – parameter (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>, in which case <code class="docutils literal notranslate"><span class="pre">t</span></code> is used)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">sp</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">scalar_t</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">sp</span>
<span class="go">(-t^2 - 1)/(t^5 - 2*t^4 + t^3 - t^2 + 2*t - 1)</span>
<span class="gp">sage: </span><span class="n">sp</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Fraction Field of Univariate Polynomial Ring in t over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_jack">
<code class="sig-name descname">scalar_jack</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">t</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_jack" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Jack-scalar product between <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>This scalar product is defined so that the power sum elements
<span class="math notranslate nohighlight">\(p_{\mu}\)</span> are orthogonal and <span class="math notranslate nohighlight">\(\langle p_{\mu}, p_{\mu} \rangle =
z_{\mu} t^{\ell(\mu)}\)</span>, where <span class="math notranslate nohighlight">\(\ell(\mu)\)</span> denotes the length of
<span class="math notranslate nohighlight">\(\mu\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the
same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – an optional parameter (default: <code class="docutils literal notranslate"><span class="pre">None</span></code> in which
case <code class="docutils literal notranslate"><span class="pre">t</span></code> is used)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">power</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([[</span><span class="n">p</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_jack</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">nu</span><span class="p">))</span> <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)])</span>
<span class="go">[   4*t      0      0      0      0]</span>
<span class="go">[     0  3*t^2      0      0      0]</span>
<span class="go">[     0      0  8*t^2      0      0]</span>
<span class="go">[     0      0      0  4*t^3      0]</span>
<span class="go">[     0      0      0      0 24*t^4]</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([[</span><span class="n">p</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_jack</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">nu</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)])</span>
<span class="go">[  8   0   0   0   0]</span>
<span class="go">[  0  12   0   0   0]</span>
<span class="go">[  0   0  32   0   0]</span>
<span class="go">[  0   0   0  32   0]</span>
<span class="go">[  0   0   0   0 384]</span>
<span class="gp">sage: </span><span class="n">JQ</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span><span class="o">.</span><span class="n">jack</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([[</span><span class="n">JQ</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_jack</span><span class="p">(</span><span class="n">JQ</span><span class="p">(</span><span class="n">nu</span><span class="p">))</span> <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
<span class="go">[(1/3*t^2 + 1/2*t + 1/6)/t^3                           0                           0]</span>
<span class="go">[                          0 (1/2*t + 1)/(t^3 + 1/2*t^2)                           0]</span>
<span class="go">[                          0                           0       6/(t^3 + 3*t^2 + 2*t)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_qt">
<code class="sig-name descname">scalar_qt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">q</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_qt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <span class="math notranslate nohighlight">\(q,t\)</span>-deformed standard Hall-Littlewood scalar product of
<code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the same
base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code> – parameters (default: <code class="docutils literal notranslate"><span class="pre">None</span></code> in which case <code class="docutils literal notranslate"><span class="pre">q</span></code>
and <code class="docutils literal notranslate"><span class="pre">t</span></code> are used)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">sp</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">factor</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
<span class="go">(t - 1)^-3 * (q - 1) * (t^2 + t + 1)^-1 * (q^2*t^2 - q*t^2 + q^2 - 2*q*t + t^2 - q + 1)</span>
<span class="gp">sage: </span><span class="n">sp</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">q</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">(-t^2 - 1)/(t^5 - 2*t^4 + t^3 - t^2 + 2*t - 1)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">-q^3 + 2*q^2 - 2*q + 1</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span> <span class="c1"># q=5 and t=7</span>
<span class="go">490/1539</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;x,y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">q</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
<span class="go">1/3*(x^3 - 1)/(y^3 - 1) + 2/3*(x - 1)^3/(y - 1)^3</span>
<span class="gp">sage: </span><span class="n">Rn</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">Rn</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Mac</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">Rn</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">y</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="n">z</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">Mac</span><span class="o">.</span><span class="n">_sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">(</span><span class="n">Mac</span><span class="o">.</span><span class="n">P</span><span class="p">()(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">Mac</span><span class="o">.</span><span class="n">Q</span><span class="p">()(</span><span class="n">a</span><span class="p">),</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">))</span>
<span class="go">(t - 1)^-3 * (q - 1) * (t^2 + t + 1)^-1 * (q^2*t^2 - q*t^2 + q^2 - 2*q*t + t^2 - q + 1)</span>
<span class="gp">sage: </span><span class="n">factor</span><span class="p">(</span><span class="n">Mac</span><span class="o">.</span><span class="n">P</span><span class="p">()(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">Mac</span><span class="o">.</span><span class="n">Q</span><span class="p">()(</span><span class="n">a</span><span class="p">)))</span>
<span class="go">(z - 1)^-3 * (y - 1) * (z^2 + z + 1)^-1 * (y^2*z^2 - y*z^2 + y^2 - 2*y*z + z^2 - y + 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_t">
<code class="sig-name descname">scalar_t</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">t</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <span class="math notranslate nohighlight">\(t\)</span>-deformed standard Hall-Littlewood scalar product of
<code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the same
base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – parameter (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>, in which case <code class="docutils literal notranslate"><span class="pre">t</span></code> is used)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">sp</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">scalar_t</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">sp</span>
<span class="go">(-t^2 - 1)/(t^5 - 2*t^4 + t^3 - t^2 + 2*t - 1)</span>
<span class="gp">sage: </span><span class="n">sp</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Fraction Field of Univariate Polynomial Ring in t over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.skew_by">
<code class="sig-name descname">skew_by</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.skew_by" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of skewing <code class="docutils literal notranslate"><span class="pre">self</span></code> by <code class="docutils literal notranslate"><span class="pre">x</span></code>. (Skewing by <code class="docutils literal notranslate"><span class="pre">x</span></code> is
the endomorphism (as additive group) of the ring of symmetric
functions adjoint to multiplication by <code class="docutils literal notranslate"><span class="pre">x</span></code> with respect to the
Hall inner product.)</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of symmetric functions over the same
base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">s[2, 1] + s[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[1, 1, 1] + 2*s[2, 1] + s[3]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">powersum</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">4*p[4, 3, 3, 2]</span>
<span class="gp">sage: </span><span class="n">zee</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">sf</span><span class="o">.</span><span class="n">sfa</span><span class="o">.</span><span class="n">zee</span>
<span class="gp">sage: </span><span class="n">zee</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">zee</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">([]))</span>
<span class="go">s[]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.theta">
<code class="sig-name descname">theta</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the theta endomorphism which sends
<span class="math notranslate nohighlight">\(p_k\)</span> to <span class="math notranslate nohighlight">\(a \cdot p_k\)</span> for every positive integer <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>In general, this is well-defined outside of the powersum basis only
if the base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code> – an element of the base ring</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">theta</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2*s[1, 1, 1] + 6*s[2, 1] + 2*s[3]</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">theta</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2*p[2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">theta</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">theta</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">p[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.theta_qt">
<code class="sig-name descname">theta_qt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">q</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.theta_qt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the <span class="math notranslate nohighlight">\(q,t\)</span>-deformed theta
endomorphism which sends <span class="math notranslate nohighlight">\(p_k\)</span> to <span class="math notranslate nohighlight">\(\frac{1-q^k}{1-t^k} \cdot p_k\)</span>
for all positive integers <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>In general, this is well-defined outside of the powersum basis only
if the base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code> – parameters (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>, in which case ‘q’
and ‘t’ are used)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QQqt</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q,t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">q</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">QQqt</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQqt</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">((-q^2+1)/(-t^2+1))*p[2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">((q^3-q^2-q+1)/(t^3-t^2-t+1))*p[2, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3/16*p[2, 1]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">realization_of</span><span class="p">()</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span>
<span class="go">t^3*s[1, 1, 1] + (t^2+t)*s[2, 1] + s[3]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">()</span>
<span class="go">p[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung">
<code class="sig-name descname">verschiebung</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the symmetric function <code class="docutils literal notranslate"><span class="pre">self</span></code> under the
<span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator.</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator <span class="math notranslate nohighlight">\(\mathbf{V}_n\)</span> is defined to be
the unique algebra endomorphism <span class="math notranslate nohighlight">\(V\)</span> of the ring of symmetric
functions that satisfies <span class="math notranslate nohighlight">\(V(h_r) = h_{r/n}\)</span> for every positive
integer <span class="math notranslate nohighlight">\(r\)</span> divisible by <span class="math notranslate nohighlight">\(n\)</span>, and satisfies <span class="math notranslate nohighlight">\(V(h_r) = 0\)</span> for
every positive integer <span class="math notranslate nohighlight">\(r\)</span> not divisible by <span class="math notranslate nohighlight">\(n\)</span>. This operator
<span class="math notranslate nohighlight">\(\mathbf{V}_n\)</span> is a Hopf algebra endomorphism. For every
nonnegative integer <span class="math notranslate nohighlight">\(r\)</span> with <span class="math notranslate nohighlight">\(n \mid r\)</span>, it satisfies</p>
<div class="math notranslate nohighlight">
\[\mathbf{V}_n(h_r) = h_{r/n},
\quad \mathbf{V}_n(p_r) = n p_{r/n},
\quad \mathbf{V}_n(e_r) = (-1)^{r - r/n} e_{r/n}\]</div>
<p>(where <span class="math notranslate nohighlight">\(h\)</span> is the complete homogeneous basis, <span class="math notranslate nohighlight">\(p\)</span> is the
powersum basis, and <span class="math notranslate nohighlight">\(e\)</span> is the elementary basis). For every
nonnegative integer <span class="math notranslate nohighlight">\(r\)</span> with <span class="math notranslate nohighlight">\(n \nmid r\)</span>, it satisfes</p>
<div class="math notranslate nohighlight">
\[\mathbf{V}_n(h_r) = \mathbf{V}_n(p_r) = \mathbf{V}_n(e_r) = 0.\]</div>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator is also called the <span class="math notranslate nohighlight">\(n\)</span>-th
Verschiebung endomorphism. Its name derives from the Verschiebung
(German for “shift”) endomorphism of the Witt vectors.</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator is adjoint to the <span class="math notranslate nohighlight">\(n\)</span>-th
Frobenius operator (see <a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.frobenius"><code class="xref py py-meth docutils literal notranslate"><span class="pre">frobenius()</span></code></a> for its definition)
with respect to the Hall scalar product (<a class="reference internal" href="#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scalar()</span></code></a>).</p>
<p>The action of the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator on the Schur basis
can also be computed explicitly. The following (probably clumsier
than necessary) description can be obtained by solving exercise
7.61 in Stanley’s <a class="reference internal" href="sf.html#sta" id="id17"><span>[STA]</span></a>.</p>
<p>Let <span class="math notranslate nohighlight">\(\lambda\)</span> be a partition. Let <span class="math notranslate nohighlight">\(n\)</span> be a positive integer. If
the <span class="math notranslate nohighlight">\(n\)</span>-core of <span class="math notranslate nohighlight">\(\lambda\)</span> is nonempty, then
<span class="math notranslate nohighlight">\(\mathbf{V}_n(s_\lambda) = 0\)</span>. Otherwise, the following method
computes <span class="math notranslate nohighlight">\(\mathbf{V}_n(s_\lambda)\)</span>: Write the partition <span class="math notranslate nohighlight">\(\lambda\)</span>
in the form <span class="math notranslate nohighlight">\((\lambda_1, \lambda_2, \ldots, \lambda_{ns})\)</span> for some
nonnegative integer <span class="math notranslate nohighlight">\(s\)</span>. (If <span class="math notranslate nohighlight">\(n\)</span> does not divide the length of
<span class="math notranslate nohighlight">\(\lambda\)</span>, then this is achieved by adding trailing zeroes to
<span class="math notranslate nohighlight">\(\lambda\)</span>.) Set <span class="math notranslate nohighlight">\(\beta_i = \lambda_i + ns - i\)</span> for every
<span class="math notranslate nohighlight">\(s \in \{ 1, 2, \ldots, ns \}\)</span>. Then,
<span class="math notranslate nohighlight">\((\beta_1, \beta_2, \ldots, \beta_{ns})\)</span> is a strictly decreasing
sequence of nonnegative integers. Stably sort the list
<span class="math notranslate nohighlight">\((1, 2, \ldots, ns)\)</span> in order of (weakly) increasing remainder of
<span class="math notranslate nohighlight">\(-1 - \beta_i\)</span> modulo <span class="math notranslate nohighlight">\(n\)</span>. Let <span class="math notranslate nohighlight">\(\xi\)</span> be the sign of the
permutation that is used for this sorting. Let <span class="math notranslate nohighlight">\(\psi\)</span> be the sign
of the permutation that is used to stably sort the list
<span class="math notranslate nohighlight">\((1, 2, \ldots, ns)\)</span> in order of (weakly) increasing remainder of
<span class="math notranslate nohighlight">\(i - 1\)</span> modulo <span class="math notranslate nohighlight">\(n\)</span>. (Notice that <span class="math notranslate nohighlight">\(\psi = (-1)^{n(n-1)s(s-1)/4}\)</span>.)
Then, <span class="math notranslate nohighlight">\(\mathbf{V}_n(s_\lambda) = \xi \psi \prod_{i = 0}^{n - 1}
s_{\lambda^{(i)}}\)</span>, where
<span class="math notranslate nohighlight">\((\lambda^{(0)}, \lambda^{(1)}, \ldots, \lambda^{(n - 1)})\)</span>
is the <span class="math notranslate nohighlight">\(n\)</span>-quotient of <span class="math notranslate nohighlight">\(\lambda\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a positive integer</p></li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator (on the ring of
symmetric functions) to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">s[1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3*p[1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">-18*m[1, 1] - 3*m[2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">h[2]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2*p[1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">12*m[1]</span>
</pre></div>
</div>
<p>The Verschiebung endomorphisms are multiplicative:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">....: </span>          <span class="o">==</span> <span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Being Hopf algebra endomorphisms, the Verschiebung operators
commute with the antipode:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">p</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Testing the adjointness between the Frobenius operators
<span class="math notranslate nohighlight">\(\mathbf{f}_n\)</span> and the Verschiebung operators
<span class="math notranslate nohighlight">\(\mathbf{V}_n\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
<span class="gp">....: </span>          <span class="o">==</span> <span class="n">s</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases">
<em class="property">class </em><code class="sig-prename descclassname">sage.combinat.sf.sfa.</code><code class="sig-name descname">SymmetricFunctionsBases</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parent_with_realization</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/realizations.html#sage.categories.realizations.Category_realization_of_parent" title="(in Sage 9.3 Reference Manual: Category Framework v9.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.realizations.Category_realization_of_parent</span></code></a></p>
<p>The category of bases of the ring of symmetric functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self</span></code> – a category of bases for the symmetric functions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">base</span></code> – ring of symmetric functions</p></li>
</ul>
<dl class="py class">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods">
<em class="property">class </em><code class="sig-name descname">ParentMethods</code><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.Eulerian">
<code class="sig-name descname">Eulerian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">j</span></em>, <em class="sig-param"><span class="n">k</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.Eulerian" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Eulerian symmetric function <span class="math notranslate nohighlight">\(Q_{n,j}\)</span> (with <span class="math notranslate nohighlight">\(n\)</span>
either an integer or a partition) or <span class="math notranslate nohighlight">\(Q_{n,j,k}\)</span> (if the
optional argument <code class="docutils literal notranslate"><span class="pre">k</span></code> is specified) in terms of the basis
<code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>It is known that the Eulerian quasisymmetric functions are
in fact symmetric functions <a class="reference internal" href="../ncsf_qsym/qsym.html#sw2010" id="id18"><span>[SW2010]</span></a>. For more information,
see <a class="reference internal" href="../ncsf_qsym/qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Fundamental.Eulerian" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Fundamental.Eulerian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">QuasiSymmetricFunctions.Fundamental.Eulerian()</span></code></a>,
which accepts the same syntax as this method.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – the nonnegative integer <span class="math notranslate nohighlight">\(n\)</span> or a partition</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">j</span></code> – the number of excedances</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – (optional) if specified, determines the number of fixed
points of the permutations which are being summed over</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">4*m[1, 1, 1] + 3*m[2, 1] + 2*m[3]</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">h[2, 2] + h[3, 1] + h[4]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">s[2, 2, 1] + s[3, 1, 1] + 5*s[3, 2] + 6*s[4, 1] + 6*s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">s[2, 2, 1] + s[3, 2] + s[4, 1] + s[5]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">s[3, 2] + s[4, 1] + s[5]</span>
</pre></div>
</div>
<p>We check Equation (5.4) in <a class="reference internal" href="../ncsf_qsym/qsym.html#sw2010" id="id19"><span>[SW2010]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">h[3, 2, 1] - h[4, 1, 1] + 2*h[4, 2] + h[5, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">Eulerian</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">s[3, 2, 1] + s[3, 3] + 3*s[4, 2] + 3*s[5, 1] + 3*s[6]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.carlitz_shareshian_wachs">
<code class="sig-name descname">carlitz_shareshian_wachs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">comparison</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.carlitz_shareshian_wachs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Carlitz-Shareshian-Wachs symmetric function
<span class="math notranslate nohighlight">\(X_{n, d, s}\)</span> (if <code class="docutils literal notranslate"><span class="pre">comparison</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>), or
<span class="math notranslate nohighlight">\(U_{n, d, s}\)</span> (if <code class="docutils literal notranslate"><span class="pre">comparison</span></code> is <code class="docutils literal notranslate"><span class="pre">-1</span></code>), or
<span class="math notranslate nohighlight">\(V_{n, d, s}\)</span> (if <code class="docutils literal notranslate"><span class="pre">comparison</span></code> is <code class="docutils literal notranslate"><span class="pre">0</span></code>), or
<span class="math notranslate nohighlight">\(W_{n, d, s}\)</span> (if <code class="docutils literal notranslate"><span class="pre">comparison</span></code> is <code class="docutils literal notranslate"><span class="pre">1</span></code>) written in the
basis <code class="docutils literal notranslate"><span class="pre">self</span></code>. These functions are defined below.</p>
<p>The Carlitz-Shareshian-Wachs symmetric functions have been
introduced in <a class="reference internal" href="../../../../references/index.html#grirei18" id="id20"><span>[GriRei18]</span></a>, Exercise 2.9.11, as
refinements of a certain particular case of chromatic
quasisymmetric functions defined by Shareshian and Wachs.
Their definitions are as follows:</p>
<p>Let <span class="math notranslate nohighlight">\(n\)</span>, <span class="math notranslate nohighlight">\(d\)</span> and <span class="math notranslate nohighlight">\(s\)</span> be three nonnegative integers. Let
<span class="math notranslate nohighlight">\(W(n, d, s)\)</span> denote the set of all <span class="math notranslate nohighlight">\(n\)</span>-tuples
<span class="math notranslate nohighlight">\((w_1, w_2, \ldots, w_n)\)</span> of positive integers having the
property that there exist precisely <span class="math notranslate nohighlight">\(d\)</span> elements <span class="math notranslate nohighlight">\(i\)</span>
of <span class="math notranslate nohighlight">\(\left\{ 1, 2, \ldots, n-1 \right\}\)</span> satisfying
<span class="math notranslate nohighlight">\(w_i &gt; w_{i+1}\)</span>, and precisely <span class="math notranslate nohighlight">\(s\)</span> elements <span class="math notranslate nohighlight">\(i\)</span> of
<span class="math notranslate nohighlight">\(\left\{ 1, 2, \ldots, n-1 \right\}\)</span> satisfying
<span class="math notranslate nohighlight">\(w_i = w_{i+1}\)</span>. For every
<span class="math notranslate nohighlight">\(w = (w_1, w_2, \ldots, w_n) \in W(n, d, s)\)</span>, let <span class="math notranslate nohighlight">\(x_w\)</span>
be the monomial <span class="math notranslate nohighlight">\(x_{w_1} x_{w_2} \cdots x_{w_n}\)</span>. We then
define the power series <span class="math notranslate nohighlight">\(X_{n, d, s}\)</span> by</p>
<div class="math notranslate nohighlight">
\[X_{n, d, s} = \sum_{w \in W(n, d, s)} x_w .\]</div>
<p>This is a symmetric function (according to
<a class="reference internal" href="../../../../references/index.html#grirei18" id="id21"><span>[GriRei18]</span></a>, Exercise 2.9.11(b)), and for <span class="math notranslate nohighlight">\(s = 0\)</span> equals
the <span class="math notranslate nohighlight">\(t^d\)</span>-coefficient of the descent enumerator of Smirnov
words of length <span class="math notranslate nohighlight">\(n\)</span> (an example of a chromatic
quasisymmetric function which happens to be symmetric –
see <a class="reference internal" href="#shawach2014" id="id22"><span>[ShaWach2014]</span></a>, Example 2.5).</p>
<p>Assume that <span class="math notranslate nohighlight">\(n &gt; 0\)</span>. Then, we can define three further
power series as follows:</p>
<div class="math notranslate nohighlight">
\[U_{n, d, s} = \sum_{w_1 &lt; w_n} x_w ; \qquad
V_{n, d, s} = \sum_{w_1 = w_n} x_w ; \qquad
W_{n, d, s} = \sum_{w_1 &gt; w_n} x_w ,\]</div>
<p>where all three sums range over
<span class="math notranslate nohighlight">\(w = (w_1, w_2, \ldots, w_n) \in W(n, d, s)\)</span>. These
three power series <span class="math notranslate nohighlight">\(U_{n, d, s}\)</span>, <span class="math notranslate nohighlight">\(V_{n, d, s}\)</span> and
<span class="math notranslate nohighlight">\(W_{n, d, s}\)</span> are symmetric functions as well
(<a class="reference internal" href="../../../../references/index.html#grirei18" id="id23"><span>[GriRei18]</span></a>, Exercise 2.9.11(c)). Their sum is
<span class="math notranslate nohighlight">\(X_{n, d, s}\)</span>.</p>
<p>REFERENCES:</p>
<dl class="citation">
<dt class="label" id="shawach2014"><span class="brackets"><a class="fn-backref" href="#id22">ShaWach2014</a></span></dt>
<dd><p>John Shareshian, Michelle L. Wachs.
<em>Chromatic quasisymmetric functions</em>.
<a class="reference external" href="https://arxiv.org/abs/1405.4629v2">arXiv 1405.4629v2</a>.</p>
</dd>
</dl>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a nonnegative integer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">d</span></code> – a nonnegative integer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> – a nonnegative integer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">comparison</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) – a variable
which can take the forms <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">-1</span></code>, <code class="docutils literal notranslate"><span class="pre">0</span></code>
and <code class="docutils literal notranslate"><span class="pre">1</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<p>The Carlitz-Shareshian-Wachs symmetric function
<span class="math notranslate nohighlight">\(X_{n, d, s}\)</span> (if <code class="docutils literal notranslate"><span class="pre">comparison</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>), or
<span class="math notranslate nohighlight">\(U_{n, d, s}\)</span> (if <code class="docutils literal notranslate"><span class="pre">comparison</span></code> is <code class="docutils literal notranslate"><span class="pre">-1</span></code>), or
<span class="math notranslate nohighlight">\(V_{n, d, s}\)</span> (if <code class="docutils literal notranslate"><span class="pre">comparison</span></code> is <code class="docutils literal notranslate"><span class="pre">0</span></code>), or
<span class="math notranslate nohighlight">\(W_{n, d, s}\)</span> (if <code class="docutils literal notranslate"><span class="pre">comparison</span></code> is <code class="docutils literal notranslate"><span class="pre">1</span></code>) written in the
basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<p>The power series <span class="math notranslate nohighlight">\(X_{n, d, s}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">m[2, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">m[3]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">4*m[1, 1, 1] + m[2, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">m[2, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">m[2, 2, 1] + m[3, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">m[1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">m[]</span>
</pre></div>
</div>
<p>The power series <span class="math notranslate nohighlight">\(U_{n, d, s}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">2*m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">m[2, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">3*m[1, 1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>The power series <span class="math notranslate nohighlight">\(V_{n, d, s}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">m[3]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">m[2, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">m[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">m[1]</span>
</pre></div>
</div>
<p>The power series <span class="math notranslate nohighlight">\(W_{n, d, s}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">m[2, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">2*m[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">m[2, 2, 1] + m[3, 1, 1]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">8*m[1, 1, 1, 1] + 2*m[2, 1, 1] + m[2, 2]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">carlitz_shareshian_wachs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comparison</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.corresponding_basis_over">
<code class="sig-name descname">corresponding_basis_over</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">R</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.corresponding_basis_over" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the realization of symmetric functions corresponding to
<code class="docutils literal notranslate"><span class="pre">self</span></code> but over the base ring <code class="docutils literal notranslate"><span class="pre">R</span></code>. Only works when <code class="docutils literal notranslate"><span class="pre">self</span></code>
is one of the classical bases, not one of the <span class="math notranslate nohighlight">\(q,t\)</span>-dependent
ones. In the latter case, <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned instead.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">R</span></code> – a commutative ring</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Symmetric Functions over Integer Ring in the monomial basis</span>

<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">Integers</span><span class="p">(</span><span class="mi">13</span><span class="p">))</span>
<span class="go">Symmetric Functions over Ring of integers modulo 13 in the Schur basis</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mj</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">J</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">mj</span><span class="o">.</span><span class="n">corresponding_basis_over</span><span class="p">(</span><span class="n">Integers</span><span class="p">(</span><span class="mi">13</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="id24">
<p class="admonition-title">Todo</p>
<p>This function is an ugly hack using strings. It should be
rewritten as soon as the bases of <code class="docutils literal notranslate"><span class="pre">SymmetricFunctions</span></code> are
put on a more robust and systematic footing.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.degree_on_basis">
<code class="sig-name descname">degree_on_basis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">b</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.degree_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degree of the basis element indexed by <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self</span></code> – a basis of the symmetric functions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> – a partition</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q,t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">degree_on_basis</span><span class="p">(</span><span class="n">Partition</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">P</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">degree_on_basis</span><span class="p">(</span><span class="n">Partition</span><span class="p">([]))</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.gessel_reutenauer">
<code class="sig-name descname">gessel_reutenauer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lam</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.gessel_reutenauer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Gessel-Reutenauer symmetric function
corresponding to the partition <code class="docutils literal notranslate"><span class="pre">lam</span></code> written in the basis
<code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(\lambda\)</span> be a partition. The <em>Gessel-Reutenauer
symmetric function</em> <span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> corresponding to
<span class="math notranslate nohighlight">\(\lambda\)</span> is the symmetric function denoted <span class="math notranslate nohighlight">\(L_\lambda\)</span> in
<a class="reference internal" href="#gr1993" id="id25"><span>[GR1993]</span></a> and in Exercise 7.89 of <a class="reference internal" href="sf.html#sta" id="id26"><span>[STA]</span></a> and denoted
<span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> in Definition 6.6.34 of <a class="reference internal" href="../../../../references/index.html#grirei18" id="id27"><span>[GriRei18]</span></a>.
It can be defined in several ways:</p>
<ul>
<li><p>It is the sum of the monomials <span class="math notranslate nohighlight">\(\mathbf{x}_w\)</span> over all
words <span class="math notranslate nohighlight">\(w\)</span> over the alphabet
<span class="math notranslate nohighlight">\(\left\{ 1, 2, 3, \ldots \right\}\)</span> which have CFL type
<span class="math notranslate nohighlight">\(\lambda\)</span>. Here, the monomial <span class="math notranslate nohighlight">\(\mathbf{x}_w\)</span> for a word
<span class="math notranslate nohighlight">\(w = \left(w_1, w_2, \ldots, w_k\right)\)</span> is defined as
<span class="math notranslate nohighlight">\(x_{w_1} x_{w_2} \cdots x_{w_k}\)</span>, and the <em>CFL type</em> of
a word <span class="math notranslate nohighlight">\(w\)</span> is defined as the partition obtained by
sorting (in decreasing order) the lengths of the factors
in the Lyndon factorization
(<a class="reference internal" href="../words/finite_word.html#sage.combinat.words.finite_word.FiniteWord_class.lyndon_factorization" title="sage.combinat.words.finite_word.FiniteWord_class.lyndon_factorization"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lyndon_factorization()</span></code></a>)
of <span class="math notranslate nohighlight">\(w\)</span>. The fact that this power series
<span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> is symmetric is not obvious.</p></li>
<li><p>It is the sum of the fundamental quasisymmetric
functions <span class="math notranslate nohighlight">\(F_{\operatorname{Des} \sigma}\)</span> over all
permutations <span class="math notranslate nohighlight">\(\sigma\)</span> that have cycle type <span class="math notranslate nohighlight">\(\lambda\)</span>. See
<a class="reference internal" href="../ncsf_qsym/qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Fundamental" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Fundamental"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Fundamental</span></code></a>
for the definition of fundamental quasisymmetric functions,
and <a class="reference internal" href="../permutation.html#sage.combinat.permutation.Permutation.cycle_type" title="sage.combinat.permutation.Permutation.cycle_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cycle_type()</span></code></a>
for that of cycle type. For a permutation <span class="math notranslate nohighlight">\(\sigma\)</span>, we use
<span class="math notranslate nohighlight">\(\operatorname{Des} \sigma\)</span> to denote the descent composition
(<a class="reference internal" href="../permutation.html#sage.combinat.permutation.Permutation.descents_composition" title="sage.combinat.permutation.Permutation.descents_composition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">descents_composition()</span></code></a>)
of <span class="math notranslate nohighlight">\(\sigma\)</span>. Again, this definition does not make the
symmetry of <span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> obvious.</p></li>
<li><p>For every positive integer <span class="math notranslate nohighlight">\(n\)</span>, we have</p>
<div class="math notranslate nohighlight">
\[\mathbf{GR}_{\left(n\right)}
= \frac{1}{n} \sum_{d \mid n} \mu(d) p_d^{n/d},\]</div>
<p>where <span class="math notranslate nohighlight">\(p_d\)</span> denotes the <span class="math notranslate nohighlight">\(d\)</span>-th power-sum symmetric
function. This <span class="math notranslate nohighlight">\(\mathbf{GR}_{\left(n\right)}\)</span> is also
denoted by <span class="math notranslate nohighlight">\(L_n\)</span>. Now, <span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> is defined
as the product:</p>
<div class="math notranslate nohighlight">
\[h_{m_1} \left[L_1\right] \cdot h_{m_2} \left[L_2\right]
\cdot h_{m_3} \left[L_3\right] \cdots,\]</div>
<p>where <span class="math notranslate nohighlight">\(m_i\)</span> denotes the multiplicity of the part <span class="math notranslate nohighlight">\(i\)</span> in
<span class="math notranslate nohighlight">\(\lambda\)</span>, and where the square brackets stand for
plethysm (<code class="xref py py-meth docutils literal notranslate"><span class="pre">plethysm()</span></code>). This definition makes
the symmetry (but not the integrality!) of
<span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span> obvious.</p>
</li>
</ul>
<p>The equivalences of these three definitions are proven in
<a class="reference internal" href="#gr1993" id="id28"><span>[GR1993]</span></a> Sections 2-3. (See also <a class="reference internal" href="../../../../references/index.html#grirei18" id="id29"><span>[GriRei18]</span></a> Subsection
6.6.2 for the equivalence of the first two definitions and
further formulas.)</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">lam</span></code> – a partition or a positive integer (in the latter
case, it is understood to mean the partition <code class="docutils literal notranslate"><span class="pre">[lam]</span></code>)</p></li>
</ul>
<p>OUTPUT:</p>
<p>The Gessel-Reutenauer symmetric function
<span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span>, where <span class="math notranslate nohighlight">\(\lambda\)</span> is <code class="docutils literal notranslate"><span class="pre">lam</span></code>,
expanded in the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>REFERENCES:</p>
<dl class="citation">
<dt class="label" id="gr1993"><span class="brackets">GR1993</span><span class="fn-backref">(<a href="#id25">1</a>,<a href="#id28">2</a>,<a href="#id30">3</a>)</span></dt>
<dd><p>Ira M. Gessel, Christophe Reutenauer.
<em>Counting Permutations with Given Cycle Structure
and Descent Set</em>.
Journal of Combinatorial Theory, Series A, 64 (1993),
pp. 189–215.</p>
</dd>
</dl>
<p>EXAMPLES:</p>
<p>The first few values of <span class="math notranslate nohighlight">\(\mathbf{GR}_{(n)} = L_n\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">h[1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">h[1, 1] - h[2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">h[2, 1] - h[3]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">h[2, 1, 1] - h[2, 2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">h[2, 1, 1, 1] - h[2, 2, 1] - h[3, 1, 1] + h[3, 2] + h[4, 1] - h[5]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">h[2, 1, 1, 1, 1] - h[2, 2, 1, 1] - h[2, 2, 2]</span>
<span class="go"> - 2*h[3, 1, 1, 1] + 5*h[3, 2, 1] - 2*h[3, 3] + h[4, 1, 1]</span>
<span class="go"> - h[4, 2] - h[5, 1] + h[6]</span>
</pre></div>
</div>
<p>Gessel-Reutenauer functions indexed by partitions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">h[1, 1, 1] - h[2, 1]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">h[1, 1, 1, 1] - 3*h[2, 1, 1] + 2*h[2, 2] + h[3, 1] - h[4]</span>
</pre></div>
</div>
<p>The Gessel-Reutenauer functions are Schur-positive:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1] + s[2, 1]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">s[1, 1, 1, 1, 1] + s[2, 1, 1, 1] + s[2, 2, 1] + s[3, 2]</span>
</pre></div>
</div>
<p>They do not form a basis, as the following example (from
<a class="reference internal" href="#gr1993" id="id30"><span>[GR1993]</span></a> p. 201) shows:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Of the above three equivalent definitions of
<span class="math notranslate nohighlight">\(\mathbf{GR}_\lambda\)</span>, we use the third one for
computations. Let us check that the second one gives the
same results:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QSym</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QSym</span><span class="o">.</span><span class="n">F</span><span class="p">()</span> <span class="c1"># fundamental basis</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">GR_def2</span><span class="p">(</span><span class="n">lam</span><span class="p">):</span> <span class="c1"># `\mathbf{GR}_\lambda`</span>
<span class="gp">....: </span>    <span class="n">n</span> <span class="o">=</span> <span class="n">lam</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="n">r</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">sum_of_monomials</span><span class="p">([</span><span class="n">sigma</span><span class="o">.</span><span class="n">descents_composition</span><span class="p">()</span>
<span class="gp">....: </span>                            <span class="k">for</span> <span class="n">sigma</span> <span class="ow">in</span> <span class="n">Permutations</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">....: </span>                            <span class="k">if</span> <span class="n">sigma</span><span class="o">.</span><span class="n">cycle_type</span><span class="p">()</span> <span class="o">==</span> <span class="n">lam</span><span class="p">])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">GR_def2</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>And the first one, too (assuming symmetry):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">GR_def1</span><span class="p">(</span><span class="n">lam</span><span class="p">):</span> <span class="c1"># `\mathbf{GR}_\lambda`</span>
<span class="gp">....: </span>    <span class="n">n</span> <span class="o">=</span> <span class="n">lam</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="n">Permus_mset</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">permutation</span><span class="o">.</span><span class="n">Permutations_mset</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">coeff_of_m_mu_in_result</span><span class="p">(</span><span class="n">mu</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">words_to_check</span> <span class="o">=</span> <span class="n">Permus_mset</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
<span class="gp">....: </span>                                      <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">)])</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="mi">1</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">words_to_check</span> <span class="k">if</span>
<span class="gp">....: </span>                    <span class="n">Partition</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Word</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">lyndon_factorization</span><span class="p">()]))))</span>
<span class="gp">....: </span>                    <span class="o">==</span> <span class="n">lam</span><span class="p">))</span>
<span class="gp">....: </span>    <span class="n">r</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">sum_of_terms</span><span class="p">([(</span><span class="n">mu</span><span class="p">,</span> <span class="n">coeff_of_m_mu_in_result</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>
<span class="gp">....: </span>                        <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)],</span>
<span class="gp">....: </span>                       <span class="n">distinct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">r</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">GR_def1</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">gessel_reutenauer</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The currently existing implementation of this function is
technically unsatisfactory. It distinguishes the case when the
base ring is a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra from the case
where it isn’t. In the latter, it does a computation using
universal coefficients, again distinguishing the case when it is
able to compute the “corresponding” basis of the symmetric function
algebra over <span class="math notranslate nohighlight">\(\QQ\)</span> (using the <code class="docutils literal notranslate"><span class="pre">corresponding_basis_over</span></code> hack)
from the case when it isn’t (in which case it transforms everything
into the Schur basis, which is slow).</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_commutative">
<code class="sig-name descname">is_commutative</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_commutative" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether this symmetric function algebra is commutative.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self</span></code> – a basis of the symmetric functions</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_field">
<code class="sig-name descname">is_field</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">proof</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether <code class="docutils literal notranslate"><span class="pre">self</span></code> is a field. (It is not.)</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self</span></code> – a basis of the symmetric functions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">proof</span></code> – an optional argument (default value: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">is_field</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_integral_domain">
<code class="sig-name descname">is_integral_domain</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">proof</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.is_integral_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether <code class="docutils literal notranslate"><span class="pre">self</span></code> is an integral domain. (It is if
and only if the base ring is an integral domain.)</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self</span></code> – a basis of the symmetric functions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">proof</span></code> – an optional argument (default value: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">is_integral_domain</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The following doctest is disabled pending <a class="reference external" href="https://trac.sagemath.org/15475">trac ticket #15475</a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">Zmod</span><span class="p">(</span><span class="mi">14</span><span class="p">))</span><span class="o">.</span><span class="n">s</span><span class="p">()</span> <span class="c1"># not tested</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">is_integral_domain</span><span class="p">()</span> <span class="c1"># not tested</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.one_basis">
<code class="sig-name descname">one_basis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.one_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the empty partition, as per <code class="docutils literal notranslate"><span class="pre">AlgebrasWithBasis.ParentMethods.one_basis</span></code></p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self</span></code> – a basis of the ring of symmetric functions</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">one_basis</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">one_basis</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="id31">
<p class="admonition-title">Todo</p>
<p>generalize to Modules.Graded.Connected.ParentMethods</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.skew_schur">
<code class="sig-name descname">skew_schur</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.ParentMethods.skew_schur" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the skew Schur function indexed by <code class="docutils literal notranslate"><span class="pre">x</span></code> in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – a skew partition</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sp</span> <span class="o">=</span> <span class="n">SkewPartition</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">skew_schur</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
<span class="go">s[2, 2, 1, 1] + s[2, 2, 2] + s[3, 1, 1, 1] + 3*s[3, 2, 1]</span>
<span class="go"> + s[3, 3] + 2*s[4, 1, 1] + 2*s[4, 2] + s[5, 1]</span>

<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ess</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">skew_schur</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span> <span class="n">ess</span>
<span class="go">e[2, 1, 1, 1, 1] - e[2, 2, 1, 1] - e[3, 1, 1, 1] + e[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">ess</span> <span class="o">==</span> <span class="n">e</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">skew_schur</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="sage.combinat.sf.sfa.SymmetricFunctionsBases.super_categories">
<code class="sig-name descname">super_categories</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.SymmetricFunctionsBases.super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>The super categories of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.sf.sfa</span> <span class="kn">import</span> <span class="n">SymmetricFunctionsBases</span>
<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bases</span> <span class="o">=</span> <span class="n">SymmetricFunctionsBases</span><span class="p">(</span><span class="n">Sym</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bases</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of realizations of Symmetric Functions over Rational Field,</span>
<span class="go"> Category of commutative hopf algebras with basis over Rational Field,</span>
<span class="go"> Join of Category of realizations of hopf algebras over Rational Field</span>
<span class="go">     and Category of graded algebras over Rational Field</span>
<span class="go">     and Category of graded coalgebras over Rational Field]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="sage.combinat.sf.sfa.is_SymmetricFunction">
<code class="sig-prename descclassname">sage.combinat.sf.sfa.</code><code class="sig-name descname">is_SymmetricFunction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.is_SymmetricFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether <code class="docutils literal notranslate"><span class="pre">x</span></code> is a symmetric function.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.sf.sfa</span> <span class="kn">import</span> <span class="n">is_SymmetricFunction</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunction</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunction</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunction</span><span class="p">(</span><span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sage.combinat.sf.sfa.is_SymmetricFunctionAlgebra">
<code class="sig-prename descclassname">sage.combinat.sf.sfa.</code><code class="sig-name descname">is_SymmetricFunctionAlgebra</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.is_SymmetricFunctionAlgebra" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether <code class="docutils literal notranslate"><span class="pre">x</span></code> is a symmetric function algebra.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.sf.sfa</span> <span class="kn">import</span> <span class="n">is_SymmetricFunctionAlgebra</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunctionAlgebra</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunctionAlgebra</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunctionAlgebra</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunctionAlgebra</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunctionAlgebra</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">macdonald</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">P</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_SymmetricFunctionAlgebra</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">P</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sage.combinat.sf.sfa.zee">
<code class="sig-prename descclassname">sage.combinat.sf.sfa.</code><code class="sig-name descname">zee</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">part</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sfa.zee" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of the centralizer of any permutation of cycle type
<code class="docutils literal notranslate"><span class="pre">part</span></code>.</p>
<p>Note that the size of the centralizer is the inner product between
<code class="docutils literal notranslate"><span class="pre">p(part)</span></code> and itself, where <span class="math notranslate nohighlight">\(p\)</span> is the power-sum symmetric
functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">part</span></code> – an integer partition (for example, <code class="docutils literal notranslate"><span class="pre">[2,1,1]</span></code>)</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the integer <span class="math notranslate nohighlight">\(\prod_{i} i^{m_i(part)} m_i(part)!\)</span> where <span class="math notranslate nohighlight">\(m_i(part)\)</span> is
the number of parts in the partition <code class="docutils literal notranslate"><span class="pre">part</span></code> equal to <span class="math notranslate nohighlight">\(i\)</span></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.sf.sfa</span> <span class="kn">import</span> <span class="n">zee</span>
<span class="gp">sage: </span><span class="n">zee</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="sf.html"
                        title="previous chapter">Symmetric functions, with their multiple realizations</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="witt.html"
                        title="next chapter">Witt symmetric functions</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/sage/combinat/sf/sfa.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="witt.html" title="Witt symmetric functions"
             >next</a> |</li>
        <li class="right" >
          <a href="sf.html" title="Symmetric functions, with their multiple realizations"
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Sage 9.3 Reference Manual: Combinatorics</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../../module_list.html" >Comprehensive Module list</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Symmetric Functions</a></li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2021, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>