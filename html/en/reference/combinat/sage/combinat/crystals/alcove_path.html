<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Alcove paths &mdash; Sage Reference Manual v6.9: Combinatorics</title>
    
    <link rel="stylesheet" href="../../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '6.9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v6.9: Combinatorics" href="../../../index.html" />
    <link rel="up" title="Comprehensive Module list" href="../../../module_list.html" />
    <link rel="next" title="Crystal features that are imported by default in the interpreter namespace" href="all.html" />
    <link rel="prev" title="Affinization Crystals" href="affinization.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="all.html" title="Crystal features that are imported by default in the interpreter namespace"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="affinization.html" title="Affinization Crystals"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../../index.html">Combinatorics</a> &raquo;</li>

          <li><a href="../../../module_list.html" accesskey="U">Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="alcove-paths">
<span id="sage-combinat-crystals-alcove-path"></span><h1>Alcove paths<a class="headerlink" href="#alcove-paths" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.crystals.alcove_path"></span><p>AUTHORS:</p>
<ul class="simple">
<li>Brant Jones (2008): initial version</li>
<li>Arthur Lubovsky (2013-03-07): rewritten to implement affine type</li>
</ul>
<p>Special thanks to: Nicolas Borie, Anne Schilling, Travis Scrimshaw, and
Nicolas Thiery.</p>
<dl class="class">
<dt id="sage.combinat.crystals.alcove_path.CrystalOfAlcovePaths">
<em class="property">class </em><tt class="descclassname">sage.combinat.crystals.alcove_path.</tt><tt class="descname">CrystalOfAlcovePaths</tt><big>(</big><em>starting_weight</em>, <em>highest_weight_crystal</em><big>)</big><a class="headerlink" href="#sage.combinat.crystals.alcove_path.CrystalOfAlcovePaths" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Basic Structures v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></tt></a>, <a class="reference external" href="../../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage Reference Manual: Basic Structures v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.parent.Parent</span></tt></a></p>
<p>Crystal of alcove paths generated from a &#8220;straight-line&#8221; path to the
negative of a given dominant weight.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">cartan_type</span></tt> &#8211; Cartan type of a finite or affine untwisted root
system.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">weight</span></tt> &#8211; Dominant weight as a list of (integral) coefficients of
the fundamental weights.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">highest_weight_crystal</span></tt> &#8211; (Default: <tt class="docutils literal"><span class="pre">True</span></tt>) If <tt class="docutils literal"><span class="pre">True</span></tt>
returns the highest weight crystal.  If <tt class="docutils literal"><span class="pre">False</span></tt> returns an
object which is close to being isomorphic to the tensor product
of Kirillov-Reshetikhin crystals of column shape in the
following sense: We get all the vertices, but only some of the
edges.  We&#8217;ll call the included edges pseudo-Demazure.  They are
all non-zero edges and the 0-edges not at the end of a 0-string
of edges, i.e.  not those with <span class="math">\(f_{0}(b) = b'\)</span> with
<span class="math">\(\varphi_0(b) =1\)</span>.  (Whereas Demazure 0-edges are those that
are not at the beginning of a zero string.) In this case the
weight <span class="math">\([c_1, c_2, \ldots, c_k]\)</span> represents
<span class="math">\(\sum_{i=1}^k c_i \omega_i\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <tt class="docutils literal"><span class="pre">highest_weight_crystal</span></tt> = <tt class="docutils literal"><span class="pre">False</span></tt>, since we do not
get the full crystal, <tt class="docutils literal"><span class="pre">TestSuite</span></tt> will fail on the
Stembridge axioms.</p>
</div>
</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="../../../../categories/sage/categories/crystals.html#sage.categories.crystals.Crystals" title="(in Sage Reference Manual: Category Framework v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">Crystals</span></tt></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>The following example appears in Figure 2 of <a class="reference internal" href="#lp2008" id="id1">[LP2008]</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;G&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">digraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">GG</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span>
<span class="go">....:     ()        : {(0)         : 2 },</span>
<span class="go">....:     (0)       : {(0,8)       : 1 },</span>
<span class="go">....:     (0,1)     : {(0,1,7)     : 2 },</span>
<span class="go">....:     (0,1,2)   : {(0,1,2,9)   : 1 },</span>
<span class="go">....:     (0,1,2,3) : {(0,1,2,3,4) : 2 },</span>
<span class="go">....:     (0,1,2,6) : {(0,1,2,3)   : 1 },</span>
<span class="go">....:     (0,1,2,9) : {(0,1,2,6)   : 1 },</span>
<span class="go">....:     (0,1,7)   : {(0,1,2)     : 2 },</span>
<span class="go">....:     (0,1,7,9) : {(0,1,2,9)   : 2 },</span>
<span class="go">....:     (0,5)     : {(0,1)       : 1, (0,5,7) : 2 },</span>
<span class="go">....:     (0,5,7)   : {(0,5,7,9)   : 1 },</span>
<span class="go">....:     (0,5,7,9) : {(0,1,7,9)   : 1 },</span>
<span class="go">....:     (0,8)     : {(0,5)       : 1 },</span>
<span class="go">....:     })</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">GG</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span> <span class="k">print</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">integer_sequence</span><span class="p">()</span> <span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">integer_sequence</span><span class="p">(),</span> <span class="n">i</span><span class="p">)</span>
<span class="go">([], [0], 2)</span>
<span class="go">([0], [0, 8], 1)</span>
<span class="go">([0, 1], [0, 1, 7], 2)</span>
<span class="go">([0, 1, 2], [0, 1, 2, 9], 1)</span>
<span class="go">([0, 1, 2, 3], [0, 1, 2, 3, 4], 2)</span>
<span class="go">([0, 1, 2, 6], [0, 1, 2, 3], 1)</span>
<span class="go">([0, 1, 2, 9], [0, 1, 2, 6], 1)</span>
<span class="go">([0, 1, 7], [0, 1, 2], 2)</span>
<span class="go">([0, 1, 7, 9], [0, 1, 2, 9], 2)</span>
<span class="go">([0, 5], [0, 1], 1)</span>
<span class="go">([0, 5], [0, 5, 7], 2)</span>
<span class="go">([0, 5, 7], [0, 5, 7, 9], 1)</span>
<span class="go">([0, 5, 7, 9], [0, 1, 7, 9], 1)</span>
<span class="go">([0, 8], [0, 5], 1)</span>
</pre></div>
</div>
<p>Alcove path crystals are a discrete version of Littelmann paths.
We verify that the alcove path crystal is isomorphic to the LS
path crystal:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C1</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;C&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">g1</span> <span class="o">=</span> <span class="n">C1</span><span class="o">.</span><span class="n">digraph</span><span class="p">()</span> <span class="c">#long time</span>
<span class="gp">sage: </span><span class="n">C2</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">LSPaths</span><span class="p">([</span><span class="s">&#39;C&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">g2</span> <span class="o">=</span> <span class="n">C2</span><span class="o">.</span><span class="n">digraph</span><span class="p">()</span> <span class="c">#long time</span>
<span class="gp">sage: </span><span class="n">g1</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">g2</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c">#long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The preferred initialization method is via explicit weights rather than a Cartan type
and the coefficients of the fundamental weights:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s">&#39;C&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">La</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">La</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">La</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span> <span class="n">C</span>
<span class="go">Highest weight crystal of alcove paths of type [&#39;C&#39;, 3] and weight 2*Lambda[1] + Lambda[2]</span>
<span class="gp">sage: </span><span class="n">C1</span><span class="o">==</span><span class="n">C</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We now explain the data structure:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="p">;</span> <span class="n">C</span>
<span class="go">Highest weight crystal of alcove paths of type [&#39;A&#39;, 2] and weight 2*Lambda[1]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">_R</span><span class="o">.</span><span class="n">lambda_chain</span><span class="p">()</span>
<span class="go">[(alpha[1], 0), (alpha[1] + alpha[2], 0), (alpha[1], 1), (alpha[1] + alpha[2], 1)]</span>
</pre></div>
</div>
<p>The previous list gives the initial &#8220;straight line&#8221; path from the
fundamental alcove <span class="math">\(A_o\)</span> to its translation  <span class="math">\(A_o - \lambda\)</span> where
<span class="math">\(\lambda = 2\omega_1\)</span> in this example. The initial path for weight
<span class="math">\(\lambda\)</span> is called the <span class="math">\(\lambda\)</span>-chain. This path is constructed from
the ordered pairs <span class="math">\((\beta, k)\)</span>, by crossing the hyperplane orthogonal to
<span class="math">\(\beta\)</span> at height <span class="math">\(-k\)</span>. We can view a plot of this path as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span><span class="o">=</span><span class="n">C</span><span class="p">(</span> <span class="p">()</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c"># not tested - outputs a pdf</span>
</pre></div>
</div>
<p>An element of the crystal is given by a subset of the <span class="math">\(\lambda\)</span>-chain.
This subset indicates the hyperplanes where the initial path should be
folded. The highest weight element is given by the empty subset.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span>
<span class="go">()</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">((alpha[1], 1), (alpha[1] + alpha[2], 1))</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">integer_sequence</span><span class="p">()</span>
<span class="go">[2, 3]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">((alpha[1], 1), (alpha[1] + alpha[2], 1))</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">is_admissible</span><span class="p">()</span> <span class="c">#check if a valid vertex</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">is_admissible</span><span class="p">()</span> <span class="c">#check if a valid vertex</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Alcove path crystals now works in affine type (<a class="reference external" href="http://trac.sagemath.org/14143">trac ticket #14143</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="p">;</span> <span class="n">C</span>
<span class="go">Highest weight crystal of alcove paths of type [&#39;A&#39;, 2, 1] and weight Lambda[0]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">=</span><span class="n">C</span><span class="p">(</span>  <span class="p">()</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">((alpha[0], 0),)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">R</span>
<span class="go">Root system of type [&#39;A&#39;, 2, 1]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">weight</span>
<span class="go">Lambda[0]</span>
</pre></div>
</div>
<p>Test that the tensor products of Kirillov-Reshetikhin crystals
minus non-pseudo-Demazure arrows is in bijection with alcove path
construction:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">KirillovReshetikhin</span><span class="p">([</span><span class="s">&#39;B&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">TensorProduct</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">K</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">digraph</span><span class="p">()</span> <span class="c">#long time</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span> <span class="c">#long time</span>
<span class="go">....:     if e[0].phi(0) == 1 and e[2] == 0: #long time</span>
<span class="go">....:         g.delete_edge(e)  #long time</span>

<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;B&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">highest_weight_crystal</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">digraph_fast</span><span class="p">()</span> <span class="c">#long time</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">g2</span><span class="p">,</span> <span class="n">edge_labels</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span> <span class="c">#long time</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In type <span class="math">\(C_n^{(1)}\)</span>, the Kirillov-Reshetikhin crystal is not connected
when restricted to pseudo-Demazure arrows, hence the previous example will
fail for type <span class="math">\(C_n^{(1)}\)</span> crystals.</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s">&#39;B&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">La</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">La</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">highest_weight_crystal</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">==</span> <span class="n">D</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Weights from finite root systems index non-highest weight crystals.</p>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="lp2008" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[LP2008]</a></td><td>C. Lenart and A. Postnikov. <em>A combinatorial model for
crystals of Kac-Moody algebras</em>. Trans. Amer. Math. Soc. 360 (2008),
4349-4381.</td></tr>
</tbody>
</table>
<dl class="attribute">
<dt id="sage.combinat.crystals.alcove_path.CrystalOfAlcovePaths.Element">
<tt class="descname">Element</tt><a class="headerlink" href="#sage.combinat.crystals.alcove_path.CrystalOfAlcovePaths.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement" title="sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement"><tt class="xref py py-class docutils literal"><span class="pre">CrystalOfAlcovePathsElement</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.crystals.alcove_path.CrystalOfAlcovePaths.digraph_fast">
<tt class="descname">digraph_fast</tt><big>(</big><em>depth=None</em><big>)</big><a class="headerlink" href="#sage.combinat.crystals.alcove_path.CrystalOfAlcovePaths.digraph_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the crystal <a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">graph</span></tt></a> with maximum depth
<tt class="docutils literal"><span class="pre">depth</span></tt> deep starting at the module generator. Significant speed up
for highest_weight_crystals of affine type.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">digraph_fast</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Digraph on 7 vertices</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>The following example demonstrates the speed improvement.
The speedup in non-affine types is small however:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">cartan_type</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="c">#long time</span>
<span class="gp">sage: </span><span class="n">weight</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c">#long time</span>
<span class="gp">sage: </span><span class="n">depth</span> <span class="o">=</span> <span class="mi">5</span> <span class="c">#long time</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">(</span><span class="n">cartan_type</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span> <span class="c">#long time</span>
<span class="gp">sage: </span><span class="o">%</span><span class="n">timeit</span> <span class="n">C</span><span class="o">.</span><span class="n">digraph_fast</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span> <span class="c"># not tested</span>
<span class="go">10 loops, best of 3: 171 ms per loop</span>
<span class="gp">sage: </span><span class="o">%</span><span class="n">timeit</span> <span class="n">C</span><span class="o">.</span><span class="n">digraph</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">subcrystal</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s">&#39;lower&#39;</span><span class="p">))</span> <span class="c">#not tested</span>
<span class="go">1 loops, best of 3: 19.7 s per loop</span>
<span class="gp">sage: </span><span class="n">G1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">digraph_fast</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span> <span class="c">#long time</span>
<span class="gp">sage: </span><span class="n">G2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">digraph</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">subcrystal</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s">&#39;lower&#39;</span><span class="p">))</span> <span class="c">#long time</span>
<span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">G2</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c">#long time</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.crystals.alcove_path.CrystalOfAlcovePaths.vertices">
<tt class="descname">vertices</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.crystals.alcove_path.CrystalOfAlcovePaths.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of all the vertices of the crystal.</p>
<p>The vertices are represented as lists of integers recording the folding
positions.</p>
<p>One can compute all vertices of the crystal by finding all the
admissible subsets of the <span class="math">\(\lambda\)</span>-chain  (see method
is_admissible, for definition).  We use the breath first
search algorithm.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This method is (currently) only useful for the case when
<tt class="docutils literal"><span class="pre">highest_weight_crystal</span> <span class="pre">=</span> <span class="pre">False</span></tt>, where you cannot always
reach all vertices of the crystal using crystal operators,
starting from the highest weight vertex.  This method is
typically slower than generating the crystal graph using
crystal operators.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;C&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[[], [0], [0, 1], [0, 1, 2]]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;C&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
<span class="go">80</span>
</pre></div>
</div>
<p>The number of elements reachable using the crystal operators from the
module generator:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="p">))</span>
<span class="go">55</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.crystals.alcove_path.CrystalOfAlcovePaths.weight_lattice_realization">
<tt class="descname">weight_lattice_realization</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.crystals.alcove_path.CrystalOfAlcovePaths.weight_lattice_realization" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the weight lattice realization of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">weight_lattice_realization</span><span class="p">()</span>
<span class="go">Extended weight lattice of the Root system of type [&#39;A&#39;, 2, 1]</span>

<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">(</span><span class="s">&quot;B3&quot;</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">weight_lattice_realization</span><span class="p">()</span>
<span class="go">Ambient space of the Root system of type [&#39;B&#39;, 3]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement">
<em class="property">class </em><tt class="descclassname">sage.combinat.crystals.alcove_path.</tt><tt class="descname">CrystalOfAlcovePathsElement</tt><a class="headerlink" href="#sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/element_wrapper.html#sage.structure.element_wrapper.ElementWrapper" title="(in Sage Reference Manual: Basic Structures v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.element_wrapper.ElementWrapper</span></tt></a></p>
<p>Crystal of alcove paths element.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">data</span></tt> &#8211; a list of folding positions in the lambda chain (indexing
starts at 0) or a tuple of <a class="reference internal" href="#sage.combinat.crystals.alcove_path.RootsWithHeight" title="sage.combinat.crystals.alcove_path.RootsWithHeight"><tt class="xref py py-class docutils literal"><span class="pre">RootsWithHeight</span></tt></a> giving folding
positions in the lambda chain.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">C</span> <span class="p">(</span> <span class="p">()</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">((alpha[1], 2), (alpha[1] + alpha[2], 4))</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">integer_sequence</span><span class="p">()</span>
<span class="go">[8, 9]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>
<span class="go">((alpha[1], 2), (alpha[1] + alpha[2], 4))</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement.e">
<tt class="descname">e</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement.e" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <span class="math">\(i\)</span>-th crystal raising operator on <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">i</span></tt> &#8211; element of the index set of the underlying root system.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]);</span> <span class="n">C</span>
<span class="go">Highest weight crystal of alcove paths of type [&#39;A&#39;, 2] and weight 2*Lambda[1]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span> <span class="p">()</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">e</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement.epsilon">
<tt class="descname">epsilon</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement.epsilon" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the distance to the start of the <span class="math">\(i\)</span>-string.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">epsilon</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">C</span><span class="p">]</span>
<span class="go">[0, 1, 0, 0, 1, 0, 2, 1]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">epsilon</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">C</span><span class="p">]</span>
<span class="go">[0, 0, 1, 1, 0, 2, 0, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement.f">
<tt class="descname">f</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement.f" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <span class="math">\(i\)</span>-th crystal lowering operator on <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">i</span></tt> &#8211; element of the index_set of the underlying root_system.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span><span class="o">=</span><span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;B&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">=</span><span class="n">C</span><span class="p">(</span>  <span class="p">()</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">((alpha[1], 0),)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">((alpha[1], 0), (alpha[1] + alpha[2], 2))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement.integer_sequence">
<tt class="descname">integer_sequence</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement.integer_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of integers corresponding to positions in
the <span class="math">\(\lambda\)</span>-chain where it is folded.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Incorporate this method into the <tt class="docutils literal"><span class="pre">_repr_</span></tt> for finite Cartan type.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Only works for finite Cartan types and indexing starts at 0.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span> <span class="p">()</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">integer_sequence</span><span class="p">()</span>
<span class="go">[8, 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement.is_admissible">
<tt class="descname">is_admissible</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement.is_admissible" title="Permalink to this definition">¶</a></dt>
<dd><p>Diagnostic test to check if <tt class="docutils literal"><span class="pre">self</span></tt> is a valid element of the crystal.</p>
<p>If <tt class="docutils literal"><span class="pre">self.value</span></tt> is given by</p>
<div class="math">
\[(\beta_1, i_1), (\beta_2, i_2), \ldots, (\beta_k, i_k),\]</div>
<p>for highest weight crystals this checks if the sequence</p>
<div class="math">
\[1 \rightarrow s_{\beta_1} \rightarrow
s_{\beta_1}s_{\beta_2} \rightarrow \cdots \rightarrow
s_{\beta_1}s_{\beta_2} \ldots s_{\beta_k}\]</div>
<p>is a path in the Bruhat graph. If <tt class="docutils literal"><span class="pre">highest_weight_crystal=False</span></tt>,
then the method checks if the above sequence is a path in the quantum
Bruhat graph.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span> <span class="n">C</span>
<span class="go">Highest weight crystal of alcove paths of type [&#39;A&#39;, 2] and weight Lambda[1] + Lambda[2]</span>
<span class="gp">sage: </span><span class="n">roots</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">_R</span><span class="o">.</span><span class="n">_root_lattice</span><span class="o">.</span><span class="n">positive_roots</span><span class="p">()));</span> <span class="n">roots</span>
<span class="go">[alpha[1], alpha[1] + alpha[2], alpha[2]]</span>
<span class="gp">sage: </span><span class="n">r1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">_R</span><span class="p">(</span><span class="n">roots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">);</span> <span class="n">r1</span>
<span class="go">(alpha[1], 0)</span>
<span class="gp">sage: </span><span class="n">r2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">_R</span><span class="p">(</span><span class="n">roots</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">);</span> <span class="n">r2</span>
<span class="go">(alpha[2], 0)</span>
<span class="gp">sage: </span><span class="n">r3</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">_R</span><span class="p">(</span><span class="n">roots</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">);</span> <span class="n">r3</span>
<span class="go">(alpha[1] + alpha[2], 1)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span> <span class="p">(</span> <span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">is_admissible</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span> <span class="p">(</span><span class="n">r3</span><span class="p">,)</span> <span class="p">);</span> <span class="n">x</span>
<span class="go">((alpha[1] + alpha[2], 1),)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">is_admissible</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;C&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span><span class="o">.</span><span class="n">is_admissible</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">is_admissible</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">Better doctest</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement.phi">
<tt class="descname">phi</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement.phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the distance to the end of the <span class="math">\(i\)</span>-string.</p>
<p>This method overrides the generic implementation in the category of
crystals since this computation is more efficient.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">C</span><span class="p">]</span>
<span class="go">[1, 0, 2, 0, 1, 1, 0, 0]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">C</span><span class="p">]</span>
<span class="go">[1, 2, 0, 1, 0, 0, 1, 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement.plot">
<tt class="descname">plot</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a plot <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only implemented for types <span class="math">\(A_2\)</span>, <span class="math">\(B_2\)</span>, and <span class="math">\(C_2\)</span>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span> <span class="p">()</span> <span class="p">)</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c"># Not tested - creates a pdf</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement.weight">
<tt class="descname">weight</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.crystals.alcove_path.CrystalOfAlcovePathsElement.weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the weight of self.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">C</span><span class="p">:</span> <span class="n">i</span><span class="o">.</span><span class="n">weight</span><span class="p">()</span>
<span class="go">2*Lambda[1]</span>
<span class="go">Lambda[2]</span>
<span class="go">Lambda[1] - Lambda[2]</span>
<span class="go">-2*Lambda[1] + 2*Lambda[2]</span>
<span class="go">-Lambda[1]</span>
<span class="go">-2*Lambda[2]</span>

<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">module_generators</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">f_string</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">weight</span><span class="p">()</span>
<span class="go">Lambda[0] - delta</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.crystals.alcove_path.RootsWithHeight">
<em class="property">class </em><tt class="descclassname">sage.combinat.crystals.alcove_path.</tt><tt class="descname">RootsWithHeight</tt><big>(</big><em>weight</em><big>)</big><a class="headerlink" href="#sage.combinat.crystals.alcove_path.RootsWithHeight" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Basic Structures v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></tt></a>, <a class="reference external" href="../../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage Reference Manual: Basic Structures v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.parent.Parent</span></tt></a></p>
<p>Data structure of the ordered pairs <span class="math">\((\beta,k)\)</span>,
where <span class="math">\(\beta\)</span> is a positive root and <span class="math">\(k\)</span> is a non-negative integer. A total
order is implemented on this set, and depends on the weight.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">cartan_type</span></tt> &#8211; Cartan type of a finite or affine untwisted root
system</li>
<li><tt class="docutils literal"><span class="pre">weight</span></tt> &#8211; dominant weight as a list of (integral) coefficients of
the fundamental weights</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.crystals.alcove_path</span> <span class="kn">import</span> <span class="n">RootsWithHeight</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">RootsWithHeight</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span> <span class="n">R</span>
<span class="go">Roots with height of Cartan type [&#39;A&#39;, 2] and dominant weight Lambda[1] + Lambda[2]</span>

<span class="gp">sage: </span><span class="n">r1</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">_root_lattice</span><span class="o">.</span><span class="n">from_vector</span><span class="p">(</span><span class="n">vector</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]));</span> <span class="n">r1</span>
<span class="go">alpha[1]</span>
<span class="gp">sage: </span><span class="n">r2</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">_root_lattice</span><span class="o">.</span><span class="n">from_vector</span><span class="p">(</span><span class="n">vector</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]));</span> <span class="n">r2</span>
<span class="go">alpha[1] + alpha[2]</span>

<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span> <span class="n">x</span>
<span class="go">(alpha[1], 0)</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="n">r2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="n">y</span>
<span class="go">(alpha[1] + alpha[2], 1)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="sage.combinat.crystals.alcove_path.RootsWithHeight.Element">
<tt class="descname">Element</tt><a class="headerlink" href="#sage.combinat.crystals.alcove_path.RootsWithHeight.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.crystals.alcove_path.RootsWithHeightElement" title="sage.combinat.crystals.alcove_path.RootsWithHeightElement"><tt class="xref py py-class docutils literal"><span class="pre">RootsWithHeightElement</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.crystals.alcove_path.RootsWithHeight.lambda_chain">
<tt class="descname">lambda_chain</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.crystals.alcove_path.RootsWithHeight.lambda_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unfolded <span class="math">\(\lambda\)</span>-chain.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Only works in root systems of finite type.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.crystals.alcove_path</span> <span class="kn">import</span> <span class="n">RootsWithHeight</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">RootsWithHeight</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span> <span class="n">R</span>
<span class="go">Roots with height of Cartan type [&#39;A&#39;, 2] and dominant weight Lambda[1] + Lambda[2]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">lambda_chain</span><span class="p">()</span>
<span class="go">[(alpha[2], 0), (alpha[1] + alpha[2], 0), (alpha[1], 0), (alpha[1] + alpha[2], 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.crystals.alcove_path.RootsWithHeight.word">
<tt class="descname">word</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.crystals.alcove_path.RootsWithHeight.word" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the initial alcove path (<span class="math">\(\lambda\)</span>-chain) in terms of simple
roots. Used for plotting the path.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only implemented for finite Cartan types.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.crystals.alcove_path</span> <span class="kn">import</span> <span class="n">RootsWithHeight</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">RootsWithHeight</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">word</span><span class="p">()</span>
<span class="go">[2, 1, 2, 0, 1, 2, 1, 0, 1, 2]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.crystals.alcove_path.RootsWithHeightElement">
<em class="property">class </em><tt class="descclassname">sage.combinat.crystals.alcove_path.</tt><tt class="descname">RootsWithHeightElement</tt><big>(</big><em>parent</em>, <em>root</em>, <em>height</em><big>)</big><a class="headerlink" href="#sage.combinat.crystals.alcove_path.RootsWithHeightElement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/element.html#sage.structure.element.Element" title="(in Sage Reference Manual: Basic Structures v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.element.Element</span></tt></a></p>
<p>Element of <a class="reference internal" href="#sage.combinat.crystals.alcove_path.RootsWithHeight" title="sage.combinat.crystals.alcove_path.RootsWithHeight"><tt class="xref py py-class docutils literal"><span class="pre">RootsWithHeight</span></tt></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">root</span></tt> &#8211; A positive root <span class="math">\(\beta\)</span> in our root system</li>
<li><tt class="docutils literal"><span class="pre">height</span></tt> &#8211; Is an integer, such that
<span class="math">\(0 \leq l \leq \langle \lambda, \beta^{\vee} \rangle\)</span></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.crystals.alcove_path</span> <span class="kn">import</span> <span class="n">RootsWithHeight</span>
<span class="gp">sage: </span><span class="n">rl</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">root_lattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">rl</span><span class="o">.</span><span class="n">from_vector</span><span class="p">(</span><span class="n">vector</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]));</span> <span class="n">x</span>
<span class="go">alpha[1] + alpha[2]</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">RootsWithHeight</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span> <span class="n">R</span>
<span class="go">Roots with height of Cartan type [&#39;A&#39;, 2] and dominant weight Lambda[1] + Lambda[2]</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="n">y</span>
<span class="go">(alpha[1] + alpha[2], 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.crystals.alcove_path.compare_graphs">
<tt class="descclassname">sage.combinat.crystals.alcove_path.</tt><tt class="descname">compare_graphs</tt><big>(</big><em>g1</em>, <em>g2</em>, <em>node1</em>, <em>node2</em><big>)</big><a class="headerlink" href="#sage.combinat.crystals.alcove_path.compare_graphs" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two edge-labeled <a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">graphs</span></tt></a> obtained from
<tt class="docutils literal"><span class="pre">Crystal.digraph()</span></tt>, starting from the root nodes of each graph.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">g1</span></tt> &#8211; <a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">graphs</span></tt></a>, first digraph</li>
<li><tt class="docutils literal"><span class="pre">g2</span></tt> &#8211; <a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">graphs</span></tt></a>, second digraph</li>
<li><tt class="docutils literal"><span class="pre">node1</span></tt> &#8211; element of <tt class="docutils literal"><span class="pre">g1</span></tt></li>
<li><tt class="docutils literal"><span class="pre">node2</span></tt> &#8211; element of <tt class="docutils literal"><span class="pre">g2</span></tt></li>
</ul>
<p>Traverse <tt class="docutils literal"><span class="pre">g1</span></tt> starting at <tt class="docutils literal"><span class="pre">node1</span></tt> and compare this graph with
the one obtained by traversing <tt class="docutils literal"><span class="pre">g2</span></tt> starting with <tt class="docutils literal"><span class="pre">node2</span></tt>.
If the graphs match (including labels) then return <tt class="docutils literal"><span class="pre">True</span></tt>.
Return <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.crystals.alcove_path</span> <span class="kn">import</span> <span class="n">compare_graphs</span>
<span class="gp">sage: </span><span class="n">G1</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">Tableaux</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">digraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">crystals</span><span class="o">.</span><span class="n">AlcovePaths</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">digraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">compare_graphs</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="n">G2</span><span class="p">,</span> <span class="n">C</span><span class="p">(</span> <span class="p">()</span> <span class="p">),</span> <span class="n">G2</span><span class="o">.</span><span class="n">vertices</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="affinization.html"
                                  title="previous chapter">Affinization Crystals</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="all.html"
                                  title="next chapter">Crystal features that are imported by default in the interpreter namespace</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../../_sources/sage/combinat/crystals/alcove_path.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="all.html" title="Crystal features that are imported by default in the interpreter namespace"
             >next</a> |</li>
        <li class="right" >
          <a href="affinization.html" title="Affinization Crystals"
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../../index.html">Combinatorics</a> &raquo;</li>

          <li><a href="../../../module_list.html" >Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2015, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>