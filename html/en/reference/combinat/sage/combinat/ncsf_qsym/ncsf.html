<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Non-Commutative Symmetric Functions &mdash; Sage Reference Manual v7.1: Combinatorics</title>
    
    <link rel="stylesheet" href="../../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v7.1: Combinatorics" href="../../../index.html" />
    <link rel="up" title="Comprehensive Module list" href="../../../module_list.html" />
    <link rel="next" title="Quasisymmetric functions" href="qsym.html" />
    <link rel="prev" title="Generic code for bases" href="generic_basis_code.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="qsym.html" title="Quasisymmetric functions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="generic_basis_code.html" title="Generic code for bases"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../../index.html">Combinatorics</a> &raquo;</li>

          <li><a href="../../../module_list.html" accesskey="U">Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="non-commutative-symmetric-functions">
<span id="sage-combinat-ncsf-qsym-ncsf"></span><h1>Non-Commutative Symmetric Functions<a class="headerlink" href="#non-commutative-symmetric-functions" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.ncsf_qsym.ncsf"></span><dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions">
<em class="property">class </em><tt class="descclassname">sage.combinat.ncsf_qsym.ncsf.</tt><tt class="descname">NonCommutativeSymmetricFunctions</tt><big>(</big><em>R</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Basic Structures v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></tt></a>, <a class="reference external" href="../../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage Reference Manual: Basic Structures v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.parent.Parent</span></tt></a></p>
<p>The abstract algebra of non-commutative symmetric functions.</p>
<p>We construct the abstract algebra of non-commutative symmetric
functions over the rational numbers:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">NCSF</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="go">S[2, 1, 1, 2] - S[2, 1, 3]</span>
</pre></div>
</div>
<p>NCSF is the unique free (non-commutative!) graded connected algebra with
one generator in each degree:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of hopf algebras over Rational Field</span>
<span class="go">    and Category of graded algebras over Rational Field</span>
<span class="go">    and Category of monoids with realizations</span>
<span class="go">    and Category of coalgebras over Rational Field with realizations</span>

<span class="gp">sage: </span><span class="p">[</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
</pre></div>
</div>
<p>We use the Sage standard renaming idiom to get shorter outputs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;NCSF&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">NCSF</span>
<span class="go">NCSF</span>
</pre></div>
</div>
<p>NCSF has many representations as a concrete algebra. Each of them
has a distinguished basis, and its elements are expanded in this
basis. Here is the <span class="math">\(\Psi\)</span>
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi"><tt class="xref py py-class docutils literal"><span class="pre">Psi</span></tt></a>)
representation:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span>
<span class="go">NCSF in the Psi basis</span>
</pre></div>
</div>
<p>Elements of <tt class="docutils literal"><span class="pre">Psi</span></tt> are linear combinations of basis elements indexed
by compositions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">2*Psi[] + 2*Psi[1] + 3*Psi[1, 1]</span>
</pre></div>
</div>
<p>The basis itself is accessible through:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="go">Lazy family (Term map from Compositions of non-negative integers...</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">Compositions of non-negative integers</span>
</pre></div>
</div>
<p>To construct an element one can therefore do:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])]</span>
<span class="go">Psi[2, 1, 3]</span>
</pre></div>
</div>
<p>As this is rather cumbersome, the following abuses of notation are
allowed:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])]</span>
<span class="go">Psi[2, 1, 3]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="go">Psi[2, 1, 3]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="go">Psi[2, 1, 3]</span>
</pre></div>
</div>
<p>or even:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">[(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])]</span>
<span class="go">Psi[2, 1, 3]</span>
</pre></div>
</div>
<p>Unfortunately, due to a limitation in Python syntax, one cannot use:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">[]</span>       <span class="c1"># not implemented</span>
</pre></div>
</div>
<p>Instead, you can use:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">[[]]</span>
<span class="go">Psi[]</span>
</pre></div>
</div>
<p>Now, we can construct linear combinations of basis elements:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">Psi</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*Psi[2, 1] + Psi[2, 1, 3] + 2*Psi[4]</span>
</pre></div>
</div>
<p class="rubric">Algebra structure</p>
<p>To start with, <tt class="docutils literal"><span class="pre">Psi</span></tt> is a graded algebra, the grading being induced by
the size of compositions. The one is the basis element indexed by the empty
composition:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="go">Psi[]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="go">S[]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="go">R[]</span>
</pre></div>
</div>
<p>As we have seen above, the <tt class="docutils literal"><span class="pre">Psi</span></tt> basis is multiplicative; that is
multiplication is induced by linearity from the concatenation of
compositions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Psi[1, 3, 2, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Psi</span><span class="o">.</span><span class="n">one</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="go">2*Psi[1, 3, 2, 4] + Psi[2, 4]</span>
</pre></div>
</div>
<p class="rubric">Hopf algebra structure</p>
<p><tt class="docutils literal"><span class="pre">Psi</span></tt> is further endowed with a coalgebra structure. The coproduct
is an algebra morphism, and therefore determined by its values on
the generators; those are primitive:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">Psi[] # Psi[1] + Psi[1] # Psi[]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">Psi[] # Psi[2] + Psi[2] # Psi[]</span>
</pre></div>
</div>
<p>The coproduct, being cocommutative on the generators, is
cocommutative everywhere:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">Psi[] # Psi[1, 2] + Psi[1] # Psi[2] + Psi[1, 2] # Psi[] + Psi[2] # Psi[1]</span>
</pre></div>
</div>
<p>The algebra and coalgebra structures on <tt class="docutils literal"><span class="pre">Psi</span></tt> combine to form a
bialgebra structure, which cooperates with the grading to form a
connected graded bialgebra. Thus, as any connected graded bialgebra,
<tt class="docutils literal"><span class="pre">Psi</span></tt> is a Hopf algebra. Over <tt class="docutils literal"><span class="pre">QQ</span></tt> (or any other <span class="math">\(\QQ\)</span>-algebra),
this Hopf algebra <tt class="docutils literal"><span class="pre">Psi</span></tt> is isomorphic to the tensor algebra of
its space of primitive elements.</p>
<p>The antipode is an anti-algebra morphism; in the <tt class="docutils literal"><span class="pre">Psi</span></tt> basis, it
sends the generators to their opposites and changes their sign if
they are of odd degree:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">-Psi[3]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">-Psi[2, 3, 1]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span><span class="o">.</span><span class="n">apply_multilinear_morphism</span><span class="p">(</span><span class="k">lambda</span> <span class="n">be</span><span class="p">,</span><span class="n">ga</span><span class="p">:</span> <span class="n">Psi</span><span class="p">(</span><span class="n">be</span><span class="p">)</span><span class="o">*</span><span class="n">Psi</span><span class="p">(</span><span class="n">ga</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">())</span>
<span class="go">0</span>
</pre></div>
</div>
<p>The counit is defined by sending all elements of positive degree to
zero:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">degree</span><span class="p">(),</span> <span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">degree</span><span class="p">(),</span> <span class="n">S</span><span class="o">.</span><span class="n">one</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">(3, 6, 0)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">counit</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">counit</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">one</span><span class="p">()</span><span class="o">.</span><span class="n">counit</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">counit</span><span class="p">()</span>
<span class="go">7</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">counit</span><span class="p">()</span>
<span class="go">7</span>
</pre></div>
</div>
<p>It is possible to change the prefix used to display the basis
elements using the method
<a class="reference external" href="../../../../structure/sage/structure/indexed_generators.html#sage.structure.indexed_generators.IndexedGenerators.print_options" title="(in Sage Reference Manual: Basic Structures v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">print_options()</span></tt></a>.
Say that for instance one wanted to display the 
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete"><tt class="xref py py-class docutils literal"><span class="pre">Complete</span></tt></a> basis as having
a prefix <tt class="docutils literal"><span class="pre">H</span></tt> instead of the default <tt class="docutils literal"><span class="pre">S</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">2*S[] + 2*S[1] + 3*S[1, 1]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">print_options</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">2*H[] + 2*H[1] + 3*H[1, 1]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">print_options</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;S&#39;</span><span class="p">)</span> <span class="c1">#restore to &#39;S&#39;</span>
</pre></div>
</div>
<p class="rubric">Concrete representations</p>
<p>NCSF admits the concrete realizations defined in <a class="reference internal" href="qsym.html#ncsf1" id="id1">[NCSF1]</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Phi</span>        <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span>        <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ribbon</span>     <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">complete</span>   <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">elementary</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">elementary</span><span class="p">()</span>
</pre></div>
</div>
<p>To change from one basis to another, one simply does:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Phi</span><span class="p">(</span><span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">Phi[1]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">(</span><span class="n">Psi</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">-1/4*Phi[1, 2] + 1/4*Phi[2, 1] + Phi[3]</span>
</pre></div>
</div>
<p>In general, one can mix up different bases in computations:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Phi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Phi[1, 1]</span>
</pre></div>
</div>
<p>Some of the changes of basis are easy to guess:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ribbon</span><span class="p">(</span><span class="n">complete</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">R[1, 3, 2] + R[1, 5] + R[4, 2] + R[6]</span>
</pre></div>
</div>
<p>This is the sum of all fatter compositions. Using the usual
Möbius function for the boolean lattice, the inverse change of
basis is given by the alternating sum of all fatter compositions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">complete</span><span class="p">(</span><span class="n">ribbon</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">S[1, 3, 2] - S[1, 5] - S[4, 2] + S[6]</span>
</pre></div>
</div>
<p>The analogue of the elementary basis is the sum over
all finer compositions than the &#8216;complement&#8217; of the composition
in the ribbon basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="go">[2, 1, 2, 1]</span>
<span class="gp">sage: </span><span class="n">ribbon</span><span class="p">(</span><span class="n">elementary</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">R[1, 1, 1, 1, 1, 1] + R[1, 1, 1, 2, 1] + R[2, 1, 1, 1, 1] + R[2, 1, 2, 1]</span>
</pre></div>
</div>
<p>By Möbius inversion on the composition poset, the ribbon
basis element corresponding to a composition <span class="math">\(I\)</span> is then the
alternating sum over all compositions fatter than the
complement composition of <span class="math">\(I\)</span> in the elementary basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">elementary</span><span class="p">(</span><span class="n">ribbon</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">L[1, 3, 2] - L[1, 5] - L[4, 2] + L[6]</span>
</pre></div>
</div>
<p>The <span class="math">\(\Phi\)</span>
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi"><tt class="xref py py-class docutils literal"><span class="pre">Phi</span></tt></a>)
and <span class="math">\(\Psi\)</span> bases are computed by changing to and from the
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete"><tt class="xref py py-class docutils literal"><span class="pre">Complete</span></tt></a>
basis. The expansion of <span class="math">\(\Psi\)</span> basis is given in Proposition 4.5
of <a class="reference internal" href="qsym.html#ncsf1" id="id2">[NCSF1]</a> by the formulae</p>
<div class="math">
\[S^I = \sum_{J \geq I} \frac{1}{\pi_u(J,I)} \Psi^J\]</div>
<p>and</p>
<div class="math">
\[\Psi^I = \sum_{J \geq I} (-1)^{\ell(J)-\ell(I)} lp(J,I) S^J\]</div>
<p>where the coefficients <span class="math">\(\pi_u(J,I)\)</span> and <span class="math">\(lp(J,I)\)</span> are coefficients in the
methods <a class="reference internal" href="combinatorics.html#sage.combinat.ncsf_qsym.combinatorics.coeff_pi" title="sage.combinat.ncsf_qsym.combinatorics.coeff_pi"><tt class="xref py py-meth docutils literal"><span class="pre">coeff_pi()</span></tt></a> and
<a class="reference internal" href="combinatorics.html#sage.combinat.ncsf_qsym.combinatorics.coeff_lp" title="sage.combinat.ncsf_qsym.combinatorics.coeff_lp"><tt class="xref py py-meth docutils literal"><span class="pre">coeff_lp()</span></tt></a> respectively.  For
example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">(</span><span class="n">complete</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">1/6*Psi[1, 1, 1] + 1/3*Psi[1, 2] + 1/6*Psi[2, 1] + 1/3*Psi[3]</span>
<span class="gp">sage: </span><span class="n">complete</span><span class="p">(</span><span class="n">Psi</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">S[1, 1, 1] - 2*S[1, 2] - S[2, 1] + 3*S[3]</span>
</pre></div>
</div>
<p>The
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi"><tt class="xref py py-class docutils literal"><span class="pre">Phi</span></tt></a>
basis is another analogue of the power sum basis from the algebra of
symmetric functions and the expansion in the Complete basis is given in
Proposition 4.9 of <a class="reference internal" href="qsym.html#ncsf1" id="id3">[NCSF1]</a> by the formulae</p>
<div class="math">
\[S^I = \sum_{J \geq I} \frac{1}{sp(J,I)} \Phi^J\]</div>
<p>and</p>
<div class="math">
\[\Phi^I = \sum_{J \geq I} (-1)^{\ell(J)-\ell(I)} 
\frac{\prod_i I_i}{\ell(J,I)} S^J\]</div>
<p>where the coefficients <span class="math">\(sp(J,I)\)</span> and <span class="math">\(\ell(J,I)\)</span> are coefficients in the
methods <a class="reference internal" href="combinatorics.html#sage.combinat.ncsf_qsym.combinatorics.coeff_sp" title="sage.combinat.ncsf_qsym.combinatorics.coeff_sp"><tt class="xref py py-meth docutils literal"><span class="pre">coeff_sp()</span></tt></a> and
<a class="reference internal" href="combinatorics.html#sage.combinat.ncsf_qsym.combinatorics.coeff_ell" title="sage.combinat.ncsf_qsym.combinatorics.coeff_ell"><tt class="xref py py-meth docutils literal"><span class="pre">coeff_ell()</span></tt></a> respectively.
For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Phi</span><span class="p">(</span><span class="n">complete</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">1/6*Phi[1, 1, 1] + 1/4*Phi[1, 2] + 1/4*Phi[2, 1] + 1/3*Phi[3]</span>
<span class="gp">sage: </span><span class="n">complete</span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">S[1, 1, 1] - 3/2*S[1, 2] - 3/2*S[2, 1] + 3*S[3]</span>
</pre></div>
</div>
<p>Here is how to fetch the conversion morphisms:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">complete</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">elementary</span><span class="p">);</span> <span class="n">f</span>
<span class="go">Generic morphism:</span>
<span class="go">  From: NCSF in the Elementary basis</span>
<span class="go">  To:   NCSF in the Complete basis</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">elementary</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">complete</span><span class="p">);</span> <span class="n">g</span>
<span class="go">Generic morphism:</span>
<span class="go">  From: NCSF in the Complete basis</span>
<span class="go">  To:   NCSF in the Elementary basis</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of homsets of unital magmas and right modules over Rational Field and</span>
<span class="go">  left modules over Rational Field</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">elementary</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">S[1, 1, 1, 1, 1] - S[1, 1, 1, 2] - S[1, 2, 1, 1] + S[1, 2, 2]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">(</span><span class="n">complete</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">L[1, 1, 1, 1, 1] - L[1, 1, 1, 2] - L[1, 2, 1, 1] + L[1, 2, 2]</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">g</span><span class="p">;</span> <span class="n">h</span>
<span class="go">Composite map:</span>
<span class="go">  From: NCSF in the Complete basis</span>
<span class="go">  To:   NCSF in the Complete basis</span>
<span class="go">  Defn:   Generic morphism:</span>
<span class="go">          From: NCSF in the Complete basis</span>
<span class="go">          To:   NCSF in the Elementary basis</span>
<span class="go">        then</span>
<span class="go">          Generic morphism:</span>
<span class="go">          From: NCSF in the Elementary basis</span>
<span class="go">          To:   NCSF in the Complete basis</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span><span class="n">complete</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">S[1, 3, 2]</span>
</pre></div>
</div>
<p class="rubric">Additional concrete representations</p>
<p>NCSF has some additional bases which appear in the literature:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Monomial</span>                 <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Immaculate</span>               <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Immaculate</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">dualQuasisymmetric_Schur</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">dualQuasisymmetric_Schur</span><span class="p">()</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Monomial" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Monomial"><tt class="xref py py-class docutils literal"><span class="pre">Monomial</span></tt></a>
basis was introduced in <a class="reference internal" href="combinatorics.html#tev2007" id="id4">[Tev2007]</a> and the
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate"><tt class="xref py py-class docutils literal"><span class="pre">Immaculate</span></tt></a>
basis was introduced in <a class="reference internal" href="qsym.html#bbssz2012" id="id5">[BBSSZ2012]</a>.  The
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Quasisymmetric_Schur" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Quasisymmetric_Schur"><tt class="xref py py-class docutils literal"><span class="pre">Quasisymmetric_Schur</span></tt></a>
were defined in <a class="reference internal" href="combinatorics.html#qschur" id="id6">[QSCHUR]</a> and the dual basis is implemented here as
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualQuasisymmetric_Schur" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualQuasisymmetric_Schur"><tt class="xref py py-class docutils literal"><span class="pre">dualQuasisymmetric_Schur</span></tt></a>.
Refer to the documentation for the use and definition of these bases.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<ul class="last simple">
<li>implement fundamental, forgotten, and simple (coming
from the simple modules of HS_n) bases.</li>
</ul>
</div>
<p>We revert back to the original name from our custom short name NCSF:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span>
<span class="go">NCSF</span>
<span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">rename</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">NCSF</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">Phi</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">Psi</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">complete</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases">
<em class="property">class </em><tt class="descname">Bases</tt><big>(</big><em>parent_with_realization</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/realizations.html#sage.categories.realizations.Category_realization_of_parent" title="(in Sage Reference Manual: Category Framework v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.realizations.Category_realization_of_parent</span></tt></a></p>
<p>Category of bases of non-commutative symmetric functions.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">Bases</span><span class="p">()</span>
<span class="go">Category of bases of Non-Commutative Symmetric Functions over the Rational Field</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">Bases</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods">
<em class="property">class </em><tt class="descname">ElementMethods</tt><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.bernstein_creation_operator">
<tt class="descname">bernstein_creation_operator</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.bernstein_creation_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <tt class="docutils literal"><span class="pre">self</span></tt> under the <span class="math">\(n\)</span>-th Bernstein
creation operator.</p>
<p>Let <span class="math">\(n\)</span> be an integer. The <span class="math">\(n\)</span>-th Bernstein creation
operator <span class="math">\(\mathbb{B}_n\)</span> is defined as the endomorphism of
the space <span class="math">\(NSym\)</span> of noncommutative symmetric functions
which sends every <span class="math">\(f\)</span> to</p>
<div class="math">
\[\sum_{i \geq 0} (-1)^i H_{n+i} F_{1^i}^\perp,\]</div>
<p>where usual notations are in place (the letter <span class="math">\(H\)</span> stands
for the complete basis of <span class="math">\(NSym\)</span>, the letter <span class="math">\(F\)</span> stands
for the fundamental basis of the algebra <span class="math">\(QSym\)</span> of
quasisymmetric functions, and <span class="math">\(F_{1^i}^\perp\)</span> means
skewing (<a class="reference internal" href="generic_basis_code.html#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.skew_by" title="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.skew_by"><tt class="xref py py-meth docutils literal"><span class="pre">skew_by()</span></tt></a>)
by <span class="math">\(F_{1^i}\)</span>). Notice that <span class="math">\(F_{1^i}\)</span> is nothing other than the
elementary symmetric function <span class="math">\(e_i\)</span>.</p>
<p>This has been introduced in <a class="reference internal" href="qsym.html#bbssz2012" id="id7">[BBSSZ2012]</a>, section 3.1, in
analogy to the Bernstein creation operators on the
symmetric functions
(<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.bernstein_creation_operator" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.bernstein_creation_operator"><tt class="xref py py-meth docutils literal"><span class="pre">bernstein_creation_operator()</span></tt></a>),
and studied further in <a class="reference internal" href="qsym.html#bbssz2012" id="id8">[BBSSZ2012]</a>, mainly in the context
of immaculate functions
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate"><tt class="xref py py-class docutils literal"><span class="pre">Immaculate</span></tt></a>).
In fact, if <span class="math">\((\alpha_1, \alpha_2, \ldots, \alpha_m)\)</span> is
an <span class="math">\(m\)</span>-tuple of integers, then</p>
<div class="math">
\[\mathbb{B}_n I_{(\alpha_1, \alpha_2, \ldots, \alpha_m)}
= I_{(n, \alpha_1, \alpha_2, \ldots, \alpha_m)},\]</div>
<p>where <span class="math">\(I_{(\alpha_1, \alpha_2, \ldots, \alpha_m)}\)</span> is the
immaculate function associated to the <span class="math">\(m\)</span>-tuple
<span class="math">\((\alpha_1, \alpha_2, \ldots, \alpha_m)\)</span> (see
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.immaculate_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.immaculate_function"><tt class="xref py py-meth docutils literal"><span class="pre">immaculate_function()</span></tt></a>).</p>
<p>EXAMPLES:</p>
<p>We get the immaculate functions by repeated application of
Bernstein creation operators:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">I</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">immaculate_by_bernstein</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
<span class="go">....:     # immaculate function corresponding to integer</span>
<span class="go">....:     # tuple ``xs``, computed by iterated application</span>
<span class="go">....:     # of Bernstein creation operators.</span>
<span class="go">....:     res = S.one()</span>
<span class="go">....:     for i in reversed(xs):</span>
<span class="go">....:         res = res.bernstein_creation_operator(i)</span>
<span class="go">....:     return res</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">itertools</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">immaculate_by_bernstein</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">....:      for p in itertools.product(range(-1, 3), repeat=3))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Some examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">S[2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">S[1, 2, 1] - S[2, 2] - S[3, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">-S[1, 2, 2] - S[1, 3, 1] + S[2, 2, 1] + S[3, 2]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">S[1, 3, 2] - S[2, 2, 2] - S[2, 3, 1] + S[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">S[2, 3, 2] - S[3, 2, 2] - S[3, 3, 1] + S[4, 2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.chi">
<tt class="descname">chi</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.chi" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the commutative image of a non-commutative symmetric function.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>The commutative image of <tt class="docutils literal"><span class="pre">self</span></tt>. This will be a symmetric function.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*R[] + 2*R[1] + 3*R[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="go">2*s[] + 2*s[1] + 3*s[1, 1]</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Phi</span><span class="p">()[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="go">h[1, 1, 1, 1] - 3*h[2, 1, 1] + 3*h[3, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.expand">
<tt class="descname">expand</tt><big>(</big><em>n</em>, <em>alphabet='x'</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand the noncommutative symmetric function into an
element of a free algebra in <tt class="docutils literal"><span class="pre">n</span></tt> indeterminates of
an alphabet, which by default is <tt class="docutils literal"><span class="pre">'x'</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; a nonnegative integer; the number of variables
in the expansion</li>
<li><tt class="docutils literal"><span class="pre">alphabet</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">'x'</span></tt>); the alphabet in
which <tt class="docutils literal"><span class="pre">self</span></tt> is to be expanded</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>An expansion of <tt class="docutils literal"><span class="pre">self</span></tt> into the <tt class="docutils literal"><span class="pre">n</span></tt> variables
specified by <tt class="docutils literal"><span class="pre">alphabet</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">x0^3 + x0^2*x1 + x0^2*x2 + x0*x1^2 + x0*x1*x2</span>
<span class="go"> + x0*x2^2 + x1^3 + x1^2*x2 + x1*x2^2 + x2^3</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">x2*x1*x0</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">x1*x0 + x2*x0 + x2*x1</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">x2*x1*x0 + x3*x1*x0 + x3*x2*x0 + x3*x2*x1</span>
<span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">x0^3 + x0^2*x1 + x0^2*x2 + x0*x1*x0 + x0*x1^2 + x0*x1*x2</span>
<span class="go"> + x0*x2*x0 + x0*x2*x1 + x0*x2^2 - x1*x0^2 - x1*x0*x1</span>
<span class="go"> - x1*x0*x2 + x1^2*x0 + x1^3 + x1^2*x2 + x1*x2*x0</span>
<span class="go"> + x1*x2*x1 + x1*x2^2 - x2*x0^2 - x2*x0*x1 - x2*x0*x2</span>
<span class="go"> - x2*x1*x0 - x2*x1^2 - x2*x1*x2 + x2^2*x0 + x2^2*x1 + x2^3</span>
</pre></div>
</div>
<p>One can use a different set of variables by adding an optional
argument <tt class="docutils literal"><span class="pre">alphabet=...</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
<span class="go">y2*y1*y0 + y3*y1*y0 + y3*y2*y0 + y3*y2*y1</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">S</span><span class="p">([]))</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">([])</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">x0^3 + x0^2*x1 + x0^2*x2 + x0*x1^2 + x0*x1*x2</span>
<span class="go"> + x0*x2^2 + x1^3 + x1^2*x2 + x1*x2^2 + x2^3</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">So far this is only implemented on the elementary
basis, and everything else goes through coercion.
Maybe it is worth shortcutting some of the other
bases?</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.left_padded_kronecker_product">
<tt class="descname">left_padded_kronecker_product</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.left_padded_kronecker_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the left-padded Kronecker product of <tt class="docutils literal"><span class="pre">self</span></tt> and
<tt class="docutils literal"><span class="pre">x</span></tt> in the basis of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The left-padded Kronecker product is a bilinear map
mapping two non-commutative symmetric functions to
another, not necessarily preserving degree.
It can be defined as follows: Let <span class="math">\(*\)</span> denote the internal
product (<a class="reference internal" href="generic_basis_code.html#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product"><tt class="xref py py-meth docutils literal"><span class="pre">internal_product()</span></tt></a>)
on the space of non-commutative symmetric functions. For any
composition <span class="math">\(I\)</span>, let <span class="math">\(S^I\)</span> denote the complete homogeneous
symmetric function indexed by <span class="math">\(I\)</span>. For any compositions
<span class="math">\(\alpha\)</span>, <span class="math">\(\beta\)</span>, <span class="math">\(\gamma\)</span>, let
<span class="math">\(g^{\gamma}_{\alpha, \beta}\)</span> denote the coefficient of
<span class="math">\(S^{\gamma}\)</span> in the internal product
<span class="math">\(S^{\alpha} * S^{\beta}\)</span>.
For every composition <span class="math">\(I = (i_1, i_2, \ldots, i_k)\)</span>
and every integer <span class="math">\(n &gt; \left\lvert I \right\rvert\)</span>, define the
<em>`n`-completion of `I`</em> to be the composition
<span class="math">\((n - \left\lvert I \right\rvert, i_1, i_2, \ldots, i_k)\)</span>;
this <span class="math">\(n\)</span>-completion is denoted by <span class="math">\(I[n]\)</span>.
Then, for any compositions <span class="math">\(\alpha\)</span> and <span class="math">\(\beta\)</span> and every
integer <span class="math">\(n &gt; \left\lvert \alpha \right\rvert
+ \left\lvert\beta\right\rvert\)</span>, we can write the
internal product <span class="math">\(S^{\alpha[n]} * S^{\beta[n]}\)</span> in the form</p>
<div class="math">
\[S^{\alpha[n]} * S^{\beta[n]} =
\sum_{\gamma} g^{\gamma[n]}_{\alpha[n], \beta[n]}
S^{\gamma[n]}\]</div>
<p>with <span class="math">\(\gamma\)</span> ranging over all compositions. The
coefficients <span class="math">\(g^{\gamma[n]}_{\alpha[n], \beta[n]}\)</span>
are independent on <span class="math">\(n\)</span>. These coefficients
<span class="math">\(g^{\gamma[n]}_{\alpha[n], \beta[n]}\)</span> are denoted by
<span class="math">\(\widetilde{g}^{\gamma}_{\alpha, \beta}\)</span>, and the
non-commutative symmetric function</p>
<div class="math">
\[\sum_{\gamma} \widetilde{g}^{\gamma}_{\alpha, \beta}
S^{\gamma}\]</div>
<p>is said to be the <em>left-padded Kronecker product</em> of
<span class="math">\(S^{\alpha}\)</span> and <span class="math">\(S^{\beta}\)</span>. By bilinearity, this
extends to a definition of a left-padded Kronecker product
of any two non-commutative symmetric functions.</p>
<p>The left-padded Kronecker product on the non-commutative
symmetric functions lifts the left-padded Kronecker
product on the symmetric functions. More precisely: Let
<span class="math">\(\pi\)</span> denote the canonical projection
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><tt class="xref py py-meth docutils literal"><span class="pre">to_symmetric_function()</span></tt></a>) from the non-commutative
symmetric functions to the symmetric functions. Then, any
two non-commutative symmetric functions <span class="math">\(f\)</span> and <span class="math">\(g\)</span>
satisfy</p>
<div class="math">
\[\pi(f \overline{*} g) = \pi(f) \overline{*} \pi(g),\]</div>
<p>where the <span class="math">\(\overline{*}\)</span> on the left-hand side denotes the
left-padded Kronecker product on the non-commutative
symmetric functions, and the <span class="math">\(\overline{*}\)</span> on the
right-hand side denotes the left-padded Kronecker product
on the symmetric functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; element of the ring of non-commutative
symmetric functions over the same base ring as <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the left-padded Kronecker product of <tt class="docutils literal"><span class="pre">self</span></tt> with <tt class="docutils literal"><span class="pre">x</span></tt>
(an element of the ring of non-commutative symmetric
functions in the same basis as <tt class="docutils literal"><span class="pre">self</span></tt>)</li>
</ul>
<p>AUTHORS:</p>
<ul class="simple">
<li>Darij Grinberg (15 Mar 2014)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">S[1, 1, 1, 1] + S[1, 2, 1] + S[2, 1] + S[2, 1, 1, 1] + S[2, 2, 1] + S[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">S[1, 1, 1] + S[1, 2, 1] + S[2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">S[1, 1, 1] + S[2, 1] + S[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">S[1, 1] + 2*S[1, 1, 1] + S[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">S[1, 1, 1, 1] + S[1, 2, 1] + S[1, 2, 1, 1] + S[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">S[1, 2] + S[2, 1, 1] + S[3, 2]</span>
</pre></div>
</div>
<p>Taking the left-padded Kronecker product with
<span class="math">\(1 = S^{\empty}\)</span> is the identity map on the ring of
non-commutative symmetric functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">S</span><span class="p">[</span><span class="n">Composition</span><span class="p">([])]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">lam</span><span class="p">])</span>
<span class="go">....:      == S[lam].left_padded_kronecker_product(S[Composition([])])</span>
<span class="go">....:      == S[lam] for i in range(4)</span>
<span class="go">....:      for lam in Compositions(i) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Here is a rule for the left-padded Kronecker product of
<span class="math">\(S_1\)</span> (this is the same as <span class="math">\(S^{(1)}\)</span>) with any complete
homogeneous function: Let <span class="math">\(I\)</span> be a composition.
Then, the left-padded Kronecker product of <span class="math">\(S_1\)</span> and
<span class="math">\(S^I\)</span> is <span class="math">\(\sum_K a_K S^K\)</span>, where the sum runs
over all compositions <span class="math">\(K\)</span>, and the coefficient <span class="math">\(a_K\)</span> is
defined as the number of ways to obtain <span class="math">\(K\)</span> from <span class="math">\(I\)</span> by
one of the following two operations:</p>
<ul class="simple">
<li>Insert a <span class="math">\(1\)</span> at the end of <span class="math">\(I\)</span>.</li>
<li>Subtract <span class="math">\(1\)</span> from one of the entries of <span class="math">\(I\)</span> (and remove
the entry if it thus becomes <span class="math">\(0\)</span>), and insert a <span class="math">\(1\)</span> at
the end of <span class="math">\(I\)</span>.</li>
</ul>
<p>We check this for compositions of size <span class="math">\(\leq 4\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">mults1</span><span class="p">(</span><span class="n">I</span><span class="p">):</span>
<span class="go">....:     # Left left-padded Kronecker multiplication by S[1].</span>
<span class="go">....:     res = S[I[:] + [1]]</span>
<span class="go">....:     for k in range(len(I)):</span>
<span class="go">....:         I2 = I[:]</span>
<span class="go">....:         if I2[k] == 1:</span>
<span class="go">....:             I2 = I2[:k] + I2[k+1:]</span>
<span class="go">....:         else:</span>
<span class="go">....:             I2[k] -= 1</span>
<span class="go">....:         res += S[I2 + [1]]</span>
<span class="go">....:     return res</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">mults1</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">==</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">I</span><span class="p">])</span>
<span class="go">....:      for i in range(5) for I in Compositions(i) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A similar rule can be made for the left-padded Kronecker
product of any complete homogeneous function with <span class="math">\(S_1\)</span>:
Let <span class="math">\(I\)</span> be a composition. Then, the left-padded Kronecker
product of <span class="math">\(S^I\)</span> and <span class="math">\(S_1\)</span> is <span class="math">\(\sum_K b_K S^K\)</span>, where the
sum runs over all compositions <span class="math">\(K\)</span>, and the coefficient
<span class="math">\(b_K\)</span> is defined as the number of ways to obtain <span class="math">\(K\)</span> from
<span class="math">\(I\)</span> by one of the following two operations:</p>
<ul class="simple">
<li>Insert a <span class="math">\(1\)</span> at the front of <span class="math">\(I\)</span>.</li>
<li>Subtract <span class="math">\(1\)</span> from one of the entries of <span class="math">\(I\)</span> (and remove
the entry if it thus becomes <span class="math">\(0\)</span>), and insert a <span class="math">\(1\)</span>
right after this entry.</li>
</ul>
<p>We check this for compositions of size <span class="math">\(\leq 4\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">mults2</span><span class="p">(</span><span class="n">I</span><span class="p">):</span>
<span class="go">....:     # Left left-padded Kronecker multiplication by S[1].</span>
<span class="go">....:     res = S[[1] + I[:]]</span>
<span class="go">....:     for k in range(len(I)):</span>
<span class="go">....:         I2 = I[:]</span>
<span class="go">....:         i2k = I2[k]</span>
<span class="go">....:         if i2k != 1:</span>
<span class="go">....:             I2 = I2[:k] + [i2k-1, 1] + I2[k+1:]</span>
<span class="go">....:         res += S[I2]</span>
<span class="go">....:     return res</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">mults2</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">==</span> <span class="n">S</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">....:      for i in range(5) for I in Compositions(i) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Checking the
<span class="math">\(\pi(f \overline{*} g) = \pi(f) \overline{*} \pi(g)\)</span>
equality:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">testpi</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="go">....:     for I in Compositions(n):</span>
<span class="go">....:         for J in Compositions(n):</span>
<span class="go">....:             a = R[I].to_symmetric_function()</span>
<span class="go">....:             b = R[J].to_symmetric_function()</span>
<span class="go">....:             x = a.left_padded_kronecker_product(b)</span>
<span class="go">....:             y = R[I].left_padded_kronecker_product(R[J])</span>
<span class="go">....:             y = y.to_symmetric_function()</span>
<span class="go">....:             if x != y:</span>
<span class="go">....:                 return False</span>
<span class="go">....:     return True</span>
<span class="gp">sage: </span><span class="n">testpi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">([]))</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">S</span><span class="p">([]))</span>
<span class="go">6*S[]</span>
</pre></div>
</div>
<p>Different bases and base rings:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">L[1, 1, 1] + L[2] + L[2, 1, 1] - L[2, 2]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">S[1, 1] + 2*S[1, 1, 1] + S[1, 1, 1, 1] - S[1, 1, 2]</span>

<span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span> <span class="n">v</span>
<span class="go">L[1, 1] + L[1, 1, 1] + (-1)*L[2] + L[2, 2]</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">Non-Commutative Symmetric Functions over the Cyclotomic Field of order 12 and degree 4 in the Elementary basis</span>

<span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">Zmod</span><span class="p">(</span><span class="mi">14</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span> <span class="n">v</span>
<span class="go">L[1, 1] + L[1, 1, 1] + 13*L[2] + L[2, 2]</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">Non-Commutative Symmetric Functions over the Ring of integers modulo 14 in the Elementary basis</span>

<span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="n">parent</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">Non-Commutative Symmetric Functions over the Integer Ring in the Ribbon basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.omega_involution">
<tt class="descname">omega_involution</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.omega_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<tt class="docutils literal"><span class="pre">self</span></tt> under the omega involution.</p>
<p>The omega involution is defined as the algebra antihomomorphism
<span class="math">\(NCSF \to NCSF\)</span> which, for every positive integer <span class="math">\(n\)</span>, sends
the <span class="math">\(n\)</span>-th complete non-commutative symmetric function <span class="math">\(S_n\)</span> to
the <span class="math">\(n\)</span>-th elementary non-commutative symmetric function
<span class="math">\(\Lambda_n\)</span>. This omega involution is denoted by <span class="math">\(\omega\)</span>. It
can be shown that every composition <span class="math">\(I\)</span> satisfies</p>
<div class="math">
\[\omega(S^I) = \Lambda^{I^r}, \quad
\omega(\Lambda^I) = S^{I^r}, \quad
\omega(R_I) = R_{I^t}, \quad
\omega(\Phi^I) = (-1)^{|I|-\ell(I)} \Phi^{I^r},
\omega(\Psi^I) = (-1)^{|I|-\ell(I)} \Psi^{I^r},\]</div>
<p>where <span class="math">\(I^r\)</span> denotes the reversed composition of <span class="math">\(I\)</span>, and
<span class="math">\(I^t\)</span> denotes the conjugate composition of <span class="math">\(I\)</span>, and <span class="math">\(\ell(I)\)</span>
denotes the length of the
composition <span class="math">\(I\)</span>, and standard notations for classical bases
of <span class="math">\(NCSF\)</span> are being used (<span class="math">\(S\)</span> for the complete basis,
<span class="math">\(\Lambda\)</span> for the elementary basis, <span class="math">\(R\)</span> for the ribbon
basis, <span class="math">\(\Phi\)</span> for that of the power-sums of the second
kind, and <span class="math">\(\Psi\)</span> for that of the power-sums of the first
kind). More generally, if <span class="math">\(f\)</span> is a homogeneous element of
<span class="math">\(NCSF\)</span> of degree <span class="math">\(n\)</span>, then</p>
<div class="math">
\[\omega(f) = (-1)^n S(f),\]</div>
<p>where <span class="math">\(S\)</span> denotes the antipode of <span class="math">\(NCSF\)</span>.</p>
<p>The omega involution <span class="math">\(\omega\)</span> is an involution and a
coalgebra automorphism of <span class="math">\(NCSF\)</span>. It is an automorphism of the
graded vector space <span class="math">\(NCSF\)</span>. If <span class="math">\(\pi\)</span> denotes the projection
from <span class="math">\(NCSF\)</span> to the ring of symmetric functions
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><tt class="xref py py-meth docutils literal"><span class="pre">to_symmetric_function()</span></tt></a>), then
<span class="math">\(\pi(\omega(f)) = \omega(\pi(f))\)</span> for every <span class="math">\(f \in NCSF\)</span>,
where the <span class="math">\(\omega\)</span> on the right hand side denotes the omega
automorphism of <span class="math">\(Sym\)</span>.</p>
<p>The omega involution on <span class="math">\(NCSF\)</span> is adjoint to the omega
involution on <span class="math">\(QSym\)</span> by the standard adjunction between <span class="math">\(NCSF\)</span>
and <span class="math">\(QSym\)</span>.</p>
<p>The omega involution has been denoted by <span class="math">\(\omega\)</span> in <a class="reference internal" href="qsym.html#lmvw13" id="id9">[LMvW13]</a>,
section 3.6.
See <a class="reference internal" href="qsym.html#ncsf1" id="id10">[NCSF1]</a>, section 3.1 for the properties of this map.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.omega_involution" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.omega_involution"><tt class="xref py py-meth docutils literal"><span class="pre">omega</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">QSym</span></tt></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution"><tt class="xref py py-meth docutils literal"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution"><tt class="xref py py-meth docutils literal"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">())</span>
<span class="go">L[2, 3]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">())</span>
<span class="go">L[3, 6]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">())</span>
<span class="go">L[3, 1]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">((</span><span class="n">S</span><span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">S</span><span class="p">[[]])</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">())</span> <span class="c1"># long time</span>
<span class="go">4*L[] + L[1, 9] - L[2, 8] - 3*L[3] + 2*L[4, 6]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">((</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">())</span>
<span class="go">-2*L[2] + L[3, 3]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">(</span><span class="n">S</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">())</span>
<span class="go">L[2, 4]</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">()</span>
<span class="go">R[1, 2, 1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">()</span>
<span class="go">-Phi[1, 2]</span>
<span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">()</span>
<span class="go">-Psi[1, 2]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">()</span>
<span class="go">Psi[1, 3]</span>
</pre></div>
</div>
<p>Testing the <span class="math">\(\pi(\omega(f)) = \omega(\pi(f))\)</span> relation noticed
above:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">()</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="go">....:      == R(I).to_symmetric_function().omega_involution()</span>
<span class="go">....:      for I in Compositions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The omega involution on <span class="math">\(QSym\)</span> is adjoint to the omega
involution on <span class="math">\(NSym\)</span> with respect to the duality pairing:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QSym</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QSym</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">M</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">()</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">J</span><span class="p">))</span>
<span class="go">....:           == M(I).duality_pairing(S(J).omega_involution())</span>
<span class="go">....:           for I in Compositions(2) )</span>
<span class="go">....:      for J in Compositions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution">
<tt class="descname">psi_involution</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<tt class="docutils literal"><span class="pre">self</span></tt> under the involution <span class="math">\(\psi\)</span>.</p>
<p>The involution <span class="math">\(\psi\)</span> is defined as the linear map
<span class="math">\(NCSF \to NCSF\)</span> which, for every composition <span class="math">\(I\)</span>, sends the
complete noncommutative symmetric function <span class="math">\(S^I\)</span> to the
elementary noncommutative symmetric function <span class="math">\(\Lambda^I\)</span>.
It can be shown that every composition <span class="math">\(I\)</span> satisfies</p>
<div class="math">
\[\psi(R_I) = R_{I^c}, \quad \psi(S^I) = \Lambda^I, \quad
\psi(\Lambda^I) = S^I, \quad
\psi(\Phi^I) = (-1)^{|I| - \ell(I)} \Phi^I\]</div>
<p>where <span class="math">\(I^c\)</span> denotes the complement of the composition <span class="math">\(I\)</span>, and
<span class="math">\(\ell(I)\)</span> denotes the length of <span class="math">\(I\)</span>, and where standard
notations for classical bases of <span class="math">\(NCSF\)</span> are being used
(<span class="math">\(S\)</span> for the complete basis, <span class="math">\(\Lambda\)</span> for the elementary basis,
<span class="math">\(\Phi\)</span> for the basis of the power sums of the second kind,
and <span class="math">\(R\)</span> for the ribbon basis). The map <span class="math">\(\psi\)</span> is an involution
and a graded Hopf algebra automorphism of <span class="math">\(NCSF\)</span>. If <span class="math">\(\pi\)</span>
denotes the projection from <span class="math">\(NCSF\)</span> to the ring of symmetric
functions (<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><tt class="xref py py-meth docutils literal"><span class="pre">to_symmetric_function()</span></tt></a>), then
<span class="math">\(\pi(\psi(f)) = \omega(\pi(f))\)</span> for every <span class="math">\(f \in NCSF\)</span>, where
the <span class="math">\(\omega\)</span> on the right hand side denotes the omega
automorphism of <span class="math">\(Sym\)</span>.</p>
<p>The involution <span class="math">\(\psi\)</span> of <span class="math">\(NCSF\)</span> is adjoint to the involution
<span class="math">\(\psi\)</span> of <span class="math">\(QSym\)</span> by the standard adjunction between <span class="math">\(NCSF\)</span> and
<span class="math">\(QSym\)</span>.</p>
<p>The involution <span class="math">\(\psi\)</span> has been denoted by <span class="math">\(\psi\)</span> in <a class="reference internal" href="qsym.html#lmvw13" id="id11">[LMvW13]</a>,
section 3.6.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.psi_involution"><tt class="xref py py-meth docutils literal"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">QSym</span></tt></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution"><tt class="xref py py-meth docutils literal"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">R[1, 1, 2, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">R[1, 1, 1, 1, 1, 2, 1, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">R</span><span class="p">[[]])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">4*R[] - 3*R[1, 1, 1] + R[1, 1, 1, 1, 1, 1, 1, 1, 2] - R[1, 1, 1, 1, 1, 1, 1, 2, 1] + 2*R[1, 2, 1, 1, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">-2*R[1, 1] + R[1, 1, 2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">R[1, 3]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">S[1, 1, 1] - S[2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">-Phi[2, 1]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">Phi[3, 1]</span>
</pre></div>
</div>
<p>The Psi basis doesn&#8217;t behave as nicely:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">-Psi[2, 1]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">1/2*Psi[1, 2, 1] - 1/2*Psi[2, 1, 1] + Psi[3, 1]</span>
</pre></div>
</div>
<p>The involution <span class="math">\(\psi\)</span> commutes with the antipode:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">....:      == R(I).antipode().psi_involution()</span>
<span class="go">....:      for I in Compositions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Testing the <span class="math">\(\pi(\psi(f)) = \omega(\pi(f))\)</span> relation noticed
above:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="go">....:      == R(I).to_symmetric_function().omega()</span>
<span class="go">....:      for I in Compositions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The involution <span class="math">\(\psi\)</span> of <span class="math">\(QSym\)</span> is adjoint to the involution
<span class="math">\(\psi\)</span> of <span class="math">\(NSym\)</span> with respect to the duality pairing:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QSym</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QSym</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">M</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">J</span><span class="p">))</span>
<span class="go">....:           == M(I).duality_pairing(S(J).psi_involution())</span>
<span class="go">....:           for I in Compositions(2) )</span>
<span class="go">....:      for J in Compositions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution">
<tt class="descname">star_involution</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<tt class="docutils literal"><span class="pre">self</span></tt> under the star involution.</p>
<p>The star involution is defined as the algebra antihomomorphism
<span class="math">\(NCSF \to NCSF\)</span> which, for every positive integer <span class="math">\(n\)</span>, sends
the <span class="math">\(n\)</span>-th complete non-commutative symmetric function <span class="math">\(S_n\)</span> to
<span class="math">\(S_n\)</span>. Denoting by <span class="math">\(f^{\ast}\)</span> the image of an element
<span class="math">\(f \in NCSF\)</span> under this star involution, it can be shown that
every composition <span class="math">\(I\)</span> satisfies</p>
<div class="math">
\[(S^I)^{\ast} = S^{I^r}, \quad
(\Lambda^I)^{\ast} = \Lambda^{I^r}, \quad
R_I^{\ast} = R_{I^r}, \quad
(\Phi^I)^{\ast} = \Phi^{I^r},\]</div>
<p>where <span class="math">\(I^r\)</span> denotes the reversed composition of <span class="math">\(I\)</span>, and
standard notations for classical bases of <span class="math">\(NCSF\)</span> are being used
(<span class="math">\(S\)</span> for the complete basis, <span class="math">\(\Lambda\)</span> for the elementary basis,
<span class="math">\(R\)</span> for the ribbon basis, and <span class="math">\(\Phi\)</span> for that of the power-sums
of the second kind). The star involution is an involution and a
coalgebra automorphism of <span class="math">\(NCSF\)</span>. It is an automorphism of the
graded vector space <span class="math">\(NCSF\)</span>. Under the canonical isomorphism
between the <span class="math">\(n\)</span>-th graded component of <span class="math">\(NCSF\)</span> and the descent
algebra of the symmetric group <span class="math">\(S_n\)</span> (see
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra"><tt class="xref py py-meth docutils literal"><span class="pre">to_descent_algebra()</span></tt></a>), the star involution (restricted to
the <span class="math">\(n\)</span>-th graded component) corresponds to the automorphism
of the descent algebra given by
<span class="math">\(x \mapsto \omega_n x \omega_n\)</span>, where <span class="math">\(\omega_n\)</span> is the
permutation <span class="math">\((n, n-1, \ldots, 1) \in S_n\)</span> (written here in
one-line notation). If <span class="math">\(\pi\)</span> denotes the projection from <span class="math">\(NCSF\)</span>
to the ring of symmetric functions
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><tt class="xref py py-meth docutils literal"><span class="pre">to_symmetric_function()</span></tt></a>), then <span class="math">\(\pi(f^{\ast}) = \pi(f)\)</span>
for every <span class="math">\(f \in NCSF\)</span>.</p>
<p>The star involution on <span class="math">\(NCSF\)</span> is adjoint to the star involution
on <span class="math">\(QSym\)</span> by the standard adjunction between <span class="math">\(NCSF\)</span> and <span class="math">\(QSym\)</span>.</p>
<p>The star involution has been denoted by <span class="math">\(\rho\)</span> in <a class="reference internal" href="qsym.html#lmvw13" id="id12">[LMvW13]</a>,
section 3.6.
See <a class="reference internal" href="qsym.html#ncsf2" id="id13">[NCSF2]</a>, section 2.3 for the properties of this map.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.star_involution"><tt class="xref py py-meth docutils literal"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">QSym</span></tt></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution"><tt class="xref py py-meth docutils literal"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">S[2, 3]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">S[3, 6]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">S</span><span class="p">[[]])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">4*S[] + S[1, 9] - S[2, 8] - 3*S[3] + 2*S[4, 6]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">-2*S[2] + S[3, 3]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">S[2, 4]</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">R[2, 4]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">Phi[1, 2]</span>
</pre></div>
</div>
<p>The Psi basis doesn&#8217;t behave as nicely:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">Psi[1, 2]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">1/2*Psi[1, 1, 2] - 1/2*Psi[1, 2, 1] + Psi[1, 3]</span>
</pre></div>
</div>
<p>The star involution commutes with the antipode:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">....:      == R(I).antipode().star_involution()</span>
<span class="go">....:      for I in Compositions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Checking the relation with the descent algebra described
above:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">descent_test</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="go">....:     DA = DescentAlgebra(QQ, n)</span>
<span class="go">....:     NSym = NonCommutativeSymmetricFunctions(QQ)</span>
<span class="go">....:     S = NSym.S()</span>
<span class="go">....:     DAD = DA.D()</span>
<span class="go">....:     w_n = DAD(set(range(1, n)))</span>
<span class="go">....:     for I in Compositions(n):</span>
<span class="go">....:         if not (S[I].star_involution()</span>
<span class="go">....:                 == w_n * S[I].to_descent_algebra(n) * w_n):</span>
<span class="go">....:             return False</span>
<span class="go">....:         return True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">descent_test</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">descent_test</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span> <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Testing the <span class="math">\(\pi(f^{\ast}) = \pi(f)\)</span> relation noticed above:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="go">....:      == R(I).to_symmetric_function()</span>
<span class="go">....:      for I in Compositions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The star involution on <span class="math">\(QSym\)</span> is adjoint to the star involution
on <span class="math">\(NSym\)</span> with respect to the duality pairing:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QSym</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QSym</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">M</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">J</span><span class="p">))</span>
<span class="go">....:           == M(I).duality_pairing(S(J).star_involution())</span>
<span class="go">....:           for I in Compositions(2) )</span>
<span class="go">....:      for J in Compositions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra">
<tt class="descname">to_descent_algebra</tt><big>(</big><em>n=None</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the <tt class="docutils literal"><span class="pre">n</span></tt>-th degree homogeneous component
of <tt class="docutils literal"><span class="pre">self</span></tt> in the descent algebra of <span class="math">\(S_n\)</span> over the same
base ring as <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This is based upon the canonical isomorphism from the
<span class="math">\(n\)</span>-th degree homogeneous component of the algebra of
noncommutative symmetric functions to the descent algebra
of <span class="math">\(S_n\)</span>. This isomorphism maps the inner product of
noncommutative symmetric functions either to the product
in the descent algebra of <span class="math">\(S_n\)</span> or to its opposite
(depending on how the latter is defined).</p>
<p>If <tt class="docutils literal"><span class="pre">n</span></tt> is not specified, it will be taken to be the highest
homogeneous component of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>The image of the <tt class="docutils literal"><span class="pre">n</span></tt>-th homogeneous component of <tt class="docutils literal"><span class="pre">self</span></tt>
under the isomorphism into the descent algebra of <span class="math">\(S_n\)</span>
over the same base ring as <tt class="docutils literal"><span class="pre">self</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">to_descent_algebra</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">B[2, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">to_descent_algebra</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">-3*B[1, 1, 2] + B[1, 2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">to_descent_algebra</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">to_descent_algebra</span><span class="p">()</span>
<span class="go">B[2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span><span class="o">.</span><span class="n">to_descent_algebra</span><span class="p">()</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Descent algebra of 0 over Integer Ring in the subset basis</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">to_descent_algebra</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_ncsym">
<tt class="descname">to_ncsym</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_ncsym" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <tt class="docutils literal"><span class="pre">self</span></tt> in the symmetric functions in
non-commuting variables under the map described in
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.to_ncsym_on_basis" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.to_ncsym_on_basis"><tt class="xref py py-meth docutils literal"><span class="pre">to_ncsym_on_basis()</span></tt></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*R[] + 2*R[1] + 3*R[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">to_ncsym</span><span class="p">()</span>
<span class="go">2*m{} + 2*m{{1}} + 3/2*m{{1}, {2}}</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Phi</span><span class="p">()[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">to_ncsym</span><span class="p">()</span>
<span class="go">m{{1}, {2, 3}} + m{{1, 2, 3}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function">
<tt class="descname">to_symmetric_function</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the commutative image of a non-commutative symmetric function.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>The commutative image of <tt class="docutils literal"><span class="pre">self</span></tt>. This will be a symmetric function.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*R[] + 2*R[1] + 3*R[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="go">2*s[] + 2*s[1] + 3*s[1, 1]</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Phi</span><span class="p">()[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="go">h[1, 1, 1, 1] - 3*h[2, 1, 1] + 3*h[3, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_group_algebra">
<tt class="descname">to_symmetric_group_algebra</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_group_algebra" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of a non-commutative symmetric function into the
symmetric group algebra where the ribbon basis element indexed by a
composition is associated with the sum of all permutations which have
descent set equal to said composition. In compliance with the anti-
isomorphism between the descent algebra and the non-commutative
symmetric functions, we index descent positions by the reversed composition.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>The image of <tt class="docutils literal"><span class="pre">self</span></tt> under the embedding of the <span class="math">\(n\)</span>-th
degree homogeneous component of the non-commutative
symmetric functions in the symmetric group algebra of
<span class="math">\(S_n\)</span>. This can behave unexpectedly when <tt class="docutils literal"><span class="pre">self</span></tt> is
not homogeneous.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">to_symmetric_group_algebra</span><span class="p">()</span>
<span class="go">[1, 3, 2] + [2, 3, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([])</span><span class="o">.</span><span class="n">to_symmetric_group_algebra</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Sending a noncommutative symmetric function to the symmetric
group algebra directly has the same result as going through
the descent algebra:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">SGA4</span> <span class="o">=</span> <span class="n">SymmetricGroupAlgebra</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D4</span> <span class="o">=</span> <span class="n">DescentAlgebra</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">D</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">S</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">to_symmetric_group_algebra</span><span class="p">()</span>
<span class="go">....:      == SGA4(D4(S[C].to_descent_algebra(4)))</span>
<span class="go">....:      for C in Compositions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung">
<tt class="descname">verschiebung</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<tt class="docutils literal"><span class="pre">self</span></tt> under the <span class="math">\(n\)</span>-th Verschiebung operator.</p>
<p>The <span class="math">\(n\)</span>-th Verschiebung operator <span class="math">\(\mathbf{V}_n\)</span> is defined
to be the map from the <span class="math">\(\mathbf{k}\)</span>-algebra of noncommutative
symmetric functions to itself that sends the complete function
<span class="math">\(S^I\)</span> indexed by a composition <span class="math">\(I = (i_1, i_2, \ldots , i_k)\)</span>
to <span class="math">\(S^{(i_1/n, i_2/n, \ldots , i_k/n)}\)</span> if all of the numbers
<span class="math">\(i_1, i_2, \ldots, i_k\)</span> are divisible by <span class="math">\(n\)</span>, and to <span class="math">\(0\)</span>
otherwise. This operator <span class="math">\(\mathbf{V}_n\)</span> is a Hopf algebra
endomorphism. For every positive integer <span class="math">\(r\)</span> with <span class="math">\(n \mid r\)</span>,
it satisfies</p>
<div class="math">
\[\mathbf{V}_n(S_r) = S_{r/n},
\quad \mathbf{V}_n(\Lambda_r) = (-1)^{r - r/n} \Lambda_{r/n},
\quad \mathbf{V}_n(\Psi_r) = n \Psi_{r/n},
\quad \mathbf{V}_n(\Phi_r) = n \Phi_{r/n}\]</div>
<p>(where <span class="math">\(S_r\)</span> denotes the <span class="math">\(r\)</span>-th complete non-commutative
symmetric function, <span class="math">\(\Lambda_r\)</span> denotes the <span class="math">\(r\)</span>-th elementary
non-commutative symmetric function, <span class="math">\(\Psi_r\)</span> denotes the <span class="math">\(r\)</span>-th
power-sum non-commutative symmetric function of the first kind,
and <span class="math">\(\Phi_r\)</span> denotes the <span class="math">\(r\)</span>-th power-sum non-commutative
symmetric function of the second kind). For every positive
integer <span class="math">\(r\)</span> with <span class="math">\(n \nmid r\)</span>, it satisfes</p>
<div class="math">
\[\mathbf{V}_n(S_r) = \mathbf{V}_n(\Lambda_r)
= \mathbf{V}_n(\Psi_r) = \mathbf{V}_n(\Phi_r) = 0.\]</div>
<p>The <span class="math">\(n\)</span>-th Verschiebung operator is also called the <span class="math">\(n\)</span>-th
Verschiebung endomorphism.</p>
<p>It is a lift of the <span class="math">\(n\)</span>-th Verschiebung operator on the ring
of symmetric functions
(<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><tt class="xref py py-meth docutils literal"><span class="pre">verschiebung()</span></tt></a>)
to the ring of noncommutative symmetric functions.</p>
<p>The action of the <span class="math">\(n\)</span>-th Verschiebung operator can also be
described on the ribbon Schur functions. Namely, every
composition <span class="math">\(I\)</span> of size <span class="math">\(n \ell\)</span> satisfies</p>
<div class="math">
\[\mathbf{V}_n ( R_I )
= (-1)^{\ell(I) - \ell(J)} \cdot R_{J / n},\]</div>
<p>where <span class="math">\(J\)</span> denotes the meet of the compositions <span class="math">\(I\)</span> and
<span class="math">\((\underbrace{n, n, \ldots, n}_{|I|/n \mbox{ times}})\)</span>,
where <span class="math">\(\ell(I)\)</span> is the length of <span class="math">\(I\)</span>, and
where <span class="math">\(J / n\)</span> denotes the composition obtained by dividing
every entry of <span class="math">\(J\)</span> by <span class="math">\(n\)</span>.
For a composition <span class="math">\(I\)</span> of size not divisible by <span class="math">\(n\)</span>, we have
<span class="math">\(\mathbf{V}_n( R_I ) = 0\)</span>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius"><tt class="xref py py-meth docutils literal"><span class="pre">frobenius</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">QSym</span></tt></a>,
<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><tt class="xref py py-meth docutils literal"><span class="pre">verschiebung</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">Sym</span></tt></a></p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; a positive integer</li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the <span class="math">\(n\)</span>-th Verschiebung operator (on the
ring of noncommutative symmetric functions) to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">S[3, 2]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">S</span><span class="p">[[]])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*S[] + 2*S[3, 2] - S[4, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">S[1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">S[4, 2]</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">R[2, 1]</span>
</pre></div>
</div>
<p>Being Hopf algebra endomorphisms, the Verschiebung operators
commute with the antipode:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">....:      == R(I).antipode().verschiebung(2)</span>
<span class="go">....:      for I in Compositions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>They lift the Verschiebung operators of the ring of symmetric
functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">S</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="go">....:      == S(I).to_symmetric_function().verschiebung(2)</span>
<span class="go">....:      for I in Compositions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Frobenius operators on <span class="math">\(QSym\)</span> are adjoint to the
Verschiebung operators on <span class="math">\(NSym\)</span> with respect to the duality
pairing:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QSym</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QSym</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">M</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">J</span><span class="p">))</span>
<span class="go">....:           == M(I).duality_pairing(S(J).verschiebung(3))</span>
<span class="go">....:           for I in Compositions(2) )</span>
<span class="go">....:      for J in Compositions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods">
<em class="property">class </em><tt class="descclassname">NonCommutativeSymmetricFunctions.Bases.</tt><tt class="descname">ParentMethods</tt><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.immaculate_function">
<tt class="descname">immaculate_function</tt><big>(</big><em>xs</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.immaculate_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the immaculate function corresponding to the
integer vector <tt class="docutils literal"><span class="pre">xs</span></tt>, written in the basis <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>If <span class="math">\(\alpha\)</span> is any integer vector &#8211; i.e., an element of
<span class="math">\(\ZZ^m\)</span> for some <span class="math">\(m \in \NN\)</span> &#8211;, the <em>immaculate function
corresponding to</em> <span class="math">\(\alpha\)</span> is a non-commutative symmetric
function denoted by <span class="math">\(\mathfrak{S}_{\alpha}\)</span>. One way to
define this function is by setting</p>
<div class="math">
\[\mathfrak{S}_{\alpha}
= \sum_{\sigma \in S_m} (-1)^{\sigma}
S_{\alpha_1 + \sigma(1) - 1}
S_{\alpha_2 + \sigma(2) - 2}
\cdots
S_{\alpha_m + \sigma(m) - m},\]</div>
<p>where <span class="math">\(\alpha\)</span> is written in the form
<span class="math">\((\alpha_1, \alpha_2, \ldots, \alpha_m)\)</span>, and where <span class="math">\(S\)</span>
stands for the complete basis
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete"><tt class="xref py py-class docutils literal"><span class="pre">Complete</span></tt></a>).</p>
<p>The immaculate function <span class="math">\(\mathfrak{S}_{\alpha}\)</span> first
appeared in <a class="reference internal" href="qsym.html#bbssz2012" id="id14">[BBSSZ2012]</a> (where it was defined
differently, but the definition we gave above appeared as
Theorem 3.27).</p>
<p>The immaculate functions <span class="math">\(\mathfrak{S}_{\alpha}\)</span> for
<span class="math">\(\alpha\)</span> running over all compositions (i.e., finite
sequences of positive integers) form a basis of <span class="math">\(NCSF\)</span>.
This is the <em>immaculate basis</em>
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate"><tt class="xref py py-class docutils literal"><span class="pre">Immaculate</span></tt></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">xs</span></tt> &#8211; list (or tuple or any iterable &#8211; possibly a
composition) of integers</li>
</ul>
<p>OUTPUT:</p>
<p>The immaculate function <span class="math">\(\mathfrak{S}_{xs}\)</span>
written in the basis <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<p>Let us first check that, for <tt class="docutils literal"><span class="pre">xs</span></tt> a composition, we get
the same as the result of
<tt class="docutils literal"><span class="pre">self.realization_of().I()[xs]</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_comp</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
<span class="go">....:     NSym = NonCommutativeSymmetricFunctions(QQ)</span>
<span class="go">....:     I = NSym.I()</span>
<span class="go">....:     return I[xs] == I.immaculate_function(xs)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_allcomp</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="go">....:     return all( test_comp(c) for c in Compositions(n) )</span>
<span class="gp">sage: </span><span class="n">test_allcomp</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_allcomp</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_allcomp</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Now some examples of non-composition immaculate
functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">I</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">-I[1, 1]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">-I[]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">I[2]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">-I[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">-I[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">I[1, 1, 1, 1] + I[1, 2, 1]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">I[2, 1, 1, 1, 1] + I[2, 1, 2, 1]</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Basis-independence:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span> <span class="o">==</span> <span class="n">L</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.to_ncsym">
<tt class="descname">to_ncsym</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.to_ncsym" title="Permalink to this definition">¶</a></dt>
<dd><p>Morphism <span class="math">\(\kappa\)</span> of <tt class="docutils literal"><span class="pre">self</span></tt> to the algebra of symmetric
functions in non-commuting variables that for the natural
maps <span class="math">\(\chi : NCSym \to Sym\)</span> and <span class="math">\(\rho : NSym \to Sym\)</span>, we
have <span class="math">\(\chi \circ \kappa = \rho\)</span>.</p>
<p>This is constructed by extending the method
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.to_ncsym_on_basis" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.to_ncsym_on_basis"><tt class="xref py py-meth docutils literal"><span class="pre">to_ncsym_on_basis()</span></tt></a>
linearly.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*R[] + 2*R[1] + 3*R[1, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">to_ncsym</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">2*m{} + 2*m{{1}} + 3/2*m{{1}, {2}}</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">to_ncsym</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">1/2*m{{1}, {2}, {3}} + m{{1}, {2, 3}} + 1/2*m{{1, 2}, {3}}</span>
<span class="go"> + m{{1, 2, 3}} + 1/2*m{{1, 3}, {2}}</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="o">.</span><span class="n">to_ncsym</span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">-1/4*m{{1}, {2}, {3, 4}} - 1/4*m{{1}, {2, 3}, {4}} + m{{1}, {2, 3, 4}}</span>
<span class="go"> + 1/2*m{{1}, {2, 4}, {3}} - 1/4*m{{1, 2}, {3, 4}} - 1/4*m{{1, 2, 3}, {4}}</span>
<span class="go"> + m{{1, 2, 3, 4}} + 1/2*m{{1, 2, 4}, {3}} + 1/2*m{{1, 3}, {2, 4}}</span>
<span class="go"> - 1/4*m{{1, 3, 4}, {2}} - 1/4*m{{1, 4}, {2, 3}}</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">to_ncsym</span>
<span class="go">Generic morphism:</span>
<span class="go">  From: Non-Commutative Symmetric Functions over the Rational Field in the Ribbon basis</span>
<span class="go">  To:   Symmetric functions in non-commuting variables over the Rational Field in the monomial basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.to_ncsym_on_basis">
<tt class="descname">to_ncsym_on_basis</tt><big>(</big><em>I</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.to_ncsym_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>The image of the basis element indexed by <tt class="docutils literal"><span class="pre">I</span></tt> under the
map <span class="math">\(\kappa\)</span> to the symmetric functions in non-commuting
variables such that for the natural maps <span class="math">\(\chi : NCSym \to Sym\)</span>
and <span class="math">\(\rho : NSym \to Sym\)</span>, we have <span class="math">\(\chi \circ \kappa = \rho\)</span>.</p>
<p>This default implementation does a change of basis and
computes the image in the complete basis.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.to_ncsym_on_basis" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.to_ncsym_on_basis"><tt class="xref py py-meth docutils literal"><span class="pre">to_ncsym_on_basis()</span></tt></a></p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">I</span></tt> &#8211; a composition</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">to_ncsym</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">1/2*m{{1}, {2}, {3}} + 1/2*m{{1}, {2, 3}} + m{{1, 2}, {3}}</span>
<span class="go"> + m{{1, 2, 3}} + 1/2*m{{1, 3}, {2}}</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">to_ncsym_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">1/3*m{{1}, {2}, {3}} + 1/6*m{{1}, {2, 3}} + 2/3*m{{1, 2}, {3}} + 1/6*m{{1, 3}, {2}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.to_symmetric_function">
<tt class="descname">to_symmetric_function</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.to_symmetric_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Morphism to the algebra of symmetric functions.</p>
<p>This is constructed by extending the computation on the basis
or by coercion to the complete basis.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>The module morphism from the basis <tt class="docutils literal"><span class="pre">self</span></tt> to the symmetric
functions which corresponds to taking a commutative image.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*R[] + 2*R[1] + 3*R[1, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">2*s[] + 2*s[1] + 3*s[1, 1]</span>
<span class="gp">sage: </span><span class="n">nM</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">nM</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">nM</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">h[1, 1, 1, 1] - 7/2*h[2, 1, 1] + h[2, 2] + 7/2*h[3, 1] - 2*h[4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.to_symmetric_function_on_basis">
<tt class="descname">to_symmetric_function_on_basis</tt><big>(</big><em>I</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.to_symmetric_function_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>The image of the basis element indexed by <tt class="docutils literal"><span class="pre">I</span></tt> under the map
to the symmetric functions.</p>
<p>This default implementation does a change of basis and
computes the image in the complete basis.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">I</span></tt> &#8211; a composition</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The image of the non-commutative basis element of
<tt class="docutils literal"><span class="pre">self</span></tt> indexed by the composition <tt class="docutils literal"><span class="pre">I</span></tt> under the map from
non-commutative symmetric functions to the symmetric
functions. This will be a symmetric function.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Immaculate</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">-h[2, 2] + h[3, 1]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">==</span><span class="n">Phi</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">([])</span>
<span class="go">h[]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.super_categories">
<tt class="descclassname">NonCommutativeSymmetricFunctions.Bases.</tt><tt class="descname">super_categories</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the super categories of the category of bases of the
non-commutative symmetric functions.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>list</li>
</ul>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">Bases</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of bases of Non-Commutative Symmetric Functions or Quasisymmetric functions over the Rational Field,</span>
<span class="go"> Category of realizations of graded modules with internal product over Rational Field]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete">
<em class="property">class </em><tt class="descclassname">NonCommutativeSymmetricFunctions.</tt><tt class="descname">Complete</tt><big>(</big><em>NCSF</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></tt></a>, <a class="reference external" href="../../../../misc/sage/misc/bindable_class.html#sage.misc.bindable_class.BindableClass" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.misc.bindable_class.BindableClass</span></tt></a></p>
<p>The Hopf algebra of non-commutative symmetric functions in the
Complete basis.</p>
<p>The Complete basis is defined in Definition 3.4 of <a class="reference internal" href="qsym.html#ncsf1" id="id15">[NCSF1]</a>, where
it is denoted by <span class="math">\((S^I)_I\)</span>. It is a multiplicative basis, and is
connected to the elementary generators <span class="math">\(\Lambda_i\)</span> of the ring of
non-commutative symmetric functions by the following relation:
Define a non-commutative symmetric function <span class="math">\(S_n\)</span> for every
nonnegative integer <span class="math">\(n\)</span> by the power series identity</p>
<div class="math">
\[\sum_{k \geq 0} t^k S_k
= \left( \sum_{k \geq 0} (-t)^k \Lambda_k \right)^{-1},\]</div>
<p>with <span class="math">\(\Lambda_0\)</span> denoting <span class="math">\(1\)</span>. For every composition
<span class="math">\((i_1, i_2, \ldots, i_k)\)</span>, we have
<span class="math">\(S^{(i_1, i_2, \ldots, i_k)} = S_{i_1} S_{i_2} \cdots S_{i_k}\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Complete</span><span class="p">();</span> <span class="n">S</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Complete basis</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">2*S[] + 2*S[1] + 3*S[1, 1]</span>
</pre></div>
</div>
<p>The following are aliases for this basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Complete basis</span>
<span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Complete basis</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.Element">
<em class="property">class </em><tt class="descname">Element</tt><big>(</big><em>M</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModuleElement" title="sage.combinat.free_module.CombinatorialFreeModuleElement"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.free_module.CombinatorialFreeModuleElement</span></tt></a></p>
<p>An element in the Complete basis.</p>
<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.Element.psi_involution">
<tt class="descname">psi_involution</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.Element.psi_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<tt class="docutils literal"><span class="pre">self</span></tt> under the involution <span class="math">\(\psi\)</span>.</p>
<p>The involution <span class="math">\(\psi\)</span> is defined as the linear map
<span class="math">\(NCSF \to NCSF\)</span> which, for every composition <span class="math">\(I\)</span>, sends the
complete noncommutative symmetric function <span class="math">\(S^I\)</span> to the
elementary noncommutative symmetric function <span class="math">\(\Lambda^I\)</span>.
It can be shown that every composition <span class="math">\(I\)</span> satisfies</p>
<div class="math">
\[\psi(R_I) = R_{I^c}, \quad \psi(S^I) = \Lambda^I, \quad
\psi(\Lambda^I) = S^I, \quad
\psi(\Phi^I) = (-1)^{|I| - \ell(I)} \Phi^I\]</div>
<p>where <span class="math">\(I^c\)</span> denotes the complement of the composition <span class="math">\(I\)</span>, and
<span class="math">\(\ell(I)\)</span> denotes the length of <span class="math">\(I\)</span>, and where standard
notations for classical bases of <span class="math">\(NCSF\)</span> are being used
(<span class="math">\(S\)</span> for the complete basis, <span class="math">\(\Lambda\)</span> for the elementary
basis, <span class="math">\(\Phi\)</span> for the basis of the power sums of the second
kind, and <span class="math">\(R\)</span> for the ribbon basis). The map <span class="math">\(\psi\)</span> is an
involution and a graded Hopf algebra automorphism of <span class="math">\(NCSF\)</span>.
If <span class="math">\(\pi\)</span> denotes the projection from <span class="math">\(NCSF\)</span> to the ring of
symmetric functions
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><tt class="xref py py-meth docutils literal"><span class="pre">to_symmetric_function()</span></tt></a>),
then <span class="math">\(\pi(\psi(f)) = \omega(\pi(f))\)</span> for every <span class="math">\(f \in NCSF\)</span>, where
the <span class="math">\(\omega\)</span> on the right hand side denotes the omega
automorphism of <span class="math">\(Sym\)</span>.</p>
<p>The involution <span class="math">\(\psi\)</span> of <span class="math">\(NCSF\)</span> is adjoint to the involution
<span class="math">\(\psi\)</span> of <span class="math">\(QSym\)</span> by the standard adjunction between <span class="math">\(NCSF\)</span> and
<span class="math">\(QSym\)</span>.</p>
<p>The involution <span class="math">\(\psi\)</span> has been denoted by <span class="math">\(\psi\)</span> in <a class="reference internal" href="qsym.html#lmvw13" id="id16">[LMvW13]</a>,
section 3.6.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution"><tt class="xref py py-meth docutils literal"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.psi_involution"><tt class="xref py py-meth docutils literal"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">QSym</span></tt></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution"><tt class="xref py py-meth docutils literal"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">S[1, 1, 1, 1] - S[1, 2, 1] - S[2, 1, 1] + S[3, 1]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">())</span>
<span class="go">L[3, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[[]]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">S[]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">S[1, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">-2*S[1, 1] + S[1, 1, 1] + 2*S[2] - S[2, 1]</span>
</pre></div>
</div>
<p>The implementation at hand is tailored to the complete basis.
It is equivalent to the generic implementation via the
ribbon basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">())</span> <span class="o">==</span> <span class="n">R</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">I</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">....:      for I in Compositions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.dual">
<tt class="descclassname">NonCommutativeSymmetricFunctions.Complete.</tt><tt class="descname">dual</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual basis to the complete basis of non-commutative symmetric
functions. This is the Monomial basis of quasi-symmetric functions.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>The Monomial basis of quasi-symmetric functions.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="go">Quasisymmetric functions over the Rational Field in the Monomial basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.internal_product_on_basis">
<tt class="descclassname">NonCommutativeSymmetricFunctions.Complete.</tt><tt class="descname">internal_product_on_basis</tt><big>(</big><em>I</em>, <em>J</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.internal_product_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>The internal product of two non-commutative symmetric
complete functions.</p>
<p>See <a class="reference internal" href="generic_basis_code.html#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product"><tt class="xref py py-meth docutils literal"><span class="pre">internal_product()</span></tt></a>
for a thorough documentation of this operation.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">I</span></tt>, <tt class="docutils literal"><span class="pre">J</span></tt> &#8211; compositions</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The internal product of the complete non-commutative symmetric
function basis elements indexed by <tt class="docutils literal"><span class="pre">I</span></tt> and <tt class="docutils literal"><span class="pre">J</span></tt>, expressed in
the complete basis.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product_on_basis</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*S[1, 1, 1, 1] + S[1, 1, 2] + S[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product_on_basis</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.to_ncsym_on_basis">
<tt class="descclassname">NonCommutativeSymmetricFunctions.Complete.</tt><tt class="descname">to_ncsym_on_basis</tt><big>(</big><em>I</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.to_ncsym_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the complete non-commutative symmetric function
in the symmetric functions in non-commuting variables under the
embedding <span class="math">\(\mathcal{I}\)</span> which fixes the symmetric functions.</p>
<p>This map is defined by</p>
<div class="math">
\[S_n \mapsto \sum_{A \vdash [n]}
\frac{\lambda(A)! \lambda(A)^!}{n!} \mathbf{m}_A\]</div>
<p>and extended as an algebra homomorphism.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A remark in <a class="reference internal" href="../ncsym/ncsym.html#brrz08" id="id17">[BRRZ08]</a>  makes it clear that the embedding of <tt class="docutils literal"><span class="pre">NCSF</span></tt>
into <tt class="docutils literal"><span class="pre">NCSym</span></tt> that preserves the projection into the symmetric
functions is not unique.  While this seems to be a natural embedding,
any set of algebraic generators can be sent to a set of free elements
in <tt class="docutils literal"><span class="pre">NCSym</span></tt> is also an embedding.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">to_ncsym_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">1/2*m{{1}, {2}} + m{{1, 2}}</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">to_ncsym_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">1/2*m{{1}, {2}, {3}, {4}} + 1/2*m{{1}, {2}, {3, 4}} + m{{1}, {2, 3}, {4}}</span>
<span class="go"> + m{{1}, {2, 3, 4}} + 1/2*m{{1}, {2, 4}, {3}} + 1/2*m{{1, 2}, {3}, {4}}</span>
<span class="go"> + 1/2*m{{1, 2}, {3, 4}} + m{{1, 2, 3}, {4}} + m{{1, 2, 3, 4}}</span>
<span class="go"> + 1/2*m{{1, 2, 4}, {3}} + 1/2*m{{1, 3}, {2}, {4}} + 1/2*m{{1, 3}, {2, 4}}</span>
<span class="go"> + 1/2*m{{1, 3, 4}, {2}} + 1/2*m{{1, 4}, {2}, {3}} + m{{1, 4}, {2, 3}}</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">to_ncsym_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([]))</span>
<span class="go">m{}</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Check that the image under <span class="math">\(\mathcal{I}\)</span> fixes the
symmetric functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">SymmetricFunctionsNonCommutingVariables</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">mon</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">to_ncsym</span><span class="p">()</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span> <span class="o">==</span> <span class="n">S</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="go">....:     for i in range(5) for c in Compositions(i))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We also check that the <span class="math">\(NCSym\)</span> monomials agree on the homogeneous
and complete basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">from_symmetric_function</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">to_ncsym</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.to_symmetric_function">
<tt class="descclassname">NonCommutativeSymmetricFunctions.Complete.</tt><tt class="descname">to_symmetric_function</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.to_symmetric_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Morphism to the algebra of symmetric functions.</p>
<p>This is constructed by extending the computation on the
complete basis.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>The module morphism from the basis <tt class="docutils literal"><span class="pre">self</span></tt> to the symmetric
functions which corresponds to taking a commutative image.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">h[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">S</span><span class="p">[[]])</span>
<span class="go">h[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.to_symmetric_function_on_basis">
<tt class="descclassname">NonCommutativeSymmetricFunctions.Complete.</tt><tt class="descname">to_symmetric_function_on_basis</tt><big>(</big><em>I</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.to_symmetric_function_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>The commutative image of a complete element</p>
<p>The commutative image of a basis element is obtained by sorting
the indexing composition of the basis element and the output
is in the complete basis of the symmetric functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">I</span></tt> &#8211; a composition</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The commutative image of the complete basis element
indexed by <tt class="docutils literal"><span class="pre">I</span></tt>. The result is the complete symmetric function
indexed by the partition obtained by sorting <tt class="docutils literal"><span class="pre">I</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">h[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">([])</span>
<span class="go">h[]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary">
<em class="property">class </em><tt class="descclassname">NonCommutativeSymmetricFunctions.</tt><tt class="descname">Elementary</tt><big>(</big><em>NCSF</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></tt></a>, <a class="reference external" href="../../../../misc/sage/misc/bindable_class.html#sage.misc.bindable_class.BindableClass" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.misc.bindable_class.BindableClass</span></tt></a></p>
<p>The Hopf algebra of non-commutative symmetric functions in the
Elementary basis.</p>
<p>The Elementary basis is defined in Definition 3.4 of <a class="reference internal" href="qsym.html#ncsf1" id="id18">[NCSF1]</a>,
where it is denoted by <span class="math">\((\Lambda^I)_I\)</span>. It is a multiplicative
basis, and is obtained from the elementary generators
<span class="math">\(\Lambda_i\)</span> of the ring of non-commutative symmetric functions
through the formula
<span class="math">\(\Lambda^{(i_1, i_2, \ldots, i_k)}
= \Lambda_{i_1} \Lambda_{i_2} \cdots \Lambda_{i_k}\)</span>
for every composition <span class="math">\((i_1, i_2, \ldots, i_k)\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Elementary</span><span class="p">();</span> <span class="n">L</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Elementary basis</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">2*L[] + 2*L[1] + 3*L[1, 1]</span>
</pre></div>
</div>
<p>The following are aliases for this basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">elementary</span><span class="p">()</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Elementary basis</span>
<span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Elementary basis</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary.Element">
<em class="property">class </em><tt class="descname">Element</tt><big>(</big><em>M</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModuleElement" title="sage.combinat.free_module.CombinatorialFreeModuleElement"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.free_module.CombinatorialFreeModuleElement</span></tt></a></p>
<p>Create a combinatorial module element. This should never be
called directly, but only through the parent combinatorial
free module&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt> method.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">B</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">];</span> <span class="n">f</span>
<span class="go">B[&#39;a&#39;] + 3*B[&#39;c&#39;]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">==</span> <span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary.Element.psi_involution">
<tt class="descname">psi_involution</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary.Element.psi_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<tt class="docutils literal"><span class="pre">self</span></tt> under the involution <span class="math">\(\psi\)</span>.</p>
<p>The involution <span class="math">\(\psi\)</span> is defined as the linear map
<span class="math">\(NCSF \to NCSF\)</span> which, for every composition <span class="math">\(I\)</span>, sends the
complete noncommutative symmetric function <span class="math">\(S^I\)</span> to the
elementary noncommutative symmetric function <span class="math">\(\Lambda^I\)</span>.
It can be shown that every composition <span class="math">\(I\)</span> satisfies</p>
<div class="math">
\[\psi(R_I) = R_{I^c}, \quad \psi(S^I) = \Lambda^I, \quad
\psi(\Lambda^I) = S^I, \quad
\psi(\Phi^I) = (-1)^{|I| - \ell(I)} \Phi^I\]</div>
<p>where <span class="math">\(I^c\)</span> denotes the complement of the composition <span class="math">\(I\)</span>, and
<span class="math">\(\ell(I)\)</span> denotes the length of <span class="math">\(I\)</span>, and where standard
notations for classical bases of <span class="math">\(NCSF\)</span> are being used
(<span class="math">\(S\)</span> for the complete basis, <span class="math">\(\Lambda\)</span> for the elementary basis,
<span class="math">\(\Phi\)</span> for the basis of the power sums of the second kind,
and <span class="math">\(R\)</span> for the ribbon basis). The map <span class="math">\(\psi\)</span> is an involution
and a graded Hopf algebra automorphism of <span class="math">\(NCSF\)</span>. If <span class="math">\(\pi\)</span>
denotes the projection from <span class="math">\(NCSF\)</span> to the ring of symmetric functions
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><tt class="xref py py-meth docutils literal"><span class="pre">to_symmetric_function()</span></tt></a>),
then <span class="math">\(\pi(\psi(f)) = \omega(\pi(f))\)</span> for every <span class="math">\(f \in NCSF\)</span>, where
the <span class="math">\(\omega\)</span> on the right hand side denotes the omega
automorphism of <span class="math">\(Sym\)</span>.</p>
<p>The involution <span class="math">\(\psi\)</span> of <span class="math">\(NCSF\)</span> is adjoint to the involution
<span class="math">\(\psi\)</span> of <span class="math">\(QSym\)</span> by the standard adjunction between <span class="math">\(NCSF\)</span> and
<span class="math">\(QSym\)</span>.</p>
<p>The involution <span class="math">\(\psi\)</span> has been denoted by <span class="math">\(\psi\)</span> in <a class="reference internal" href="qsym.html#lmvw13" id="id19">[LMvW13]</a>,
section 3.6.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution"><tt class="xref py py-meth docutils literal"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.psi_involution"><tt class="xref py py-meth docutils literal"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">QSym</span></tt></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution"><tt class="xref py py-meth docutils literal"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">L[1, 1, 1, 1] - L[1, 2, 1] - L[2, 1, 1] + L[3, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">())</span>
<span class="go">S[3, 1]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[[]]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">L[]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">L[1, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">-2*L[1, 1] + L[1, 1, 1] + 2*L[2] - L[2, 1]</span>
</pre></div>
</div>
<p>The implementation at hand is tailored to the elementary basis.
It is equivalent to the generic implementation via the
ribbon basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">())</span> <span class="o">==</span> <span class="n">R</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">I</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">....:      for I in Compositions(3) )</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">())</span> <span class="o">==</span> <span class="n">R</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">I</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">....:      for I in Compositions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary.Element.star_involution">
<tt class="descname">star_involution</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary.Element.star_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<tt class="docutils literal"><span class="pre">self</span></tt> under the star involution.</p>
<p>The star involution is defined as the algebra antihomomorphism
<span class="math">\(NCSF \to NCSF\)</span> which, for every positive integer <span class="math">\(n\)</span>, sends
the <span class="math">\(n\)</span>-th complete non-commutative symmetric function <span class="math">\(S_n\)</span> to
<span class="math">\(S_n\)</span>. Denoting by <span class="math">\(f^{\ast}\)</span> the image of an element
<span class="math">\(f \in NCSF\)</span> under this star involution, it can be shown that
every composition <span class="math">\(I\)</span> satisfies</p>
<div class="math">
\[(S^I)^{\ast} = S^{I^r}, \quad
(\Lambda^I)^{\ast} = \Lambda^{I^r}, \quad
R_I^{\ast} = R_{I^r}, \quad
(\Phi^I)^{\ast} = \Phi^{I^r},\]</div>
<p>where <span class="math">\(I^r\)</span> denotes the reversed composition of <span class="math">\(I\)</span>, and
standard notations for classical bases of <span class="math">\(NCSF\)</span> are being used
(<span class="math">\(S\)</span> for the complete basis, <span class="math">\(\Lambda\)</span> for the elementary basis,
<span class="math">\(R\)</span> for the ribbon basis, and <span class="math">\(\Phi\)</span> for that of the power-sums
of the second kind). The star involution is an involution and a
coalgebra automorphism of <span class="math">\(NCSF\)</span>. It is an automorphism of the
graded vector space <span class="math">\(NCSF\)</span>. Under the canonical isomorphism
between the <span class="math">\(n\)</span>-th graded component of <span class="math">\(NCSF\)</span> and the descent
algebra of the symmetric group <span class="math">\(S_n\)</span> (see
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra"><tt class="xref py py-meth docutils literal"><span class="pre">to_descent_algebra()</span></tt></a>),
the star involution (restricted to
the <span class="math">\(n\)</span>-th graded component) corresponds to the automorphism
of the descent algebra given by
<span class="math">\(x \mapsto \omega_n x \omega_n\)</span>, where <span class="math">\(\omega_n\)</span> is the
permutation <span class="math">\((n, n-1, \ldots, 1) \in S_n\)</span> (written here in
one-line notation). If <span class="math">\(\pi\)</span> denotes the projection from <span class="math">\(NCSF\)</span>
to the ring of symmetric functions
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><tt class="xref py py-meth docutils literal"><span class="pre">to_symmetric_function()</span></tt></a>),
then <span class="math">\(\pi(f^{\ast}) = \pi(f)\)</span> for every <span class="math">\(f \in NCSF\)</span>.</p>
<p>The star involution on <span class="math">\(NCSF\)</span> is adjoint to the star involution
on <span class="math">\(QSym\)</span> by the standard adjunction between <span class="math">\(NCSF\)</span> and <span class="math">\(QSym\)</span>.</p>
<p>The star involution has been denoted by <span class="math">\(\rho\)</span> in <a class="reference internal" href="qsym.html#lmvw13" id="id20">[LMvW13]</a>,
section 3.6.
See <a class="reference internal" href="qsym.html#ncsf2" id="id21">[NCSF2]</a>, section 2.3 for the properties of this map.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution"><tt class="xref py py-meth docutils literal"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution"><tt class="xref py py-meth docutils literal"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.star_involution"><tt class="xref py py-meth docutils literal"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">QSym</span></tt></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">L[3, 2, 3, 3]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">L[3, 3, 6]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">L</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">L</span><span class="p">[[]])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">4*L[] + L[1, 9, 1] - L[2, 8] - 3*L[3] + 2*L[4, 6]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">-2*L[2] + L[3, 3]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">L[1, 4]</span>
</pre></div>
</div>
<p>The implementation at hand is tailored to the elementary basis.
It is equivalent to the generic implementation via the
complete basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">S</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">())</span> <span class="o">==</span> <span class="n">S</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">I</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">....:      for I in Compositions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary.Element.verschiebung">
<tt class="descname">verschiebung</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary.Element.verschiebung" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<tt class="docutils literal"><span class="pre">self</span></tt> under the <span class="math">\(n\)</span>-th Verschiebung operator.</p>
<p>The <span class="math">\(n\)</span>-th Verschiebung operator <span class="math">\(\mathbf{V}_n\)</span> is defined
to be the map from the <span class="math">\(\mathbf{k}\)</span>-algebra of noncommutative
symmetric functions to itself that sends the complete function
<span class="math">\(S^I\)</span> indexed by a composition <span class="math">\(I = (i_1, i_2, \ldots , i_k)\)</span>
to <span class="math">\(S^{(i_1/n, i_2/n, \ldots , i_k/n)}\)</span> if all of the numbers
<span class="math">\(i_1, i_2, \ldots, i_k\)</span> are divisible by <span class="math">\(n\)</span>, and to <span class="math">\(0\)</span>
otherwise. This operator <span class="math">\(\mathbf{V}_n\)</span> is a Hopf algebra
endomorphism. For every positive integer <span class="math">\(r\)</span> with <span class="math">\(n \mid r\)</span>,
it satisfies</p>
<div class="math">
\[\mathbf{V}_n(S_r) = S_{r/n},
\quad \mathbf{V}_n(\Lambda_r) = (-1)^{r - r/n} \Lambda_{r/n},
\quad \mathbf{V}_n(\Psi_r) = n \Psi_{r/n},
\quad \mathbf{V}_n(\Phi_r) = n \Phi_{r/n}\]</div>
<p>(where <span class="math">\(S_r\)</span> denotes the <span class="math">\(r\)</span>-th complete non-commutative
symmetric function, <span class="math">\(\Lambda_r\)</span> denotes the <span class="math">\(r\)</span>-th elementary
non-commutative symmetric function, <span class="math">\(\Psi_r\)</span> denotes the <span class="math">\(r\)</span>-th
power-sum non-commutative symmetric function of the first kind,
and <span class="math">\(\Phi_r\)</span> denotes the <span class="math">\(r\)</span>-th power-sum non-commutative
symmetric function of the second kind). For every positive
integer <span class="math">\(r\)</span> with <span class="math">\(n \nmid r\)</span>, it satisfes</p>
<div class="math">
\[\mathbf{V}_n(S_r) = \mathbf{V}_n(\Lambda_r)
= \mathbf{V}_n(\Psi_r) = \mathbf{V}_n(\Phi_r) = 0.\]</div>
<p>The <span class="math">\(n\)</span>-th Verschiebung operator is also called the <span class="math">\(n\)</span>-th
Verschiebung endomorphism.</p>
<p>It is a lift of the <span class="math">\(n\)</span>-th Verschiebung operator on the ring
of symmetric functions
(<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><tt class="xref py py-meth docutils literal"><span class="pre">verschiebung()</span></tt></a>)
to the ring of noncommutative symmetric functions.</p>
<p>The action of the <span class="math">\(n\)</span>-th Verschiebung operator can also be
described on the ribbon Schur functions. Namely, every
composition <span class="math">\(I\)</span> of size <span class="math">\(n \ell\)</span> satisfies</p>
<div class="math">
\[\mathbf{V}_n ( R_I )
= (-1)^{\ell(I) - \ell(J)} \cdot R_{J / n},\]</div>
<p>where <span class="math">\(J\)</span> denotes the meet of the compositions <span class="math">\(I\)</span> and
<span class="math">\((\underbrace{n, n, \ldots, n}_{|I|/n \mbox{ times}})\)</span>,
where <span class="math">\(\ell(I)\)</span> is the length of <span class="math">\(I\)</span>, and
where <span class="math">\(J / n\)</span> denotes the composition obtained by
dividing every entry of <span class="math">\(J\)</span> by <span class="math">\(n\)</span>.
For a composition <span class="math">\(I\)</span> of size not divisible by <span class="math">\(n\)</span>, we
have <span class="math">\(\mathbf{V}_n ( R_I ) = 0\)</span>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung"><tt class="xref py py-meth docutils literal"><span class="pre">verschiebung</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius"><tt class="xref py py-meth docutils literal"><span class="pre">frobenius</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">QSym</span></tt></a>,
<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><tt class="xref py py-meth docutils literal"><span class="pre">verschiebung</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">Sym</span></tt></a></p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; a positive integer</li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the <span class="math">\(n\)</span>-th Verschiebung operator (on the
ring of noncommutative symmetric functions) to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-L[2, 1]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-L[1, 2]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">6</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-L[3]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">L[]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">7</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">L[1]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">L[1] - L[2] + 2*L[3]</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>The current implementation on the Elementary basis gives
the same results as the default implementation:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_L</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="go">....:     for I in Compositions(N):</span>
<span class="go">....:         if S(L[I].verschiebung(n)) != S(L[I]).verschiebung(n):</span>
<span class="go">....:             return False</span>
<span class="go">....:     return True</span>
<span class="gp">sage: </span><span class="n">test_L</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_L</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_L</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_L</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>     <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate">
<em class="property">class </em><tt class="descclassname">NonCommutativeSymmetricFunctions.</tt><tt class="descname">Immaculate</tt><big>(</big><em>NCSF</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></tt></a>, <a class="reference external" href="../../../../misc/sage/misc/bindable_class.html#sage.misc.bindable_class.BindableClass" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.misc.bindable_class.BindableClass</span></tt></a></p>
<p>The immaculate basis of the non-commutative symmetric
functions.</p>
<p>The immaculate basis first appears in Berg, Bergeron,
Saliola, Serrano and Zabrocki&#8217;s <a class="reference internal" href="qsym.html#bbssz2012" id="id22">[BBSSZ2012]</a>. It can be
described as the family <span class="math">\((\mathfrak{S}_{\alpha})\)</span>, where
<span class="math">\(\alpha\)</span> runs over all compositions, and
<span class="math">\(\mathfrak{S}_{\alpha}\)</span> denotes the immaculate function
corresponding to <span class="math">\(\alpha\)</span> (see
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.immaculate_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.immaculate_function"><tt class="xref py py-meth docutils literal"><span class="pre">immaculate_function()</span></tt></a>).</p>
<p>If <span class="math">\(\alpha\)</span> is a composition <span class="math">\((\alpha_1, \alpha_2, \ldots,
\alpha_m)\)</span>, then</p>
<div class="math">
\[\mathfrak{S}_{\alpha}
= \sum_{\sigma \in S_m} (-1)^{\sigma}
S_{\alpha_1 + \sigma(1) - 1} S_{\alpha_2 + \sigma(2) - 2}
\cdots S_{\alpha_m + \sigma(m) - m}.\]</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This <em>basis</em> contains only the immaculate functions
indexed by compositions (i.e., finite sequences of
positive integers). To obtain the remaining immaculate
functions (sensu lato), use the
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.immaculate_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.immaculate_function"><tt class="xref py py-meth docutils literal"><span class="pre">immaculate_function()</span></tt></a>
method. Calling the immaculate <em>basis</em> with a list
which is not a composition will currently return
garbage!</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">I</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">I</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">I</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">I[1, 3, 2, 1] + I[1, 3, 3] + I[1, 4, 2] + I[2, 3, 2]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">I</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">I[1, 1, 3, 2] - I[2, 2, 1, 2] - I[2, 2, 2, 1] - I[2, 2, 3] - I[3, 2, 2]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="n">I</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">I[1, 3, 1, 1] + I[1, 4, 1] + I[2, 3, 1] + I[2, 4]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">I</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">I[3, 1, 2, 1] + I[3, 2, 1, 1] + I[3, 2, 2] + I[3, 3, 1] + I[4, 1, 1, 1] + I[4, 1, 2] + 2*I[4, 2, 1] + I[4, 3] + I[5, 1, 1] + I[5, 2]</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">I</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">I[1, 3, 1] + I[2, 2, 1] + I[2, 3] + I[3, 1, 1] + I[3, 2]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">(</span><span class="n">R</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])))</span>
<span class="go">R[2, 1, 3]</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate.Element">
<em class="property">class </em><tt class="descname">Element</tt><big>(</big><em>M</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModuleElement" title="sage.combinat.free_module.CombinatorialFreeModuleElement"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.free_module.CombinatorialFreeModuleElement</span></tt></a></p>
<p>An element in the Immaculate basis.</p>
<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate.Element.bernstein_creation_operator">
<tt class="descname">bernstein_creation_operator</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate.Element.bernstein_creation_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <tt class="docutils literal"><span class="pre">self</span></tt> under the <span class="math">\(n\)</span>-th Bernstein
creation operator.</p>
<p>Let <span class="math">\(n\)</span> be an integer. The <span class="math">\(n\)</span>-th Bernstein creation
operator <span class="math">\(\mathbb{B}_n\)</span> is defined as the endomorphism of
the space <span class="math">\(NSym\)</span> of noncommutative symmetric functions
given by</p>
<div class="math">
\[\mathbb{B}_n I_{(\alpha_1, \alpha_2, \ldots, \alpha_m)}
= I_{(n, \alpha_1, \alpha_2, \ldots, \alpha_m)},\]</div>
<p>where <span class="math">\(I_{(\alpha_1, \alpha_2, \ldots, \alpha_m)}\)</span> is the
immaculate function associated to the <span class="math">\(m\)</span>-tuple
<span class="math">\((\alpha_1, \alpha_2, \ldots, \alpha_m) \in \ZZ^m\)</span>.</p>
<p>This has been introduced in <a class="reference internal" href="qsym.html#bbssz2012" id="id23">[BBSSZ2012]</a>, section 3.1, in
analogy to the Bernstein creation operators on the
symmetric functions.</p>
<p>For more information on the <span class="math">\(n\)</span>-th Bernstein creation
operator, see
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.bernstein_creation_operator" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.bernstein_creation_operator"><tt class="xref py py-meth docutils literal"><span class="pre">bernstein_creation_operator()</span></tt></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">I</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">I[3, 1, 3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">I[5, 1, 3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">elt</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">elt</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">I[1, 1, 3, 2, 1] + 3*I[1, 4, 1, 2]</span>
</pre></div>
</div>
<p>We check that this agrees with the definition on the
Complete basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">S</span><span class="p">(</span><span class="n">elt</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Check on non-positive values of <span class="math">\(n\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">I</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">I[1, 1, 1, 2] + I[1, 1, 2, 1] + I[1, 2, 1, 1] - I[1, 2, 2]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">-I[1, 1, 3, 2] - I[1, 2, 2, 2] - I[1, 2, 3, 1] + I[2, 3, 2]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate.dual">
<tt class="descclassname">NonCommutativeSymmetricFunctions.Immaculate.</tt><tt class="descname">dual</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate.dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual basis to the Immaculate basis of NCSF.</p>
<p>The basis returned is the dualImmaculate basis of QSym.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>The dualImmaculate basis of the quasi-symmetric functions.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">I</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Immaculate</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="go">Quasisymmetric functions over the Rational Field in the dualImmaculate</span>
<span class="go">basis</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Monomial">
<em class="property">class </em><tt class="descclassname">NonCommutativeSymmetricFunctions.</tt><tt class="descname">Monomial</tt><big>(</big><em>NCSF</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Monomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></tt></a>, <a class="reference external" href="../../../../misc/sage/misc/bindable_class.html#sage.misc.bindable_class.BindableClass" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.misc.bindable_class.BindableClass</span></tt></a></p>
<p>The monomial basis defined in Tevlin&#8217;s paper <a class="reference internal" href="combinatorics.html#tev2007" id="id24">[Tev2007]</a>.</p>
<p>The monomial basis is well-defined only when the base ring is a
<span class="math">\(\QQ\)</span>-algebra. It is the basis denoted by <span class="math">\((M^I)_I\)</span> in <a class="reference internal" href="combinatorics.html#tev2007" id="id25">[Tev2007]</a>.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">nM</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">monomial</span><span class="p">();</span> <span class="n">nM</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Monomial basis</span>
<span class="gp">sage: </span><span class="n">nM</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">nM</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="go">3*nM[1, 1, 2] + nM[1, 3] + nM[2, 2]</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">nM</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">11*nM[1, 1, 1, 1, 1] + 8*nM[1, 1, 2, 1] + 8*nM[1, 2, 1, 1] + 5*nM[1, 3, 1] + 8*nM[2, 1, 1, 1] + 5*nM[2, 2, 1] + 5*nM[3, 1, 1] + 2*nM[4, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases">
<em class="property">class </em><tt class="descclassname">NonCommutativeSymmetricFunctions.</tt><tt class="descname">MultiplicativeBases</tt><big>(</big><em>parent_with_realization</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/realizations.html#sage.categories.realizations.Category_realization_of_parent" title="(in Sage Reference Manual: Category Framework v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.realizations.Category_realization_of_parent</span></tt></a></p>
<p>Category of multiplicative bases of non-commutative symmetric functions.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBases</span><span class="p">()</span>
<span class="go">Category of multiplicative bases of Non-Commutative Symmetric Functions over the Rational Field</span>
</pre></div>
</div>
<p>The complete basis is a multiplicative basis, but the ribbon basis is not:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">Complete</span><span class="p">()</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBases</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">Ribbon</span><span class="p">()</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBases</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods">
<em class="property">class </em><tt class="descname">ParentMethods</tt><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.algebra_generators">
<tt class="descname">algebra_generators</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.algebra_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the algebra generators of a given multiplicative basis of
non-commutative symmetric functions.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>The family of generators of the multiplicative basis <tt class="docutils literal"><span class="pre">self</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Psi</span><span class="o">.</span><span class="n">algebra_generators</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">Lazy family (&lt;lambda&gt;(i))_{i in Positive integers}</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">(Psi[1], Psi[2], Psi[3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.algebra_morphism">
<tt class="descname">algebra_morphism</tt><big>(</big><em>on_generators</em>, <em>**keywords</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.algebra_morphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a map defined on the generators of the multiplicative
basis <tt class="docutils literal"><span class="pre">self</span></tt>, return the algebra morphism that extends
this map to the whole algebra of non-commutative symmetric
functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">on_generators</span></tt> &#8211; a function defined on the index set of
the generators (that is, on the positive integers)</li>
<li><tt class="docutils literal"><span class="pre">anti</span></tt> &#8211; a boolean; defaults to <tt class="docutils literal"><span class="pre">False</span></tt></li>
<li><tt class="docutils literal"><span class="pre">category</span></tt> &#8211; a category; defaults to <tt class="docutils literal"><span class="pre">None</span></tt></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The algebra morphism of <tt class="docutils literal"><span class="pre">self</span></tt> which is defined by
<tt class="docutils literal"><span class="pre">on_generators</span></tt> in the basis <tt class="docutils literal"><span class="pre">self</span></tt>. When <tt class="docutils literal"><span class="pre">anti</span></tt>
is set to <tt class="docutils literal"><span class="pre">True</span></tt>, an algebra anti-morphism is
computed instead of an algebra morphism.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">double</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">Psi</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Psi</span><span class="o">.</span><span class="n">algebra_morphism</span><span class="p">(</span><span class="n">double</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">Psi</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">Generic endomorphism of Non-Commutative Symmetric Functions over the Rational Field in the Psi basis</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Psi</span><span class="p">[[]]</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">)</span>
<span class="go">2*Psi[] + 3*Psi[1, 1, 3, 3, 2, 2] + Psi[2, 2, 4, 4]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of endsets of unital magmas and right modules over Rational Field and left modules over Rational Field</span>
</pre></div>
</div>
<p>When extra properties about the morphism are known, one
can specify the category of which it is a morphism:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">negate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="o">-</span><span class="n">Psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Psi</span><span class="o">.</span><span class="n">algebra_morphism</span><span class="p">(</span><span class="n">negate</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">Psi</span><span class="p">,</span> <span class="n">category</span> <span class="o">=</span> <span class="n">GradedHopfAlgebrasWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">Generic endomorphism of Non-Commutative Symmetric Functions over the Rational Field in the Psi basis</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Psi</span><span class="p">[[]]</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">)</span>
<span class="go">2*Psi[] - 3*Psi[1, 3, 2] + Psi[2, 4]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of endsets of hopf algebras over Rational Field and graded modules over Rational Field</span>
</pre></div>
</div>
<p>If <tt class="docutils literal"><span class="pre">anti</span></tt> is true, this returns an anti-algebra morphism:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Psi</span><span class="o">.</span><span class="n">algebra_morphism</span><span class="p">(</span><span class="n">double</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">Psi</span><span class="p">,</span> <span class="n">anti</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">Generic endomorphism of Non-Commutative Symmetric Functions over the Rational Field in the Psi basis</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Psi</span><span class="p">[[]]</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">)</span>
<span class="go">2*Psi[] + 3*Psi[2, 2, 3, 3, 1, 1] + Psi[4, 4, 2, 2]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of endsets of modules with basis over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.antipode">
<tt class="descname">antipode</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.antipode" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the antipode morphism on the basis <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The antipode of <span class="math">\(NSym\)</span> is closely related to the omega
involution; see
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.omega_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.omega_involution"><tt class="xref py py-meth docutils literal"><span class="pre">omega_involution()</span></tt></a>
for the latter.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>The antipode module map from non-commutative symmetric
functions on basis <tt class="docutils literal"><span class="pre">self</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">antipode</span>
<span class="go">Generic endomorphism of Non-Commutative Symmetric Functions over the Rational Field in the Complete basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.coproduct">
<tt class="descname">coproduct</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.coproduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coproduct morphism in the basis <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>The coproduct module map from non-commutative symmetric
functions on basis <tt class="docutils literal"><span class="pre">self</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">coproduct</span>
<span class="go">Generic morphism:</span>
<span class="go">  From: Non-Commutative Symmetric Functions over the Rational Field in the Complete basis</span>
<span class="go">  To:   Non-Commutative Symmetric Functions over the Rational Field in the Complete basis # Non-Commutative Symmetric Functions over the Rational Field in the Complete basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.product_on_basis">
<tt class="descname">product_on_basis</tt><big>(</big><em>composition1</em>, <em>composition2</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.product_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of two basis elements from the multiplicative basis.
Multiplication is just concatenation on compositions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">composition1</span></tt>, <tt class="docutils literal"><span class="pre">composition2</span></tt> &#8211; integer compositions</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The product of the two non-commutative symmetric functions
indexed by <tt class="docutils literal"><span class="pre">composition1</span></tt> and <tt class="docutils literal"><span class="pre">composition2</span></tt> in the
multiplicative basis <tt class="docutils literal"><span class="pre">self</span></tt>. This will be again
a non-commutative symmetric function.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">product_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">S[2, 1, 1, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.to_symmetric_function">
<tt class="descname">to_symmetric_function</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.to_symmetric_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Morphism to the algebra of symmetric functions.</p>
<p>This is constructed by extending the algebra morphism
by the image of the generators.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>The module morphism from the basis <tt class="docutils literal"><span class="pre">self</span></tt> to the symmetric
functions which corresponds to taking a commutative image.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">h[3, 1]</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">h[1, 1, 1, 1] - 3*h[2, 1, 1] + 3*h[3, 1]</span>
<span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">h[1, 1, 1, 1] - 3*h[2, 1, 1] + 3*h[3, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.to_symmetric_function_on_generators">
<tt class="descname">to_symmetric_function_on_generators</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.to_symmetric_function_on_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Morphism of the generators to symmetric functions.</p>
<p>This is constructed by coercion to the complete basis
and applying the morphism.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>The module morphism from the basis <tt class="docutils literal"><span class="pre">self</span></tt> to the symmetric
functions which corresponds to taking a commutative image.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="o">.</span><span class="n">to_symmetric_function_on_generators</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">h[1, 1, 1] - 3*h[2, 1] + 3*h[3]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="o">.</span><span class="n">to_symmetric_function_on_generators</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">h[]</span>
<span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">to_symmetric_function_on_generators</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">h[1, 1, 1] - 3*h[2, 1] + 3*h[3]</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">elementary</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">to_symmetric_function_on_generators</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">h[1, 1, 1] - 2*h[2, 1] + h[3]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.super_categories">
<tt class="descclassname">NonCommutativeSymmetricFunctions.MultiplicativeBases.</tt><tt class="descname">super_categories</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the super categories of the category of multiplicative
bases of the non-commutative symmetric functions.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>list</li>
</ul>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBases</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of bases of Non-Commutative Symmetric Functions over the Rational Field]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements">
<em class="property">class </em><tt class="descclassname">NonCommutativeSymmetricFunctions.</tt><tt class="descname">MultiplicativeBasesOnGroupLikeElements</tt><big>(</big><em>parent_with_realization</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/realizations.html#sage.categories.realizations.Category_realization_of_parent" title="(in Sage Reference Manual: Category Framework v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.realizations.Category_realization_of_parent</span></tt></a></p>
<p>Category of multiplicative bases on grouplike elements of
non-commutative symmetric functions.</p>
<p>Here, a &#8220;multiplicative basis on grouplike elements&#8221; means
a multiplicative basis whose generators <span class="math">\((f_1, f_2, f_3, \ldots )\)</span>
satisfy</p>
<div class="math">
\[\Delta(f_i) = \sum_{j=0}^{i} f_j \otimes f_{i-j}\]</div>
<p>with <span class="math">\(f_0 = 1\)</span>. (In other words, the generators are to form a
divided power sequence in the sense of a coalgebra.) This
does not mean that the generators are grouplike, but means that
the element <span class="math">\(1 + f_1 + f_2 + f_3 + \cdots\)</span> in the completion of
the ring of non-commutative symmetric functions with respect
to the grading is grouplike.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBasesOnGroupLikeElements</span><span class="p">()</span>
<span class="go">Category of multiplicative bases on group like elements of Non-Commutative Symmetric Functions over the Rational Field</span>
</pre></div>
</div>
<p>The complete basis is a multiplicative basis, but the ribbon basis is not:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">Complete</span><span class="p">()</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBasesOnGroupLikeElements</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">Ribbon</span><span class="p">()</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBasesOnGroupLikeElements</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements.ParentMethods">
<em class="property">class </em><tt class="descname">ParentMethods</tt><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements.ParentMethods.antipode_on_basis">
<tt class="descname">antipode_on_basis</tt><big>(</big><em>composition</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements.ParentMethods.antipode_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the application of the antipode to a basis element.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">composition</span></tt> &#8211; a composition</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The image of the basis element indexed by <tt class="docutils literal"><span class="pre">composition</span></tt>
under the antipode map.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">antipode_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">-S[1, 1, 1] + S[1, 2]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="c1"># indirect doctest</span>
<span class="go">-S[1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="c1"># indirect doctest</span>
<span class="go">S[1, 1] - S[2]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="c1"># indirect docttest</span>
<span class="go">-S[1, 1, 1] + S[1, 2] + S[2, 1] - S[3]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span><span class="o">.</span><span class="n">apply_multilinear_morphism</span><span class="p">(</span><span class="k">lambda</span> <span class="n">be</span><span class="p">,</span><span class="n">ga</span><span class="p">:</span> <span class="n">S</span><span class="p">(</span><span class="n">be</span><span class="p">)</span><span class="o">*</span><span class="n">S</span><span class="p">(</span><span class="n">ga</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">())</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span><span class="o">.</span><span class="n">apply_multilinear_morphism</span><span class="p">(</span><span class="k">lambda</span> <span class="n">be</span><span class="p">,</span><span class="n">ga</span><span class="p">:</span> <span class="n">S</span><span class="p">(</span><span class="n">be</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span><span class="o">*</span><span class="n">S</span><span class="p">(</span><span class="n">ga</span><span class="p">))</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements.ParentMethods.coproduct_on_generators">
<tt class="descname">coproduct_on_generators</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements.ParentMethods.coproduct_on_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the <span class="math">\(i^{th}\)</span> generator of the algebra under
the coproduct.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">i</span></tt> &#8211; a positive integer</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The result of applying the coproduct to the <span class="math">\(i^{th}\)</span>
generator of <tt class="docutils literal"><span class="pre">self</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">coproduct_on_generators</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">S[] # S[3] + S[1] # S[2] + S[2] # S[1] + S[3] # S[]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">coproduct_on_generators</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Not a positive integer: 0</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements.super_categories">
<tt class="descclassname">NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements.</tt><tt class="descname">super_categories</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements.super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the super categories of the category of multiplicative
bases of group-like elements of the non-commutative symmetric
functions.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>list</li>
</ul>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBasesOnGroupLikeElements</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of multiplicative bases of Non-Commutative Symmetric Functions over the Rational Field]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements">
<em class="property">class </em><tt class="descclassname">NonCommutativeSymmetricFunctions.</tt><tt class="descname">MultiplicativeBasesOnPrimitiveElements</tt><big>(</big><em>parent_with_realization</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/realizations.html#sage.categories.realizations.Category_realization_of_parent" title="(in Sage Reference Manual: Category Framework v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.realizations.Category_realization_of_parent</span></tt></a></p>
<p>Category of multiplicative bases of the non-commutative symmetric
functions whose generators are primitive elements.</p>
<p>An element <span class="math">\(x\)</span> of a bialgebra is <em>primitive</em> if
<span class="math">\(\Delta(x) = x \otimes 1 + 1 \otimes x\)</span>, where
<span class="math">\(\Delta\)</span> is the coproduct of the bialgebra.</p>
<p>Given a multiplicative basis and knowing the coproducts and antipodes
of its generators, one can compute the coproduct and the antipode of
any element, since they are respectively algebra morphisms and
anti-morphisms. See <a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods.antipode_on_generators" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods.antipode_on_generators"><tt class="xref py py-meth docutils literal"><span class="pre">antipode_on_generators()</span></tt></a> and
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods.coproduct_on_generators" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods.coproduct_on_generators"><tt class="xref py py-meth docutils literal"><span class="pre">coproduct_on_generators()</span></tt></a>.</p>
<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">this could be generalized to any free algebra.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBasesOnPrimitiveElements</span><span class="p">()</span>
<span class="go">Category of multiplicative bases on primitive elements of Non-Commutative Symmetric Functions over the Rational Field</span>
</pre></div>
</div>
<p>The Phi and Psi bases are multiplicative bases whose generators
are primitive elements, but the complete and ribbon bases are not:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBasesOnPrimitiveElements</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBasesOnPrimitiveElements</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">Complete</span><span class="p">()</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBasesOnPrimitiveElements</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">Ribbon</span><span class="p">()</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBasesOnPrimitiveElements</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods">
<em class="property">class </em><tt class="descname">ParentMethods</tt><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods.antipode_on_generators">
<tt class="descname">antipode_on_generators</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods.antipode_on_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of a generator of a primitive basis of
the non-commutative symmetric functions under the antipode
map.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">i</span></tt> &#8211; a positive integer</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The image of the <span class="math">\(i\)</span>-th generator of the multiplicative
basis <tt class="docutils literal"><span class="pre">self</span></tt> under the antipode of the algebra of
non-commutative symmetric functions.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">antipode_on_generators</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-Psi[2]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">antipode_on_generators</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Not a positive integer: 0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods.coproduct_on_generators">
<tt class="descname">coproduct_on_generators</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods.coproduct_on_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the <span class="math">\(i^{th}\)</span> generator of the
multiplicative basis <tt class="docutils literal"><span class="pre">self</span></tt> under the coproduct.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">i</span></tt> &#8211; a positive integer</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The result of applying the coproduct to the
<span class="math">\(i^{th}\)</span> generator of <tt class="docutils literal"><span class="pre">self</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">coproduct_on_generators</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Psi[] # Psi[3] + Psi[3] # Psi[]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">coproduct_on_generators</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Not a positive integer: 0</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.super_categories">
<tt class="descclassname">NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.</tt><tt class="descname">super_categories</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the super categories of the category of multiplicative
bases of primitive elements of the non-commutative symmetric
functions.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>list</li>
</ul>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBasesOnPrimitiveElements</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of multiplicative bases of Non-Commutative Symmetric Functions over the Rational Field]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi">
<em class="property">class </em><tt class="descclassname">NonCommutativeSymmetricFunctions.</tt><tt class="descname">Phi</tt><big>(</big><em>NCSF</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></tt></a>, <a class="reference external" href="../../../../misc/sage/misc/bindable_class.html#sage.misc.bindable_class.BindableClass" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.misc.bindable_class.BindableClass</span></tt></a></p>
<p>The Hopf algebra of non-commutative symmetric functions in the
Phi basis.</p>
<p>The Phi basis is defined in Definition 3.4 of <a class="reference internal" href="qsym.html#ncsf1" id="id26">[NCSF1]</a>, where
it is denoted by <span class="math">\((\Phi^I)_I\)</span>. It is a multiplicative basis, and
is connected to the elementary generators <span class="math">\(\Lambda_i\)</span> of the ring
of non-commutative symmetric functions by the following relation:
Define a non-commutative symmetric function <span class="math">\(\Phi_n\)</span> for every
positive integer <span class="math">\(n\)</span> by the power series identity</p>
<div class="math">
\[\sum_{k\geq 1} t^k \frac{1}{k} \Phi_k
= -\log \left( \sum_{k \geq 0} (-t)^k \Lambda_k \right),\]</div>
<p>with <span class="math">\(\Lambda_0\)</span> denoting <span class="math">\(1\)</span>. For every composition
<span class="math">\((i_1, i_2, \ldots, i_k)\)</span>, we have
<span class="math">\(\Phi^{(i_1, i_2, \ldots, i_k)}
= \Phi_{i_1} \Phi_{i_2} \cdots \Phi_{i_k}\)</span>.</p>
<p>The <span class="math">\(\Phi\)</span>-basis is well-defined only when the base ring is a
<span class="math">\(\QQ\)</span>-algebra. The elements of the <span class="math">\(\Phi\)</span>-basis are known as the
&#8220;power-sum non-commutative symmetric functions of the second
kind&#8221;.</p>
<p>The generators <span class="math">\(\Phi_n\)</span> are related to the (first) Eulerian
idempotents in the descent algebras of the symmetric groups (see
<a class="reference internal" href="qsym.html#ncsf1" id="id27">[NCSF1]</a>, 5.4 for details).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Phi</span><span class="p">();</span> <span class="n">Phi</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Phi basis</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">2*Phi[] + 2*Phi[1] + 3*Phi[1, 1]</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi.Element">
<em class="property">class </em><tt class="descname">Element</tt><big>(</big><em>M</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModuleElement" title="sage.combinat.free_module.CombinatorialFreeModuleElement"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.free_module.CombinatorialFreeModuleElement</span></tt></a></p>
<p>Create a combinatorial module element. This should never be
called directly, but only through the parent combinatorial
free module&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt> method.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">B</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">];</span> <span class="n">f</span>
<span class="go">B[&#39;a&#39;] + 3*B[&#39;c&#39;]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">==</span> <span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi.Element.psi_involution">
<tt class="descname">psi_involution</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi.Element.psi_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<tt class="docutils literal"><span class="pre">self</span></tt> under the involution <span class="math">\(\psi\)</span>.</p>
<p>The involution <span class="math">\(\psi\)</span> is defined as the linear map
<span class="math">\(NCSF \to NCSF\)</span> which, for every composition <span class="math">\(I\)</span>, sends the
complete noncommutative symmetric function <span class="math">\(S^I\)</span> to the
elementary noncommutative symmetric function <span class="math">\(\Lambda^I\)</span>.
It can be shown that every composition <span class="math">\(I\)</span> satisfies</p>
<div class="math">
\[\psi(R_I) = R_{I^c}, \quad \psi(S^I) = \Lambda^I, \quad
\psi(\Lambda^I) = S^I, \quad
\psi(\Phi^I) = (-1)^{|I| - \ell(I)} \Phi^I\]</div>
<p>where <span class="math">\(I^c\)</span> denotes the complement of the composition <span class="math">\(I\)</span>, and
<span class="math">\(\ell(I)\)</span> denotes the length of <span class="math">\(I\)</span>, and where standard
notations for classical bases of <span class="math">\(NCSF\)</span> are being used
(<span class="math">\(S\)</span> for the complete basis, <span class="math">\(\Lambda\)</span> for the elementary basis,
<span class="math">\(\Phi\)</span> for the basis of the power sums of the second kind,
and <span class="math">\(R\)</span> for the ribbon basis). The map <span class="math">\(\psi\)</span> is an involution
and a graded Hopf algebra automorphism of <span class="math">\(NCSF\)</span>. If <span class="math">\(\pi\)</span>
denotes the projection from <span class="math">\(NCSF\)</span> to the ring of symmetric functions
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><tt class="xref py py-meth docutils literal"><span class="pre">to_symmetric_function()</span></tt></a>),
then <span class="math">\(\pi(\psi(f)) = \omega(\pi(f))\)</span> for every <span class="math">\(f \in NCSF\)</span>, where
the <span class="math">\(\omega\)</span> on the right hand side denotes the omega
automorphism of <span class="math">\(Sym\)</span>.</p>
<p>The involution <span class="math">\(\psi\)</span> of <span class="math">\(NCSF\)</span> is adjoint to the involution
<span class="math">\(\psi\)</span> of <span class="math">\(QSym\)</span> by the standard adjunction between <span class="math">\(NCSF\)</span> and
<span class="math">\(QSym\)</span>.</p>
<p>The involution <span class="math">\(\psi\)</span> has been denoted by <span class="math">\(\psi\)</span> in <a class="reference internal" href="qsym.html#lmvw13" id="id28">[LMvW13]</a>,
section 3.6.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution"><tt class="xref py py-meth docutils literal"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.psi_involution"><tt class="xref py py-meth docutils literal"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">QSym</span></tt></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution"><tt class="xref py py-meth docutils literal"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">-Phi[3, 2]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">Phi[2, 2]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">[[]]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">Phi[]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">Phi</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">2*Phi[2] - Phi[2, 1]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>The implementation at hand is tailored to the Phi basis.
It is equivalent to the generic implementation via the
ribbon basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">())</span> <span class="o">==</span> <span class="n">R</span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="n">I</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">....:      for I in Compositions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi.Element.star_involution">
<tt class="descname">star_involution</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi.Element.star_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<tt class="docutils literal"><span class="pre">self</span></tt> under the star involution.</p>
<p>The star involution is defined as the algebra antihomomorphism
<span class="math">\(NCSF \to NCSF\)</span> which, for every positive integer <span class="math">\(n\)</span>, sends
the <span class="math">\(n\)</span>-th complete non-commutative symmetric function <span class="math">\(S_n\)</span> to
<span class="math">\(S_n\)</span>. Denoting by <span class="math">\(f^{\ast}\)</span> the image of an element
<span class="math">\(f \in NCSF\)</span> under this star involution, it can be shown that
every composition <span class="math">\(I\)</span> satisfies</p>
<div class="math">
\[(S^I)^{\ast} = S^{I^r}, \quad
(\Lambda^I)^{\ast} = \Lambda^{I^r}, \quad
R_I^{\ast} = R_{I^r}, \quad
(\Phi^I)^{\ast} = \Phi^{I^r},\]</div>
<p>where <span class="math">\(I^r\)</span> denotes the reversed composition of <span class="math">\(I\)</span>, and
standard notations for classical bases of <span class="math">\(NCSF\)</span> are being used
(<span class="math">\(S\)</span> for the complete basis, <span class="math">\(\Lambda\)</span> for the elementary basis,
<span class="math">\(R\)</span> for the ribbon basis, and <span class="math">\(\Phi\)</span> for that of the power-sums
of the second kind). The star involution is an involution and a
coalgebra automorphism of <span class="math">\(NCSF\)</span>. It is an automorphism of the
graded vector space <span class="math">\(NCSF\)</span>. Under the canonical isomorphism
between the <span class="math">\(n\)</span>-th graded component of <span class="math">\(NCSF\)</span> and the descent
algebra of the symmetric group <span class="math">\(S_n\)</span> (see
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra"><tt class="xref py py-meth docutils literal"><span class="pre">to_descent_algebra()</span></tt></a>),
the star involution (restricted to
the <span class="math">\(n\)</span>-th graded component) corresponds to the automorphism
of the descent algebra given by
<span class="math">\(x \mapsto \omega_n x \omega_n\)</span>, where <span class="math">\(\omega_n\)</span> is the
permutation <span class="math">\((n, n-1, \ldots, 1) \in S_n\)</span> (written here in
one-line notation). If <span class="math">\(\pi\)</span> denotes the projection from <span class="math">\(NCSF\)</span>
to the ring of symmetric functions
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><tt class="xref py py-meth docutils literal"><span class="pre">to_symmetric_function()</span></tt></a>),
then <span class="math">\(\pi(f^{\ast}) = \pi(f)\)</span> for every <span class="math">\(f \in NCSF\)</span>.</p>
<p>The star involution on <span class="math">\(NCSF\)</span> is adjoint to the star involution
on <span class="math">\(QSym\)</span> by the standard adjunction between <span class="math">\(NCSF\)</span> and <span class="math">\(QSym\)</span>.</p>
<p>The star involution has been denoted by <span class="math">\(\rho\)</span> in <a class="reference internal" href="qsym.html#lmvw13" id="id29">[LMvW13]</a>,
section 3.6.
See <a class="reference internal" href="qsym.html#ncsf2" id="id30">[NCSF2]</a>, section 2.3 for the properties of this map.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution"><tt class="xref py py-meth docutils literal"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution"><tt class="xref py py-meth docutils literal"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.star_involution"><tt class="xref py py-meth docutils literal"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">QSym</span></tt></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">Phi[4, 1, 1, 3]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">Phi[1, 2, 4]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">Phi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">Phi</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">Phi</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">Phi</span><span class="p">[[]])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">4*Phi[] - 3*Phi[3] - Phi[3, 2] + Phi[4, 1] + 2*Phi[4, 5]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">Phi</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">3*Phi[1] + Phi[3, 3]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">Phi[1, 2]</span>
</pre></div>
</div>
<p>The implementation at hand is tailored to the Phi basis.
It is equivalent to the generic implementation via the
complete basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">S</span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">())</span> <span class="o">==</span> <span class="n">S</span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="n">I</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">....:      for I in Compositions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi.Element.verschiebung">
<tt class="descname">verschiebung</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi.Element.verschiebung" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<tt class="docutils literal"><span class="pre">self</span></tt> under the <span class="math">\(n\)</span>-th Verschiebung operator.</p>
<p>The <span class="math">\(n\)</span>-th Verschiebung operator <span class="math">\(\mathbf{V}_n\)</span> is defined
to be the map from the <span class="math">\(\mathbf{k}\)</span>-algebra of noncommutative
symmetric functions to itself that sends the complete function
<span class="math">\(S^I\)</span> indexed by a composition <span class="math">\(I = (i_1, i_2, \ldots , i_k)\)</span>
to <span class="math">\(S^{(i_1/n, i_2/n, \ldots , i_k/n)}\)</span> if all of the numbers
<span class="math">\(i_1, i_2, \ldots, i_k\)</span> are divisible by <span class="math">\(n\)</span>, and to <span class="math">\(0\)</span>
otherwise. This operator <span class="math">\(\mathbf{V}_n\)</span> is a Hopf algebra
endomorphism. For every positive integer <span class="math">\(r\)</span> with <span class="math">\(n \mid r\)</span>,
it satisfies</p>
<div class="math">
\[\mathbf{V}_n(S_r) = S_{r/n},
\quad \mathbf{V}_n(\Lambda_r) = (-1)^{r - r/n} \Lambda_{r/n},
\quad \mathbf{V}_n(\Psi_r) = n \Psi_{r/n},
\quad \mathbf{V}_n(\Phi_r) = n \Phi_{r/n}\]</div>
<p>(where <span class="math">\(S_r\)</span> denotes the <span class="math">\(r\)</span>-th complete non-commutative
symmetric function, <span class="math">\(\Lambda_r\)</span> denotes the <span class="math">\(r\)</span>-th elementary
non-commutative symmetric function, <span class="math">\(\Psi_r\)</span> denotes the <span class="math">\(r\)</span>-th
power-sum non-commutative symmetric function of the first kind,
and <span class="math">\(\Phi_r\)</span> denotes the <span class="math">\(r\)</span>-th power-sum non-commutative
symmetric function of the second kind). For every positive
integer <span class="math">\(r\)</span> with <span class="math">\(n \nmid r\)</span>, it satisfes</p>
<div class="math">
\[\mathbf{V}_n(S_r) = \mathbf{V}_n(\Lambda_r)
= \mathbf{V}_n(\Psi_r) = \mathbf{V}_n(\Phi_r) = 0.\]</div>
<p>The <span class="math">\(n\)</span>-th Verschiebung operator is also called the <span class="math">\(n\)</span>-th
Verschiebung endomorphism.</p>
<p>It is a lift of the <span class="math">\(n\)</span>-th Verschiebung operator on the ring
of symmetric functions
(<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><tt class="xref py py-meth docutils literal"><span class="pre">verschiebung()</span></tt></a>)
to the ring of noncommutative symmetric functions.</p>
<p>The action of the <span class="math">\(n\)</span>-th Verschiebung operator can also be
described on the ribbon Schur functions. Namely, every
composition <span class="math">\(I\)</span> of size <span class="math">\(n \ell\)</span> satisfies</p>
<div class="math">
\[\mathbf{V}_n ( R_I )
= (-1)^{\ell(I) - \ell(J)} \cdot R_{J / n},\]</div>
<p>where <span class="math">\(J\)</span> denotes the meet of the compositions <span class="math">\(I\)</span> and
<span class="math">\((\underbrace{n, n, \ldots, n}_{|I|/n \mbox{ times}})\)</span>,
where <span class="math">\(\ell(I)\)</span> is the length of <span class="math">\(I\)</span>, and
where <span class="math">\(J / n\)</span> denotes the composition obtained by
dividing every entry of <span class="math">\(J\)</span> by <span class="math">\(n\)</span>.
For a composition <span class="math">\(I\)</span> of size not divisible by <span class="math">\(n\)</span>, we
have <span class="math">\(\mathbf{V}_n ( R_I ) = 0\)</span>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung"><tt class="xref py py-meth docutils literal"><span class="pre">verschiebung</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius"><tt class="xref py py-meth docutils literal"><span class="pre">frobenius</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">QSym</span></tt></a>,
<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><tt class="xref py py-meth docutils literal"><span class="pre">verschiebung</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">Sym</span></tt></a></p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; a positive integer</li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the <span class="math">\(n\)</span>-th Verschiebung operator (on the
ring of noncommutative symmetric functions) to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*Phi[2, 1]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*Phi[1, 2]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">6</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2*Phi[3]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Phi[]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">7</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">7*Phi[1]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Phi</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">Phi</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Phi[1] - Phi[2] + 2*Phi[3]</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>The current implementation on the Phi basis gives the
same results as the default implementation:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_phi</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="go">....:     for I in Compositions(N):</span>
<span class="go">....:         if S(Phi[I].verschiebung(n)) != S(Phi[I]).verschiebung(n):</span>
<span class="go">....:             return False</span>
<span class="go">....:     return True</span>
<span class="gp">sage: </span><span class="n">test_phi</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_phi</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_phi</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_phi</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>     <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi">
<em class="property">class </em><tt class="descclassname">NonCommutativeSymmetricFunctions.</tt><tt class="descname">Psi</tt><big>(</big><em>NCSF</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></tt></a>, <a class="reference external" href="../../../../misc/sage/misc/bindable_class.html#sage.misc.bindable_class.BindableClass" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.misc.bindable_class.BindableClass</span></tt></a></p>
<p>The Hopf algebra of non-commutative symmetric functions in the
Psi basis.</p>
<p>The Psi basis is defined in Definition 3.4 of <a class="reference internal" href="qsym.html#ncsf1" id="id31">[NCSF1]</a>, where
it is denoted by <span class="math">\((\Psi^I)_I\)</span>. It is a multiplicative basis, and
is connected to the elementary generators <span class="math">\(\Lambda_i\)</span> of the ring
of non-commutative symmetric functions by the following relation:
Define a non-commutative symmetric function <span class="math">\(\Psi_n\)</span> for every
positive integer <span class="math">\(n\)</span> by the power series identity</p>
<div class="math">
\[\frac{d}{dt} \sigma(t)
= \sigma(t) \cdot \left( \sum_{k \geq 1} t^{k-1} \Psi_k \right),\]</div>
<p>where</p>
<div class="math">
\[\sigma(t) = \left( \sum_{k \geq 0} (-t)^k \Lambda_k \right)^{-1}\]</div>
<p>and where <span class="math">\(\Lambda_0\)</span> denotes <span class="math">\(1\)</span>. For every composition
<span class="math">\((i_1, i_2, \ldots, i_k)\)</span>, we have
<span class="math">\(\Psi^{(i_1, i_2, \ldots, i_k)}
= \Psi_{i_1} \Psi_{i_2} \cdots \Psi_{i_k}\)</span>.</p>
<p>The <span class="math">\(\Psi\)</span>-basis is a basis only when the base ring is a
<span class="math">\(\QQ\)</span>-algebra (although the <span class="math">\(\Psi^I\)</span> can be defined over any base
ring). The elements of the <span class="math">\(\Psi\)</span>-basis are known as the
&#8220;power-sum non-commutative symmetric functions of the first kind&#8221;.
The generators <span class="math">\(\Psi_n\)</span> correspond to the Dynkin
(quasi-)idempotents in the descent algebras of the symmetric
groups (see <a class="reference internal" href="qsym.html#ncsf1" id="id32">[NCSF1]</a>, 5.2 for details).</p>
<p>Another (equivalent) definition of <span class="math">\(\Psi_n\)</span> is</p>
<div class="math">
\[\Psi_n = \sum_{i=0}^{n-1} (-1)^i R_{1^i, n-i},\]</div>
<p>where <span class="math">\(R\)</span> denotes the ribbon basis of <span class="math">\(NCSF\)</span>, and where <span class="math">\(1^i\)</span>
stands for <span class="math">\(i\)</span> repetitions of the integer <span class="math">\(1\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Psi</span><span class="p">();</span> <span class="n">Psi</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Psi basis</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">2*Psi[] + 2*Psi[1] + 3*Psi[1, 1]</span>
</pre></div>
</div>
<p>Checking the equivalent definition of <span class="math">\(\Psi_n\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_psi</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="go">....:     NCSF = NonCommutativeSymmetricFunctions(ZZ)</span>
<span class="go">....:     R = NCSF.R()</span>
<span class="go">....:     Psi = NCSF.Psi()</span>
<span class="go">....:     a = R.sum([(-1) ** i * R[[1]*i + [n-i]]</span>
<span class="go">....:                for i in range(n)])</span>
<span class="go">....:     return a == R(Psi[n])</span>
<span class="gp">sage: </span><span class="n">test_psi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_psi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_psi</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi.Element">
<em class="property">class </em><tt class="descname">Element</tt><big>(</big><em>M</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModuleElement" title="sage.combinat.free_module.CombinatorialFreeModuleElement"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.free_module.CombinatorialFreeModuleElement</span></tt></a></p>
<p>Create a combinatorial module element. This should never be
called directly, but only through the parent combinatorial
free module&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt> method.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">B</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">];</span> <span class="n">f</span>
<span class="go">B[&#39;a&#39;] + 3*B[&#39;c&#39;]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">==</span> <span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi.Element.verschiebung">
<tt class="descname">verschiebung</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi.Element.verschiebung" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<tt class="docutils literal"><span class="pre">self</span></tt> under the <span class="math">\(n\)</span>-th Verschiebung operator.</p>
<p>The <span class="math">\(n\)</span>-th Verschiebung operator <span class="math">\(\mathbf{V}_n\)</span> is defined
to be the map from the <span class="math">\(\mathbf{k}\)</span>-algebra of noncommutative
symmetric functions to itself that sends the complete function
<span class="math">\(S^I\)</span> indexed by a composition <span class="math">\(I = (i_1, i_2, \ldots , i_k)\)</span>
to <span class="math">\(S^{(i_1/n, i_2/n, \ldots , i_k/n)}\)</span> if all of the numbers
<span class="math">\(i_1, i_2, \ldots, i_k\)</span> are divisible by <span class="math">\(n\)</span>, and to <span class="math">\(0\)</span>
otherwise. This operator <span class="math">\(\mathbf{V}_n\)</span> is a Hopf algebra
endomorphism. For every positive integer <span class="math">\(r\)</span> with <span class="math">\(n \mid r\)</span>,
it satisfies</p>
<div class="math">
\[\mathbf{V}_n(S_r) = S_{r/n},
\quad \mathbf{V}_n(\Lambda_r) = (-1)^{r - r/n} \Lambda_{r/n},
\quad \mathbf{V}_n(\Psi_r) = n \Psi_{r/n},
\quad \mathbf{V}_n(\Phi_r) = n \Phi_{r/n}\]</div>
<p>(where <span class="math">\(S_r\)</span> denotes the <span class="math">\(r\)</span>-th complete non-commutative
symmetric function, <span class="math">\(\Lambda_r\)</span> denotes the <span class="math">\(r\)</span>-th elementary
non-commutative symmetric function, <span class="math">\(\Psi_r\)</span> denotes the <span class="math">\(r\)</span>-th
power-sum non-commutative symmetric function of the first kind,
and <span class="math">\(\Phi_r\)</span> denotes the <span class="math">\(r\)</span>-th power-sum non-commutative
symmetric function of the second kind). For every positive
integer <span class="math">\(r\)</span> with <span class="math">\(n \nmid r\)</span>, it satisfes</p>
<div class="math">
\[\mathbf{V}_n(S_r) = \mathbf{V}_n(\Lambda_r)
= \mathbf{V}_n(\Psi_r) = \mathbf{V}_n(\Phi_r) = 0.\]</div>
<p>The <span class="math">\(n\)</span>-th Verschiebung operator is also called the <span class="math">\(n\)</span>-th
Verschiebung endomorphism.</p>
<p>It is a lift of the <span class="math">\(n\)</span>-th Verschiebung operator on the ring
of symmetric functions
(<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><tt class="xref py py-meth docutils literal"><span class="pre">verschiebung()</span></tt></a>)
to the ring of noncommutative symmetric functions.</p>
<p>The action of the <span class="math">\(n\)</span>-th Verschiebung operator can also be
described on the ribbon Schur functions. Namely, every
composition <span class="math">\(I\)</span> of size <span class="math">\(n \ell\)</span> satisfies</p>
<div class="math">
\[\mathbf{V}_n ( R_I )
= (-1)^{\ell(I) - \ell(J)} \cdot R_{J / n},\]</div>
<p>where <span class="math">\(J\)</span> denotes the meet of the compositions <span class="math">\(I\)</span> and
<span class="math">\((\underbrace{n, n, \ldots, n}_{|I|/n \mbox{ times}})\)</span>,
where <span class="math">\(\ell(I)\)</span> is the length of <span class="math">\(I\)</span>, and
where <span class="math">\(J / n\)</span> denotes the composition obtained by
dividing every entry of <span class="math">\(J\)</span> by <span class="math">\(n\)</span>.
For a composition <span class="math">\(I\)</span> of size not divisible by <span class="math">\(n\)</span>, we
have <span class="math">\(\mathbf{V}_n ( R_I ) = 0\)</span>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung"><tt class="xref py py-meth docutils literal"><span class="pre">verschiebung</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius"><tt class="xref py py-meth docutils literal"><span class="pre">frobenius</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">QSym</span></tt></a>,
<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><tt class="xref py py-meth docutils literal"><span class="pre">verschiebung</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">Sym</span></tt></a></p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; a positive integer</li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the <span class="math">\(n\)</span>-th Verschiebung operator (on the
ring of noncommutative symmetric functions) to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*Psi[2, 1]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*Psi[1, 2]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">6</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2*Psi[3]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Psi[]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">7</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">7*Psi[1]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">Psi</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Psi[1] - Psi[2] + 2*Psi[3]</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>The current implementation on the Psi basis gives the
same results as the default implementation:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_psi</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="go">....:     for I in Compositions(N):</span>
<span class="go">....:         if S(Psi[I].verschiebung(n)) != S(Psi[I]).verschiebung(n):</span>
<span class="go">....:             return False</span>
<span class="go">....:     return True</span>
<span class="gp">sage: </span><span class="n">test_psi</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_psi</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_psi</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_psi</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>     <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi.internal_product_on_basis_by_bracketing">
<tt class="descclassname">NonCommutativeSymmetricFunctions.Psi.</tt><tt class="descname">internal_product_on_basis_by_bracketing</tt><big>(</big><em>I</em>, <em>J</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi.internal_product_on_basis_by_bracketing" title="Permalink to this definition">¶</a></dt>
<dd><p>The internal product of two elements of the Psi basis.</p>
<p>See <a class="reference internal" href="generic_basis_code.html#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product"><tt class="xref py py-meth docutils literal"><span class="pre">internal_product()</span></tt></a>
for a thorough documentation of this operation.</p>
<p>This is an implementation using <a class="reference internal" href="qsym.html#ncsf2" id="id33">[NCSF2]</a> Lemma 3.10.
It is fast when the length of <span class="math">\(I\)</span> is small, but can get
very slow otherwise. Therefore it is not being used by
default for internally multiplying Psi functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">I</span></tt>, <tt class="docutils literal"><span class="pre">J</span></tt> &#8211; compositions</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The internal product of the elements of the Psi basis of
<span class="math">\(NSym\)</span> indexed by <tt class="docutils literal"><span class="pre">I</span></tt> and <tt class="docutils literal"><span class="pre">J</span></tt>, expressed in the Psi
basis.</li>
</ul>
<p>AUTHORS:</p>
<ul class="simple">
<li>Travis Scrimshaw, 29 Mar 2014</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">internal_product_on_basis_by_bracketing</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">internal_product_on_basis_by_bracketing</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">4*Psi[1, 2, 1]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">internal_product_on_basis_by_bracketing</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">4*Psi[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">internal_product_on_basis_by_bracketing</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">internal_product_on_basis_by_bracketing</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">-Psi[1, 2, 1] + Psi[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">internal_product_on_basis_by_bracketing</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">internal_product_on_basis_by_bracketing</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">internal_product_on_basis_by_bracketing</span><span class="p">([</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">-Psi[1, 1, 2] + 2*Psi[1, 2, 1] - Psi[2, 1, 1]</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>The internal product computed by this method is identical with
the one obtained by coercion to the complete basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">psi_int_test</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="go">....:     for I in Compositions(n):</span>
<span class="go">....:         for J in Compositions(n):</span>
<span class="go">....:             a = S(Psi.internal_product_on_basis_by_bracketing(I, J))</span>
<span class="go">....:             b = S(Psi[I]).internal_product(S(Psi[J]))</span>
<span class="go">....:             if a != b:</span>
<span class="go">....:                 return False</span>
<span class="go">....:     return True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">psi_int_test</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">psi_int_test</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>   <span class="c1"># long time</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">psi_int_test</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>   <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon">
<em class="property">class </em><tt class="descclassname">NonCommutativeSymmetricFunctions.</tt><tt class="descname">Ribbon</tt><big>(</big><em>NCSF</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></tt></a>, <a class="reference external" href="../../../../misc/sage/misc/bindable_class.html#sage.misc.bindable_class.BindableClass" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.misc.bindable_class.BindableClass</span></tt></a></p>
<p>The Hopf algebra of non-commutative symmetric functions in the
Ribbon basis.</p>
<p>The Ribbon basis is defined in Definition 3.12 of <a class="reference internal" href="qsym.html#ncsf1" id="id34">[NCSF1]</a>, where
it is denoted by <span class="math">\((R_I)_I\)</span>. It is connected to the complete
basis of the ring of non-commutative symmetric functions by the
following relation: For every composition <span class="math">\(I\)</span>, we have</p>
<div class="math">
\[R_I = \sum_J (-1)^{\ell(I) - \ell(J)} S^J,\]</div>
<p>where the sum is over all compositions <span class="math">\(J\)</span> which are coarser than
<span class="math">\(I\)</span> and <span class="math">\(\ell(I)\)</span> denotes the length of <span class="math">\(I\)</span>. (See the proof of
Proposition 4.13 in <a class="reference internal" href="qsym.html#ncsf1" id="id35">[NCSF1]</a>.)</p>
<p>The elements of the Ribbon basis are commonly referred to as the
ribbon Schur functions.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Ribbon</span><span class="p">();</span> <span class="n">R</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Ribbon basis</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">2*R[] + 2*R[1] + 3*R[1, 1]</span>
</pre></div>
</div>
<p>The following are aliases for this basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Ribbon basis</span>
<span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Ribbon basis</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.Element">
<em class="property">class </em><tt class="descname">Element</tt><big>(</big><em>M</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModuleElement" title="sage.combinat.free_module.CombinatorialFreeModuleElement"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.free_module.CombinatorialFreeModuleElement</span></tt></a></p>
<p>Create a combinatorial module element. This should never be
called directly, but only through the parent combinatorial
free module&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt> method.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">B</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">];</span> <span class="n">f</span>
<span class="go">B[&#39;a&#39;] + 3*B[&#39;c&#39;]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">==</span> <span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.Element.star_involution">
<tt class="descname">star_involution</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.Element.star_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<tt class="docutils literal"><span class="pre">self</span></tt> under the star involution.</p>
<p>The star involution is defined as the algebra antihomomorphism
<span class="math">\(NCSF \to NCSF\)</span> which, for every positive integer <span class="math">\(n\)</span>, sends
the <span class="math">\(n\)</span>-th complete non-commutative symmetric function <span class="math">\(S_n\)</span> to
<span class="math">\(S_n\)</span>. Denoting by <span class="math">\(f^{\ast}\)</span> the image of an element
<span class="math">\(f \in NCSF\)</span> under this star involution, it can be shown that
every composition <span class="math">\(I\)</span> satisfies</p>
<div class="math">
\[(S^I)^{\ast} = S^{I^r}, \quad
(\Lambda^I)^{\ast} = \Lambda^{I^r}, \quad
R_I^{\ast} = R_{I^r}, \quad
(\Phi^I)^{\ast} = \Phi^{I^r},\]</div>
<p>where <span class="math">\(I^r\)</span> denotes the reversed composition of <span class="math">\(I\)</span>, and
standard notations for classical bases of <span class="math">\(NCSF\)</span> are being used
(<span class="math">\(S\)</span> for the complete basis, <span class="math">\(\Lambda\)</span> for the elementary basis,
<span class="math">\(R\)</span> for the ribbon basis, and <span class="math">\(\Phi\)</span> for that of the power-sums
of the second kind). The star involution is an involution and a
coalgebra automorphism of <span class="math">\(NCSF\)</span>. It is an automorphism of the
graded vector space <span class="math">\(NCSF\)</span>. Under the canonical isomorphism
between the <span class="math">\(n\)</span>-th graded component of <span class="math">\(NCSF\)</span> and the descent
algebra of the symmetric group <span class="math">\(S_n\)</span> (see
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra"><tt class="xref py py-meth docutils literal"><span class="pre">to_descent_algebra()</span></tt></a>),
the star involution (restricted to
the <span class="math">\(n\)</span>-th graded component) corresponds to the automorphism
of the descent algebra given by
<span class="math">\(x \mapsto \omega_n x \omega_n\)</span>, where <span class="math">\(\omega_n\)</span> is the
permutation <span class="math">\((n, n-1, \ldots, 1) \in S_n\)</span> (written here in
one-line notation). If <span class="math">\(\pi\)</span> denotes the projection from <span class="math">\(NCSF\)</span>
to the ring of symmetric functions
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><tt class="xref py py-meth docutils literal"><span class="pre">to_symmetric_function()</span></tt></a>),
then <span class="math">\(\pi(f^{\ast}) = \pi(f)\)</span> for every <span class="math">\(f \in NCSF\)</span>.</p>
<p>The star involution on <span class="math">\(NCSF\)</span> is adjoint to the star involution
on <span class="math">\(QSym\)</span> by the standard adjunction between <span class="math">\(NCSF\)</span> and <span class="math">\(QSym\)</span>.</p>
<p>The star involution has been denoted by <span class="math">\(\rho\)</span> in <a class="reference internal" href="qsym.html#lmvw13" id="id36">[LMvW13]</a>,
section 3.6.
See <a class="reference internal" href="qsym.html#ncsf2" id="id37">[NCSF2]</a>, section 2.3 for the properties of this map.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution"><tt class="xref py py-meth docutils literal"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.star_involution"><tt class="xref py py-meth docutils literal"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">QSym</span></tt></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution"><tt class="xref py py-meth docutils literal"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">R[2, 4, 1, 3]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">R[2, 1, 4]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">R</span><span class="p">[[]])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">4*R[] + R[1] - R[2] - 3*R[3] + 2*R[4, 5]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">21</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">-21*R[1] + R[3, 3]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">14</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">R[1, 14]</span>
</pre></div>
</div>
<p>The implementation at hand is tailored to the ribbon basis.
It is equivalent to the generic implementation via the
complete basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">S</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">())</span> <span class="o">==</span> <span class="n">S</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">I</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">....:      for I in Compositions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.Element.verschiebung">
<tt class="descname">verschiebung</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.Element.verschiebung" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<tt class="docutils literal"><span class="pre">self</span></tt> under the <span class="math">\(n\)</span>-th Verschiebung operator.</p>
<p>The <span class="math">\(n\)</span>-th Verschiebung operator <span class="math">\(\mathbf{V}_n\)</span> is defined
to be the map from the <span class="math">\(\mathbf{k}\)</span>-algebra of noncommutative
symmetric functions to itself that sends the complete function
<span class="math">\(S^I\)</span> indexed by a composition <span class="math">\(I = (i_1, i_2, \ldots , i_k)\)</span>
to <span class="math">\(S^{(i_1/n, i_2/n, \ldots , i_k/n)}\)</span> if all of the numbers
<span class="math">\(i_1, i_2, \ldots, i_k\)</span> are divisible by <span class="math">\(n\)</span>, and to <span class="math">\(0\)</span>
otherwise. This operator <span class="math">\(\mathbf{V}_n\)</span> is a Hopf algebra
endomorphism. For every positive integer <span class="math">\(r\)</span> with <span class="math">\(n \mid r\)</span>,
it satisfies</p>
<div class="math">
\[\mathbf{V}_n(S_r) = S_{r/n},
\quad \mathbf{V}_n(\Lambda_r) = (-1)^{r - r/n} \Lambda_{r/n},
\quad \mathbf{V}_n(\Psi_r) = n \Psi_{r/n},
\quad \mathbf{V}_n(\Phi_r) = n \Phi_{r/n}\]</div>
<p>(where <span class="math">\(S_r\)</span> denotes the <span class="math">\(r\)</span>-th complete non-commutative
symmetric function, <span class="math">\(\Lambda_r\)</span> denotes the <span class="math">\(r\)</span>-th elementary
non-commutative symmetric function, <span class="math">\(\Psi_r\)</span> denotes the <span class="math">\(r\)</span>-th
power-sum non-commutative symmetric function of the first kind,
and <span class="math">\(\Phi_r\)</span> denotes the <span class="math">\(r\)</span>-th power-sum non-commutative
symmetric function of the second kind). For every positive
integer <span class="math">\(r\)</span> with <span class="math">\(n \nmid r\)</span>, it satisfes</p>
<div class="math">
\[\mathbf{V}_n(S_r) = \mathbf{V}_n(\Lambda_r)
= \mathbf{V}_n(\Psi_r) = \mathbf{V}_n(\Phi_r) = 0.\]</div>
<p>The <span class="math">\(n\)</span>-th Verschiebung operator is also called the <span class="math">\(n\)</span>-th
Verschiebung endomorphism.</p>
<p>It is a lift of the <span class="math">\(n\)</span>-th Verschiebung operator on the ring
of symmetric functions
(<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><tt class="xref py py-meth docutils literal"><span class="pre">verschiebung()</span></tt></a>)
to the ring of noncommutative symmetric functions.</p>
<p>The action of the <span class="math">\(n\)</span>-th Verschiebung operator can also be
described on the ribbon Schur functions. Namely, every
composition <span class="math">\(I\)</span> of size <span class="math">\(n \ell\)</span> satisfies</p>
<div class="math">
\[\mathbf{V}_n ( R_I )
= (-1)^{\ell(I) - \ell(J)} \cdot R_{J / n},\]</div>
<p>where <span class="math">\(J\)</span> denotes the meet of the compositions <span class="math">\(I\)</span> and
<span class="math">\((\underbrace{n, n, \ldots, n}_{|I|/n \mbox{ times}})\)</span>,
where <span class="math">\(\ell(I)\)</span> is the length of <span class="math">\(I\)</span>, and
where <span class="math">\(J / n\)</span> denotes the composition obtained by
dividing every entry of <span class="math">\(J\)</span> by <span class="math">\(n\)</span>.
For a composition <span class="math">\(I\)</span> of size not divisible by <span class="math">\(n\)</span>, we
have <span class="math">\(\mathbf{V}_n ( R_I ) = 0\)</span>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung"><tt class="xref py py-meth docutils literal"><span class="pre">verschiebung</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">NCSF</span></tt></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius"><tt class="xref py py-meth docutils literal"><span class="pre">frobenius</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">QSym</span></tt></a>,
<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><tt class="xref py py-meth docutils literal"><span class="pre">verschiebung</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">Sym</span></tt></a></p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; a positive integer</li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the <span class="math">\(n\)</span>-th Verschiebung operator (on the
ring of noncommutative symmetric functions) to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">R[2, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">-R[1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">R[]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">-R[2]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">-R[1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-R[3]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">-R[1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">R[1] - R[2] + 2*R[3]</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>The current implementation on the ribbon basis gives the
same results as the default implementation:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_ribbon</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="go">....:     for I in Compositions(N):</span>
<span class="go">....:         if S(R[I].verschiebung(n)) != S(R[I]).verschiebung(n):</span>
<span class="go">....:             return False</span>
<span class="go">....:     return True</span>
<span class="gp">sage: </span><span class="n">test_ribbon</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_ribbon</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_ribbon</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_ribbon</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>     <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.antipode_on_basis">
<tt class="descclassname">NonCommutativeSymmetricFunctions.Ribbon.</tt><tt class="descname">antipode_on_basis</tt><big>(</big><em>composition</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.antipode_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the application of the antipode to a basis element
of the ribbon basis <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">composition</span></tt> &#8211; a composition</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The image of the basis element indexed by <tt class="docutils literal"><span class="pre">composition</span></tt>
under the antipode map.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">antipode_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">-R[2, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="c1"># indirect doctest</span>
<span class="go">R[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[[]]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="c1"># indirect doctest</span>
<span class="go">R[]</span>
</pre></div>
</div>
<p>We check that the implementation of the antipode at hand does
not contradict the generic one:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">S</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">())</span> <span class="o">==</span> <span class="n">S</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">I</span><span class="p">])</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">....:      for I in Compositions(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.dual">
<tt class="descclassname">NonCommutativeSymmetricFunctions.Ribbon.</tt><tt class="descname">dual</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual basis to the ribbon basis of the non-commutative symmetric
functions. This is the Fundamental basis of the quasi-symmetric functions.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>The fundamental basis of the quasi-symmetric functions.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="go">Quasisymmetric functions over the Rational Field in the Fundamental basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.product_on_basis">
<tt class="descclassname">NonCommutativeSymmetricFunctions.Ribbon.</tt><tt class="descname">product_on_basis</tt><big>(</big><em>I</em>, <em>J</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.product_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of two ribbon basis elements of the non-commutative
symmetric functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">I</span></tt>, <tt class="docutils literal"><span class="pre">J</span></tt> &#8211; compositions</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The product of the ribbon functions indexed by <tt class="docutils literal"><span class="pre">I</span></tt> and <tt class="docutils literal"><span class="pre">J</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">R[1, 2, 1, 3, 1] + R[1, 2, 4, 1]</span>
<span class="gp">sage: </span><span class="p">(</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">)</span> <span class="o">*</span> <span class="p">(</span> <span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
<span class="go">R[1, 2, 1, 2, 1] + R[1, 2, 3, 1] + R[1, 3, 2, 1] + R[1, 5, 1] + R[3, 1, 2, 1] + R[3, 3, 1] + R[4, 2, 1] + R[6, 1]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span><span class="p">[[]]</span> <span class="o">*</span> <span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">R[3, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">R</span><span class="p">[[]]</span>
<span class="go">R[1, 2, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">product_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">R[2, 1, 1] + R[2, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.to_symmetric_function_on_basis">
<tt class="descclassname">NonCommutativeSymmetricFunctions.Ribbon.</tt><tt class="descname">to_symmetric_function_on_basis</tt><big>(</big><em>I</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.to_symmetric_function_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the commutative image of a ribbon basis element of the
non-commutative symmetric functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">I</span></tt> &#8211; a composition</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The commutative image of the ribbon basis element indexed by
<tt class="docutils literal"><span class="pre">I</span></tt>. This will be expressed as a symmetric function in the
Schur basis.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[3, 1, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[4, 2, 1] + s[5, 1, 1] + s[5, 2]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([]))</span>
<span class="go">s[]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.a_realization">
<tt class="descclassname">NonCommutativeSymmetricFunctions.</tt><tt class="descname">a_realization</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.a_realization" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a realization of the algebra of non-commutative symmetric functions. This
particular realization is the complete basis of non-commutative symmetric functions.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>The realization of the non-commutative symmetric functions in the
complete basis.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">a_realization</span><span class="p">()</span>
<span class="go">Non-Commutative Symmetric Functions over the Integer Ring in the Complete basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dual">
<tt class="descclassname">NonCommutativeSymmetricFunctions.</tt><tt class="descname">dual</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual to the non-commutative symmetric functions.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>The dual of the non-commutative symmetric functions over a ring. This
is the algebra of quasi-symmetric functions over the ring.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="go">Quasisymmetric functions over the Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualQuasisymmetric_Schur">
<em class="property">class </em><tt class="descclassname">NonCommutativeSymmetricFunctions.</tt><tt class="descname">dualQuasisymmetric_Schur</tt><big>(</big><em>NCSF</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualQuasisymmetric_Schur" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></tt></a>, <a class="reference external" href="../../../../misc/sage/misc/bindable_class.html#sage.misc.bindable_class.BindableClass" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.misc.bindable_class.BindableClass</span></tt></a></p>
<p>The basis of NCSF dual to the Quasisymmetric-Schur basis of QSym.</p>
<p>The 
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Quasisymmetric_Schur" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Quasisymmetric_Schur"><tt class="xref py py-class docutils literal"><span class="pre">Quasisymmetric_Schur</span></tt></a>
functions are defined in <a class="reference internal" href="combinatorics.html#qschur" id="id38">[QSCHUR]</a> (see also
Definition 5.1.1 of <a class="reference internal" href="qsym.html#lmvw13" id="id39">[LMvW13]</a>).  The dual basis in the algebra
of non-commutative symmetric functions is defined by the following
formula:</p>
<div class="math">
\[R_\alpha = \sum_{T} dQS_{shape(T)},\]</div>
<p>where the sum is over all standard composition tableaux with
descent composition equal to <span class="math">\(\alpha\)</span>.
The
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Quasisymmetric_Schur" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Quasisymmetric_Schur"><tt class="xref py py-class docutils literal"><span class="pre">Quasisymmetric_Schur</span></tt></a>
basis <span class="math">\(QS_\alpha\)</span> has the property that</p>
<div class="math">
\[s_\lambda = \sum_{sort(\alpha) = \lambda} QS_\alpha.\]</div>
<p>As a consequence the commutative image of a dual
Quasisymmetric-Schur element in the algebra of symmetric functions
(the map defined in the method
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><tt class="xref py py-meth docutils literal"><span class="pre">to_symmetric_function()</span></tt></a>)
is equal to the Schur function indexed by the decreasing sort of the
indexing composition.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../composition_tableau.html#sage.combinat.composition_tableau.CompositionTableaux" title="sage.combinat.composition_tableau.CompositionTableaux"><tt class="xref py py-class docutils literal"><span class="pre">CompositionTableaux</span></tt></a>,
<a class="reference internal" href="../composition_tableau.html#sage.combinat.composition_tableau.CompositionTableau" title="sage.combinat.composition_tableau.CompositionTableau"><tt class="xref py py-class docutils literal"><span class="pre">CompositionTableau</span></tt></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dQS</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">dQS</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">dQS</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">dQS[1, 2, 4] + dQS[1, 3, 2, 1] + dQS[1, 3, 3] + dQS[3, 2, 2]</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">dQS</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">dQS[1, 1, 3, 2] + dQS[1, 3, 3] + dQS[1, 4, 2] + dQS[2, 3, 2]</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="n">dQS</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">dQS[1, 3, 1, 1] + dQS[1, 4, 1] + dQS[3, 2, 1] + dQS[4, 2]</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">dQS</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">dQS[1, 1, 4, 1] + dQS[1, 4, 2] + dQS[1, 5, 1] + dQS[2, 4, 1] + dQS[3, 1,</span>
<span class="go">2, 1] + dQS[3, 2, 2] + dQS[3, 3, 1] + dQS[4, 3] + dQS[5, 2]</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">dQS[] # dQS[1, 1] + dQS[1] # dQS[1] + dQS[1, 1] # dQS[]</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span><span class="o">.</span><span class="n">monomial_coefficients</span><span class="p">()[(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span><span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]))]</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">dQS[1, 3, 1] + dQS[1, 4] + dQS[3, 2] + dQS[4, 1] + dQS[5]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">(</span><span class="n">dQS</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">S[1, 3, 1] - S[3, 2] - S[4, 1] + S[5]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">dQS</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">())</span>
<span class="go">s[3, 2, 1]</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualQuasisymmetric_Schur.dual">
<tt class="descname">dual</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualQuasisymmetric_Schur.dual" title="Permalink to this definition">¶</a></dt>
<dd><p>The dual basis to the dual Quasisymmetric-Schur basis of NCSF.</p>
<p>The basis returned is the
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Quasisymmetric_Schur" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Quasisymmetric_Schur"><tt class="xref py py-class docutils literal"><span class="pre">Quasisymmetric_Schur</span></tt></a>
basis of QSym.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>the Quasisymmetric-Schur basis of the quasi-symmetric functions</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dQS</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">dualQuasisymmetric_Schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="go">Quasisymmetric functions over the Rational Field in the Quasisymmetric</span>
<span class="go">Schur basis</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="o">.</span><span class="n">duality_pairing_matrix</span><span class="p">(</span><span class="n">dQS</span><span class="o">.</span><span class="n">dual</span><span class="p">(),</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[1 0 0 0]</span>
<span class="go">[0 1 0 0]</span>
<span class="go">[0 0 1 0]</span>
<span class="go">[0 0 0 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualQuasisymmetric_Schur.to_symmetric_function_on_basis">
<tt class="descname">to_symmetric_function_on_basis</tt><big>(</big><em>I</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualQuasisymmetric_Schur.to_symmetric_function_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>The commutative image of a dual quasi-symmetric Schur element</p>
<p>The commutative image of a basis element is obtained by sorting
the indexing composition of the basis element.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">I</span></tt> &#8211; a composition</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The commutative image of the dual quasi-Schur basis element
indexed by <tt class="docutils literal"><span class="pre">I</span></tt>. The result is the Schur symmetric function
indexed by the partition obtained by sorting <tt class="docutils literal"><span class="pre">I</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dQS</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">dQS</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">s[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">([])</span>
<span class="go">s[]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="generic_basis_code.html"
                                  title="previous chapter">Generic code for bases</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="qsym.html"
                                  title="next chapter">Quasisymmetric functions</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../../_sources/sage/combinat/ncsf_qsym/ncsf.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="qsym.html" title="Quasisymmetric functions"
             >next</a> |</li>
        <li class="right" >
          <a href="generic_basis_code.html" title="Generic code for bases"
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../../index.html">Combinatorics</a> &raquo;</li>

          <li><a href="../../../module_list.html" >Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2016, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>