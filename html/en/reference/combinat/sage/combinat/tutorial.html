<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="Vector Partitions" href="vector_partition.html" /><link rel="prev" title="Tuples" href="tuple.html" />

    <meta name="generator" content="sphinx-5.2.3, furo 2022.09.29"/>
        <title>Introduction to combinatorics in Sage - Combinatorics</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=d81277517bee4d6b0349d71bb2661d4890b5617c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom-furo.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom-jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom-codemirror-monokai.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Combinatorics</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logo_sagemath_black.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logo_sagemath_white.svg" alt="Dark Logo"/>
  </div>
  
      <span class="sidebar-brand-text">Sage 10.2 Reference Manual</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-home">
  <div class="sidebar-tree">
    <ul><li class="toctree-l1">
      <a class="reference internal" href="../../index.html">Home - Combinatorics</a>
    </li></ul>
  </div>
</div><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="../../module_list.html">Comprehensive Module List</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="abstract_tree.html">Abstract Recursive Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="affine_permutation.html">Affine Permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="algebraic_combinatorics.html">Algebraic combinatorics</a></li>
<li class="toctree-l2"><a class="reference internal" href="all.html">Combinatorics</a></li>
<li class="toctree-l2"><a class="reference internal" href="alternating_sign_matrix.html">Alternating Sign Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="backtrack.html">Backtracking</a></li>
<li class="toctree-l2"><a class="reference internal" href="baxter_permutations.html">Baxter permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="bijectionist.html">A bijectionist’s toolkit</a></li>
<li class="toctree-l2"><a class="reference internal" href="binary_recurrence_sequences.html">Binary Recurrence Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="binary_tree.html">Binary Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="blob_algebra.html">Blob Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="cartesian_product.html">Cartesian Products</a></li>
<li class="toctree-l2"><a class="reference internal" href="catalog_partitions.html">Enumerated sets of partitions, tableaux, …</a></li>
<li class="toctree-l2"><a class="reference internal" href="chas/all.html">Combinatorial Hopf algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="chas/fsym.html">Poirier-Reutenauer Hopf algebra of standard tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="chas/wqsym.html">Word Quasi-symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="cluster_algebra_quiver/all.html">Cluster algebras and quivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="cluster_algebra_quiver/cluster_seed.html">ClusterSeed</a></li>
<li class="toctree-l2"><a class="reference internal" href="cluster_algebra_quiver/mutation_class.html">mutation_class</a></li>
<li class="toctree-l2"><a class="reference internal" href="cluster_algebra_quiver/mutation_type.html">Helper functions for mutation types of quivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="cluster_algebra_quiver/quiver.html">Quiver</a></li>
<li class="toctree-l2"><a class="reference internal" href="cluster_algebra_quiver/quiver_mutation_type.html">Quiver mutation types</a></li>
<li class="toctree-l2"><a class="reference internal" href="cluster_complex.html">Cluster complex (or generalized dual associahedron)</a></li>
<li class="toctree-l2"><a class="reference internal" href="colored_permutations.html">Colored Permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="combinat.html">Combinatorial Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="combinat_cython.html">Fast computation of combinatorial functions (Cython + mpz)</a></li>
<li class="toctree-l2"><a class="reference internal" href="combination.html">Combinations</a></li>
<li class="toctree-l2"><a class="reference internal" href="combinatorial_map.html">Combinatorial maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="composition.html">Integer compositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="composition_signed.html">Signed Compositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="composition_tableau.html">Composition Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="constellation.html">Constellations</a></li>
<li class="toctree-l2"><a class="reference internal" href="core.html">Cores</a></li>
<li class="toctree-l2"><a class="reference internal" href="counting.html">Counting</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/affine.html">Affine Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/affine_factorization.html">Affine factorization crystal of type <span class="math notranslate nohighlight">\(A\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/affinization.html">Affinization Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/alcove_path.html">Alcove paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/all.html">Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/bkk_crystals.html">Benkart-Kang-Kashiwara crystals for the general-linear Lie superalgebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/catalog.html">Catalog Of Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/catalog_elementary_crystals.html">Catalog Of Elementary Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/catalog_infinity_crystals.html">Catalog Of Crystal Models For <span class="math notranslate nohighlight">\(B(\infty)\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/catalog_kirillov_reshetikhin.html">Catalog Of Crystal Models For Kirillov-Reshetikhin Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/crystals.html">An introduction to crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/direct_sum.html">Direct Sum of Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/elementary_crystals.html">Elementary Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/fast_crystals.html">Fast Rank Two Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/fully_commutative_stable_grothendieck.html">Fully commutative stable Grothendieck crystal</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/generalized_young_walls.html">Crystals of Generalized Young Walls</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/highest_weight_crystals.html">Highest weight crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/induced_structure.html">Induced Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/infinity_crystals.html"><span class="math notranslate nohighlight">\(\mathcal{B}(\infty)\)</span> Crystals of Tableaux in Nonexceptional Types and <span class="math notranslate nohighlight">\(G_2\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/kac_modules.html">Crystals of Kac modules of the general-linear Lie superalgebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/kirillov_reshetikhin.html">Kirillov-Reshetikhin Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/kyoto_path_model.html">Kyoto Path Model for Affine Highest Weight Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/letters.html">Crystals of letters</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/littelmann_path.html">Littelmann paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/monomial_crystals.html">Crystals of Modified Nakajima Monomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/multisegments.html">Crystal of Bernstein-Zelevinsky Multisegments</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/mv_polytopes.html">Crystal Of Mirković-Vilonen (MV) Polytopes</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/pbw_crystal.html"><span class="math notranslate nohighlight">\(\mathcal{B}(\infty)\)</span> Crystal Of PBW Monomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/pbw_datum.html">PBW Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/polyhedral_realization.html">Polyhedral Realization of <span class="math notranslate nohighlight">\(B(\infty)\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/spins.html">Spin Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/star_crystal.html">Star-Crystal Structure On <span class="math notranslate nohighlight">\(B(\infty)\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/tensor_product.html">Tensor Products of Crystals</a></li>
<li class="toctree-l2"><a class="reference internal" href="crystals/tensor_product_element.html">Tensor Products of Crystal Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="cyclic_sieving_phenomenon.html">Cyclic sieving phenomenon</a></li>
<li class="toctree-l2"><a class="reference internal" href="debruijn_sequence.html">De Bruijn sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="degree_sequences.html">Degree sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="derangements.html">Derangements</a></li>
<li class="toctree-l2"><a class="reference internal" href="descent_algebra.html">Descent Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/all.html">Combinatorial designs and incidence structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/bibd.html">Balanced Incomplete Block Designs (BIBD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/resolvable_bibd.html">Resolvable Balanced Incomplete Block Design (RBIBD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/group_divisible_designs.html">Group-Divisible Designs (GDD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/block_design.html">Block designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/covering_array.html">Covering Arrays (CA)</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/covering_design.html">Covering designs: coverings of <span class="math notranslate nohighlight">\(t\)</span>-element subsets of a <span class="math notranslate nohighlight">\(v\)</span>-set by <span class="math notranslate nohighlight">\(k\)</span>-sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/database.html">Database of small combinatorial designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/design_catalog.html">Catalog of designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/designs_pyx.html">Cython functions for combinatorial designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/difference_family.html">Difference families</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/difference_matrices.html">Difference Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/evenly_distributed_sets.html">Evenly distributed sets in finite fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/ext_rep.html">External Representations of Block Designs</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/gen_quadrangles_with_spread.html">Database of generalised quadrangles with spread</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/incidence_structures.html">Incidence structures (i.e. hypergraphs, i.e. set systems)</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/latin_squares.html">Mutually Orthogonal Latin Squares (MOLS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/orthogonal_arrays.html">Orthogonal arrays (OA)</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/orthogonal_arrays_build_recursive.html">Orthogonal arrays (build recursive constructions)</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/orthogonal_arrays_find_recursive.html">Orthogonal arrays (find recursive constructions)</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/steiner_quadruple_systems.html">Steiner Quadruple Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/subhypergraph_search.html">Hypergraph isomorphic copy search</a></li>
<li class="toctree-l2"><a class="reference internal" href="designs/twographs.html">Two-graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="diagram.html">Combinatorial diagrams</a></li>
<li class="toctree-l2"><a class="reference internal" href="diagram_algebras.html">Diagram and Partition Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="dlx.html">Exact Cover Problem via Dancing Links</a></li>
<li class="toctree-l2"><a class="reference internal" href="dyck_word.html">Dyck Words</a></li>
<li class="toctree-l2"><a class="reference internal" href="e_one_star.html">Substitutions over unit cube faces (Rauzy fractals)</a></li>
<li class="toctree-l2"><a class="reference internal" href="enumerated_sets.html">Enumerated sets and combinatorial objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="enumeration_mod_permgroup.html">Tools for enumeration modulo the action of a permutation group</a></li>
<li class="toctree-l2"><a class="reference internal" href="expnums.html">Compute Bell and Uppuluri-Carpenter numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="family.html">Families</a></li>
<li class="toctree-l2"><a class="reference internal" href="fast_vector_partitions.html">Brent Yorgey’s fast algorithm for integer vector (multiset) partitions.</a></li>
<li class="toctree-l2"><a class="reference internal" href="fully_commutative_elements.html">Fully commutative elements of Coxeter groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="finite_state_machine.html">Finite state machines, automata, transducers</a></li>
<li class="toctree-l2"><a class="reference internal" href="finite_state_machine_generators.html">Common Automata and Transducers (Finite State Machines Generators)</a></li>
<li class="toctree-l2"><a class="reference internal" href="fqsym.html">Free Quasi-symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="free_module.html">Free modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="free_dendriform_algebra.html">Free Dendriform Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="free_prelie_algebra.html">Free Pre-Lie Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="fully_packed_loop.html">Fully packed loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="gelfand_tsetlin_patterns.html">Gelfand-Tsetlin Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="graph_path.html">Paths in Directed Acyclic Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="gray_codes.html">Gray codes</a></li>
<li class="toctree-l2"><a class="reference internal" href="growth.html">Growth diagrams and dual graded graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="grossman_larson_algebras.html">Grossman-Larson Hopf Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="hall_polynomial.html">Hall Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="hillman_grassl.html">The Hillman-Grassl correspondence</a></li>
<li class="toctree-l2"><a class="reference internal" href="integer_lists/base.html">Enumerated set of lists of integers with constraints: base classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="integer_lists/lists.html">Enumerated set of lists of integers with constraints: front-end</a></li>
<li class="toctree-l2"><a class="reference internal" href="integer_lists/invlex.html">Enumerated set of lists of integers with constraints, in inverse lexicographic order</a></li>
<li class="toctree-l2"><a class="reference internal" href="integer_matrices.html">Counting, generating, and manipulating non-negative integer matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="integer_vector.html">(Non-negative) Integer vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="integer_vector_weighted.html">Weighted Integer Vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="integer_vectors_mod_permgroup.html">Integer vectors modulo the action of a permutation group</a></li>
<li class="toctree-l2"><a class="reference internal" href="interval_posets.html">Tamari Interval-posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="k_tableau.html">Strong and weak tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="kazhdan_lusztig.html">Kazhdan-Lusztig Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="key_polynomial.html">Key polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="knutson_tao_puzzles.html">Knutson-Tao Puzzles</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices/all.html">Combinatorics on matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices/dancing_links.html">Dancing Links internal pyx code</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices/dlxcpp.html">Dancing links C++ wrapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices/hadamard_matrix.html">Hadamard matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices/latin.html">Latin Squares</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="multiset_partition_into_sets_ordered.html">Ordered Multiset Partitions into Sets and the Minimaj Crystal</a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsf_qsym/all.html">Non-commutative symmetric functions and quasi-symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsf_qsym/combinatorics.html">Common combinatorial tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsf_qsym/generic_basis_code.html">Generic code for bases</a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsf_qsym/ncsf.html">Non-Commutative Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsf_qsym/qsym.html">Quasisymmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsf_qsym/tutorial.html">Introduction to Quasisymmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsym/all.html">Symmetric functions in non-commuting variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsym/bases.html">Bases for <span class="math notranslate nohighlight">\(NCSym\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsym/dual.html">Dual Symmetric Functions in Non-Commuting Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="ncsym/ncsym.html">Symmetric Functions in Non-Commuting Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="necklace.html">Necklaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="non_decreasing_parking_function.html">Non-Decreasing Parking Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="nu_dyck_word.html"><span class="math notranslate nohighlight">\(\nu\)</span>-Dyck Words</a></li>
<li class="toctree-l2"><a class="reference internal" href="nu_tamari_lattice.html"><span class="math notranslate nohighlight">\(\nu\)</span>-Tamari lattice</a></li>
<li class="toctree-l2"><a class="reference internal" href="ordered_tree.html">Ordered Rooted Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="output.html">Output functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallelogram_polyomino.html">Parallelogram Polyominoes</a></li>
<li class="toctree-l2"><a class="reference internal" href="parking_functions.html">Parking Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="path_tableaux/catalog.html">Catalog of Path Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="path_tableaux/dyck_path.html">Dyck Paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="path_tableaux/frieze.html">Frieze Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="path_tableaux/path_tableau.html">Path Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="path_tableaux/semistandard.html">Semistandard Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="plane_partition.html">Plane Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="partition.html">Integer partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="partition_algebra.html">Partition/Diagram Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="partition_kleshchev.html">Kleshchev partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="partition_shifting_algebras.html">Partition Shifting Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="partition_tuple.html">Partition tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="partitions.html">Iterators over the partitions of an integer</a></li>
<li class="toctree-l2"><a class="reference internal" href="perfect_matching.html">Perfect matchings</a></li>
<li class="toctree-l2"><a class="reference internal" href="permutation.html">Permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="permutation_cython.html">Permutations (Cython file)</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/all.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/cartesian_product.html">Cartesian products of Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/d_complete.html">D-Complete Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/mobile.html">Mobile posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/elements.html">Elements of posets, lattices, semilattices, etc.</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/forest.html">Forest Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/hasse_diagram.html">Hasse diagrams of posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/incidence_algebras.html">Incidence Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/lattices.html">Finite lattices and semilattices</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/linear_extensions.html">Linear Extensions of Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/moebius_algebra.html">Möbius Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/poset_examples.html">Catalog of posets and lattices</a></li>
<li class="toctree-l2"><a class="reference internal" href="posets/posets.html">Finite posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="q_analogues.html"><span class="math notranslate nohighlight">\(q\)</span>-Analogues</a></li>
<li class="toctree-l2"><a class="reference internal" href="q_bernoulli.html"><span class="math notranslate nohighlight">\(q\)</span>-Bernoulli Numbers and Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="quickref.html">Combinatorics quickref</a></li>
<li class="toctree-l2"><a class="reference internal" href="ranker.html">Rankers</a></li>
<li class="toctree-l2"><a class="reference internal" href="recognizable_series.html">Recognizable Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="regular_sequence.html"><span class="math notranslate nohighlight">\(k\)</span>-regular sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="restricted_growth.html">Restricted growth arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="ribbon.html">Ribbons</a></li>
<li class="toctree-l2"><a class="reference internal" href="ribbon_shaped_tableau.html">Ribbon Shaped Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="ribbon_tableau.html">Ribbon Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/all.html">Rigged configurations</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_abstract_class.html">Abstract classes for the rigged configuration bijections</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_infinity.html">Bijection between rigged configurations for <span class="math notranslate nohighlight">\(B(\infty)\)</span> and marginally large tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_type_A.html">Bijection classes for type <span class="math notranslate nohighlight">\(A_n^{(1)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_type_A2_dual.html">Bijection classes for type <span class="math notranslate nohighlight">\(A_{2n}^{(2)\dagger}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_type_A2_even.html">Bijection classes for type <span class="math notranslate nohighlight">\(A_{2n}^{(2)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_type_A2_odd.html">Bijection classes for type <span class="math notranslate nohighlight">\(A_{2n-1}^{(2)}\)</span>.</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_type_B.html">Bijection classes for type <span class="math notranslate nohighlight">\(B_n^{(1)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_type_C.html">Bijection classes for type <span class="math notranslate nohighlight">\(C_n^{(1)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_type_D.html">Bijection classes for type <span class="math notranslate nohighlight">\(D_n^{(1)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_type_D_twisted.html">Bijection classes for type <span class="math notranslate nohighlight">\(D_{n+1}^{(2)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bij_type_D_tri.html">Bijection classes for type <span class="math notranslate nohighlight">\(D_4^{(3)}\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/bijection.html">Bijection between rigged configurations and KR tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/kleber_tree.html">Kleber Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/kr_tableaux.html">Kirillov-Reshetikhin Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/rc_crystal.html">Crystal of Rigged Configurations</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/rc_infinity.html">Rigged Configurations of <span class="math notranslate nohighlight">\(\mathcal{B}(\infty)\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/rigged_configuration_element.html">Rigged Configuration Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/rigged_configurations.html">Rigged Configurations</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/rigged_partition.html">Rigged Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/tensor_product_kr_tableaux.html">Tensor Product of Kirillov-Reshetikhin Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigged_configurations/tensor_product_kr_tableaux_element.html">Tensor Product of Kirillov-Reshetikhin Tableaux Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/all.html">Root Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/ambient_space.html">Ambient lattices and ambient spaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/associahedron.html">Associahedron</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/braid_move_calculator.html">Braid Move Calculator</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/braid_orbit.html">Braid Orbit</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/branching_rules.html">Branching Rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/cartan_matrix.html">Cartan matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/cartan_type.html">Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/coxeter_group.html">Coxeter Groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/coxeter_matrix.html">Coxeter Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/coxeter_type.html">Coxeter Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/dynkin_diagram.html">Dynkin diagrams</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/hecke_algebra_representation.html">Hecke algebra representations</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/integrable_representations.html">Integrable Representations of Affine Lie Algebras</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/non_symmetric_macdonald_polynomials.html">Nonsymmetric Macdonald polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/pieri_factors.html">Pieri Factors</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/plot.html">Tutorial: visualizing root systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/reflection_group_complex.html">Finite complex reflection groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/reflection_group_real.html">Finite real reflection groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/root_lattice_realization_algebras.html">Group algebras of root lattice realizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/root_lattice_realizations.html">Root lattice realizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/root_space.html">Root lattices and root spaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/root_system.html">Root systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_super_A.html">Root system data for super type A</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_A.html">Root system data for type A</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_A_affine.html">Root system data for (untwisted) type A affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_A_infinity.html">Root system data for type A infinity</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_B.html">Root system data for type B</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_BC_affine.html">Root system data for type BC affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_B_affine.html">Root system data for (untwisted) type B affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_C.html">Root system data for type C</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_C_affine.html">Root system data for (untwisted) type C affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_D.html">Root system data for type D</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_D_affine.html">Root system data for (untwisted) type D affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_E.html">Root system data for type E</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_E_affine.html">Root system data for (untwisted) type E affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_F.html">Root system data for type F</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_F_affine.html">Root system data for (untwisted) type F affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_G.html">Root system data for type G</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_G_affine.html">Root system data for (untwisted) type G affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_H.html">Root system data for type H</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_I.html">Root system data for type I</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_Q.html">Root system data for type Q</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_affine.html">Root system data for affine Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_dual.html">Root system data for dual Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/extended_affine_weyl_group.html">Extended Affine Weyl Groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/fundamental_group.html">Fundamental Group of an Extended Affine Weyl Group</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_folded.html">Root system data for folded Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_marked.html">Root system data for Cartan types with marked nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_reducible.html">Root system data for reducible Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/type_relabel.html">Root system data for relabelled Cartan types</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/weight_lattice_realizations.html">Weight lattice realizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/weight_space.html">Weight lattices and weight spaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/weyl_characters.html">Weyl Character Rings</a></li>
<li class="toctree-l2"><a class="reference internal" href="root_system/weyl_group.html">Weyl Groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="rooted_tree.html">Rooted (Unordered) Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="rsk.html">Robinson-Schensted-Knuth correspondence</a></li>
<li class="toctree-l2"><a class="reference internal" href="schubert_polynomial.html">Schubert Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="set_partition.html">Set Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="set_partition_iterator.html">Fast set partition iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="set_partition_ordered.html">Ordered Set Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/all.html">Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/character.html">Characters of the symmetric group as bases of the symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/classical.html">Classical symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/dual.html">Generic dual bases symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/elementary.html">Elementary symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/hall_littlewood.html">Hall-Littlewood Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/hecke.html">Hecke Character Basis</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/homogeneous.html">Homogeneous symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/jack.html">Jack Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/k_dual.html">Quotient of symmetric function space by ideal generated by Hall-Littlewood symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/kfpoly.html">Kostka-Foulkes Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/llt.html">LLT symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/macdonald.html">Macdonald Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/monomial.html">Monomial symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/multiplicative.html">Multiplicative symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/new_kschur.html"><span class="math notranslate nohighlight">\(k\)</span>-Schur Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/ns_macdonald.html">Non-symmetric Macdonald Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/orthogonal.html">Orthogonal Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/orthotriang.html">Symmetric functions defined by orthogonality and triangularity</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/powersum.html">Power sum symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/schur.html">Schur symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/symplectic.html">Symplectic Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/sf.html">Symmetric functions, with their multiple realizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/sfa.html">Symmetric Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sf/witt.html">Witt symmetric functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="shard_order.html">Shard intersection order</a></li>
<li class="toctree-l2"><a class="reference internal" href="shifted_primed_tableau.html">Shifted primed tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="shuffle.html">Shuffle product of iterables</a></li>
<li class="toctree-l2"><a class="reference internal" href="sidon_sets.html">Sidon sets and their generalizations, Sidon <span class="math notranslate nohighlight">\(g\)</span>-sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="similarity_class_type.html">Similarity class types of matrices with entries in a finite field</a></li>
<li class="toctree-l2"><a class="reference internal" href="sine_gordon.html">sine-Gordon Y-system plotter</a></li>
<li class="toctree-l2"><a class="reference internal" href="six_vertex_model.html">Six Vertex Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="skew_partition.html">Skew Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="skew_tableau.html">Skew Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="sloane_functions.html">Functions that compute some of the sequences in Sloane’s tables</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/all.html">Combinatorial species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/characteristic_species.html">Characteristic Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/composition_species.html">Composition species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/cycle_species.html">Cycle Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/empty_species.html">Empty Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/functorial_composition_species.html">Functorial composition species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/generating_series.html">Generating Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/library.html">Examples of Combinatorial Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/linear_order_species.html">Linear-order Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/misc.html">Miscellaneous Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/partition_species.html">Partition Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/permutation_species.html">Permutation species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/product_species.html">Product species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/recursive_species.html">Recursive Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/set_species.html">Set Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/species.html">Combinatorial Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/structure.html">Species structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/subset_species.html">Subset Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="species/sum_species.html">Sum species</a></li>
<li class="toctree-l2"><a class="reference internal" href="specht_module.html">Specht Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="subset.html">Subsets</a></li>
<li class="toctree-l2"><a class="reference internal" href="subsets_hereditary.html">Subsets satisfying a hereditary property</a></li>
<li class="toctree-l2"><a class="reference internal" href="subsets_pairwise.html">Subsets whose elements satisfy a predicate pairwise</a></li>
<li class="toctree-l2"><a class="reference internal" href="subword.html">Subwords</a></li>
<li class="toctree-l2"><a class="reference internal" href="subword_complex.html">Subword complex</a></li>
<li class="toctree-l2"><a class="reference internal" href="super_tableau.html">Super Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="superpartition.html">Super Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="symmetric_group_algebra.html">Symmetric Group Algebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="symmetric_group_representations.html">Representations of the Symmetric Group</a></li>
<li class="toctree-l2"><a class="reference internal" href="t_sequences.html">T-sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="tableau.html">Tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="tableau_residues.html">Residue sequences of tableaux</a></li>
<li class="toctree-l2"><a class="reference internal" href="tableau_tuple.html">TableauTuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="tamari_lattices.html">Generalized Tamari lattices</a></li>
<li class="toctree-l2"><a class="reference internal" href="tiling.html">Tiling Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="tools.html">Transitive ideal closure tool</a></li>
<li class="toctree-l2"><a class="reference internal" href="triangles_FHM.html">Combinatorial triangles for posets and fans</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuple.html">Tuples</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Introduction to combinatorics in Sage</a></li>
<li class="toctree-l2"><a class="reference internal" href="vector_partition.html">Vector Partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/abstract_word.html">Abstract word (finite or infinite)</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/all.html">Combinatorics on words</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/alphabet.html">Alphabet</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/finite_word.html">Finite word</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/infinite_word.html">Infinite word</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/lyndon_word.html">Lyndon words</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/morphism.html">Word morphisms/substitutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/paths.html">Word paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/shuffle_product.html">Shuffle product of words</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/suffix_trees.html">Suffix Tries and Suffix Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/word.html">Word classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/word_char.html">Fast word datatype using an array of unsigned char</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/word_datatypes.html">Datatypes for finite words</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/word_generators.html">Common words</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/word_infinite_datatypes.html">Datatypes for words defined by iterators and callables</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/word_options.html">User-customizable options for words</a></li>
<li class="toctree-l2"><a class="reference internal" href="words/words.html">Set of words</a></li>
<li class="toctree-l2"><a class="reference internal" href="yang_baxter_graph.html">Yang-Baxter Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rings/cfinite_sequence.html">C-Finite Sequences</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="introduction-to-combinatorics-in-sage">
<span id="sage-combinat-tutorial"></span><h1>Introduction to combinatorics in Sage<a class="headerlink" href="#introduction-to-combinatorics-in-sage" title="Permalink to this heading">#</a></h1>
<span class="target" id="module-sage.combinat.tutorial"></span><p>This thematic tutorial is a translation by Hugh Thomas of the
combinatorics chapter written by Nicolas M. Thiéry in the book “Calcul
Mathématique avec Sage” <a class="reference internal" href="#cms2012" id="id1"><span>[CMS2012]</span></a>. It covers mainly the treatment in
<code class="docutils literal notranslate"><span class="pre">Sage</span></code> of the following combinatorial problems: enumeration (how
many elements are there in a set <span class="math notranslate nohighlight">\(S\)</span>?), listing (generate all the
elements of <span class="math notranslate nohighlight">\(S\)</span>, or iterate through them), and random selection
(choosing an element at random from a set <span class="math notranslate nohighlight">\(S\)</span> according to a given
distribution, for example the uniform distribution). These questions
arise naturally in the calculation of probabilities (what is the
probability in poker of obtaining a straight or a four-of-a-kind of
aces?), in statistical physics, and also in computer algebra (the number
of elements in a finite field), or in the analysis of
algorithms. Combinatorics covers a much wider domain (partial orders,
representation theory, …) for which we only give a few pointers
towards the possibilities offered by <code class="docutils literal notranslate"><span class="pre">Sage</span></code>.</p>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">Todo</p>
<p>Add link to some thematic tutorial on graphs</p>
</div>
<p>A characteristic of computational combinatorics is the profusion of
types of objects and sets that one wants to manipulate. It would be
impossible to describe them all or, a fortiori, to implement them all.
After some <a class="reference internal" href="#section-examples"><span class="std std-ref">Initial examples</span></a>, this chapter illustrates the
underlying method: supplying the basic building blocks to describe
common combinatorial sets <a class="reference internal" href="#section-bricks"><span class="std std-ref">Common enumerated sets</span></a>, tools for combining
them to construct new examples <a class="reference internal" href="#section-constructions"><span class="std std-ref">Constructions</span></a>, and
generic algorithms for solving uniformly a large class of problems
<a class="reference internal" href="#section-generic"><span class="std std-ref">Generic algorithms</span></a>.</p>
<p>This is a domain in which <code class="docutils literal notranslate"><span class="pre">Sage</span></code> has much more extensive capabilities
than most computer algebra systems, and it is rapidly expanding; at the
same time, it is still quite new, and has many unnecessary limitations
and incoherences.</p>
<section id="initial-examples">
<span id="section-examples"></span><h2>Initial examples<a class="headerlink" href="#initial-examples" title="Permalink to this heading">#</a></h2>
<section id="poker-and-probability">
<span id="section-examples-poker"></span><h3>Poker and probability<a class="headerlink" href="#poker-and-probability" title="Permalink to this heading">#</a></h3>
<p>We begin by solving a classic problem: enumerating certain combinations
of cards in the game of poker, in order to deduce their probability.</p>
<p>A card in a poker deck is characterized by a suit (hearts, diamonds,
spades, or clubs) and a value (2, 3, …, 10, jack, queen, king, ace). The
game is played with a full deck, which consists of the Cartesian product
of the set of suits and the set of values:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\operatorname{Cards} = \operatorname{Suits} \times
\operatorname{Values} = \{ (s, v)  \mathrel| s\in
\operatorname{Suits} \text{ et } v \in \operatorname{Values} \}\,.\]</div>
</div>
<p>We construct these examples in <code class="docutils literal notranslate"><span class="pre">Sage</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Suits</span> <span class="o">=</span> <span class="n">Set</span><span class="p">([</span><span class="s2">&quot;Hearts&quot;</span><span class="p">,</span> <span class="s2">&quot;Diamonds&quot;</span><span class="p">,</span> <span class="s2">&quot;Spades&quot;</span><span class="p">,</span> <span class="s2">&quot;Clubs&quot;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Values</span> <span class="o">=</span> <span class="n">Set</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span>
<span class="gp">....: </span>              <span class="s2">&quot;Jack&quot;</span><span class="p">,</span> <span class="s2">&quot;Queen&quot;</span><span class="p">,</span> <span class="s2">&quot;King&quot;</span><span class="p">,</span> <span class="s2">&quot;Ace&quot;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Cards</span> <span class="o">=</span> <span class="n">cartesian_product</span><span class="p">([</span><span class="n">Values</span><span class="p">,</span> <span class="n">Suits</span><span class="p">])</span>
</pre></div>
</div>
<p>There are <span class="math notranslate nohighlight">\(4\)</span> suits and <span class="math notranslate nohighlight">\(13\)</span> possible values, and
therefore <span class="math notranslate nohighlight">\(4\times 13=52\)</span> cards in the poker deck:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Suits</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">Values</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">13</span>
<span class="gp">sage: </span><span class="n">Cards</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">52</span>
</pre></div>
</div>
<p>Draw a card at random:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Cards</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>                      <span class="c1"># random</span>
<span class="go">(6, &#39;Clubs&#39;)</span>
</pre></div>
</div>
<p>Now we can define a set of cards:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Set</span><span class="p">([</span><span class="n">Cards</span><span class="o">.</span><span class="n">random_element</span><span class="p">(),</span> <span class="n">Cards</span><span class="o">.</span><span class="n">random_element</span><span class="p">()])</span>  <span class="c1"># random</span>
<span class="go">{(2, &#39;Hearts&#39;), (4, &#39;Spades&#39;)}</span>
</pre></div>
</div>
<p>This problem should eventually disappear: it is planned to change the
implementation of Cartesian products so that their elements are
immutable by default.</p>
<p>Returning to our main topic, we will be considering a simplified version
of poker, in which each player directly draws five cards, which form his
<em>hand</em>. The cards are all distinct and the order in which they are drawn
is irrelevant; a hand is therefore a subset of size <span class="math notranslate nohighlight">\(5\)</span> of the
set of cards. To draw a hand at random, we first construct the set of
all possible hands, and then we ask for a randomly chosen element:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Hands</span> <span class="o">=</span> <span class="n">Subsets</span><span class="p">(</span><span class="n">Cards</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Hands</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>                      <span class="c1"># random</span>
<span class="go">{(4, &#39;Hearts&#39;, 4), (9, &#39;Diamonds&#39;), (8, &#39;Spades&#39;),</span>
<span class="go"> (9, &#39;Clubs&#39;), (7, &#39;Hearts&#39;)}</span>
</pre></div>
</div>
<p>The total number of hands is given by the number of subsets of size
<span class="math notranslate nohighlight">\(5\)</span> of a set of size <span class="math notranslate nohighlight">\(52\)</span>, which is given by the
binomial coefficient <span class="math notranslate nohighlight">\(\binom{52}{5}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">binomial</span><span class="p">(</span><span class="mi">52</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="go">2598960</span>
</pre></div>
</div>
<p>One can also ignore the method of calculation, and
simply ask for the size of the set of hands:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Hands</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">2598960</span>
</pre></div>
</div>
<p>The strength of a poker hand depends on the particular combination of
cards present. One such combination is the <em>flush</em>; this is a hand all
of whose cards have the same suit. (In principle, straight flushes
should be excluded; this will be the goal of an exercise given below.)
Such a hand is therefore characterized by the choice of five values from
among the thirteen possibilities, and the choice of one of four suits.
We will construct the set of all flushes, so as to determine how many
there are:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Flushes</span> <span class="o">=</span> <span class="n">cartesian_product</span><span class="p">([</span><span class="n">Subsets</span><span class="p">(</span><span class="n">Values</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">Suits</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Flushes</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5148</span>
</pre></div>
</div>
<p>The probability of obtaining a flush when drawing a hand at random is
therefore:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Flushes</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>  <span class="o">/</span> <span class="n">Hands</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">33/16660</span>
</pre></div>
</div>
<p>or about two in a thousand:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="mf">1000.0</span> <span class="o">*</span> <span class="n">Flushes</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>  <span class="o">/</span> <span class="n">Hands</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">1.98079231692677</span>
</pre></div>
</div>
<p>We will now attempt a little numerical simulation. The following
function tests whether a given hand is a flush or not:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">is_flush</span><span class="p">(</span><span class="n">hand</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">suit</span> <span class="k">for</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">suit</span><span class="p">)</span> <span class="ow">in</span> <span class="n">hand</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>We now draw 10000 hands at random, and count the number of flushes
obtained (this takes about 10 seconds):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="gp">sage: </span><span class="n">nflush</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>                            <span class="c1"># long time</span>
<span class="gp">....: </span>   <span class="n">hand</span> <span class="o">=</span> <span class="n">Hands</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="gp">....: </span>   <span class="k">if</span> <span class="n">is_flush</span><span class="p">(</span><span class="n">hand</span><span class="p">):</span>
<span class="gp">....: </span>       <span class="n">nflush</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">n</span><span class="p">,</span> <span class="n">nflush</span>                               <span class="c1"># random</span>
<span class="go">(10000, 18)</span>
</pre></div>
</div>
<aside class="topic">
<p class="topic-title">Exercises</p>
<p>A hand containing four cards of the same value is called a <em>four
of a kind</em>. Construct the set of four of a kind hands (Hint: use
<code class="docutils literal notranslate"><span class="pre">Arrangements</span></code> to choose a pair of distinct values at random,
then choose a suit for the first value). Calculate the number of
four of a kind hand, list them, and then determine the probability
of obtaining a four of a kind when drawing a hand at random.</p>
<p>A hand all of whose cards have the same suit, and whose values are
consecutive, is called a <em>straight flush</em> rather than a <em>flush</em>.
Count the number of straight flushes, and then deduce the correct
probability of obtaining a flush when drawing a hand at random.</p>
<p>Calculate the probability of each of the poker hands (see
<a class="reference external" href="https://en.wikipedia.org/wiki/Poker_hands">Wikipedia article Poker_hands</a>), and compare them with the results of
simulations.</p>
</aside>
</section>
<section id="enumeration-of-trees-using-generating-functions">
<span id="section-examples-catalan"></span><h3>Enumeration of trees using generating functions<a class="headerlink" href="#enumeration-of-trees-using-generating-functions" title="Permalink to this heading">#</a></h3>
<p>In this section, we discuss the example of complete binary trees, and
illustrate in this context many techniques of enumeration in which
formal power series play a natural role. These techniques are quite
general, and can be applied whenever the combinatorial objects in
question admit a recursive definition (grammar) (see
<a class="reference internal" href="#section-generic-species"><span class="std std-ref">Species, decomposable combinatorial classes</span></a> for an automated treatment). The
goal is not a formal presentation of these methods; the calculations are
rigorous, but most of the justifications will be skipped.</p>
<p>A <em>complete binary tree</em> is either a leaf <span class="math notranslate nohighlight">\(\mathrm{L}\)</span>, or a
node to which two complete binary trees are attached (see
<a class="reference internal" href="#figure-examples-catalan-trees"><span class="std std-ref">Figure: The five complete binary trees with four leaves</span></a>).</p>
<figure class="align-default" id="id11">
<span id="figure-examples-catalan-trees"></span><a class="reference internal image-reference" href="../../_images/complete-binary-trees-4.png"><img alt="../../_images/complete-binary-trees-4.png" src="../../_images/complete-binary-trees-4.png" style="width: 699.0px; height: 91.5px;" /></a>
<figcaption>
<p><span class="caption-text">Figure: The five complete binary trees with four leaves</span><a class="headerlink" href="#id11" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<aside class="topic" id="exo-enumeration-arbres">
<p class="topic-title">Exercise: enumeration of binary trees</p>
<p>Find by hand all the complete binary trees with <span class="math notranslate nohighlight">\(n=1, 2, 3, 4, 5\)</span>
leaves (see <a class="reference internal" href="#exo-iterators-catalan"><span class="std std-ref">Exercise: complete binary tree iterator</span></a> to find them using <code class="docutils literal notranslate"><span class="pre">Sage</span></code>).</p>
</aside>
<p>Our goal is to determine the number <span class="math notranslate nohighlight">\(c_n\)</span> of complete binary
trees with <span class="math notranslate nohighlight">\(n\)</span> leaves (in this section, except when explicitly
stated otherwise, “trees” always means complete binary trees). This is a
typical situation in which one is not only interested in a single set,
but in a family of sets, typically parameterized by <span class="math notranslate nohighlight">\(n\in \NN\)</span>.</p>
<p>According to the solution of <a class="reference internal" href="#exo-enumeration-arbres"><span class="std std-ref">Exercise: enumeration of binary trees</span></a>, the first terms are given by
<span class="math notranslate nohighlight">\(c_1,\dots,c_5=1,1,2,5,14\)</span>. The simple fact of knowing these few
numbers is already very valuable. In fact, this permits research in a
gold mine of information: the <a class="reference external" href="http://oeis.org/">Online Encyclopedia of Integer Sequences</a>, commonly called “Sloane”, the name of its principal
author, which contains more than 190000 sequences of integers:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">oeis</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">14</span><span class="p">])</span>                            <span class="c1"># optional -- internet</span>
<span class="go">0: A000108: Catalan numbers: ...</span>
<span class="go">1: ...</span>
<span class="go">2: ...</span>
</pre></div>
</div>
<p>The result suggests that the trees are counted by one of the most famous
sequences, the Catalan numbers. Looking through the references supplied
by the Encyclopedia, we see that this is really the case: the few
numbers above form a digital fingerprint of our objects, which enable us
to find, in a few seconds, a precise result from within an abundant
literature.</p>
<p>Our next goal is to recover this result using <code class="docutils literal notranslate"><span class="pre">Sage</span></code>. Let
<span class="math notranslate nohighlight">\(C_n\)</span> be the set of trees with <span class="math notranslate nohighlight">\(n\)</span> leaves, so that
<span class="math notranslate nohighlight">\(c_n=|C_n|\)</span>; by convention, we will define
<span class="math notranslate nohighlight">\(C_0=\emptyset\)</span> and <span class="math notranslate nohighlight">\(c_0=0\)</span>. The set of all trees is
then the disjoint union of the sets <span class="math notranslate nohighlight">\(C_n\)</span>:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[C=\biguplus_{n\in \mathbb N} C_n\,.\]</div>
</div>
<p>Having named the set <span class="math notranslate nohighlight">\(C\)</span> of all trees, we can translate the
recursive definition of trees into a set-theoretic equation:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[C \quad \approx \quad  \{ \mathrm{L} \} \quad \uplus\quad C \times C\,.\]</div>
</div>
<p>In words: a tree <span class="math notranslate nohighlight">\(t\)</span> (which is by definition in <span class="math notranslate nohighlight">\(C\)</span>) is either a
leaf (so in <span class="math notranslate nohighlight">\(\{\mathrm{L}\}\)</span>) or a node to which two trees
<span class="math notranslate nohighlight">\(t_1\)</span> and <span class="math notranslate nohighlight">\(t_2\)</span> have been attached, and which we can
therefore identify with the pair <span class="math notranslate nohighlight">\((t_1,t_2)\)</span> (in the Cartesian
product <span class="math notranslate nohighlight">\(C\times C\)</span>).</p>
<p>The founding idea of algebraic combinatorics, introduced by Euler in
a letter to Goldbach of 1751 to treat a similar problem , is to
manipulate all the numbers <span class="math notranslate nohighlight">\(c_n\)</span> simultaneously, by encoding them
as coefficients in a formal power series, called the <em>generating
function</em> of the <span class="math notranslate nohighlight">\(c_n\)</span>’s:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[C(z) = \sum_{n\in \mathbb N} c_n z^n\,,\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(z\)</span> is a formal variable (which means that we do not
have to worry about questions of convergence). The beauty of this idea
is that set-theoretic operations <span class="math notranslate nohighlight">\((A\uplus B\)</span>,
<span class="math notranslate nohighlight">\(A\times B)\)</span> translate naturally into algebraic operations on
the corresponding series (<span class="math notranslate nohighlight">\(A(z)+B(z)\)</span>,
<span class="math notranslate nohighlight">\(A(z)\cdot B(z)\)</span>), in such a way that the set-theoretic equation
satisfied by <span class="math notranslate nohighlight">\(C\)</span> can be translated directly into an algebraic
equation satisfied by <span class="math notranslate nohighlight">\(C(z)\)</span>:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[C(z) = z + C(z) \cdot C(z)\,.\]</div>
</div>
<p>Now we can solve this equation with <code class="docutils literal notranslate"><span class="pre">Sage</span></code>. In order to do so, we
introduce two variables, <span class="math notranslate nohighlight">\(C\)</span> and <span class="math notranslate nohighlight">\(z\)</span>, and we define the
equation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;C,z&#39;</span><span class="p">)</span>                                                             <span class="c1"># needs sage.symbolic</span>
<span class="gp">sage: </span><span class="n">sys</span> <span class="o">=</span> <span class="p">[</span> <span class="n">C</span> <span class="o">==</span> <span class="n">z</span> <span class="o">+</span> <span class="n">C</span><span class="o">*</span><span class="n">C</span> <span class="p">]</span>                                                        <span class="c1"># needs sage.symbolic</span>
</pre></div>
</div>
<p>There are two solutions, which happen to have closed forms:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">solution_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">sol</span>                                  <span class="c1"># needs sage.symbolic</span>
<span class="go">[{C: -1/2*sqrt(-4*z + 1) + 1/2}, {C: 1/2*sqrt(-4*z + 1) + 1/2}]</span>
<span class="gp">sage: </span><span class="n">s0</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">C</span><span class="p">];</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">C</span><span class="p">]</span>                                                <span class="c1"># needs sage.symbolic</span>
</pre></div>
</div>
<p>and whose Taylor series begin as follows:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s0</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>                                                               <span class="c1"># needs sage.symbolic</span>
<span class="go">1*z + 1*z^2 + 2*z^3 + 5*z^4 + 14*z^5 + Order(z^6)</span>
<span class="gp">sage: </span><span class="n">s1</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>                                                               <span class="c1"># needs sage.symbolic</span>
<span class="go">1 + (-1)*z + (-1)*z^2 + (-2)*z^3 + (-5)*z^4 + (-14)*z^5</span>
<span class="go">+ Order(z^6)</span>
</pre></div>
</div>
<p>The second solution is clearly aberrant, while the first one gives the
expected coefficients. Therefore, we set:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">s0</span>                                                                        <span class="c1"># needs sage.symbolic</span>
</pre></div>
</div>
<p>We can now calculate the next terms:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>                                                               <span class="c1"># needs sage.symbolic</span>
<span class="go">1*z + 1*z^2 + 2*z^3 + 5*z^4 + 14*z^5 + 42*z^6 +</span>
<span class="go">132*z^7 + 429*z^8 + 1430*z^9 + 4862*z^10 + Order(z^11)</span>
</pre></div>
</div>
<p>or calculate, more or less instantaneously, the 100-th coefficient:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span><span class="o">.</span><span class="n">coefficient</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>                                           <span class="c1"># needs sage.symbolic</span>
<span class="go">227508830794229349661819540395688853956041682601541047340</span>
</pre></div>
</div>
<p>It is unfortunate to have to recalculate everything if at some point we
wanted the 101-st coefficient. Lazy power series (see
<a class="reference external" href="../../../power_series/sage/rings/lazy_series_ring.html#module-sage.rings.lazy_series_ring" title="(in Reference Manual v10.2)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.rings.lazy_series_ring</span></code></a>) come into their own here, in that
one can define them from a system of equations without solving it, and,
in particular, without needing a closed form for the answer. We begin by
defining the ring of lazy power series:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span><span class="o">.&lt;</span><span class="n">z</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">LazyPowerSeriesRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we create a “free” power series, which we name, and which we then
define by a recursive equation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">undefined</span><span class="p">(</span><span class="n">valuation</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">z</span> <span class="o">+</span> <span class="n">C</span> <span class="o">*</span> <span class="n">C</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">C</span><span class="o">.</span><span class="n">coefficient</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">)]</span>
<span class="go">[0, 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862]</span>
</pre></div>
</div>
<p>At any point, one can ask for any coefficient without having to redefine
<span class="math notranslate nohighlight">\(C\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">coefficient</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="go">227508830794229349661819540395688853956041682601541047340</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">coefficient</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>
<span class="go">129013158064429114001222907669676675134349530552728882499810851598901419013348319045534580850847735528275750122188940</span>
</pre></div>
</div>
<p>We now return to the closed form of <span class="math notranslate nohighlight">\(C(z)\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>                                                                  <span class="c1"># needs sage.symbolic</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">s0</span><span class="p">;</span> <span class="n">C</span>                                                                     <span class="c1"># needs sage.symbolic</span>
<span class="go">-1/2*sqrt(-4*z + 1) + 1/2</span>
</pre></div>
</div>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th coefficient in the Taylor series for <span class="math notranslate nohighlight">\(C(z)\)</span>
being given by <span class="math notranslate nohighlight">\(\frac{1}{n!} C(z)^{(n)}(0)\)</span>, we look at the
successive derivatives <span class="math notranslate nohighlight">\(C(z)^{(n)}(z)\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">derivative</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>                                                           <span class="c1"># needs sage.symbolic</span>
<span class="go">1/sqrt(-4*z + 1)</span>
<span class="gp">sage: </span><span class="n">derivative</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>                                                           <span class="c1"># needs sage.symbolic</span>
<span class="go">2/(-4*z + 1)^(3/2)</span>
<span class="gp">sage: </span><span class="n">derivative</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>                                                           <span class="c1"># needs sage.symbolic</span>
<span class="go">12/(-4*z + 1)^(5/2)</span>
</pre></div>
</div>
<p>This suggests the existence of a simple explicit formula, which we will
now seek. The following small function returns <span class="math notranslate nohighlight">\(d_n=n! \, c_n\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">d</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="k">return</span> <span class="n">derivative</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Taking successive quotients:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span> <span class="p">(</span><span class="n">d</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">)</span> <span class="p">]</span>                                      <span class="c1"># needs sage.symbolic</span>
<span class="go">[2, 6, 10, 14, 18, 22, 26, 30, 34, 38, 42, 46, 50, 54, 58, 62]</span>
</pre></div>
</div>
<p>we observe that <span class="math notranslate nohighlight">\(d_n\)</span> satisfies the recurrence relation
<span class="math notranslate nohighlight">\(d_{n+1}=(4n-2)d_n\)</span>, from which we deduce that <span class="math notranslate nohighlight">\(c_n\)</span>
satisfies the recurrence relation
<span class="math notranslate nohighlight">\(c_{n+1}=\frac{(4n-2)}{n+1}c_n\)</span>. Simplifying, we find that
<span class="math notranslate nohighlight">\(c_n\)</span> is the <span class="math notranslate nohighlight">\((n-1)\)</span>-th Catalan number:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[c_n = \operatorname{Catalan}(n-1) = \frac {1}{n} \binom{2(n-1)}{n-1}\,.\]</div>
</div>
<p>We check this:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span>                                                                  <span class="c1"># needs sage.symbolic</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="o">*</span><span class="n">binomial</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>                                                 <span class="c1"># needs sage.symbolic</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)]</span>                                           <span class="c1"># needs sage.symbolic</span>
<span class="go">[1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">catalan_number</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)]</span>
<span class="go">[1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862]</span>
</pre></div>
</div>
<p>We can now calculate coefficients much further; here we calculate
<span class="math notranslate nohighlight">\(c_{100000}\)</span> which has more than <span class="math notranslate nohighlight">\(60000\)</span> digits:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cc</span> <span class="o">=</span> <span class="n">c</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">100000</span><span class="p">)</span>                                                              <span class="c1"># needs sage.symbolic</span>
</pre></div>
</div>
<p>This takes a couple of seconds:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="o">%</span><span class="k">time</span> cc = c(100000)                  # not tested                            # needs sage.symbolic
<span class="go">CPU times: user 2.34 s, sys: 0.00 s, total: 2.34 s</span>
<span class="go">Wall time: 2.34 s</span>
<span class="gp">sage: </span><span class="n">ZZ</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span><span class="o">.</span><span class="n">ndigits</span><span class="p">()</span>                                                              <span class="c1"># needs sage.symbolic</span>
<span class="go">60198</span>
</pre></div>
</div>
<p>The methods which we have used generalize to all recursively defined
objects: the system of set-theoretic equations can be translated into a
system of equations on the generating function, which enables the
recursive calculation of its coefficients. If the set-theoretic
equations are simple enough (for example, if they only involve Cartesian
products and disjoint unions), the equation for <span class="math notranslate nohighlight">\(C(z)\)</span> is
algebraic. This equation has, in general, no closed-form solution.
However, using <em>confinement</em>, one can deduce a <em>linear</em> differential
equation which <span class="math notranslate nohighlight">\(C(z)\)</span> satisfies. This differential equation, in
turn, can be translated into a recurrence relation of fixed length on
its coefficients <span class="math notranslate nohighlight">\(c_n\)</span>. In this case, the series is called
<em>D-finite</em>. After the initial calculation of this recurrence relation,
the calculation of coefficients is very fast. All these steps are purely
algorithmic, and it is planned to port into <code class="docutils literal notranslate"><span class="pre">Sage</span></code> the implementations
which exist in <code class="docutils literal notranslate"><span class="pre">Maple</span></code> (the <code class="docutils literal notranslate"><span class="pre">gfun</span></code> and <code class="docutils literal notranslate"><span class="pre">combstruct</span></code> packages) or
<code class="docutils literal notranslate"><span class="pre">MuPAD-Combinat</span></code> (the <code class="docutils literal notranslate"><span class="pre">decomposableObjects</span></code> library).</p>
<p>For the moment, we illustrate this general procedure in the case of
complete binary trees. The generating function <span class="math notranslate nohighlight">\(C(z)\)</span> is a
solution to an algebraic equation <span class="math notranslate nohighlight">\(P(z,C(z)) = 0\)</span>, where
<span class="math notranslate nohighlight">\(P=P(x,y)\)</span> is a polynomial with coefficients in <span class="math notranslate nohighlight">\(\QQ\)</span>.
In the present case, <span class="math notranslate nohighlight">\(P=y^2-y+x\)</span>. We formally differentiate this
equation with respect to <span class="math notranslate nohighlight">\(z\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="c1"># needs sage.symbolic</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;x, y, z&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)(</span><span class="n">z</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">equation</span> <span class="o">=</span>  <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">C</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="gp">sage: </span><span class="n">diff</span><span class="p">(</span><span class="n">equation</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">diff(C(z), z)*D[1](P)(z, C(z)) + D[0](P)(z, C(z)) == 0</span>
</pre></div>
</div>
<p>or, in a more readable format,</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{d C(z)}{d z} \frac{\partial P}{\partial y} (z, C(z)) + \frac{\partial P}{\partial x}(z,C(z)) = 0\]</div>
</div>
<p>From this we deduce:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{d C(z)}{d z} = - \frac{\frac{\partial P}{\partial x}}{\frac{\partial P}{\partial y}}(z, C(z))\,.\]</div>
</div>
<p>In the case of complete binary trees, this gives:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>                                                               <span class="c1"># needs sage.symbolic</span>
<span class="gp">sage: </span><span class="n">Px</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="n">Py</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>                                              <span class="c1"># needs sage.symbolic</span>
<span class="gp">sage: </span><span class="o">-</span> <span class="n">Px</span> <span class="o">/</span> <span class="n">Py</span>                                                                     <span class="c1"># needs sage.symbolic</span>
<span class="go">-1/(2*y - 1)</span>
</pre></div>
</div>
<p>Recall that <span class="math notranslate nohighlight">\(P(z, C(z))=0\)</span>. Thus, we can calculate this fraction
mod <span class="math notranslate nohighlight">\(P\)</span> and, in this way, express the derivative of
<span class="math notranslate nohighlight">\(C(z)\)</span> as a <em>polynomial in</em> <span class="math notranslate nohighlight">\(C(z)\)</span> <em>with coefficients in</em>
<span class="math notranslate nohighlight">\(\QQ(z)\)</span>. In order to achieve this, we construct the quotient
ring <span class="math notranslate nohighlight">\(R= \QQ(x)[y]/ (P)\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Qx</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Qxy</span> <span class="o">=</span> <span class="n">Qx</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">Qxy</span><span class="o">.</span><span class="n">quo</span><span class="p">(</span><span class="n">P</span><span class="p">);</span> <span class="n">R</span>                                                             <span class="c1"># needs sage.symbolic</span>
<span class="go">Univariate Quotient Polynomial Ring in ybar</span>
<span class="go">over Fraction Field of Univariate Polynomial Ring in x</span>
<span class="go">over Rational Field with modulus y^2 - y + x</span>
</pre></div>
</div>
<p>Note: <code class="docutils literal notranslate"><span class="pre">ybar</span></code> is the name of the variable <span class="math notranslate nohighlight">\(y\)</span> in the quotient ring.</p>
<div class="admonition-todo admonition" id="id3">
<p class="admonition-title">Todo</p>
<p>add link to some tutorial on quotient rings</p>
</div>
<p>We continue the calculation of this fraction in <span class="math notranslate nohighlight">\(R\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fraction</span> <span class="o">=</span> <span class="o">-</span> <span class="n">R</span><span class="p">(</span><span class="n">Px</span><span class="p">)</span> <span class="o">/</span> <span class="n">R</span><span class="p">(</span><span class="n">Py</span><span class="p">);</span> <span class="n">fraction</span>                                          <span class="c1"># needs sage.symbolic</span>
<span class="go">(1/2/(x - 1/4))*ybar - 1/4/(x - 1/4)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following variant does not work yet:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fraction</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span> <span class="o">-</span> <span class="n">Px</span> <span class="o">/</span> <span class="n">Py</span> <span class="p">);</span> <span class="n">fraction</span>   <span class="c1"># todo: not implemented</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: denominator must be a unit</span>
</pre></div>
</div>
</div>
<p>We lift the result to <span class="math notranslate nohighlight">\(\QQ(x)[y]\)</span> and then substitute
<span class="math notranslate nohighlight">\(z\)</span> and <span class="math notranslate nohighlight">\(C(z)\)</span> to obtain an expression for
<span class="math notranslate nohighlight">\(\frac{d}{dz}C(z)\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fraction</span> <span class="o">=</span> <span class="n">fraction</span><span class="o">.</span><span class="n">lift</span><span class="p">();</span> <span class="n">fraction</span>                                          <span class="c1"># needs sage.symbolic</span>
<span class="go">(1/2/(x - 1/4))*y - 1/4/(x - 1/4)</span>
<span class="gp">sage: </span><span class="n">fraction</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">C</span><span class="p">)</span>                                                            <span class="c1"># needs sage.symbolic</span>
<span class="go">2*C(z)/(4*z - 1) - 1/(4*z - 1)</span>
</pre></div>
</div>
<p>or, more legibly,</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{\partial C(z)}{\partial z} = \frac{1}{1-4z} -\frac{2}{1-4z}C(z)\,.\]</div>
</div>
<p>In this simple case, we can directly deduce from this expression a
linear differential equation with coefficients in <span class="math notranslate nohighlight">\(\QQ[z]\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="c1"># needs sage.symbolic</span>
<span class="gp">sage: </span><span class="n">equadiff</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="n">fraction</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">C</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">equadiff</span>
<span class="go">diff(C(z), z) == 2*C(z)/(4*z - 1) - 1/(4*z - 1)</span>
<span class="gp">sage: </span><span class="n">equadiff</span> <span class="o">=</span> <span class="n">equadiff</span><span class="o">.</span><span class="n">simplify_rational</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">equadiff</span> <span class="o">=</span> <span class="n">equadiff</span> <span class="o">*</span> <span class="n">equadiff</span><span class="o">.</span><span class="n">rhs</span><span class="p">()</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">equadiff</span> <span class="o">=</span> <span class="n">equadiff</span> <span class="o">-</span> <span class="n">equadiff</span><span class="o">.</span><span class="n">rhs</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">equadiff</span>
<span class="go">(4*z - 1)*diff(C(z), z) - 2*C(z) + 1 == 0</span>
</pre></div>
</div>
<p>or, more legibly,</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[(1-4z) \frac{\partial C(z)}{\partial z} + 2 C(z) - 1 = 0\,.\]</div>
</div>
<p>It is trivial to verify this equation on the closed form:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Cf</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">symbolic</span><span class="o">.</span><span class="n">function_factory</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>                             <span class="c1"># needs sage.symbolic</span>
<span class="gp">sage: </span><span class="n">equadiff</span><span class="o">.</span><span class="n">substitute_function</span><span class="p">(</span><span class="n">Cf</span><span class="p">,</span> <span class="n">s0</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>                              <span class="c1"># needs sage.symbolic</span>
<span class="go">(4*z - 1)/sqrt(-4*z + 1) + sqrt(-4*z + 1) == 0</span>
<span class="gp">sage: </span><span class="nb">bool</span><span class="p">(</span><span class="n">equadiff</span><span class="o">.</span><span class="n">substitute_function</span><span class="p">(</span><span class="n">Cf</span><span class="p">,</span> <span class="n">s0</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">z</span><span class="p">)))</span>                        <span class="c1"># needs sage.symbolic</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In the general case, one continues to calculate successive derivatives
of <span class="math notranslate nohighlight">\(C(z)\)</span>. These derivatives are <em>confined</em> in the quotient ring
<span class="math notranslate nohighlight">\(\QQ(z)[C]/(P)\)</span> which is of finite dimension <span class="math notranslate nohighlight">\(\deg P\)</span>
over <span class="math notranslate nohighlight">\(\QQ(z)\)</span>. Therefore, one will eventually find a linear
relation among the first <span class="math notranslate nohighlight">\(\deg P\)</span> derivatives of <span class="math notranslate nohighlight">\(C(z)\)</span>.
Putting it over a single denominator, we obtain a linear
differential equation of degree <span class="math notranslate nohighlight">\(\leq \deg P\)</span> with coefficients
in <span class="math notranslate nohighlight">\(\QQ[z]\)</span>. By extracting the coefficient of <span class="math notranslate nohighlight">\(z^n\)</span> in
the differential equation, we obtain the desired recurrence relation on
the coefficients; in this case we recover the relation we had already
found, based on the closed form:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[c_{n+1}=\frac{(4n-2)}{n+1}c_n\]</div>
</div>
<p>After fixing the correct initial conditions, it becomes possible to
calculate the coefficients of <span class="math notranslate nohighlight">\(C(z)\)</span> recursively:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">6</span><span class="p">)</span><span class="o">/</span><span class="n">n</span> <span class="o">*</span> <span class="n">C</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span> <span class="n">C</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[1, 1, 1, 2, 5, 14, 42, 132, 429, 1430]</span>
</pre></div>
</div>
<p>If <span class="math notranslate nohighlight">\(n\)</span> is too large for the explicit calculation of
<span class="math notranslate nohighlight">\(c_n\)</span>, a sequence asymptotically equivalent to the sequence of
coefficients <span class="math notranslate nohighlight">\(c_n\)</span> may be sought. Here again, there are generic
techniques. The central tool is complex analysis, specifically, the
study of the generating function around its singularities. In the
present instance, the singularity is at <span class="math notranslate nohighlight">\(z_0=1/4\)</span> and one would
obtain <span class="math notranslate nohighlight">\(c_n \sim \frac{4^n}{n^{3/2}\sqrt{\pi}}\)</span>.</p>
<section id="summary">
<h4>Summary<a class="headerlink" href="#summary" title="Permalink to this heading">#</a></h4>
<p>We see here a general phenomenon of computer algebra: the best <em>data
structure</em> to describe a complicated mathematical object (a real number,
a sequence, a formal power series, a function, a set) is often an
equation defining the object (or a system of equations, typically with
some initial conditions). Attempting to find a closed-form
solution to this equation is not necessarily of interest: on the one
hand, such a closed form rarely exists (e.g., the problem of
solving a polynomial by radicals), and on the other hand, the equation,
in itself, contains all the necessary information to calculate
algorithmically the properties of the object under consideration (e.g.,
a numerical approximation, the initial terms or elements, an asymptotic
equivalent), or to calculate with the object itself (e.g., performing
arithmetic on power series). Therefore, instead of solving the equation,
we look for the equation describing the object which is best suited to
the problem we want to solve.</p>
<p>As we saw in our example, confinement (for example, in a finite
dimensional vector space) is a fundamental tool for studying such
equations. This notion of confinement is widely applicable in
elimination techniques (linear algebra, Gröbner bases, and their
algebro-differential generalizations). The same tool is central in
algorithms for automatic summation and automatic verification of
identities (Gosper’s algorithm, Zeilberger’s algorithm, and their
generalizations; see also <a class="reference internal" href="#exercise-alternating-sign-matrices"><span class="std std-ref">Exercise: alternating sign matrices</span></a>).</p>
<div class="admonition-todo admonition" id="id4">
<p class="admonition-title">Todo</p>
<p>add link to some tutorial on summation</p>
</div>
<p>All these techniques and their many generalizations are at the heart of
very active topics of research: automatic combinatorics and analytic
combinatorics, with major applications in the analysis of algorithms. It is
likely, and desirable, that they will be progressively implemented in
<code class="docutils literal notranslate"><span class="pre">Sage</span></code>.</p>
</section>
</section>
</section>
<section id="common-enumerated-sets">
<span id="section-bricks"></span><h2>Common enumerated sets<a class="headerlink" href="#common-enumerated-sets" title="Permalink to this heading">#</a></h2>
<section id="first-example-the-subsets-of-a-set">
<h3>First example: the subsets of a set<a class="headerlink" href="#first-example-the-subsets-of-a-set" title="Permalink to this heading">#</a></h3>
<p>Fix a set <span class="math notranslate nohighlight">\(E\)</span> of size <span class="math notranslate nohighlight">\(n\)</span> and consider the subsets of
<span class="math notranslate nohighlight">\(E\)</span> of size <span class="math notranslate nohighlight">\(k\)</span>. We know that these subsets are counted
by the binomial coefficients <span class="math notranslate nohighlight">\(\binom n k\)</span>. We can therefore
calculate the number of subsets of size <span class="math notranslate nohighlight">\(k=2\)</span> of
<span class="math notranslate nohighlight">\(E=\{1,2,3,4\}\)</span> with the function <code class="docutils literal notranslate"><span class="pre">binomial</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">binomial</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">6</span>
</pre></div>
</div>
<p>Alternatively, we can <em>construct</em> the set <span class="math notranslate nohighlight">\(\mathcal P_2(E)\)</span> of
all the subsets of size <span class="math notranslate nohighlight">\(2\)</span> of <span class="math notranslate nohighlight">\(E\)</span>, then ask its
cardinality:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<p>Once <code class="docutils literal notranslate"><span class="pre">S</span></code> has been constructed, we can also obtain the list of its
elements:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[{1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4}]</span>
</pre></div>
</div>
<p>or select an element at random:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>                 <span class="c1"># random</span>
<span class="go">{1, 4}</span>
</pre></div>
</div>
<p>More precisely, the object <code class="docutils literal notranslate"><span class="pre">S</span></code> models the set
<span class="math notranslate nohighlight">\(\mathcal P_2(E)\)</span> equipped with a fixed order (here,
lexicographic order). It is therefore possible to ask for its
<span class="math notranslate nohighlight">\(5\)</span>-th element, keeping in mind that, as with <code class="docutils literal notranslate"><span class="pre">Python</span></code> lists, the first
element is numbered zero:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">unrank</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">{2, 4}</span>
</pre></div>
</div>
<p>As a shortcut, in this setting, one can also use the notation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="go">{2, 4}</span>
</pre></div>
</div>
<p>but this should be used with care because some sets have a
natural indexing other than by <span class="math notranslate nohighlight">\((0, 1, \dots)\)</span>.</p>
<p>Conversely, one can calculate the position of an object in this order:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">S</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]);</span> <span class="n">s</span>
<span class="go">{2, 4}</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">S</span></code> is <em>not</em> the list of its elements. One can, for example,
model the set <span class="math notranslate nohighlight">\(\mathcal P(\mathcal P(\mathcal P(E)))\)</span> and
calculate its cardinality (<span class="math notranslate nohighlight">\(2^{2^{2^4}}\)</span>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Subsets</span><span class="p">(</span><span class="n">Subsets</span><span class="p">(</span><span class="n">Subsets</span><span class="p">(</span><span class="n">E</span><span class="p">)));</span> <span class="n">S</span>
<span class="go">Subsets of Subsets of Subsets of {1, 2, 3, 4}</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">cardinality</span><span class="p">();</span> <span class="n">n</span>
<span class="go">2003529930406846464979072351560255750447825475569751419265016973...</span>
</pre></div>
</div>
<p>which is roughly <span class="math notranslate nohighlight">\(2\cdot 10^{19728}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span><span class="o">.</span><span class="n">ndigits</span><span class="p">()</span>
<span class="go">19729</span>
</pre></div>
</div>
<p>or ask for its <span class="math notranslate nohighlight">\(237102124\)</span>-th element:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">unrank</span><span class="p">(</span><span class="mi">237102123</span><span class="p">)</span> <span class="c1"># random print output</span>
<span class="go">{{{2, 4}, {1, 4}, {}, {1, 3, 4}, {1, 2, 4}, {4}, {2, 3}, {1, 3}, {2}},</span>
<span class="go">  {{1, 3}, {2, 4}, {1, 2, 4}, {}, {3, 4}}}</span>
</pre></div>
</div>
<p>It would be physically impossible to construct explicitly all the
elements of <span class="math notranslate nohighlight">\(S\)</span>, as there are many more of them than there are
particles in the universe (estimated at <span class="math notranslate nohighlight">\(10^{82}\)</span>).</p>
<p>Remark: it would be natural in <code class="docutils literal notranslate"><span class="pre">Python</span></code> to use <code class="docutils literal notranslate"><span class="pre">len(S)</span></code> to ask for the
cardinality of <code class="docutils literal notranslate"><span class="pre">S</span></code>. This is not possible because <code class="docutils literal notranslate"><span class="pre">Python</span></code> requires that the
result of <code class="docutils literal notranslate"><span class="pre">len</span></code> be an integer of type <code class="docutils literal notranslate"><span class="pre">int</span></code>; this could cause
overflows, and would not permit the return of {Infinity} for infinite
sets:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">OverflowError: cannot fit &#39;int&#39; into an index-sized integer</span>
</pre></div>
</div>
</section>
<section id="partitions-of-integers">
<h3>Partitions of integers<a class="headerlink" href="#partitions-of-integers" title="Permalink to this heading">#</a></h3>
<p>We now consider another classic problem: given a positive integer
<span class="math notranslate nohighlight">\(n\)</span>, in how many ways can it be written in the form of a sum
<span class="math notranslate nohighlight">\(n=i_1+i_2+\dots+i_\ell\)</span>, where <span class="math notranslate nohighlight">\(i_1,\dots,i_\ell\)</span> are
positive integers? There are two cases to distinguish:</p>
<ul class="simple">
<li><p>the order of the elements in the sum is not important, in which case
we call <span class="math notranslate nohighlight">\((i_1,\dots,i_\ell)\)</span> a <em>partition</em> of <span class="math notranslate nohighlight">\(n\)</span>;</p></li>
<li><p>the order of the elements in the sum is important, in which case we
call <span class="math notranslate nohighlight">\((i_1,\dots,i_\ell)\)</span> a <em>composition</em> of <span class="math notranslate nohighlight">\(n\)</span>.</p></li>
</ul>
<p>We will begin with the partitions of <span class="math notranslate nohighlight">\(n=5\)</span>; as before, we begin
by constructing the set of these partitions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P5</span> <span class="o">=</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="n">P5</span>
<span class="go">Partitions of the integer 5</span>
</pre></div>
</div>
<p>then we ask for its cardinality:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P5</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">7</span>
</pre></div>
</div>
<p>We look at these <span class="math notranslate nohighlight">\(7\)</span> partitions; the order being irrelevant, the
entries are ordered, by convention, in decreasing order.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P5</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[5], [4, 1], [3, 2], [3, 1, 1], [2, 2, 1], [2, 1, 1, 1],</span>
<span class="go"> [1, 1, 1, 1, 1]]</span>
</pre></div>
</div>
<p>The calculation of the number of partitions uses the Rademacher
formula (<a class="reference external" href="https://en.wikipedia.org/wiki/Partition_(number_theory)">Wikipedia article Partition_(number_theory)</a>), implemented in <code class="docutils literal notranslate"><span class="pre">C</span></code>
and highly optimized, which makes it very fast:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Partitions</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">27493510569775696512677516320986352688173429315980054758203125984302147328114964173055050741660736621590157844774296248940493063070200461792764493033510116079342457190155718943509725312466108452006369558934464248716828789832182345009262853831404597021307130674510624419227311238999702284408609370935531629697851569569892196108480158600569421098519</span>
</pre></div>
</div>
<p>Partitions of integers are combinatorial objects naturally equipped with
many operations. They are therefore returned as objects that are
richer than simple lists:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P7</span> <span class="o">=</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">P7</span><span class="o">.</span><span class="n">unrank</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="n">p</span>
<span class="go">[4, 2, 1]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.combinat.partition.Partitions_n_with_category.element_class&#39;&gt;</span>
</pre></div>
</div>
<p>For example, they can be represented graphically by a Ferrers diagram:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">ferrers_diagram</span><span class="p">())</span>
<span class="go">****</span>
<span class="go">**</span>
<span class="go">*</span>
</pre></div>
</div>
<p>We leave it to the user to explore by introspection the available
operations.</p>
<p>Note that we can also construct a partition directly by:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Partition</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[4, 2, 1]</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P7</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[4, 2, 1]</span>
</pre></div>
</div>
<p>If one wants to restrict the possible values of the parts
<span class="math notranslate nohighlight">\(i_1,\dots,i_\ell\)</span> of the partition as, for example, when giving
change, one can use <code class="docutils literal notranslate"><span class="pre">WeightedIntegerVectors</span></code>. For example, the
following calculation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">WeightedIntegerVectors</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[0, 1, 1], [1, 2, 0], [4, 0, 0]]</span>
</pre></div>
</div>
<p>shows that to make 8 dollars using 2, 3, and 5 dollar bills, one can
use a 3 and a 5 dollar bill, or a 2 and two 3 dollar bills, or four 2
dollar bills.</p>
<p>Compositions of integers are manipulated the same way:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C5</span> <span class="o">=</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="n">C5</span>
<span class="go">Compositions of 5</span>
<span class="gp">sage: </span><span class="n">C5</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">16</span>
<span class="gp">sage: </span><span class="n">C5</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 1, 2, 1], [1, 1, 3],</span>
<span class="go"> [1, 2, 1, 1], [1, 2, 2], [1, 3, 1], [1, 4], [2, 1, 1, 1],</span>
<span class="go"> [2, 1, 2], [2, 2, 1], [2, 3], [3, 1, 1], [3, 2], [4, 1], [5]]</span>
</pre></div>
</div>
<p>The number <span class="math notranslate nohighlight">\(16\)</span> above seems significant and suggests the existence of a
formula. We look at the number of compositions of <span class="math notranslate nohighlight">\(n\)</span> ranging
from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(9\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">Compositions</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[1, 1, 2, 4, 8, 16, 32, 64, 128, 256]</span>
</pre></div>
</div>
<p>Similarly, if we consider the number of compositions of <span class="math notranslate nohighlight">\(5\)</span> by
length, we find a line of Pascal’s triangle:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>                                                                  <span class="c1"># needs sage.symbolic</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">C5</span><span class="p">)</span>                                                     <span class="c1"># needs sage.symbolic</span>
<span class="go">x^5 + 4*x^4 + 6*x^3 + 4*x^2 + x</span>
</pre></div>
</div>
<p>The above example uses a functionality which we have not seen yet:
<code class="docutils literal notranslate"><span class="pre">C5</span></code> being iterable, it can be used like a list in a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop or
a comprehension (<a class="reference internal" href="#section-bricks-iterators"><span class="std std-ref">Set comprehension and iterators</span></a>).</p>
<blockquote>
<div><p>Prove the formulas suggested by the above examples for the number of
compositions of <span class="math notranslate nohighlight">\(n\)</span> and the number of compositions of
<span class="math notranslate nohighlight">\(n\)</span> of length <span class="math notranslate nohighlight">\(k\)</span>; investigate by introspection
whether <code class="docutils literal notranslate"><span class="pre">Sage</span></code> uses these formulas for calculating cardinalities.</p>
</div></blockquote>
</section>
<section id="some-other-finite-enumerated-sets">
<span id="section-bricks-divers"></span><h3>Some other finite enumerated sets<a class="headerlink" href="#some-other-finite-enumerated-sets" title="Permalink to this heading">#</a></h3>
<p>Essentially, the principle is the same for all the finite sets with
which one wants to do combinatorics in <code class="docutils literal notranslate"><span class="pre">Sage</span></code>; begin by constructing
an object which models this set, and then supply appropriate methods,
following a uniform interface <a class="footnote-reference brackets" href="#id9" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. We now give a few more typical
examples.</p>
<p>Intervals of integers:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">IntegerRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="n">C</span>
<span class="go">{3, 5, ..., 19}</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">9</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[3, 5, 7, 9, 11, 13, 15, 17, 19]</span>
</pre></div>
</div>
<p>Permutations:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Permutations</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">C</span>
<span class="go">Standard permutations of 4</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">24</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[1, 2, 3, 4], [1, 2, 4, 3], [1, 3, 2, 4], [1, 3, 4, 2],</span>
<span class="go"> [1, 4, 2, 3], [1, 4, 3, 2], [2, 1, 3, 4], [2, 1, 4, 3],</span>
<span class="go"> [2, 3, 1, 4], [2, 3, 4, 1], [2, 4, 1, 3], [2, 4, 3, 1],</span>
<span class="go"> [3, 1, 2, 4], [3, 1, 4, 2], [3, 2, 1, 4], [3, 2, 4, 1],</span>
<span class="go"> [3, 4, 1, 2], [3, 4, 2, 1], [4, 1, 2, 3], [4, 1, 3, 2],</span>
<span class="go"> [4, 2, 1, 3], [4, 2, 3, 1], [4, 3, 1, 2], [4, 3, 2, 1]]</span>
</pre></div>
</div>
<p>Set partitions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">SetPartitions</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="c1"># random print output</span>
<span class="go">Set partitions of {&#39;a&#39;, &#39;c&#39;, &#39;b&#39;}</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[{{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}},</span>
<span class="go"> {{&#39;a&#39;, &#39;b&#39;}, {&#39;c&#39;}},</span>
<span class="go"> {{&#39;a&#39;, &#39;c&#39;}, {&#39;b&#39;}},</span>
<span class="go"> {{&#39;a&#39;}, {&#39;b&#39;, &#39;c&#39;}},</span>
<span class="go"> {{&#39;a&#39;}, {&#39;b&#39;}, {&#39;c&#39;}}]</span>
</pre></div>
</div>
<p>Partial orders on a set of <span class="math notranslate nohighlight">\(8\)</span> elements, up to isomorphism:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span> <span class="n">C</span>
<span class="go">Posets containing 8 elements</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">16999</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">unrank</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Graphics object consisting of 20 graphics primitives</span>
</pre></div>
</div>
<img alt="../../_images/a_poset.png" src="../../_images/a_poset.png" />
<p>One can iterate through all graphs up to isomorphism. For example,
there are 34 simple graphs with 5 vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">graphs</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="go">34</span>
</pre></div>
</div>
<p>Here are those with at most <span class="math notranslate nohighlight">\(4\)</span> edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">up_to_four_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graphs</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">G</span><span class="p">:</span> <span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">pretty_print</span><span class="p">(</span><span class="o">*</span><span class="n">up_to_four_edges</span><span class="p">)</span>
</pre></div>
</div>
<img alt="../../_images/graphs-5.png" src="../../_images/graphs-5.png" />
<p>However, the <em>set</em> <code class="docutils literal notranslate"><span class="pre">C</span></code> of these graphs is not yet available in
<code class="docutils literal notranslate"><span class="pre">Sage</span></code>; as a result, the following commands are not yet
implemented:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="c1"># not implemented</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graphs</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">34</span>
<span class="gp">sage: </span><span class="n">Graphs</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">24637809253125004524383007491432768</span>
<span class="gp">sage: </span><span class="n">Graphs</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="go">Graph on 19 vertices</span>
</pre></div>
</div>
<p>What we have seen so far also applies, in principle, to finite algebraic
structures like the dihedral groups:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DihedralGroup</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Dihedral group of order 8 as a permutation group</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">8</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[(), (1,3)(2,4), (1,4,3,2), (1,2,3,4), (2,4), (1,3), (1,4)(2,3), (1,2)(3,4)]</span>
</pre></div>
</div>
<p>or the algebra of <span class="math notranslate nohighlight">\(2\times 2\)</span> matrices over the finite field
<span class="math notranslate nohighlight">\(\ZZ/2\ZZ\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">MatrixSpace</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>                                                     <span class="c1"># needs sage.modules sage.rings.finite_rings</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>                                                                      <span class="c1"># needs sage.modules sage.rings.finite_rings</span>
<span class="go">[</span>
<span class="go">[0 0]  [1 0]  [0 1]  [0 0]  [0 0]  [1 1]  [1 0]  [1 0]  [0 1]  [0 1]</span>
<span class="go">[0 0], [0 0], [0 0], [1 0], [0 1], [0 0], [1 0], [0 1], [1 0], [0 1],</span>

<span class="go">[0 0]  [1 1]  [1 1]  [1 0]  [0 1]  [1 1]</span>
<span class="go">[1 1], [1 0], [0 1], [1 1], [1 1], [1 1]</span>
<span class="go">]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>                                                               <span class="c1"># needs sage.modules sage.rings.finite_rings</span>
<span class="go">16</span>
</pre></div>
</div>
<aside class="topic">
<p class="topic-title">Exercise</p>
<p>List all the monomials of degree <span class="math notranslate nohighlight">\(5\)</span> in three variables (see
<code class="docutils literal notranslate"><span class="pre">IntegerVectors</span></code>). Manipulate the ordered set partitions
<code class="docutils literal notranslate"><span class="pre">OrderedSetPartitions</span></code> and standard tableaux
(<code class="docutils literal notranslate"><span class="pre">StandardTableaux</span></code>).</p>
</aside>
<aside class="topic" id="exercise-alternating-sign-matrices">
<p class="topic-title">Exercise</p>
<p>List the alternating sign matrices of size <span class="math notranslate nohighlight">\(3\)</span>, <span class="math notranslate nohighlight">\(4\)</span>,
and <span class="math notranslate nohighlight">\(5\)</span> (<code class="docutils literal notranslate"><span class="pre">AlternatingSignMatrices</span></code>), and try to guess the
definition. The discovery and proof of the formula for the
enumeration of these matrices (see the method <code class="docutils literal notranslate"><span class="pre">cardinality</span></code>),
motivated by calculations of determinants in physics, is quite a
story. In particular, the first proof, given by Zeilberger in 1992
was automatically produced by a computer program.  It was 84 pages long,
and required nearly a hundred people to verify it.</p>
</aside>
<aside class="topic">
<p class="topic-title">Exercise</p>
<p>Calculate by hand the number of vectors in <span class="math notranslate nohighlight">\((\ZZ/2\ZZ)^5\)</span>, and
the number of matrices in <span class="math notranslate nohighlight">\(GL_3(\ZZ/2\ZZ)\)</span> (that is to say,
the number of invertible <span class="math notranslate nohighlight">\(3\times 3\)</span> matrices with
coefficients in <span class="math notranslate nohighlight">\(\ZZ/2\ZZ\)</span>). Verify your answer with <code class="docutils literal notranslate"><span class="pre">Sage</span></code>.
Generalize to <span class="math notranslate nohighlight">\(GL_n(\ZZ/q\ZZ)\)</span>.</p>
</aside>
</section>
<section id="set-comprehension-and-iterators">
<span id="section-bricks-iterators"></span><h3>Set comprehension and iterators<a class="headerlink" href="#set-comprehension-and-iterators" title="Permalink to this heading">#</a></h3>
<p>We will now show some of the possibilities offered by <code class="docutils literal notranslate"><span class="pre">Python</span></code> for
constructing (and iterating through) sets, with a notation that is
flexible and close to usual mathematical usage, and in particular the
benefits this yields in combinatorics.</p>
<p>We begin by constructing the finite set
<span class="math notranslate nohighlight">\(\{i^2\ \|\ i \in \{1,3,7\}\}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span> <span class="n">i</span><span class="o">^</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span> <span class="p">]</span>
<span class="go">[1, 9, 49]</span>
</pre></div>
</div>
<p>and then the same set, but with <span class="math notranslate nohighlight">\(i\)</span> running from <span class="math notranslate nohighlight">\(1\)</span> to
<span class="math notranslate nohighlight">\(9\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span> <span class="n">i</span><span class="o">^</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span>
</pre></div>
</div>
<p>A construction of this form in <code class="docutils literal notranslate"><span class="pre">Python</span></code> is called <em>set comprehension</em>.
A clause can be added to keep only those elements with <span class="math notranslate nohighlight">\(i\)</span> prime:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span> <span class="n">i</span><span class="o">^</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[4, 9, 25, 49]</span>
</pre></div>
</div>
<p>Combining more than one set comprehension, it is possible to construct
the set <span class="math notranslate nohighlight">\(\{(i,j) \ | \ 1\leq j &lt; i &lt;5\}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[(2, 1), (3, 1), (3, 2), (4, 1), (4, 2), (4, 3),</span>
<span class="go"> (5, 1), (5, 2), (5, 3), (5, 4)]</span>
</pre></div>
</div>
<p>or to produce Pascal’s triangle:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[[</span><span class="n">binomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[[1],</span>
<span class="go"> [1, 1],</span>
<span class="go"> [1, 2, 1],</span>
<span class="go"> [1, 3, 3, 1],</span>
<span class="go"> [1, 4, 6, 4, 1],</span>
<span class="go"> [1, 5, 10, 10, 5, 1],</span>
<span class="go"> [1, 6, 15, 20, 15, 6, 1],</span>
<span class="go"> [1, 7, 21, 35, 35, 21, 7, 1],</span>
<span class="go"> [1, 8, 28, 56, 70, 56, 28, 8, 1],</span>
<span class="go"> [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]]</span>
</pre></div>
</div>
<p>The execution of a set comprehension is accomplished in two steps; first
an <em>iterator</em> is constructed, and then a list is filled with the
elements successively produced by the iterator. Technically, an
<em>iterator</em> is an object with a method <code class="docutils literal notranslate"><span class="pre">next</span></code> which returns a new value
each time it is called, until it is exhausted. For example, the
following iterator <code class="docutils literal notranslate"><span class="pre">it</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="p">(</span><span class="n">binomial</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p>returns successively the binomial coefficients <span class="math notranslate nohighlight">\(\binom 3 i\)</span> with
<span class="math notranslate nohighlight">\(i=0,1,2,3\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>When the iterator is finally exhausted, an exception is raised:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">  ...</span>
<span class="go">StopIteration</span>
</pre></div>
</div>
<p>More generally, an <em>iterable</em> is a <code class="docutils literal notranslate"><span class="pre">Python</span></code> object <code class="docutils literal notranslate"><span class="pre">L</span></code> (a list,
a set, …) over whose elements it is possible to iterate. Technically,
the iterator is constructed by <code class="docutils literal notranslate"><span class="pre">iter(L)</span></code>. In practice, the commands
<code class="docutils literal notranslate"><span class="pre">iter</span></code> and <code class="docutils literal notranslate"><span class="pre">next</span></code> are used very rarely, since <code class="docutils literal notranslate"><span class="pre">for</span></code> loops and list
comprehensions provide a much pleasanter syntax:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">{}</span>
<span class="go">{1}</span>
<span class="go">{2}</span>
<span class="go">{3}</span>
<span class="go">{1, 2}</span>
<span class="go">{1, 3}</span>
<span class="go">{2, 3}</span>
<span class="go">{1, 2, 3}</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span> <span class="n">s</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[0, 1, 1, 1, 2, 2, 2, 3]</span>
</pre></div>
</div>
<p>What is the point of an iterator? Consider the following example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span> <span class="p">[</span> <span class="n">binomial</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="p">]</span> <span class="p">)</span>
<span class="go">256</span>
</pre></div>
</div>
<p>When it is executed, a list of <span class="math notranslate nohighlight">\(9\)</span> elements is constructed, and
then it is passed as an argument to <code class="docutils literal notranslate"><span class="pre">sum</span></code> to add them up. If, on the
other hand, the iterator is passed directly to <code class="docutils literal notranslate"><span class="pre">sum</span></code> (note the absence
of square brackets):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span> <span class="n">binomial</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="p">)</span>
<span class="go">256</span>
</pre></div>
</div>
<p>the function <code class="docutils literal notranslate"><span class="pre">sum</span></code> receives the iterator directly, and can
short-circuit the construction of the intermediate list. If there are a
large number of elements, this avoids allocating a large quantity of
memory to fill a list which will be immediately destroyed.</p>
<p>Most functions that take a list of elements as input will also accept
an iterator (or an iterable) instead. To begin with, one can obtain the
list (or the tuple) of elements of an iterator as follows:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">binomial</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="go">[1, 8, 28, 56, 70, 56, 28, 8, 1]</span>
<span class="gp">sage: </span><span class="nb">tuple</span><span class="p">(</span><span class="n">binomial</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="go">(1, 8, 28, 56, 70, 56, 28, 8, 1)</span>
</pre></div>
</div>
<p>We now consider the functions <code class="docutils literal notranslate"><span class="pre">all</span></code> and <code class="docutils literal notranslate"><span class="pre">any</span></code> which denote
respectively the <span class="math notranslate nohighlight">\(n\)</span>-ary <em>and</em> and <em>or</em>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">any</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">any</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The following example verifies that all primes from <span class="math notranslate nohighlight">\(3\)</span> to
<span class="math notranslate nohighlight">\(99\)</span> are odd:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">is_odd</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A <em>Mersenne prime</em> is a prime of the form <span class="math notranslate nohighlight">\(2^p -1\)</span>. We verify
that, for <span class="math notranslate nohighlight">\(p&lt;1000\)</span>, if <span class="math notranslate nohighlight">\(2^p-1\)</span> is prime, then
<span class="math notranslate nohighlight">\(p\)</span> is also prime:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">mersenne</span><span class="p">(</span><span class="n">p</span><span class="p">):</span> <span class="k">return</span> <span class="mi">2</span><span class="o">^</span><span class="n">p</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">sage: </span><span class="p">[</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gp">....: </span>  <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">mersenne</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">]</span>
<span class="go">[True, True, True, True, True, True, True, True, True, True,</span>
<span class="go"> True, True, True, True]</span>
</pre></div>
</div>
<p>Is the converse true?</p>
<aside class="topic">
<p class="topic-title">Exercise</p>
<p>Try the two following commands and explain the considerable
difference in the length of the calculations:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span>   <span class="n">is_prime</span><span class="p">(</span><span class="n">mersenne</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="gp">....: </span>       <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>  <span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="p">[</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">mersenne</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="gp">....: </span>       <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</aside>
<p>We now try to find the smallest counter-example. In order to do this, we
use the <code class="docutils literal notranslate"><span class="pre">Sage</span></code> function <code class="docutils literal notranslate"><span class="pre">exists</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">exists</span><span class="p">(</span> <span class="p">(</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">p</span><span class="p">)),</span>
<span class="gp">....: </span>        <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="ow">not</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">mersenne</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">)</span>
<span class="go">(True, 11)</span>
</pre></div>
</div>
<p>Alternatively, we could construct an iterator on the counter-examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">counter_examples</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">if</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">mersenne</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">counter_examples</span><span class="p">)</span>
<span class="go">11</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">counter_examples</span><span class="p">)</span>
<span class="go">23</span>
</pre></div>
</div>
<aside class="topic">
<p class="topic-title">Exercise</p>
<p>What do the following commands do?</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cubes</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">999</span><span class="p">,</span><span class="mi">1000</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">exists</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cubes</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">cubes</span><span class="p">],</span>  <span class="c1"># long time (3s, 2012)</span>
<span class="gp">....: </span>       <span class="k">lambda</span> <span class="n">x_y</span><span class="p">:</span> <span class="n">x_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">218</span><span class="p">)</span>
<span class="go">(True, (-125, 343))</span>
<span class="gp">sage: </span><span class="n">exists</span><span class="p">(((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cubes</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">cubes</span><span class="p">),</span>  <span class="c1"># long time (2s, 2012)</span>
<span class="gp">....: </span>       <span class="k">lambda</span> <span class="n">x_y</span><span class="p">:</span> <span class="n">x_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">218</span><span class="p">)</span>
<span class="go">(True, (-125, 343))</span>
</pre></div>
</div>
<p>Which of the last two is more economical in terms of time? In terms
of memory? By how much?</p>
</aside>
<aside class="topic">
<p class="topic-title">Exercise</p>
<p>Try each of the following commands, and explain its result. If
possible, hide the result first and try to guess it before
launching the command.</p>
<div class="admonition-todo admonition" id="id6">
<p class="admonition-title">Todo</p>
<p>hide the results by default</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>it will be necessary to interrupt the execution of some of the commands</p>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>                                                              <span class="c1"># needs sage.symbolic</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>                                         <span class="c1"># needs sage.symbolic</span>
<span class="go">x^8 + 8*x^7 + 28*x^6 + 56*x^5 + 70*x^4 + 56*x^3 + 28*x^2 + 8*x + 1</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="n">p</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Permutations</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>                                <span class="c1"># needs sage.symbolic</span>
<span class="go">x^3 + 2*x^2 + 2*x + 1</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">factor</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="n">p</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Permutations</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span>                        <span class="c1"># needs sage.symbolic</span>
<span class="go">(x^2 + x + 1)*(x + 1)</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Permutations</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">p</span> <span class="ow">in</span> <span class="n">P</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">GL</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="go">[1 0]</span>
<span class="go">[0 1]</span>

<span class="go">[0 1]</span>
<span class="go">[1 0]</span>

<span class="go">[0 1]</span>
<span class="go">[1 1]</span>

<span class="go">[1 1]</span>
<span class="go">[0 1]</span>

<span class="go">[1 1]</span>
<span class="go">[1 0]</span>

<span class="go">[1 0]</span>
<span class="go">[1 1]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>   <span class="c1"># not tested</span>
<span class="go">[3]</span>
<span class="go">[2, 1]</span>
<span class="go">[1, 1, 1]</span>
<span class="go">...</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">():</span> <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>    <span class="c1"># not tested</span>
<span class="go">[]</span>
<span class="go">[1]</span>
<span class="go">[2]</span>
<span class="go">[1, 1]</span>
<span class="go">[3]</span>
<span class="go">...</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Primes</span><span class="p">():</span> <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>        <span class="c1"># not tested</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">5</span>
<span class="go">7</span>
<span class="go">...</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">exists</span><span class="p">(</span> <span class="n">Primes</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="ow">not</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">mersenne</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">)</span>
<span class="go">(True, 11)</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">counter_examples</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Primes</span><span class="p">()</span>
<span class="gp">....: </span>                   <span class="k">if</span> <span class="ow">not</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">mersenne</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">counter_examples</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>   <span class="c1"># not tested</span>
<span class="go">11</span>
<span class="go">23</span>
<span class="go">29</span>
<span class="go">37</span>
<span class="go">41</span>
<span class="go">43</span>
<span class="go">47</span>
<span class="go">...</span>
</pre></div>
</div>
</aside>
<section id="operations-on-iterators">
<h4>Operations on iterators<a class="headerlink" href="#operations-on-iterators" title="Permalink to this heading">#</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">Python</span></code> provides numerous tools for manipulating iterators; most of them
are in the <a class="reference external" href="https://docs.python.org/library/itertools.html#module-itertools" title="(in Python v3.11)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a> library, which can be imported by:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">itertools</span>
</pre></div>
</div>
<p>We will demonstrate some applications, taking as a starting point the
permutations of <span class="math notranslate nohighlight">\(3\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Permutations</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">[[1, 2, 3], [1, 3, 2], [2, 1, 3],</span>
<span class="go"> [2, 3, 1], [3, 1, 2], [3, 2, 1]]</span>
</pre></div>
</div>
<p>We can list the elements of a set by numbering them:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">Permutations</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span>
<span class="go">[(0, [1, 2, 3]), (1, [1, 3, 2]), (2, [2, 1, 3]),</span>
<span class="go"> (3, [2, 3, 1]), (4, [3, 1, 2]), (5, [3, 2, 1])]</span>
</pre></div>
</div>
<p>or select only the elements in positions 2, 3, and 4 (analogue of
<code class="docutils literal notranslate"><span class="pre">l[1:4]</span></code>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">itertools</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">Permutations</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>
<span class="go">[[1, 3, 2], [2, 1, 3], [2, 3, 1]]</span>
</pre></div>
</div>
<p>To apply a function to all the elements, one can do:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">z</span><span class="o">.</span><span class="n">cycle_type</span><span class="p">()</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">Permutations</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="go">[[1, 1, 1], [2, 1], [2, 1], [3], [3], [2, 1]]</span>
</pre></div>
</div>
<p>and similarly to select the elements satisfying a certain condition:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">z</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">Permutations</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">has_pattern</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])]</span>
<span class="go">[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2]]</span>
</pre></div>
</div>
</section>
<section id="implementation-of-new-iterators">
<h4>Implementation of new iterators<a class="headerlink" href="#implementation-of-new-iterators" title="Permalink to this heading">#</a></h4>
<p>It is easy to construct new iterators, using the keyword <code class="docutils literal notranslate"><span class="pre">yield</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">return</span></code> in a function:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">yield</span> <span class="n">i</span>
</pre></div>
</div>
<p>After the <code class="docutils literal notranslate"><span class="pre">yield</span></code>, execution is not halted, but only suspended, ready
to be continued from the same point. The result of the function is
therefore an iterator over the successive values returned by <code class="docutils literal notranslate"><span class="pre">yield</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">  ...</span>
<span class="go">StopIteration</span>
</pre></div>
</div>
<p>The function could be used as follows:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[0, 1, 2, 3, 4]</span>
</pre></div>
</div>
<p>This model of computation, called <em>continuation</em>, is very useful in
combinatorics, especially when combined with recursion. Here is how to
generate all words of a given length on a given alphabet:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">words</span><span class="p">(</span><span class="n">alphabet</span><span class="p">,</span><span class="n">l</span><span class="p">):</span>
<span class="gp">....: </span>   <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">....: </span>       <span class="k">yield</span> <span class="p">[]</span>
<span class="gp">....: </span>   <span class="k">else</span><span class="p">:</span>
<span class="gp">....: </span>       <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">(</span><span class="n">alphabet</span><span class="p">,</span> <span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">....: </span>           <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">alphabet</span><span class="p">:</span>
<span class="gp">....: </span>               <span class="k">yield</span> <span class="n">word</span> <span class="o">+</span> <span class="p">[</span><span class="n">l</span><span class="p">]</span>
<span class="gp">sage: </span><span class="p">[</span> <span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">words</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;], [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;], [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;],</span>
<span class="go"> [&#39;a&#39;, &#39;b&#39;, &#39;b&#39;], [&#39;b&#39;, &#39;a&#39;, &#39;a&#39;], [&#39;b&#39;, &#39;a&#39;, &#39;b&#39;],</span>
<span class="go"> [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;], [&#39;b&#39;, &#39;b&#39;, &#39;b&#39;]]</span>
</pre></div>
</div>
<p>These words can then be counted by:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">words</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="mi">10</span><span class="p">))</span>
<span class="go">1048576</span>
</pre></div>
</div>
<p>Counting the words one by one is clearly not an efficient method in this
case, since the formula <span class="math notranslate nohighlight">\(n^\ell\)</span> is also available; note,
though, that this is not the stupidest possible approach - it does, at
least, avoid constructing the entire list in memory.</p>
<p>We now consider Dyck words, which are well-parenthesized words in the
letters “<span class="math notranslate nohighlight">\((\)</span>” and “<span class="math notranslate nohighlight">\()\)</span>”. The function below generates
all the Dyck words of a given length (where the length is the number of
pairs of parentheses), using the recursive definition which says that a
Dyck word is either empty or of the form <span class="math notranslate nohighlight">\((w_1)w_2\)</span> where
<span class="math notranslate nohighlight">\(w_1\)</span> and <span class="math notranslate nohighlight">\(w_2\)</span> are Dyck words:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">dyck_words</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="n">l</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">yield</span> <span class="s1">&#39;&#39;</span>
<span class="gp">....: </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="k">for</span> <span class="n">w1</span> <span class="ow">in</span> <span class="n">dyck_words</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
<span class="gp">....: </span>                <span class="k">for</span> <span class="n">w2</span> <span class="ow">in</span> <span class="n">dyck_words</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">....: </span>                    <span class="k">yield</span> <span class="s1">&#39;(&#39;</span><span class="o">+</span><span class="n">w1</span><span class="o">+</span><span class="s1">&#39;)&#39;</span><span class="o">+</span><span class="n">w2</span>
</pre></div>
</div>
<p>Here are all the Dyck words of length <span class="math notranslate nohighlight">\(4\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">dyck_words</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">[&#39;()()()()&#39;, &#39;()()(())&#39;, &#39;()(())()&#39;, &#39;()(()())&#39;, &#39;()((()))&#39;,</span>
<span class="go"> &#39;(())()()&#39;, &#39;(())(())&#39;, &#39;(()())()&#39;, &#39;((()))()&#39;, &#39;(()()())&#39;,</span>
<span class="go"> &#39;(()(()))&#39;, &#39;((())())&#39;, &#39;((()()))&#39;, &#39;(((())))&#39;]</span>
</pre></div>
</div>
<p>Counting them, we recover a well-known sequence:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">dyck_words</span><span class="p">(</span><span class="n">l</span><span class="p">))</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862]</span>
</pre></div>
</div>
<aside class="topic" id="exo-iterators-catalan">
<p class="topic-title">Exercise: complete binary tree iterator</p>
<p>Construct an iterator on the set <span class="math notranslate nohighlight">\(C_n\)</span> of complete binary
trees with <span class="math notranslate nohighlight">\(n\)</span> leaves
(see <a class="reference internal" href="#section-examples-catalan"><span class="std std-ref">Enumeration of trees using generating functions</span></a>).</p>
<p>Hint: <code class="docutils literal notranslate"><span class="pre">Sage</span></code> 4.8.2 does not yet have a native data structure to
represent complete binary trees. One simple way to represent them is
to define a formal variable <code class="docutils literal notranslate"><span class="pre">Leaf</span></code> for the leaves and a formal
2-ary function <code class="docutils literal notranslate"><span class="pre">Node</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;Leaf&#39;</span><span class="p">)</span>                                                               <span class="c1"># needs sage.symbolic</span>
<span class="go">Leaf</span>
<span class="gp">sage: </span><span class="n">function</span><span class="p">(</span><span class="s1">&#39;Node&#39;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>                                                 <span class="c1"># needs sage.symbolic</span>
<span class="go">Node</span>
</pre></div>
</div>
<p>The second tree in <a class="reference internal" href="#figure-examples-catalan-trees"><span class="std std-ref">Figure: The five complete binary trees with four leaves</span></a>
can be represented by the expression:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">tr</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">Leaf</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="n">Leaf</span><span class="p">,</span> <span class="n">Leaf</span><span class="p">)),</span> <span class="n">Leaf</span><span class="p">)</span>                             <span class="c1"># needs sage.symbolic</span>
</pre></div>
</div>
</aside>
</section>
</section>
</section>
<section id="constructions">
<span id="section-constructions"></span><h2>Constructions<a class="headerlink" href="#constructions" title="Permalink to this heading">#</a></h2>
<p>We will now see how to construct new sets starting from these building
blocks. In fact, we have already begun to do this with the construction
of <span class="math notranslate nohighlight">\(\mathcal P(\mathcal P(\mathcal P(\{1,2,3,4\})))\)</span> in the
previous section, and to construct the example of sets of cards in
<a class="reference internal" href="#section-examples"><span class="std std-ref">Initial examples</span></a>.</p>
<p>Consider a large Cartesian product:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">cartesian_product</span><span class="p">([</span><span class="n">Compositions</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">Permutations</span><span class="p">(</span><span class="mi">20</span><span class="p">)]);</span> <span class="n">C</span>
<span class="go">The Cartesian product of (Compositions of 8, Standard permutations of 20)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">311411457046609920000</span>
</pre></div>
</div>
<p>Clearly, it is impractical to construct the list of all the elements of this
Cartesian product! And, in the following example, <span class="math notranslate nohighlight">\(H\)</span> is equipped with the
usual combinatorial operations and also its structure as a product group:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DihedralGroup</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">cartesian_product</span><span class="p">([</span><span class="n">G</span><span class="p">,</span><span class="n">G</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="ow">in</span> <span class="n">Groups</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">((1,3), (1,3))</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">H</span><span class="p">([</span><span class="n">G</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">G</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">t</span>
<span class="go">((1,2,3,4), (1,2,3,4))</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">*</span><span class="n">t</span>
<span class="go">((1,3)(2,4), (1,3)(2,4))</span>
</pre></div>
</div>
<p>We now construct the union of two existing disjoint sets:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">DisjointUnionEnumeratedSets</span><span class="p">(</span>
<span class="gp">....: </span>      <span class="p">[</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">Permutations</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">Disjoint union of Family (Compositions of 4,</span>
<span class="go">Standard permutations of 3)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">14</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2],</span>
<span class="go">[3, 1], [4], [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1],</span>
<span class="go">[3, 1, 2], [3, 2, 1]]</span>
</pre></div>
</div>
<p>It is also possible to take the union of more than two disjoint sets, or
even an infinite number of them. We will now construct the set of all
permutations, viewed as the union of the sets <span class="math notranslate nohighlight">\(P_n\)</span> of
permutations of size <span class="math notranslate nohighlight">\(n\)</span>. We begin by constructing the infinite
family <span class="math notranslate nohighlight">\(F=(P_n)_{n\in N}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Family</span><span class="p">(</span><span class="n">NonNegativeIntegers</span><span class="p">(),</span> <span class="n">Permutations</span><span class="p">);</span> <span class="n">F</span>
<span class="go">Lazy family (&lt;class &#39;sage.combinat.permutation.Permutations&#39;&gt;(i))_{i in Non negative integers}</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">Non negative integers</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">1000</span><span class="p">]</span>
<span class="go">Standard permutations of 1000</span>
</pre></div>
</div>
<p>Now we can construct the disjoint union <span class="math notranslate nohighlight">\(\bigcup_{n\in \NN}P_n\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">U</span> <span class="o">=</span> <span class="n">DisjointUnionEnumeratedSets</span><span class="p">(</span><span class="n">F</span><span class="p">);</span> <span class="n">U</span>
<span class="go">Disjoint union of</span>
<span class="go">Lazy family (&lt;class &#39;sage.combinat.permutation.Permutations&#39;&gt;(i))_{i in Non negative integers}</span>
</pre></div>
</div>
<p>It is an infinite set:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">U</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">+Infinity</span>
</pre></div>
</div>
<p>which doesn’t prohibit iteration through its elements, though it will be
necessary to interrupt it at some point:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">U</span><span class="p">:</span>                <span class="c1"># not tested</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">[]</span>
<span class="go">[1]</span>
<span class="go">[1, 2]</span>
<span class="go">[2, 1]</span>
<span class="go">[1, 2, 3]</span>
<span class="go">[1, 3, 2]</span>
<span class="go">[2, 1, 3]</span>
<span class="go">[2, 3, 1]</span>
<span class="go">[3, 1, 2]</span>
<span class="go">...</span>
</pre></div>
</div>
<p>Note: the above set could also have been constructed directly with:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">U</span> <span class="o">=</span> <span class="n">Permutations</span><span class="p">();</span> <span class="n">U</span>
<span class="go">Standard permutations</span>
</pre></div>
</div>
<section id="id7">
<h3>Summary<a class="headerlink" href="#id7" title="Permalink to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Sage</span></code> provides a library of common enumerated sets, which can be
combined by standard constructions, giving a toolbox that is flexible
(but which could still be expanded). It is also possible to add new
building blocks to <code class="docutils literal notranslate"><span class="pre">Sage</span></code> with a few lines (see the code in
<code class="docutils literal notranslate"><span class="pre">FiniteEnumeratedSets().example()</span></code>). This is made possible by the
uniformity of the interfaces and the fact that <code class="docutils literal notranslate"><span class="pre">Sage</span></code> is based on an
object-oriented language. Also, very large or even infinite sets can
be manipulated thanks to lazy evaluation strategies (iterators, etc.).</p>
<p>There is no magic to any of this: under the hood, <code class="docutils literal notranslate"><span class="pre">Sage</span></code> applies the
usual rules (for example, that the cardinality of <span class="math notranslate nohighlight">\(E\times E\)</span> is
<span class="math notranslate nohighlight">\(|E|^2\)</span>); the added value comes from the capacity to manipulate
complicated constructions. The situation is comparable to <code class="docutils literal notranslate"><span class="pre">Sage</span></code>’s
implementation of differential calculus: <code class="docutils literal notranslate"><span class="pre">Sage</span></code> applies the usual
rules for differentiation of functions and their compositions, where
the added value comes from the possibility of manipulating complicated
formulas. In this sense, <code class="docutils literal notranslate"><span class="pre">Sage</span></code> implements a <em>calculus</em> of finite
enumerated sets.</p>
</section>
</section>
<section id="generic-algorithms">
<span id="section-generic"></span><h2>Generic algorithms<a class="headerlink" href="#generic-algorithms" title="Permalink to this heading">#</a></h2>
<section id="lexicographic-generation-of-lists-of-integers">
<span id="section-generic-integerlistlex"></span><h3>Lexicographic generation of lists of integers<a class="headerlink" href="#lexicographic-generation-of-lists-of-integers" title="Permalink to this heading">#</a></h3>
<p>Among the classic enumerated sets, especially in algebraic
combinatorics, a certain number are composed of lists of integers of
fixed sum, such as partitions, compositions, or integer vectors. These
examples can also have supplementary constraints added to them. Here are
some examples. We start with the integer vectors with sum <span class="math notranslate nohighlight">\(10\)</span>
and length <span class="math notranslate nohighlight">\(3\)</span>, with parts bounded below by <span class="math notranslate nohighlight">\(2\)</span>,
<span class="math notranslate nohighlight">\(4\)</span> and <span class="math notranslate nohighlight">\(2\)</span> respectively:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">IntegerVectors</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">min_part</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_part</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="gp">....: </span>               <span class="n">inner</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[4, 4, 2], [3, 5, 2], [3, 4, 3], [2, 5, 3], [2, 4, 4]]</span>
</pre></div>
</div>
<p>The compositions of <span class="math notranslate nohighlight">\(5\)</span> with each part at most <span class="math notranslate nohighlight">\(3\)</span>, and
with length <span class="math notranslate nohighlight">\(2\)</span> or <span class="math notranslate nohighlight">\(3\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Compositions</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">max_part</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">....: </span>             <span class="n">min_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[3, 2], [3, 1, 1], [2, 3], [2, 2, 1], [2, 1, 2], [1, 3, 1],</span>
<span class="go"> [1, 2, 2], [1, 1, 3]]</span>
</pre></div>
</div>
<p>The strictly decreasing partitions of <span class="math notranslate nohighlight">\(5\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">max_slope</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[5], [4, 1], [3, 2]]</span>
</pre></div>
</div>
<p>These sets share the same underlying algorithmic structure, implemented
in the more general (and slightly more cumbersome) class
<code class="docutils literal notranslate"><span class="pre">IntegerListsLex</span></code>. This class models sets of vectors
<span class="math notranslate nohighlight">\((\ell_0,\dots,\ell_k)\)</span> of non-negative integers, with
constraints on the sum and the length, and bounds on the parts and on
the consecutive differences between the parts. Here are some more
examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">IntegerListsLex</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">....: </span>                <span class="n">min_part</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_part</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="gp">....: </span>                <span class="n">floor</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[4, 4, 2], [3, 5, 2], [3, 4, 3], [2, 5, 3], [2, 4, 4]]</span>

<span class="gp">sage: </span><span class="n">IntegerListsLex</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">min_part</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_part</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">....: </span>                <span class="n">min_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[3, 2], [3, 1, 1], [2, 3], [2, 2, 1], [2, 1, 2],</span>
<span class="go"> [1, 3, 1], [1, 2, 2], [1, 1, 3]]</span>

<span class="gp">sage: </span><span class="n">IntegerListsLex</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">min_part</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_slope</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[5], [4, 1], [3, 2]]</span>

<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Compositions</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[5], [4, 1], [3, 2], [2, 3], [1, 4]]</span>

<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">IntegerListsLex</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">min_part</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[5], [4, 1], [3, 2], [2, 3], [1, 4]]</span>
</pre></div>
</div>
<p>The point of the model of <code class="docutils literal notranslate"><span class="pre">IntegerListsLex</span></code> is in the compromise
between generality and efficiency. The main algorithm permits
iteration through the elements of such a set <span class="math notranslate nohighlight">\(S\)</span> in reverse
lexicographic order with a good complexity in most practical use
cases. Roughly speaking, the time needed to iterate through all the
elements of <span class="math notranslate nohighlight">\(S\)</span> is proportional to the number of elements, where the
proportion factor is controlled by the length <span class="math notranslate nohighlight">\(l\)</span> of the longest
element of <span class="math notranslate nohighlight">\(S\)</span>. In addition, the memory usage is also controlled by
<span class="math notranslate nohighlight">\(l\)</span>, which is to say negligible in practice.</p>
<p>This algorithm is based on a very general principle for traversing a
decision tree, called <em>branch and bound</em>: at the top level, we run
through all the possible choices for <span class="math notranslate nohighlight">\(\ell_0\)</span>; for each of these
choices, we run through all the possible choices for <span class="math notranslate nohighlight">\(\ell_1\)</span>,
and so on. Mathematically speaking, we have put the structure of a
prefix tree on the elements of <span class="math notranslate nohighlight">\(S\)</span>: a node of the tree at depth
<span class="math notranslate nohighlight">\(k\)</span> corresponds to a prefix <span class="math notranslate nohighlight">\(\ell_0,\dots,\ell_k\)</span> of one
(or more) elements of <span class="math notranslate nohighlight">\(S\)</span> (see <a class="reference internal" href="#figure-prefix-tree-partitions"><span class="std std-ref">Figure: The prefix tree of the partitions of 5.</span></a>).</p>
<figure class="align-default" id="id12">
<span id="figure-prefix-tree-partitions"></span><a class="reference internal image-reference" href="../../_images/prefix-tree-partitions-5.png"><img alt="../../_images/prefix-tree-partitions-5.png" src="../../_images/prefix-tree-partitions-5.png" style="width: 361.5px; height: 351.0px;" /></a>
<figcaption>
<p><span class="caption-text">Figure: The prefix tree of the partitions of 5.</span><a class="headerlink" href="#id12" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The usual problem with this type of approach is to avoid bad decisions
which lead to leaving the prefix tree and exploring dead branches;
this is particularly problematic because the growth of the number of
elements is usually exponential in the depth. It turns out that the
constraints listed above are simple enough to be able to reasonably
predict when a sequence <span class="math notranslate nohighlight">\(\ell_0,\dots,\ell_k\)</span> is a prefix of some
element <span class="math notranslate nohighlight">\(S\)</span>. Hence, most dead branches can be pruned.</p>
</section>
<section id="integer-points-in-polytopes">
<span id="section-generic-polytopes"></span><h3>Integer points in polytopes<a class="headerlink" href="#integer-points-in-polytopes" title="Permalink to this heading">#</a></h3>
<p>Although the algorithm for iteration in <code class="docutils literal notranslate"><span class="pre">IntegerListsLex</span></code> is
efficient, its counting algorithm is naive: it just iterates over all
the elements.</p>
<p>There is an alternative approach to treating this problem: modelling the
desired lists of integers as the set of integer points of a polytope,
that is to say, the set of solutions with integer coordinates of a
system of linear inequalities. This is a very general context in which
there exist advanced counting algorithms (e.g. Barvinok), which are
implemented in libraries like <code class="docutils literal notranslate"><span class="pre">LattE</span></code>. Iteration does not pose a hard problem
in principle. However, there are two limitations that justify the
existence of <code class="docutils literal notranslate"><span class="pre">IntegerListsLex</span></code>. The first is theoretical: lattice
points in a polytope only allow modelling of problems of a fixed
dimension (length). The second is practical: at the moment only the
library <code class="docutils literal notranslate"><span class="pre">PALP</span></code> has a <code class="docutils literal notranslate"><span class="pre">Sage</span></code> interface, and though it offers multiple
capabilities for the study of polytopes, in the present application it
only produces a list of lattice points, without providing either an
iterator or non-naive counting:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">random_matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">rows</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">points</span><span class="p">()</span>                               <span class="c1"># random</span>
<span class="go">M(4, 1, 0),</span>
<span class="go">M(0, 3, 5),</span>
<span class="go">M(2, 2, 3),</span>
<span class="go">M(6, 1, 3),</span>
<span class="go">M(1, 3, 6),</span>
<span class="go">M(6, 2, 3),</span>
<span class="go">M(3, 2, 4),</span>
<span class="go">M(3, 2, 3),</span>
<span class="go">M(4, 2, 4),</span>
<span class="go">M(4, 2, 3),</span>
<span class="go">M(5, 2, 3)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>                                 <span class="c1"># random</span>
<span class="go">11</span>
</pre></div>
</div>
<p>This polytope can be visualized in 3D with <code class="docutils literal notranslate"><span class="pre">L.plot3d()</span></code> (see
<a class="reference internal" href="#figure-polytope"><span class="std std-ref">Figure: The polytope L and its integer points, in cross-eyed stereographic perspective.</span></a>).</p>
<figure class="align-default" id="id13">
<span id="figure-polytope"></span><a class="reference internal image-reference" href="../../_images/polytope.png"><img alt="../../_images/polytope.png" src="../../_images/polytope.png" style="width: 1068.0px; height: 528.75px;" /></a>
<figcaption>
<p><span class="caption-text">Figure: The polytope <span class="math notranslate nohighlight">\(L\)</span> and its integer points, in cross-eyed stereographic perspective.</span><a class="headerlink" href="#id13" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="species-decomposable-combinatorial-classes">
<span id="section-generic-species"></span><h3>Species, decomposable combinatorial classes<a class="headerlink" href="#species-decomposable-combinatorial-classes" title="Permalink to this heading">#</a></h3>
<p>In <a class="reference internal" href="#section-examples-catalan"><span class="std std-ref">Enumeration of trees using generating functions</span></a>, we showed how to use the recursive
definition of binary trees to count them efficiently using generating
functions. The techniques we used there are very general, and apply
whenever the sets involved can be defined recursively (depending on
who you ask, such a set is called a <em>decomposable combinatorial class</em>
or, roughly speaking, a <em>combinatorial species</em>). This includes all
the types of trees, but also permutations, compositions, functional
graphs, etc.</p>
<p>Here, we illustrate just a few examples using the <code class="docutils literal notranslate"><span class="pre">Sage</span></code> library on
combinatorial species:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.species.library</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>                                                                  <span class="c1"># needs sage.symbolic</span>
</pre></div>
</div>
<p>We begin by redefining the complete binary trees; to do so, we stipulate
the recurrence relation directly on the sets:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BT</span> <span class="o">=</span> <span class="n">CombinatorialSpecies</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Leaf</span> <span class="o">=</span>  <span class="n">SingletonSpecies</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">BT</span><span class="o">.</span><span class="n">define</span><span class="p">(</span> <span class="n">Leaf</span> <span class="o">+</span> <span class="p">(</span><span class="n">BT</span><span class="o">*</span><span class="n">BT</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Now we can construct the set of trees with five nodes, list them, count
them…:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BT5</span> <span class="o">=</span> <span class="n">BT</span><span class="o">.</span><span class="n">isotypes</span><span class="p">([</span><span class="n">o</span><span class="p">]</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span>                                                      <span class="c1"># needs sage.symbolic</span>
<span class="gp">sage: </span><span class="n">BT5</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>                                                             <span class="c1"># needs sage.symbolic</span>
<span class="go">14</span>
<span class="gp">sage: </span><span class="n">BT5</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>                                                                    <span class="c1"># needs sage.symbolic</span>
<span class="go">[o*(o*(o*(o*o))), o*(o*((o*o)*o)), o*((o*o)*(o*o)),</span>
<span class="go"> o*((o*(o*o))*o), o*(((o*o)*o)*o), (o*o)*(o*(o*o)),</span>
<span class="go"> (o*o)*((o*o)*o), (o*(o*o))*(o*o), ((o*o)*o)*(o*o),</span>
<span class="go"> (o*(o*(o*o)))*o, (o*((o*o)*o))*o, ((o*o)*(o*o))*o,</span>
<span class="go"> ((o*(o*o))*o)*o, (((o*o)*o)*o)*o]</span>
</pre></div>
</div>
<p>The trees are constructed using a generic recursive structure; the
display is therefore not wonderful. To do better, it would be necessary
to provide <code class="docutils literal notranslate"><span class="pre">Sage</span></code> with a more specialized data structure with the
desired display capabilities.</p>
<p>We recover the generating function for the Catalan numbers:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">BT</span><span class="o">.</span><span class="n">isotype_generating_series</span><span class="p">();</span> <span class="n">g</span>
<span class="go">z + z^2 + 2*z^3 + 5*z^4 + 14*z^5 + 42*z^6 + 132*z^7 + O(z^8)</span>
</pre></div>
</div>
<p>which is returned in the form of a lazy power series:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span>
<span class="go">227508830794229349661819540395688853956041682601541047340</span>
</pre></div>
</div>
<p>We finish with the Fibonacci words, which are binary words without two
consecutive “<span class="math notranslate nohighlight">\(1\)</span>”s. They admit a natural recursive definition:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Eps</span> <span class="o">=</span>  <span class="n">EmptySetSpecies</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Z0</span>  <span class="o">=</span>  <span class="n">SingletonSpecies</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Z1</span>  <span class="o">=</span>  <span class="n">Eps</span><span class="o">*</span><span class="n">SingletonSpecies</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FW</span>  <span class="o">=</span> <span class="n">CombinatorialSpecies</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FW</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">Eps</span> <span class="o">+</span> <span class="n">Z0</span><span class="o">*</span><span class="n">FW</span>  <span class="o">+</span>  <span class="n">Z1</span><span class="o">*</span><span class="n">Eps</span> <span class="o">+</span> <span class="n">Z1</span><span class="o">*</span><span class="n">Z0</span><span class="o">*</span><span class="n">FW</span><span class="p">)</span>
</pre></div>
</div>
<p>The Fibonacci sequence is easily recognized here, hence the name:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">FW</span><span class="o">.</span><span class="n">isotype_generating_series</span><span class="p">()[:</span><span class="mi">15</span><span class="p">];</span> <span class="n">L</span>
<span class="go">[1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">oeis</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>                                       <span class="c1"># optional -- internet</span>
<span class="go">0: A000045: Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.</span>
<span class="go">1: ...</span>
<span class="go">2: ...</span>
</pre></div>
</div>
<p>This is an immediate consequence of the recurrence relation. One can
also generate immediately all the Fibonacci words of a given length,
with the same limitations resulting from the generic display.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FW3</span> <span class="o">=</span> <span class="n">FW</span><span class="o">.</span><span class="n">isotypes</span><span class="p">([</span><span class="n">o</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>                                                      <span class="c1"># needs sage.symbolic</span>
<span class="gp">sage: </span><span class="n">FW3</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>                                                                    <span class="c1"># needs sage.symbolic</span>
<span class="go">[o*(o*(o*{})), o*(o*(({}*o)*{})), o*((({}*o)*o)*{}),</span>
<span class="go"> (({}*o)*o)*(o*{}), (({}*o)*o)*(({}*o)*{})]</span>
</pre></div>
</div>
</section>
<section id="graphs-up-to-isomorphism">
<span id="section-generic-isomorphism"></span><h3>Graphs up to isomorphism<a class="headerlink" href="#graphs-up-to-isomorphism" title="Permalink to this heading">#</a></h3>
<p>We saw in <a class="reference internal" href="#section-bricks-divers"><span class="std std-ref">Some other finite enumerated sets</span></a> that <code class="docutils literal notranslate"><span class="pre">Sage</span></code> could generate
graphs and partial orders up to isomorphism. We will now describe the
underlying algorithm, which is the same in both cases, and covers a
substantially wider class of problems.</p>
<p>We begin by recalling some notions. A graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span> is a set
<span class="math notranslate nohighlight">\(V\)</span> of vertices and a set <span class="math notranslate nohighlight">\(E\)</span> of edges connecting these
vertices; an edge is described by a pair <span class="math notranslate nohighlight">\(\{u,v\}\)</span> of distinct
vertices of <span class="math notranslate nohighlight">\(V\)</span>. Such a graph is called labelled; its vertices
are typically numbered by considering <span class="math notranslate nohighlight">\(V=\{1,2,3,4,5\}\)</span>.</p>
<p>In many problems, the labels on the vertices play no role. Typically a
chemist wants to study all the possible molecules with a given
composition, for example the alkanes with <span class="math notranslate nohighlight">\(n=8\)</span> atoms of carbon
and <span class="math notranslate nohighlight">\(2n+2=18\)</span> atoms of hydrogen. He therefore wants to find all
the graphs consisting of <span class="math notranslate nohighlight">\(8\)</span> vertices with <span class="math notranslate nohighlight">\(4\)</span> neighbours, and
<span class="math notranslate nohighlight">\(18\)</span> vertices with a single neighbour. The different carbon atoms,
however, are all considered to be identical, and the same for
the hydrogen atoms. The problem of our chemist is not imaginary; this
type of application is actually at the origin of an important part of
the research in graph theory on isomorphism problems.</p>
<p>Working by hand on a small graph it is possible, as in the example of
<a class="reference internal" href="#section-bricks-divers"><span class="std std-ref">Some other finite enumerated sets</span></a>, to make a drawing, erase the labels, and
“forget” the geometrical information about the location of the
vertices in the plane. However, to represent a graph in a computer
program, it is necessary to introduce labels on the vertices so as to
be able to describe how the edges connect them together. To compensate
for the extra information which we have introduced, we then say that
two labelled graphs <span class="math notranslate nohighlight">\(g_1\)</span> and <span class="math notranslate nohighlight">\(g_2\)</span> are <em>isomorphic</em> if there is a
bijection from the vertices of <span class="math notranslate nohighlight">\(g_1\)</span> to those of <span class="math notranslate nohighlight">\(g_2\)</span>, which maps
bijectively the edges of <span class="math notranslate nohighlight">\(g_1\)</span> to those of <span class="math notranslate nohighlight">\(g_2\)</span>; an <em>unlabelled
graph</em> is then an equivalence class of labelled graphs.</p>
<p>In general, testing if two labelled graphs are isomorphic is expensive.
However, the number of graphs, even unlabelled, grows very
rapidly.  Nonetheless, it is possible to list unlabelled graphs very efficiently
considering their number. For example, the program <code class="docutils literal notranslate"><span class="pre">Nauty</span></code> can list the
<span class="math notranslate nohighlight">\(12005168\)</span> simple graphs with <span class="math notranslate nohighlight">\(10\)</span> vertices in
<span class="math notranslate nohighlight">\(20\)</span> seconds.</p>
<p>As in <a class="reference internal" href="#section-generic-integerlistlex"><span class="std std-ref">Lexicographic generation of lists of integers</span></a>, the general principle
of the algorithm is to organize the objects to be enumerated into a tree
that one traverses.</p>
<p>For this, in each equivalence class of labelled graphs (that is to say,
for each unlabelled graph) one fixes a convenient canonical
representative. The following are the fundamental operations:</p>
<ul class="simple">
<li><p>Testing whether a labelled graph is canonical</p></li>
<li><p>Calculating the canonical representative of a labelled graph</p></li>
</ul>
<p>These unavoidable operations remain expensive; one therefore tries to
minimize the number of calls to them.</p>
<p>The canonical representatives are chosen in such a way that, for each
canonical labelled graph <span class="math notranslate nohighlight">\(G\)</span>, there is a canonical choice of an edge
whose removal produces a canonical graph again, which is called the
father of <span class="math notranslate nohighlight">\(G\)</span>. This property implies that it is possible to organize
the set of canonical representatives as a tree: at the root, the graph
with no edges; below it, its unique child, the graph with one edge;
then the graphs with two edges, and so on. The set of children of a
graph <span class="math notranslate nohighlight">\(G\)</span> can be constructed by <em>augmentation</em>, adding an edge in all
the possible ways to <span class="math notranslate nohighlight">\(G\)</span>, and then selecting, from among those graphs,
the ones that are still canonical <a class="footnote-reference brackets" href="#id10" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>. Recursively, one obtains all
the canonical graphs.</p>
<figure class="align-default" id="id14">
<img alt="../../_images/prefix-tree-graphs-4.png" src="../../_images/prefix-tree-graphs-4.png" />
<figcaption>
<p><span class="caption-text">Figure: The generation tree of simple graphs with <span class="math notranslate nohighlight">\(4\)</span> vertices.</span><a class="headerlink" href="#id14" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>In what sense is this algorithm generic? Consider for example planar
graphs (graphs which can be drawn in the plane without edges crossing):
by removing an edge from a planar graph, one obtains another planar
graph; so planar graphs form a subtree of the previous tree. To generate
them, exactly the same algorithm can be used,
selecting only the children which are planar:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">graphs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">property</span><span class="o">=</span><span class="k">lambda</span> <span class="n">G</span><span class="p">:</span> <span class="n">G</span><span class="o">.</span><span class="n">is_planar</span><span class="p">())))</span>
<span class="gp">....: </span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
<span class="go">[1, 1, 2, 4, 11, 33, 142]</span>
</pre></div>
</div>
<p>In a similar fashion, one can generate any family of graphs closed
under deletion of an edge, and in particular any family characterized
by a forbidden subgraph. This includes for example forests (graphs
without cycles), bipartite graphs (graphs without odd cycles),
etc. This can be applied to generate:</p>
<ul class="simple">
<li><p>partial orders, via the bijection with Hasse diagrams which are
oriented graphs without cycles and without edges implied by the
transitivity of the order relation;</p></li>
<li><p>lattices (not implemented in <code class="docutils literal notranslate"><span class="pre">Sage</span></code>), via the bijection with the
meet semi-lattice obtained by deleting the maximal vertex; in this
case an augmentation by vertices rather than by edges is used.</p></li>
</ul>
<p>REFERENCES:</p>
<blockquote>
<div><div class="citation" id="cms2012" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">CMS2012</a><span class="fn-bracket">]</span></span>
<p>Alexandre Casamayou, Nathann Cohen, Guillaume Connan, Thierry Dumont, Laurent Fousse, François Maltey, Matthias Meulien, Marc Mezzarobba, Clément Pernet, Nicolas M. Thiéry, Paul Zimmermann
<em>Calcul Mathématique avec Sage</em>
<a class="reference external" href="https://www.sagemath.org/sagebook/french.html">https://www.sagemath.org/sagebook/french.html</a></p>
</div>
</div>
</div></blockquote>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id9" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">1</a><span class="fn-bracket">]</span></span>
<p>Or at least that should be the case; there are still many corners to
clean up.</p>
</aside>
<aside class="footnote brackets" id="id10" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">2</a><span class="fn-bracket">]</span></span>
<p>In practice, an efficient implementation would exploit the symmetries
of <span class="math notranslate nohighlight">\(G\)</span>, i.e., its automorphism group, to reduce the number of
children to explore, and to reduce the cost of each test of
canonicity.</p>
</aside>
</aside>
</section>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="vector_partition.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Vector Partitions</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="tuple.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Tuples</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2005--2023, The Sage Development Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Introduction to combinatorics in Sage</a><ul>
<li><a class="reference internal" href="#initial-examples">Initial examples</a><ul>
<li><a class="reference internal" href="#poker-and-probability">Poker and probability</a></li>
<li><a class="reference internal" href="#enumeration-of-trees-using-generating-functions">Enumeration of trees using generating functions</a><ul>
<li><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#common-enumerated-sets">Common enumerated sets</a><ul>
<li><a class="reference internal" href="#first-example-the-subsets-of-a-set">First example: the subsets of a set</a></li>
<li><a class="reference internal" href="#partitions-of-integers">Partitions of integers</a></li>
<li><a class="reference internal" href="#some-other-finite-enumerated-sets">Some other finite enumerated sets</a></li>
<li><a class="reference internal" href="#set-comprehension-and-iterators">Set comprehension and iterators</a><ul>
<li><a class="reference internal" href="#operations-on-iterators">Operations on iterators</a></li>
<li><a class="reference internal" href="#implementation-of-new-iterators">Implementation of new iterators</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#constructions">Constructions</a><ul>
<li><a class="reference internal" href="#id7">Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generic-algorithms">Generic algorithms</a><ul>
<li><a class="reference internal" href="#lexicographic-generation-of-lists-of-integers">Lexicographic generation of lists of integers</a></li>
<li><a class="reference internal" href="#integer-points-in-polytopes">Integer points in polytopes</a></li>
<li><a class="reference internal" href="#species-decomposable-combinatorial-classes">Species, decomposable combinatorial classes</a></li>
<li><a class="reference internal" href="#graphs-up-to-isomorphism">Graphs up to isomorphism</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"ZZ": "\\Bold{Z}", "NN": "\\Bold{N}", "RR": "\\Bold{R}", "CC": "\\Bold{C}", "QQ": "\\Bold{Q}", "QQbar": "\\overline{\\QQ}", "GF": ["\\Bold{F}_{#1}", 1], "Zp": ["\\Bold{Z}_{#1}", 1], "Qp": ["\\Bold{Q}_{#1}", 1], "Zmod": ["\\ZZ/#1\\ZZ", 1], "CDF": "\\Bold{C}", "CIF": "\\Bold{C}", "CLF": "\\Bold{C}", "RDF": "\\Bold{R}", "RIF": "\\Bold{I} \\Bold{R}", "RLF": "\\Bold{R}", "SL": "\\mathrm{SL}", "PSL": "\\mathrm{PSL}", "lcm": "\\mathop{\\operatorname{lcm}}", "Bold": ["\\mathbf{#1}", 1]}, "inlineMath": [["$", "$"], ["\\(", "\\)"]], "maxBuffer": 51200, "autoload": {"color": [], "colorv2": ["color"]}}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <script src="../../../_static/jupyter-sphinx-furo.js"></script>
    </body>
</html>