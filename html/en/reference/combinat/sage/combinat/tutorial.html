<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=600, initial-scale=1">
    <title>Introduction to combinatorics in Sage &mdash; Sage Reference Manual v7.3: Combinatorics</title>
    
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '7.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v7.3: Combinatorics" href="../../index.html" />
    <link rel="up" title="Comprehensive Module list" href="../../module_list.html" />
    <link rel="next" title="Vector Partitions" href="vector_partition.html" />
    <link rel="prev" title="Tuples" href="tuple.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="vector_partition.html" title="Vector Partitions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tuple.html" title="Tuples"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Combinatorics</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../../module_list.html" accesskey="U">Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="introduction-to-combinatorics-in-sage">
<span id="sage-combinat-tutorial"></span><h1>Introduction to combinatorics in Sage<a class="headerlink" href="#introduction-to-combinatorics-in-sage" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.tutorial"></span><p>This thematic tutorial is a translation by Hugh Thomas of the
combinatorics chapter written by Nicolas M. Thiéry in the book &#8220;Calcul
Mathématique avec Sage&#8221; <a class="reference internal" href="#cms2012" id="id1">[CMS2012]</a>. It covers mainly the treatment in
<code class="docutils literal"><span class="pre">Sage</span></code> of the following combinatorial problems: enumeration (how
many elements are there in a set <span class="math">\(S\)</span>?), listing (generate all the
elements of <span class="math">\(S\)</span>, or iterate through them), and random selection
(choosing an element at random from a set <span class="math">\(S\)</span> according to a given
distribution, for example the uniform distribution). These questions
arise naturally in the calculation of probabilities (what is the
probability in poker of obtaining a straight or a four-of-a-kind of
aces?), in statistical physics, and also in computer algebra (the number
of elements in a finite field), or in the analysis of
algorithms. Combinatorics covers a much wider domain (partial orders,
representation theory, …) for which we only give a few pointers
towards the possibilities offered by <code class="docutils literal"><span class="pre">Sage</span></code>.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Add link to some thematic tutorial on graphs</p>
</div>
<p>A characteristic of computational combinatorics is the profusion of
types of objects and sets that one wants to manipulate. It would be
impossible to describe them all or, a fortiori, to implement them all.
After some <a class="reference internal" href="#section-examples"><span class="std std-ref">Initial examples</span></a>, this chapter illustrates the
underlying method: supplying the basic building blocks to describe
common combinatorial sets <a class="reference internal" href="#section-bricks"><span class="std std-ref">Common enumerated sets</span></a>, tools for combining
them to construct new examples <a class="reference internal" href="#section-constructions"><span class="std std-ref">Constructions</span></a>, and
generic algorithms for solving uniformly a large class of problems
<a class="reference internal" href="#section-generic"><span class="std std-ref">Generic algorithms</span></a>.</p>
<p>This is a domain in which <code class="docutils literal"><span class="pre">Sage</span></code> has much more extensive capabilities
than most computer algebra systems, and it is rapidly expanding; at the
same time, it is still quite new, and has many unnecessary limitations
and incoherences.</p>
<div class="section" id="initial-examples">
<span id="section-examples"></span><h2>Initial examples<a class="headerlink" href="#initial-examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="poker-and-probability">
<span id="section-examples-poker"></span><h3>Poker and probability<a class="headerlink" href="#poker-and-probability" title="Permalink to this headline">¶</a></h3>
<p>We begin by solving a classic problem:&nbsp;enumerating certain combinations
of cards in the game of poker, in order to deduce their probability.</p>
<p>A card in a poker deck is characterized by a suit (hearts, diamonds,
spades, or clubs) and a value (2, 3, ..., 10, jack, queen, king, ace). The
game is played with a full deck, which consists of the Cartesian product
of the set of suits and the set of values:</p>
<div class="math">
\[\operatorname{Cards} = \operatorname{Suits} \times
\operatorname{Values} = \{ (s, v)  \mathrel| s\in
\operatorname{Suits} \text{ et } v \in \operatorname{Values} \}\,.\]</div>
<p>We construct these examples in <code class="docutils literal"><span class="pre">Sage</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Suits</span> <span class="o">=</span> <span class="n">Set</span><span class="p">([</span><span class="s2">&quot;Hearts&quot;</span><span class="p">,</span> <span class="s2">&quot;Diamonds&quot;</span><span class="p">,</span> <span class="s2">&quot;Spades&quot;</span><span class="p">,</span> <span class="s2">&quot;Clubs&quot;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Values</span> <span class="o">=</span> <span class="n">Set</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span>
<span class="go">....:               &quot;Jack&quot;, &quot;Queen&quot;, &quot;King&quot;, &quot;Ace&quot;])</span>
<span class="gp">sage: </span><span class="n">Cards</span> <span class="o">=</span> <span class="n">cartesian_product</span><span class="p">([</span><span class="n">Values</span><span class="p">,</span> <span class="n">Suits</span><span class="p">])</span>
</pre></div>
</div>
<p>There are <span class="math">\(4\)</span> suits and <span class="math">\(13\)</span> possible values, and
therefore <span class="math">\(4\times 13=52\)</span> cards in the poker deck:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Suits</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">Values</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">13</span>
<span class="gp">sage: </span><span class="n">Cards</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">52</span>
</pre></div>
</div>
<p>Draw a card at random:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Cards</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>                      <span class="c1"># random</span>
<span class="go">(6, &#39;Clubs&#39;)</span>
</pre></div>
</div>
<p>Now we can define a set of cards:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Set</span><span class="p">([</span><span class="n">Cards</span><span class="o">.</span><span class="n">random_element</span><span class="p">(),</span> <span class="n">Cards</span><span class="o">.</span><span class="n">random_element</span><span class="p">()])</span>  <span class="c1"># random</span>
<span class="go">{(2, &#39;Hearts&#39;), (4, &#39;Spades&#39;)}</span>
</pre></div>
</div>
<p>This problem should eventually disappear: it is planned to change the
implementation of Cartesian products so that their elements are
immutable by default.</p>
<p>Returning to our main topic, we will be considering a simplified version
of poker, in which each player directly draws five cards, which form his
<em>hand</em>. The cards are all distinct and the order in which they are drawn
is irrelevant; a hand is therefore a subset of size <span class="math">\(5\)</span> of the
set of cards. To draw a hand at random, we first construct the set of
all possible hands, and then we ask for a randomly chosen element:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Hands</span> <span class="o">=</span> <span class="n">Subsets</span><span class="p">(</span><span class="n">Cards</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Hands</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>                      <span class="c1"># random</span>
<span class="go">{(4, &#39;Hearts&#39;, 4), (9, &#39;Diamonds&#39;), (8, &#39;Spades&#39;),</span>
<span class="go"> (9, &#39;Clubs&#39;), (7, &#39;Hearts&#39;)}</span>
</pre></div>
</div>
<p>The total number of hands is given by the number of subsets of size
<span class="math">\(5\)</span> of a set of size <span class="math">\(52\)</span>, which is given by the
binomial coefficient <span class="math">\(\binom{52}{5}\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">binomial</span><span class="p">(</span><span class="mi">52</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="go">2598960</span>
</pre></div>
</div>
<p>One can also ignore the method of calculation, and
simply ask for the size of the set of hands:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Hands</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">2598960</span>
</pre></div>
</div>
<p>The strength of a poker hand depends on the particular combination of
cards present. One such combination is the <em>flush</em>; this is a hand all
of whose cards have the same suit. (In principle, straight flushes
should be excluded; this will be the goal of an exercise given below.)
Such a hand is therefore characterized by the choice of five values from
among the thirteen possibilities, and the choice of one of four suits.
We will construct the set of all flushes, so as to determine how many
there are:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Flushes</span> <span class="o">=</span> <span class="n">cartesian_product</span><span class="p">([</span><span class="n">Subsets</span><span class="p">(</span><span class="n">Values</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">Suits</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Flushes</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5148</span>
</pre></div>
</div>
<p>The probability of obtaining a flush when drawing a hand at random is
therefore:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Flushes</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>  <span class="o">/</span> <span class="n">Hands</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">33/16660</span>
</pre></div>
</div>
<p>or about two in a thousand:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="mf">1000.0</span> <span class="o">*</span> <span class="n">Flushes</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>  <span class="o">/</span> <span class="n">Hands</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">1.98079231692677</span>
</pre></div>
</div>
<p>We will now attempt a little numerical simulation. The following
function tests whether a given hand is a flush or not:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">is_flush</span><span class="p">(</span><span class="n">hand</span><span class="p">):</span>
<span class="go">....:     return len(set(suit for (val, suit) in hand)) == 1</span>
</pre></div>
</div>
<p>We now draw 10000 hands at random, and count the number of flushes
obtained (this takes about 10 seconds):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="gp">sage: </span><span class="n">nflush</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>                            <span class="c1"># long time</span>
<span class="go">....:    hand = Hands.random_element()</span>
<span class="go">....:    if is_flush(hand):</span>
<span class="go">....:        nflush += 1</span>
<span class="gp">sage: </span><span class="n">n</span><span class="p">,</span> <span class="n">nflush</span>                               <span class="c1"># random</span>
<span class="go">(10000, 18)</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">Exercises</p>
<p>A hand containing four cards of the same value is called a <em>four
of a kind</em>. Construct the set of four of a kind hands (Hint: use
<code class="docutils literal"><span class="pre">Arrangements</span></code> to choose a pair of distinct values at random,
then choose a suit for the first value). Calculate the number of
four of a kind hand, list them, and then determine the probability
of obtaining a four of a kind when drawing a hand at random.</p>
<p>A hand all of whose cards have the same suit, and whose values are
consecutive, is called a <em>straight flush</em> rather than a <em>flush</em>.
Count the number of straight flushes, and then deduce the correct
probability of obtaining a flush when drawing a hand at random.</p>
<p>Calculate the probability of each of the poker hands (see
<a class="reference external" href="https://en.wikipedia.org/wiki/Poker_hands">Wikipedia article Poker_hands</a>), and compare them with the results of
simulations.</p>
</div>
</div>
<div class="section" id="enumeration-of-trees-using-generating-functions">
<span id="section-examples-catalan"></span><h3>Enumeration of trees using generating functions<a class="headerlink" href="#enumeration-of-trees-using-generating-functions" title="Permalink to this headline">¶</a></h3>
<p>In this section, we discuss the example of complete binary trees, and
illustrate in this context many techniques of enumeration in which
formal power series play a natural role. These techniques are quite
general, and can be applied whenever the combinatorial objects in
question admit a recursive definition (grammar) (see
<a class="reference internal" href="#section-generic-species"><span class="std std-ref">Species, decomposable combinatorial classes</span></a> for an automated treatment). The
goal is not a formal presentation of these methods; the calculations are
rigorous, but most of the justifications will be skipped.</p>
<p>A <em>complete binary tree</em> is either a leaf <span class="math">\(\mathrm{L}\)</span>, or a
node to which two complete binary trees are attached (see
<a class="reference internal" href="#figure-examples-catalan-trees"><span class="std std-ref">Figure: The five complete binary trees with four leaves</span></a>).</p>
<div class="figure" id="id9">
<span id="figure-examples-catalan-trees"></span><a class="reference internal image-reference" href="../../_images/complete-binary-trees-4.png"><img alt="../../_images/complete-binary-trees-4.png" src="../../_images/complete-binary-trees-4.png" style="width: 699.0px; height: 91.5px;" /></a>
<p class="caption"><span class="caption-text">Figure: The five complete binary trees with four leaves</span></p>
</div>
<div class="topic" id="exo-enumeration-arbres">
<p class="topic-title first">Exercise: enumeration of binary trees</p>
<p>Find by hand all the complete binary trees with <span class="math">\(n=1, 2, 3, 4, 5\)</span>
leaves (see <a class="reference internal" href="#exo-iterators-catalan"><span class="std std-ref">Exercise: complete binary tree iterator</span></a> to find them using <code class="docutils literal"><span class="pre">Sage</span></code>).</p>
</div>
<p>Our goal is to determine the number <span class="math">\(c_n\)</span> of complete binary
trees with <span class="math">\(n\)</span> leaves (in this section, except when explicitly
stated otherwise, “trees” always means complete binary trees). This is a
typical situation in which one is not only interested in a single set,
but in a family of sets, typically parameterized by <span class="math">\(n\in \NN\)</span>.</p>
<p>According to the solution of <a class="reference internal" href="#exo-enumeration-arbres"><span class="std std-ref">Exercise: enumeration of binary trees</span></a>, the first terms are given by
<span class="math">\(c_1,\dots,c_5=1,1,2,5,14\)</span>. The simple fact of knowing these few
numbers is already very valuable. In fact, this permits research in a
gold mine of information: the <a class="reference external" href="http://oeis.org/">Online Encyclopedia of Integer Sequences</a>, commonly called “Sloane”, the name of its principal
author, which contains more than 190000 sequences of integers:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">oeis</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">14</span><span class="p">])</span>                            <span class="c1"># optional -- internet</span>
<span class="go">0: A000108: Catalan numbers: C(n) = binomial(2n,n)/(n+1) = (2n)!/(n!(n+1)!). Also called Segner numbers.</span>
<span class="go">1: A120588: G.f. satisfies: 3*A(x) = 2 + x + A(x)^2, with a(0) = 1.</span>
<span class="go">2: A080937: Number of Catalan paths (nonnegative, starting and ending at 0, step +/-1) of 2*n steps with all values &lt;= 5.</span>
</pre></div>
</div>
<p>The result suggests that the trees are counted by one of the most famous
sequences, the Catalan numbers. Looking through the references supplied
by the Encyclopedia, we see that this is really the case: the few
numbers above form a digital fingerprint of our objects, which enable us
to find, in a few seconds, a precise result from within an abundant
literature.</p>
<p>Our next goal is to recover this result using <code class="docutils literal"><span class="pre">Sage</span></code>. Let
<span class="math">\(C_n\)</span> be the set of trees with <span class="math">\(n\)</span> leaves, so that
<span class="math">\(c_n=|C_n|\)</span>; by convention, we will define
<span class="math">\(C_0=\emptyset\)</span> and <span class="math">\(c_0=0\)</span>. The set of all trees is
then the disjoint union of the sets <span class="math">\(C_n\)</span>:</p>
<div class="math">
\[C=\biguplus_{n\in \mathbb N} C_n\,.\]</div>
<p>Having named the set <span class="math">\(C\)</span> of all trees, we can translate the
recursive definition of trees into a set-theoretic equation:</p>
<div class="math">
\[C \quad \approx \quad  \{ \mathrm{L} \} \quad \uplus\quad C \times C\,.\]</div>
<p>In words: a tree <span class="math">\(t\)</span> (which is by definition in <span class="math">\(C\)</span>) is either a
leaf (so in <span class="math">\(\{\mathrm{L}\}\)</span>) or a node to which two trees
<span class="math">\(t_1\)</span> and <span class="math">\(t_2\)</span> have been attached, and which we can
therefore identify with the pair <span class="math">\((t_1,t_2)\)</span> (in the Cartesian
product <span class="math">\(C\times C\)</span>).</p>
<p>The founding idea of algebraic combinatorics, introduced by Euler in
a letter to Goldbach of 1751 to treat a similar problem&nbsp;, is to
manipulate all the numbers <span class="math">\(c_n\)</span> simultaneously, by encoding them
as coefficients in a formal power series, called the <em>generating
function</em> of the <span class="math">\(c_n\)</span>’s:</p>
<div class="math">
\[C(z) = \sum_{n\in \mathbb N} c_n z^n\,,\]</div>
<p>where <span class="math">\(z\)</span> is a formal variable (which means that we do not
have to worry about questions of convergence). The beauty of this idea
is that set-theoretic operations <span class="math">\((A\uplus B\)</span>,
<span class="math">\(A\times B)\)</span> translate naturally into algebraic operations on
the corresponding series (<span class="math">\(A(z)+B(z)\)</span>,
<span class="math">\(A(z)\cdot B(z)\)</span>), in such a way that the set-theoretic equation
satisfied by <span class="math">\(C\)</span> can be translated directly into an algebraic
equation satisfied by <span class="math">\(C(z)\)</span>:</p>
<div class="math">
\[C(z) = z + C(z) \cdot C(z)\,.\]</div>
<p>Now we can solve this equation with <code class="docutils literal"><span class="pre">Sage</span></code>. In order to do so, we
introduce two variables, <span class="math">\(C\)</span> and <span class="math">\(z\)</span>, and we define the
equation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;C,z&#39;</span><span class="p">);</span>
<span class="gp">sage: </span><span class="n">sys</span> <span class="o">=</span> <span class="p">[</span> <span class="n">C</span> <span class="o">==</span> <span class="n">z</span> <span class="o">+</span> <span class="n">C</span><span class="o">*</span><span class="n">C</span> <span class="p">]</span>
</pre></div>
</div>
<p>There are two solutions, which happen to have closed forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">solution_dict</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">sol</span>
<span class="go">[{C: -1/2*sqrt(-4*z + 1) + 1/2}, {C: 1/2*sqrt(-4*z + 1) + 1/2}]</span>
<span class="gp">sage: </span><span class="n">s0</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">C</span><span class="p">];</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">C</span><span class="p">]</span>
</pre></div>
</div>
<p>and whose Taylor series begin as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s0</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">1*z + 1*z^2 + 2*z^3 + 5*z^4 + 14*z^5 + Order(z^6)</span>
<span class="gp">sage: </span><span class="n">s1</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">1 + (-1)*z + (-1)*z^2 + (-2)*z^3 + (-5)*z^4 + (-14)*z^5</span>
<span class="go">+ Order(z^6)</span>
</pre></div>
</div>
<p>The second solution is clearly aberrant, while the first one gives the
expected coefficients. Therefore, we set:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">s0</span>
</pre></div>
</div>
<p>We can now calculate the next terms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
<span class="go">1*z + 1*z^2 + 2*z^3 + 5*z^4 + 14*z^5 + 42*z^6 +</span>
<span class="go">132*z^7 + 429*z^8 + 1430*z^9 + 4862*z^10 + Order(z^11)</span>
</pre></div>
</div>
<p>or calculate, more or less instantaneously, the 100-th coefficient:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span><span class="o">.</span><span class="n">coefficient</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="go">227508830794229349661819540395688853956041682601541047340</span>
</pre></div>
</div>
<p>It is unfortunate to have to recalculate everything if at some point we
wanted the 101-st coefficient. Lazy power series (see
<a class="reference internal" href="species/series.html#module-sage.combinat.species.series" title="sage.combinat.species.series"><code class="xref py py-mod docutils literal"><span class="pre">sage.combinat.species.series</span></code></a>) come into their own here, in that
one can define them from a system of equations without solving it, and,
in particular, without needing a closed form for the answer. We begin by
defining the ring of lazy power series:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span><span class="o">.&lt;</span><span class="n">z</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">LazyPowerSeriesRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we create a “free” power series, which we name, and which we then
define by a recursive equation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s1">&#39;C&#39;</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">define</span><span class="p">(</span> <span class="n">z</span> <span class="o">+</span> <span class="n">C</span> <span class="o">*</span> <span class="n">C</span> <span class="p">);</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">C</span><span class="o">.</span><span class="n">coefficient</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">)]</span>
<span class="go">[0, 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862]</span>
</pre></div>
</div>
<p>At any point, one can ask for any coefficient without having to redefine
<span class="math">\(C\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">coefficient</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="go">227508830794229349661819540395688853956041682601541047340</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">coefficient</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>
<span class="go">129013158064429114001222907669676675134349530552728882499810851598901419013348319045534580850847735528275750122188940</span>
</pre></div>
</div>
<p>We now return to the closed form of <span class="math">\(C(z)\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">);</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">s0</span><span class="p">;</span> <span class="n">C</span>
<span class="go">-1/2*sqrt(-4*z + 1) + 1/2</span>
</pre></div>
</div>
<p>The <span class="math">\(n\)</span>-th coefficient in the Taylor series for <span class="math">\(C(z)\)</span>
being given by <span class="math">\(\frac{1}{n!} C(z)^{(n)}(0)\)</span>, we look at the
successive derivatives <span class="math">\(C(z)^{(n)}(z)\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">derivative</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">1/sqrt(-4*z + 1)</span>
<span class="gp">sage: </span><span class="n">derivative</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">2/(-4*z + 1)^(3/2)</span>
<span class="gp">sage: </span><span class="n">derivative</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">12/(-4*z + 1)^(5/2)</span>
</pre></div>
</div>
<p>This suggests the existence of a simple explicit formula, which we will
now seek. The following small function returns <span class="math">\(d_n=n! \, c_n\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">d</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="k">return</span> <span class="n">derivative</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Taking successive quotients:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span> <span class="p">(</span><span class="n">d</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[2, 6, 10, 14, 18, 22, 26, 30, 34, 38, 42, 46, 50, 54, 58, 62]</span>
</pre></div>
</div>
<p>we observe that <span class="math">\(d_n\)</span> satisfies the recurrence relation
<span class="math">\(d_{n+1}=(4n-2)d_n\)</span>, from which we deduce that <span class="math">\(c_n\)</span>
satisfies the recurrence relation
<span class="math">\(c_{n+1}=\frac{(4n-2)}{n+1}c_n\)</span>. Simplifying, we find that
<span class="math">\(c_n\)</span> is the <span class="math">\((n-1)\)</span>-th Catalan number:</p>
<div class="math">
\[c_n = \operatorname{Catalan}(n-1) = \frac {1}{n} \binom{2(n-1)}{n-1}\,.\]</div>
<p>We check this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">);</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="o">*</span><span class="n">binomial</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)]</span>
<span class="go">[1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">catalan_number</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)]</span>
<span class="go">[1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862]</span>
</pre></div>
</div>
<p>We can now calculate coefficients much further; here we calculate
<span class="math">\(c_{100000}\)</span> which has more than <span class="math">\(60000\)</span> digits:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cc</span> <span class="o">=</span> <span class="n">c</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">)</span>
</pre></div>
</div>
<p>This takes a couple of seconds:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="o">%</span><span class="n">time</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">c</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span>                         <span class="c1"># not tested</span>
<span class="go">CPU times: user 2.34 s, sys: 0.00 s, total: 2.34 s</span>
<span class="go">Wall time: 2.34 s</span>
<span class="gp">sage: </span><span class="n">ZZ</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span><span class="o">.</span><span class="n">ndigits</span><span class="p">()</span>
<span class="go">60198</span>
</pre></div>
</div>
<p>The methods which we have used generalize to all recursively defined
objects: the system of set-theoretic equations can be translated into a
system of equations on the generating function, which enables the
recursive calculation of its coefficients. If the set-theoretic
equations are simple enough (for example, if they only involve Cartesian
products and disjoint unions), the equation for <span class="math">\(C(z)\)</span> is
algebraic. This equation has, in general, no closed-form solution.
However, using <em>confinement</em>, one can deduce a <em>linear</em> differential
equation which <span class="math">\(C(z)\)</span> satisfies. This differential equation, in
turn, can be translated into a recurrence relation of fixed length on
its coefficients <span class="math">\(c_n\)</span>. In this case, the series is called
<em>D-finite</em>. After the initial calculation of this recurrence relation,
the calculation of coefficients is very fast. All these steps are purely
algorithmic, and it is planned to port into <code class="docutils literal"><span class="pre">Sage</span></code> the implementations
which exist in <code class="docutils literal"><span class="pre">Maple</span></code> (the <code class="docutils literal"><span class="pre">gfun</span></code> and <code class="docutils literal"><span class="pre">combstruct</span></code> packages) or
<code class="docutils literal"><span class="pre">MuPAD-Combinat</span></code> (the <code class="docutils literal"><span class="pre">decomposableObjects</span></code> library).</p>
<p>For the moment, we illustrate this general procedure in the case of
complete binary trees. The generating function <span class="math">\(C(z)\)</span> is a
solution to an algebraic equation <span class="math">\(P(z,C(z)) = 0\)</span>, where
<span class="math">\(P=P(x,y)\)</span> is a polynomial with coefficients in <span class="math">\(\QQ\)</span>.
In the present case, <span class="math">\(P=y^2-y+x\)</span>. We formally differentiate this
equation with respect to <span class="math">\(z\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;x, y, z&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)(</span><span class="n">z</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">equation</span> <span class="o">=</span>  <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">C</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="gp">sage: </span><span class="n">diff</span><span class="p">(</span><span class="n">equation</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">D[0](C)(z)*D[1](P)(z, C(z)) + D[0](P)(z, C(z)) == 0</span>
</pre></div>
</div>
<p>or, in a more readable format,</p>
<div class="math">
\[\frac{d C(z)}{d z} \frac{\partial P}{\partial y} (z, C(z)) + \frac{\partial P}{\partial x}(z,C(z)) = 0\]</div>
<p>From this we deduce:</p>
<div class="math">
\[\frac{d C(z)}{d z} = - \frac{\frac{\partial P}{\partial x}}{\frac{\partial P}{\partial y}}(z, C(z))\,.\]</div>
<p>In the case of complete binary trees, this gives:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
<span class="gp">sage: </span><span class="n">Px</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="n">Py</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="o">-</span> <span class="n">Px</span> <span class="o">/</span> <span class="n">Py</span>
<span class="go">-1/(2*y - 1)</span>
</pre></div>
</div>
<p>Recall that <span class="math">\(P(z, C(z))=0\)</span>. Thus, we can calculate this fraction
mod <span class="math">\(P\)</span> and, in this way, express the derivative of
<span class="math">\(C(z)\)</span> as a <em>polynomial in</em> <span class="math">\(C(z)\)</span> <em>with coefficients in</em>
<span class="math">\(\QQ(z)\)</span>. In order to achieve this, we construct the quotient
ring <span class="math">\(R= \QQ(x)[y]/ (P)\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Qx</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Qxy</span> <span class="o">=</span> <span class="n">Qx</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">Qxy</span><span class="o">.</span><span class="n">quo</span><span class="p">(</span><span class="n">P</span><span class="p">);</span> <span class="n">R</span>
<span class="go">Univariate Quotient Polynomial Ring in ybar</span>
<span class="go">over Fraction Field of Univariate Polynomial Ring in x</span>
<span class="go">over Rational Field with modulus y^2 - y + x</span>
</pre></div>
</div>
<p>Note: <code class="docutils literal"><span class="pre">ybar</span></code> is the name of the variable <span class="math">\(y\)</span> in the quotient ring.</p>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">add link to some tutorial on quotient rings</p>
</div>
<p>We continue the calculation of this fraction in <span class="math">\(R\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fraction</span> <span class="o">=</span> <span class="o">-</span> <span class="n">R</span><span class="p">(</span><span class="n">Px</span><span class="p">)</span> <span class="o">/</span> <span class="n">R</span><span class="p">(</span><span class="n">Py</span><span class="p">);</span> <span class="n">fraction</span>
<span class="go">(1/2/(x - 1/4))*ybar - 1/4/(x - 1/4)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The following variant does not work yet:</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fraction</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span> <span class="o">-</span> <span class="n">Px</span> <span class="o">/</span> <span class="n">Py</span> <span class="p">);</span> <span class="n">fraction</span>   <span class="c1"># todo: not implemented</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">denominator must be a unit</span>
</pre></div>
</div>
</div>
<p>We lift the result to <span class="math">\(\QQ(x)[y]\)</span> and then substitute
<span class="math">\(z\)</span> and <span class="math">\(C(z)\)</span> to obtain an expression for
<span class="math">\(\frac{d}{dz}C(z)\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fraction</span> <span class="o">=</span> <span class="n">fraction</span><span class="o">.</span><span class="n">lift</span><span class="p">();</span> <span class="n">fraction</span>
<span class="go">(1/2/(x - 1/4))*y - 1/4/(x - 1/4)</span>
<span class="gp">sage: </span><span class="n">fraction</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">C</span><span class="p">)</span>
<span class="go">2*C(z)/(4*z - 1) - 1/(4*z - 1)</span>
</pre></div>
</div>
<p>or, more legibly,</p>
<div class="math">
\[\frac{\partial C(z)}{\partial z} = \frac{1}{1-4z} -\frac{2}{1-4z}C(z)\,.\]</div>
<p>In this simple case, we can directly deduce from this expression a
linear differential equation with coefficients in <span class="math">\(\QQ[z]\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">equadiff</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="n">fraction</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">C</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">equadiff</span>
<span class="go">D[0](C)(z) == 2*C(z)/(4*z - 1) - 1/(4*z - 1)</span>
<span class="gp">sage: </span><span class="n">equadiff</span> <span class="o">=</span> <span class="n">equadiff</span><span class="o">.</span><span class="n">simplify_rational</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">equadiff</span> <span class="o">=</span> <span class="n">equadiff</span> <span class="o">*</span> <span class="n">equadiff</span><span class="o">.</span><span class="n">rhs</span><span class="p">()</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">equadiff</span> <span class="o">=</span> <span class="n">equadiff</span> <span class="o">-</span> <span class="n">equadiff</span><span class="o">.</span><span class="n">rhs</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">equadiff</span>
<span class="go">(4*z - 1)*D[0](C)(z) - 2*C(z) + 1 == 0</span>
</pre></div>
</div>
<p>or, more legibly,</p>
<div class="math">
\[(1-4z) \frac{\partial C(z)}{\partial z} + 2 C(z) - 1 = 0\,.\]</div>
<p>It is trivial to verify this equation on the closed form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Cf</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">symbolic</span><span class="o">.</span><span class="n">function_factory</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">equadiff</span><span class="o">.</span><span class="n">substitute_function</span><span class="p">(</span><span class="n">Cf</span><span class="p">,</span> <span class="n">s0</span><span class="p">)</span>
<span class="go">doctest:...: DeprecationWarning:...</span>
<span class="go">(4*z - 1)/sqrt(-4*z + 1) + sqrt(-4*z + 1) == 0</span>
<span class="gp">sage: </span><span class="nb">bool</span><span class="p">(</span><span class="n">equadiff</span><span class="o">.</span><span class="n">substitute_function</span><span class="p">(</span><span class="n">Cf</span><span class="p">,</span> <span class="n">s0</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In the general case, one continues to calculate successive derivatives
of <span class="math">\(C(z)\)</span>. These derivatives are <em>confined</em> in the quotient ring
<span class="math">\(\QQ(z)[C]/(P)\)</span> which is of finite dimension <span class="math">\(\deg P\)</span>
over <span class="math">\(\QQ(z)\)</span>. Therefore, one will eventually find a linear
relation among the first <span class="math">\(\deg P\)</span> derivatives of <span class="math">\(C(z)\)</span>.
Putting it over a single denominator, we obtain a linear
differential equation of degree <span class="math">\(\leq \deg P\)</span> with coefficients
in <span class="math">\(\QQ[z]\)</span>. By extracting the coefficient of <span class="math">\(z^n\)</span> in
the differential equation, we obtain the desired recurrence relation on
the coefficients; in this case we recover the relation we had already
found, based on the closed form:</p>
<div class="math">
\[c_{n+1}=\frac{(4n-2)}{n+1}c_n\]</div>
<p>After fixing the correct initial conditions, it becomes possible to
calculate the coefficients of <span class="math">\(C(z)\)</span> recursively:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">6</span><span class="p">)</span><span class="o">/</span><span class="n">n</span> <span class="o">*</span> <span class="n">C</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span> <span class="n">C</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[1, 1, 1, 2, 5, 14, 42, 132, 429, 1430]</span>
</pre></div>
</div>
<p>If <span class="math">\(n\)</span> is too large for the explicit calculation of
<span class="math">\(c_n\)</span>, a sequence asymptotically equivalent to the sequence of
coefficients <span class="math">\(c_n\)</span> may be sought. Here again, there are generic
techniques. The central tool is complex analysis, specifically, the
study of the generating function around its singularities. In the
present instance, the singularity is at <span class="math">\(z_0=1/4\)</span> and one would
obtain <span class="math">\(c_n \sim \frac{4^n}{n^{3/2}\sqrt{\pi}}\)</span>.</p>
<div class="section" id="summary">
<h4>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h4>
<p>We see here a general phenomenon of computer algebra: the best <em>data
structure</em> to describe a complicated mathematical object (a real number,
a sequence, a formal power series, a function, a set) is often an
equation defining the object (or a system of equations, typically with
some initial conditions). Attempting to find a closed-form
solution to this equation is not necessarily of interest: on the one
hand, such a closed form rarely exists (e.g., the problem of
solving a polynomial by radicals), and on the other hand, the equation,
in itself, contains all the necessary information to calculate
algorithmically the properties of the object under consideration (e.g.,
a numerical approximation, the initial terms or elements, an asymptotic
equivalent), or to calculate with the object itself (e.g., performing
arithmetic on power series). Therefore, instead of solving the equation,
we look for the equation describing the object which is best suited to
the problem we want to solve.</p>
<p>As we saw in our example, confinement (for example, in a finite
dimensional vector space) is a fundamental tool for studying such
equations. This notion of confinement is widely applicable in
elimination techniques (linear algebra, Gröbner bases, and their
algebro-differential generalizations). The same tool is central in
algorithms for automatic summation and automatic verification of
identities (Gosper’s algorithm, Zeilberger’s algorithm, and their
generalizations; see also <a class="reference internal" href="#exercise-alternating-sign-matrices"><span class="std std-ref">Exercise: alternating sign matrices</span></a>).</p>
<p>All these techniques and their many generalizations are at the heart of
very active topics of research: automatic combinatorics and analytic
combinatorics, with major applications in the analysis of algorithms. It is
likely, and desirable, that they will be progressively implemented in
<code class="docutils literal"><span class="pre">Sage</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="common-enumerated-sets">
<span id="section-bricks"></span><h2>Common enumerated sets<a class="headerlink" href="#common-enumerated-sets" title="Permalink to this headline">¶</a></h2>
<div class="section" id="first-example-the-subsets-of-a-set">
<h3>First example: the subsets of a set<a class="headerlink" href="#first-example-the-subsets-of-a-set" title="Permalink to this headline">¶</a></h3>
<p>Fix a set <span class="math">\(E\)</span> of size <span class="math">\(n\)</span> and consider the subsets of
<span class="math">\(E\)</span> of size <span class="math">\(k\)</span>. We know that these subsets are counted
by the binomial coefficients <span class="math">\(\binom n k\)</span>. We can therefore
calculate the number of subsets of size <span class="math">\(k=2\)</span> of
<span class="math">\(E=\{1,2,3,4\}\)</span> with the function <code class="docutils literal"><span class="pre">binomial</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">binomial</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">6</span>
</pre></div>
</div>
<p>Alternatively, we can <em>construct</em> the set <span class="math">\(\mathcal P_2(E)\)</span> of
all the subsets of size <span class="math">\(2\)</span> of <span class="math">\(E\)</span>, then ask its
cardinality:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<p>Once <code class="docutils literal"><span class="pre">S</span></code> has been constructed, we can also obtain the list of its
elements:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[{1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4}]</span>
</pre></div>
</div>
<p>or select an element at random:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>                 <span class="c1"># random</span>
<span class="go">{1, 4}</span>
</pre></div>
</div>
<p>More precisely, the object <code class="docutils literal"><span class="pre">S</span></code> models the set
<span class="math">\(\mathcal P_2(E)\)</span> equipped with a fixed order (here,
lexicographic order). It is therefore possible to ask for its
<span class="math">\(5\)</span>-th element, keeping in mind that, as with <code class="docutils literal"><span class="pre">Python</span></code> lists, the first
element is numbered zero:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">unrank</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">{2, 4}</span>
</pre></div>
</div>
<p>As a shortcut, in this setting, one can also use the notation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="go">{2, 4}</span>
</pre></div>
</div>
<p>but this should be used with care because some sets have a
natural indexing other than by <span class="math">\((0, 1, \dots)\)</span>.</p>
<p>Conversely, one can calculate the position of an object in this order:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">S</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]);</span> <span class="n">s</span>
<span class="go">{2, 4}</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal"><span class="pre">S</span></code> is <em>not</em> the list of its elements. One can, for example,
model the set <span class="math">\(\mathcal P(\mathcal P(\mathcal P(E)))\)</span> and
calculate its cardinality (<span class="math">\(2^{2^{2^4}}\)</span>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Subsets</span><span class="p">(</span><span class="n">Subsets</span><span class="p">(</span><span class="n">Subsets</span><span class="p">(</span><span class="n">E</span><span class="p">)));</span> <span class="n">S</span>
<span class="go">Subsets of Subsets of Subsets of {1, 2, 3, 4}</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">cardinality</span><span class="p">();</span> <span class="n">n</span>
<span class="go">2003529930406846464979072351560255750447825475569751419265016973...</span>
</pre></div>
</div>
<p>which is roughly <span class="math">\(2\cdot 10^{19728}\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span><span class="o">.</span><span class="n">ndigits</span><span class="p">()</span>
<span class="go">19729</span>
</pre></div>
</div>
<p>or ask for its <span class="math">\(237102124\)</span>-th element:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">unrank</span><span class="p">(</span><span class="mi">237102123</span><span class="p">)</span>
<span class="go">{{{2, 4}, {1, 4}, {}, {1, 3, 4}, {1, 2, 4}, {4}, {2, 3}, {1, 3}, {2}},</span>
<span class="go">  {{1, 3}, {2, 4}, {1, 2, 4}, {}, {3, 4}}}</span>
</pre></div>
</div>
<p>It would be physically impossible to construct explicitly all the
elements of <span class="math">\(S\)</span>, as there are many more of them than there are
particles in the universe (estimated at <span class="math">\(10^{82}\)</span>).</p>
<p>Remark: it would be natural in <code class="docutils literal"><span class="pre">Python</span></code> to use <code class="docutils literal"><span class="pre">len(S)</span></code> to ask for the
cardinality of <code class="docutils literal"><span class="pre">S</span></code>. This is not possible because <code class="docutils literal"><span class="pre">Python</span></code> requires that the
result of <code class="docutils literal"><span class="pre">len</span></code> be an integer of type <code class="docutils literal"><span class="pre">int</span></code>; this could cause
overflows, and would not permit the return of {Infinity} for infinite
sets:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">OverflowError</span>: <span class="n">Python int too large to convert to C long</span>
</pre></div>
</div>
</div>
<div class="section" id="partitions-of-integers">
<h3>Partitions of integers<a class="headerlink" href="#partitions-of-integers" title="Permalink to this headline">¶</a></h3>
<p>We now consider another classic problem: given a positive integer
<span class="math">\(n\)</span>, in how many ways can it be written in the form of a sum
<span class="math">\(n=i_1+i_2+\dots+i_\ell\)</span>, where <span class="math">\(i_1,\dots,i_\ell\)</span> are
positive integers? There are two cases to distinguish:</p>
<ul class="simple">
<li>the order of the elements in the sum is not important, in which case
we call <span class="math">\((i_1,\dots,i_\ell)\)</span> a <em>partition</em> of <span class="math">\(n\)</span>;</li>
<li>the order of the elements in the sum is important, in which case we
call <span class="math">\((i_1,\dots,i_\ell)\)</span> a <em>composition</em> of <span class="math">\(n\)</span>.</li>
</ul>
<p>We will begin with the partitions of <span class="math">\(n=5\)</span>; as before, we begin
by constructing the set of these partitions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P5</span> <span class="o">=</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="n">P5</span>
<span class="go">Partitions of the integer 5</span>
</pre></div>
</div>
<p>then we ask for its cardinality:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P5</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">7</span>
</pre></div>
</div>
<p>We look at these <span class="math">\(7\)</span> partitions; the order being irrelevant, the
entries are ordered, by convention, in decreasing order.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P5</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[5], [4, 1], [3, 2], [3, 1, 1], [2, 2, 1], [2, 1, 1, 1],</span>
<span class="go"> [1, 1, 1, 1, 1]]</span>
</pre></div>
</div>
<p>The calculation of the number of partitions uses the Rademacher
formula (<a class="reference external" href="https://en.wikipedia.org/wiki/Partition_(number_theory)">Wikipedia article Partition_(number_theory)</a>), implemented in <code class="docutils literal"><span class="pre">C</span></code>
and highly optimized, which makes it very fast:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Partitions</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">27493510569775696512677516320986352688173429315980054758203125984302147328114964173055050741660736621590157844774296248940493063070200461792764493033510116079342457190155718943509725312466108452006369558934464248716828789832182345009262853831404597021307130674510624419227311238999702284408609370935531629697851569569892196108480158600569421098519</span>
</pre></div>
</div>
<p>Partitions of integers are combinatorial objects naturally equipped with
many operations. They are therefore returned as objects that are
richer than simple lists:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P7</span> <span class="o">=</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">P7</span><span class="o">.</span><span class="n">unrank</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="n">p</span>
<span class="go">[4, 2, 1]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.combinat.partition.Partitions_n_with_category.element_class&#39;&gt;</span>
</pre></div>
</div>
<p>For example, they can be represented graphically by a Ferrers diagram:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">ferrers_diagram</span><span class="p">())</span>
<span class="go">****</span>
<span class="go">**</span>
<span class="go">*</span>
</pre></div>
</div>
<p>We leave it to the user to explore by introspection the available
operations.</p>
<p>Note that we can also construct a partition directly by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Partition</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[4, 2, 1]</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P7</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[4, 2, 1]</span>
</pre></div>
</div>
<p>If one wants to restrict the possible values of the parts
<span class="math">\(i_1,\dots,i_\ell\)</span> of the partition as, for example, when giving
change, one can use <code class="docutils literal"><span class="pre">WeightedIntegerVectors</span></code>. For example, the
following calculation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">WeightedIntegerVectors</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[0, 1, 1], [1, 2, 0], [4, 0, 0]]</span>
</pre></div>
</div>
<p>shows that to make 8 dollars using 2, 3, and 5 dollar bills, one can
use a 3 and a 5 dollar bill, or a 2 and two 3 dollar bills, or four 2
dollar bills.</p>
<p>Compositions of integers are manipulated the same way:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C5</span> <span class="o">=</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="n">C5</span>
<span class="go">Compositions of 5</span>
<span class="gp">sage: </span><span class="n">C5</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">16</span>
<span class="gp">sage: </span><span class="n">C5</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 1, 2, 1], [1, 1, 3],</span>
<span class="go"> [1, 2, 1, 1], [1, 2, 2], [1, 3, 1], [1, 4], [2, 1, 1, 1],</span>
<span class="go"> [2, 1, 2], [2, 2, 1], [2, 3], [3, 1, 1], [3, 2], [4, 1], [5]]</span>
</pre></div>
</div>
<p>The number <span class="math">\(16\)</span> above seems significant and suggests the existence of a
formula. We look at the number of compositions of <span class="math">\(n\)</span> ranging
from <span class="math">\(0\)</span> to <span class="math">\(9\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span> <span class="n">Compositions</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[1, 1, 2, 4, 8, 16, 32, 64, 128, 256]</span>
</pre></div>
</div>
<p>Similarly, if we consider the number of compositions of <span class="math">\(5\)</span> by
length, we find a line of Pascal’s triangle:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span> <span class="n">x</span><span class="o">^</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">C5</span> <span class="p">)</span>
<span class="go">x^5 + 4*x^4 + 6*x^3 + 4*x^2 + x</span>
</pre></div>
</div>
<p>The above example uses a functionality which we have not seen yet:
<code class="docutils literal"><span class="pre">C5</span></code> being iterable, it can be used like a list in a <code class="docutils literal"><span class="pre">for</span></code> loop or
a comprehension (<a class="reference internal" href="#section-bricks-iterators"><span class="std std-ref">Set comprehension and iterators</span></a>).</p>
<blockquote>
<div>Prove the formulas suggested by the above examples for the number of
compositions of <span class="math">\(n\)</span> and the number of compositions of
<span class="math">\(n\)</span> of length <span class="math">\(k\)</span>; investigate by introspection
whether <code class="docutils literal"><span class="pre">Sage</span></code> uses these formulas for calculating cardinalities.</div></blockquote>
</div>
<div class="section" id="some-other-finite-enumerated-sets">
<span id="section-bricks-divers"></span><h3>Some other finite enumerated sets<a class="headerlink" href="#some-other-finite-enumerated-sets" title="Permalink to this headline">¶</a></h3>
<p>Essentially, the principle is the same for all the finite sets with
which one wants to do combinatorics in <code class="docutils literal"><span class="pre">Sage</span></code>; begin by constructing
an object which models this set, and then supply appropriate methods,
following a uniform interface <a class="footnote-reference" href="#id6" id="id2">[1]</a>. We now give a few more typical
examples.</p>
<p>Intervals of integers:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">IntegerRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="n">C</span>
<span class="go">{3, 5, ..., 19}</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">9</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[3, 5, 7, 9, 11, 13, 15, 17, 19]</span>
</pre></div>
</div>
<p>Permutations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Permutations</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">C</span>
<span class="go">Standard permutations of 4</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">24</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[1, 2, 3, 4], [1, 2, 4, 3], [1, 3, 2, 4], [1, 3, 4, 2],</span>
<span class="go"> [1, 4, 2, 3], [1, 4, 3, 2], [2, 1, 3, 4], [2, 1, 4, 3],</span>
<span class="go"> [2, 3, 1, 4], [2, 3, 4, 1], [2, 4, 1, 3], [2, 4, 3, 1],</span>
<span class="go"> [3, 1, 2, 4], [3, 1, 4, 2], [3, 2, 1, 4], [3, 2, 4, 1],</span>
<span class="go"> [3, 4, 1, 2], [3, 4, 2, 1], [4, 1, 2, 3], [4, 1, 3, 2],</span>
<span class="go"> [4, 2, 1, 3], [4, 2, 3, 1], [4, 3, 1, 2], [4, 3, 2, 1]]</span>
</pre></div>
</div>
<p>Set partitions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">SetPartitions</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">Set partitions of {1, 2, 3}</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[{{1, 2, 3}}, {{1}, {2, 3}}, {{1, 3}, {2}}, {{1, 2}, {3}},</span>
<span class="go"> {{1}, {2}, {3}}]</span>
</pre></div>
</div>
<p>Partial orders on a set of <span class="math">\(8\)</span> elements, up to isomorphism:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span> <span class="n">C</span>
<span class="go">Posets containing 8 elements</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">16999</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">unrank</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Graphics object consisting of 20 graphics primitives</span>
</pre></div>
</div>
<img alt="../../_images/a_poset.png" src="../../_images/a_poset.png" />
<p>One can iterate through all graphs up to isomorphism. For example,
there are 34 simple graphs with 5 vertices:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">graphs</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="go">34</span>
</pre></div>
</div>
<p>Here are those with at most <span class="math">\(4\)</span> edges:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">up_to_four_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graphs</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">G</span><span class="p">:</span> <span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">pretty_print</span><span class="p">(</span><span class="o">*</span><span class="n">up_to_four_edges</span><span class="p">)</span>
</pre></div>
</div>
<img alt="../../_images/graphs-5.png" src="../../_images/graphs-5.png" />
<p>However, the <em>set</em> <code class="docutils literal"><span class="pre">C</span></code> of these graphs is not yet available in
<code class="docutils literal"><span class="pre">Sage</span></code>; as a result, the following commands are not yet
implemented:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Graphs</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>                 <span class="c1"># todo: not implemented</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>               <span class="c1"># todo: not implemented</span>
<span class="go">34</span>
<span class="gp">sage: </span><span class="n">Graphs</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>      <span class="c1"># todo: not implemented</span>
<span class="go">24637809253125004524383007491432768</span>
<span class="gp">sage: </span><span class="n">Graphs</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>   <span class="c1"># todo: not implemented</span>
<span class="go">Graph on 19 vertices</span>
</pre></div>
</div>
<p>What we have seen so far also applies, in principle, to finite algebraic
structures like the dihedral groups:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DihedralGroup</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">G</span>
<span class="go">Dihedral group of order 8 as a permutation group</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">8</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[(), (1,4)(2,3), (1,2,3,4), (1,3)(2,4), (1,3), (2,4), (1,4,3,2), (1,2)(3,4)]</span>
</pre></div>
</div>
<p>or the algebra of <span class="math">\(2\times 2\)</span> matrices over the finite field
<span class="math">\(\ZZ/2\ZZ\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">MatrixSpace</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">[0 0]  [1 0]  [0 1]  [0 0]  [0 0]  [1 1]  [1 0]  [1 0]  [0 1]  [0 1]</span>
<span class="go">[0 0], [0 0], [0 0], [1 0], [0 1], [0 0], [1 0], [0 1], [1 0], [0 1],</span>

<span class="go">[0 0]  [1 1]  [1 1]  [1 0]  [0 1]  [1 1]</span>
<span class="go">[1 1], [1 0], [0 1], [1 1], [1 1], [1 1]</span>
<span class="go">]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">16</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">Exercise</p>
<p>List all the monomials of degree <span class="math">\(5\)</span> in three variables (see
<code class="docutils literal"><span class="pre">IntegerVectors</span></code>). Manipulate the ordered set partitions
<code class="docutils literal"><span class="pre">OrderedSetPartitions</span></code> and standard tableaux
(<code class="docutils literal"><span class="pre">StandardTableaux</span></code>).</p>
</div>
<div class="topic" id="exercise-alternating-sign-matrices">
<p class="topic-title first">Exercise</p>
<p>List the alternating sign matrices of size <span class="math">\(3\)</span>, <span class="math">\(4\)</span>,
and <span class="math">\(5\)</span> (<code class="docutils literal"><span class="pre">AlternatingSignMatrices</span></code>), and try to guess the
definition. The discovery and proof of the formula for the
enumeration of these matrices (see the method <code class="docutils literal"><span class="pre">cardinality</span></code>),
motivated by calculations of determinants in physics, is quite a
story. In particular, the first proof, given by Zeilberger in 1992
was automatically produced by a computer program.  It was 84 pages long,
and required nearly a hundred people to verify it.</p>
</div>
<div class="topic">
<p class="topic-title first">Exercise</p>
<p>Calculate by hand the number of vectors in <span class="math">\((\ZZ/2\ZZ)^5\)</span>, and
the number of matrices in <span class="math">\(GL_3(\ZZ/2\ZZ)\)</span> (that is to say,
the number of invertible <span class="math">\(3\times 3\)</span> matrices with
coefficients in <span class="math">\(\ZZ/2\ZZ\)</span>). Verify your answer with <code class="docutils literal"><span class="pre">Sage</span></code>.
Generalize to <span class="math">\(GL_n(\ZZ/q\ZZ)\)</span>.</p>
</div>
</div>
<div class="section" id="set-comprehension-and-iterators">
<span id="section-bricks-iterators"></span><h3>Set comprehension and iterators<a class="headerlink" href="#set-comprehension-and-iterators" title="Permalink to this headline">¶</a></h3>
<p>We will now show some of the possibilities offered by <code class="docutils literal"><span class="pre">Python</span></code> for
constructing (and iterating through) sets, with a notation that is
flexible and close to usual mathematical usage, and in particular the
benefits this yields in combinatorics.</p>
<p>We begin by constructing the finite set
<span class="math">\(\{i^2\ \|\ i \in \{1,3,7\}\}\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span> <span class="n">i</span><span class="o">^</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span> <span class="p">]</span>
<span class="go">[1, 9, 49]</span>
</pre></div>
</div>
<p>and then the same set, but with <span class="math">\(i\)</span> running from <span class="math">\(1\)</span> to
<span class="math">\(9\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span> <span class="n">i</span><span class="o">^</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span>
</pre></div>
</div>
<p>A construction of this form in <code class="docutils literal"><span class="pre">Python</span></code> is called <em>set comprehension</em>.
A clause can be added to keep only those elements with <span class="math">\(i\)</span> prime:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span> <span class="n">i</span><span class="o">^</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[4, 9, 25, 49]</span>
</pre></div>
</div>
<p>Combining more than one set comprehension, it is possible to construct
the set <span class="math">\(\{(i,j) \ | \ 1\leq j &lt; i &lt;5\}\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[(2, 1), (3, 1), (3, 2), (4, 1), (4, 2), (4, 3),</span>
<span class="go"> (5, 1), (5, 2), (5, 3), (5, 4)]</span>
</pre></div>
</div>
<p>or to produce Pascal’s triangle:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[[</span><span class="n">binomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[[1],</span>
<span class="go"> [1, 1],</span>
<span class="go"> [1, 2, 1],</span>
<span class="go"> [1, 3, 3, 1],</span>
<span class="go"> [1, 4, 6, 4, 1],</span>
<span class="go"> [1, 5, 10, 10, 5, 1],</span>
<span class="go"> [1, 6, 15, 20, 15, 6, 1],</span>
<span class="go"> [1, 7, 21, 35, 35, 21, 7, 1],</span>
<span class="go"> [1, 8, 28, 56, 70, 56, 28, 8, 1],</span>
<span class="go"> [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]]</span>
</pre></div>
</div>
<p>The execution of a set comprehension is accomplished in two steps; first
an <em>iterator</em> is constructed, and then a list is filled with the
elements successively produced by the iterator. Technically, an
<em>iterator</em> is an object with a method <code class="docutils literal"><span class="pre">next</span></code> which returns a new value
each time it is called, until it is exhausted. For example, the
following iterator <code class="docutils literal"><span class="pre">it</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="p">(</span><span class="n">binomial</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p>returns successively the binomial coefficients <span class="math">\(\binom 3 i\)</span> with
<span class="math">\(i=0,1,2,3\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>When the iterator is finally exhausted, an exception is raised:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p>More generally, an <em>iterable</em> is a <code class="docutils literal"><span class="pre">Python</span></code> object <code class="docutils literal"><span class="pre">L</span></code> (a list,
a set, ...) over whose elements it is possible to iterate. Technically,
the iterator is constructed by <code class="docutils literal"><span class="pre">iter(L)</span></code>. In practice, the commands
<code class="docutils literal"><span class="pre">iter</span></code> and <code class="docutils literal"><span class="pre">next</span></code> are used very rarely, since <code class="docutils literal"><span class="pre">for</span></code> loops and list
comprehensions provide a much pleasanter syntax:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="go">....:     print(s)</span>
<span class="go">{}</span>
<span class="go">{1}</span>
<span class="go">{2}</span>
<span class="go">{3}</span>
<span class="go">{1, 2}</span>
<span class="go">{1, 3}</span>
<span class="go">{2, 3}</span>
<span class="go">{1, 2, 3}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span> <span class="n">s</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[0, 1, 1, 1, 2, 2, 2, 3]</span>
</pre></div>
</div>
<p>What is the point of an iterator? Consider the following example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span> <span class="p">[</span> <span class="n">binomial</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="p">]</span> <span class="p">)</span>
<span class="go">256</span>
</pre></div>
</div>
<p>When it is executed, a list of <span class="math">\(9\)</span> elements is constructed, and
then it is passed as an argument to <code class="docutils literal"><span class="pre">sum</span></code> to add them up. If, on the
other hand, the iterator is passed directly to <code class="docutils literal"><span class="pre">sum</span></code> (note the absence
of square brackets):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span> <span class="n">binomial</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="p">)</span>
<span class="go">256</span>
</pre></div>
</div>
<p>the function <code class="docutils literal"><span class="pre">sum</span></code> receives the iterator directly, and can
short-circuit the construction of the intermediate list. If there are a
large number of elements, this avoids allocating a large quantity of
memory to fill a list which will be immediately destroyed <a class="footnote-reference" href="#id7" id="id3">[2]</a>.</p>
<p>Most functions that take a list of elements as input will also accept
an iterator (or an iterable) instead. To begin with, one can obtain the
list (or the tuple) of elements of an iterator as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">binomial</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="go">[1, 8, 28, 56, 70, 56, 28, 8, 1]</span>
<span class="gp">sage: </span><span class="nb">tuple</span><span class="p">(</span><span class="n">binomial</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="go">(1, 8, 28, 56, 70, 56, 28, 8, 1)</span>
</pre></div>
</div>
<p>We now consider the functions <code class="docutils literal"><span class="pre">all</span></code> and <code class="docutils literal"><span class="pre">any</span></code> which denote
respectively the <span class="math">\(n\)</span>-ary <em>and</em> and <em>or</em>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">([</span><span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">([</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">any</span><span class="p">([</span><span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">any</span><span class="p">([</span><span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The following example verifies that all primes from <span class="math">\(3\)</span> to
<span class="math">\(99\)</span> are odd:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">is_odd</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A <em>Mersenne prime</em> is a prime of the form <span class="math">\(2^p -1\)</span>. We verify
that, for <span class="math">\(p&lt;1000\)</span>, if <span class="math">\(2^p-1\)</span> is prime, then
<span class="math">\(p\)</span> is also prime:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">mersenne</span><span class="p">(</span><span class="n">p</span><span class="p">):</span> <span class="k">return</span> <span class="mi">2</span><span class="o">^</span><span class="n">p</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">sage: </span><span class="p">[</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">....:   for p in range(1000) if is_prime(mersenne(p)) ]</span>
<span class="go">[True, True, True, True, True, True, True, True, True, True,</span>
<span class="go"> True, True, True, True]</span>
</pre></div>
</div>
<p>Is the converse true?</p>
<div class="topic">
<p class="topic-title first">Exercise</p>
<p>Try the two following commands and explain the considerable
difference in the length of the calculations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span>   <span class="n">is_prime</span><span class="p">(</span><span class="n">mersenne</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="go">....:        for p in range(1000) if is_prime(p)  )</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="p">[</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">mersenne</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="go">....:        for p in range(1000) if is_prime(p)] )</span>
<span class="go">False</span>
</pre></div>
</div>
</div>
<p>We now try to find the smallest counter-example. In order to do this, we
use the <code class="docutils literal"><span class="pre">Sage</span></code> function <code class="docutils literal"><span class="pre">exists</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">exists</span><span class="p">(</span> <span class="p">(</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">p</span><span class="p">)),</span>
<span class="go">....:         lambda p: not is_prime(mersenne(p)) )</span>
<span class="go">(True, 11)</span>
</pre></div>
</div>
<p>Alternatively, we could construct an iterator on the counter-examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">counter_examples</span> <span class="o">=</span> \
<span class="go">....:   (p for p in range(1000)</span>
<span class="go">....:      if is_prime(p) and not is_prime(mersenne(p)))</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">counter_examples</span><span class="p">)</span>
<span class="go">11</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">counter_examples</span><span class="p">)</span>
<span class="go">23</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">Exercise</p>
<p>What do the following commands do?</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cubes</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">999</span><span class="p">,</span><span class="mi">1000</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">exists</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cubes</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">cubes</span><span class="p">],</span>  <span class="c1"># long time (3s, 2012)</span>
<span class="go">....:        lambda x_y: x_y[0] + x_y[1] == 218)</span>
<span class="go">(True, (-125, 343))</span>
<span class="gp">sage: </span><span class="n">exists</span><span class="p">(((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cubes</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">cubes</span><span class="p">),</span>  <span class="c1"># long time (2s, 2012)</span>
<span class="go">....:        lambda x_y: x_y[0] + x_y[1] == 218)</span>
<span class="go">(True, (-125, 343))</span>
</pre></div>
</div>
<p>Which of the last two is more economical in terms of time? In terms
of memory? By how much?</p>
</div>
<div class="topic">
<p class="topic-title first">Exercise</p>
<p>Try each of the following commands, and explain its result. If
possible, hide the result first and try to guess it before
launching the command.</p>
<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">hide the results by default</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">it will be necessary to interrupt the execution of some of the commands</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span> <span class="n">x</span><span class="o">^</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="p">)</span>
<span class="go">x^8 + 8*x^7 + 28*x^6 + 56*x^5 + 70*x^4 + 56*x^3 + 28*x^2 + 8*x + 1</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span> <span class="n">x</span><span class="o">^</span><span class="n">p</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Permutations</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">x^3 + 2*x^2 + 2*x + 1</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">factor</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span> <span class="n">x</span><span class="o">^</span><span class="n">p</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Permutations</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">))</span>
<span class="go">(x^2 + x + 1)*(x + 1)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Permutations</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">GL</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="k">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="go">[1 0]</span>
<span class="go">[0 1]</span>

<span class="go">[0 1]</span>
<span class="go">[1 0]</span>

<span class="go">[0 1]</span>
<span class="go">[1 1]</span>

<span class="go">[1 1]</span>
<span class="go">[0 1]</span>

<span class="go">[1 1]</span>
<span class="go">[1 0]</span>

<span class="go">[1 0]</span>
<span class="go">[1 1]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>   <span class="c1"># not tested</span>
<span class="go">[3]</span>
<span class="go">[2, 1]</span>
<span class="go">[1, 1, 1]</span>
<span class="gp">...</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">():</span> <span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>    <span class="c1"># not tested</span>
<span class="go">[]</span>
<span class="go">[1]</span>
<span class="go">[2]</span>
<span class="go">[1, 1]</span>
<span class="go">[3]</span>
<span class="gp">...</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Primes</span><span class="p">():</span> <span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>        <span class="c1"># not tested</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">5</span>
<span class="go">7</span>
<span class="gp">...</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">exists</span><span class="p">(</span> <span class="n">Primes</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="ow">not</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">mersenne</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">)</span>
<span class="go">(True, 11)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">counter_examples</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Primes</span><span class="p">()</span>
<span class="go">....:                    if not is_prime(mersenne(p)))</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">counter_examples</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>   <span class="c1"># not tested</span>
<span class="go">11</span>
<span class="go">23</span>
<span class="go">29</span>
<span class="go">37</span>
<span class="go">41</span>
<span class="go">43</span>
<span class="go">47</span>
<span class="gp">...</span>
</pre></div>
</div>
</div>
<div class="section" id="operations-on-iterators">
<h4>Operations on iterators<a class="headerlink" href="#operations-on-iterators" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal"><span class="pre">Python</span></code> provides numerous tools for manipulating iterators; most of them
are in the <code class="docutils literal"><span class="pre">itertools</span></code> library, which can be imported by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">itertools</span>
</pre></div>
</div>
<p>We will demonstrate some applications, taking as a starting point the
permutations of <span class="math">\(3\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Permutations</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">[[1, 2, 3], [1, 3, 2], [2, 1, 3],</span>
<span class="go"> [2, 3, 1], [3, 1, 2], [3, 2, 1]]</span>
</pre></div>
</div>
<p>We can list the elements of a set by numbering them:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">Permutations</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span>
<span class="go">[(0, [1, 2, 3]), (1, [1, 3, 2]), (2, [2, 1, 3]),</span>
<span class="go"> (3, [2, 3, 1]), (4, [3, 1, 2]), (5, [3, 2, 1])]</span>
</pre></div>
</div>
<p>select only the elements in positions 2, 3, and 4 (analogue of
<code class="docutils literal"><span class="pre">l[1:4]</span></code>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">itertools</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">Permutations</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">[[1, 3, 2], [2, 1, 3], [2, 3, 1]]</span>
</pre></div>
</div>
<p>apply a function to all the elements:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">z</span><span class="o">.</span><span class="n">cycle_type</span><span class="p">(),</span>
<span class="go">....:                     Permutations(3)))</span>
<span class="go">[[1, 1, 1], [2, 1], [2, 1], [3], [3], [2, 1]]</span>
</pre></div>
</div>
<p>or select the elements satisfying a certain condition:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">ifilter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">z</span><span class="o">.</span><span class="n">has_pattern</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span>
<span class="go">....:                        Permutations(3)))</span>
<span class="go">[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2]]</span>
</pre></div>
</div>
<p>In all these situations, <code class="docutils literal"><span class="pre">attrcall</span></code> can be an advantageous alternative
to creating an anonymous function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">z</span><span class="o">.</span><span class="n">cycle_type</span><span class="p">(),</span>
<span class="go">....:                     Permutations(3)))</span>
<span class="go">[[1, 1, 1], [2, 1], [2, 1], [3], [3], [2, 1]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;cycle_type&quot;</span><span class="p">),</span>
<span class="go">....:                     Permutations(3)))</span>
<span class="go">[[1, 1, 1], [2, 1], [2, 1], [3], [3], [2, 1]]</span>
</pre></div>
</div>
</div>
<div class="section" id="implementation-of-new-iterators">
<h4>Implementation of new iterators<a class="headerlink" href="#implementation-of-new-iterators" title="Permalink to this headline">¶</a></h4>
<p>It is easy to construct new iterators, using the keyword <code class="docutils literal"><span class="pre">yield</span></code>
instead of <code class="docutils literal"><span class="pre">return</span></code> in a function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="go">....:     for i in range(n):</span>
<span class="go">....:         yield i</span>
</pre></div>
</div>
<p>After the <code class="docutils literal"><span class="pre">yield</span></code>, execution is not halted, but only suspended, ready
to be continued from the same point. The result of the function is
therefore an iterator over the successive values returned by <code class="docutils literal"><span class="pre">yield</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p>The function could be used as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[0, 1, 2, 3, 4]</span>
</pre></div>
</div>
<p>This model of computation, called <em>continuation</em>, is very useful in
combinatorics, especially when combined with recursion. Here is how to
generate all words of a given length on a given alphabet:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">words</span><span class="p">(</span><span class="n">alphabet</span><span class="p">,</span><span class="n">l</span><span class="p">):</span>
<span class="go">....:    if l == 0:</span>
<span class="go">....:        yield []</span>
<span class="go">....:    else:</span>
<span class="go">....:        for word in words(alphabet, l-1):</span>
<span class="go">....:            for l in alphabet:</span>
<span class="go">....:                yield word + [l]</span>
<span class="gp">sage: </span><span class="p">[</span> <span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">words</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;], [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;], [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;],</span>
<span class="go"> [&#39;a&#39;, &#39;b&#39;, &#39;b&#39;], [&#39;b&#39;, &#39;a&#39;, &#39;a&#39;], [&#39;b&#39;, &#39;a&#39;, &#39;b&#39;],</span>
<span class="go"> [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;], [&#39;b&#39;, &#39;b&#39;, &#39;b&#39;]]</span>
</pre></div>
</div>
<p>These words can then be counted by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">words</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="mi">10</span><span class="p">))</span>
<span class="go">1048576</span>
</pre></div>
</div>
<p>Counting the words one by one is clearly not an efficient method in this
case, since the formula <span class="math">\(n^\ell\)</span> is also available; note,
though, that this is not the stupidest possible approach - it does, at
least, avoid constructing the entire list in memory.</p>
<p>We now consider Dyck words, which are well-parenthesized words in the
letters “<span class="math">\((\)</span>” and “<span class="math">\()\)</span>”. The function below generates
all the Dyck words of a given length (where the length is the number of
pairs of parentheses), using the recursive definition which says that a
Dyck word is either empty or of the form <span class="math">\((w_1)w_2\)</span> where
<span class="math">\(w_1\)</span> and <span class="math">\(w_2\)</span> are Dyck words:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">dyck_words</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
<span class="go">....:     if l==0:</span>
<span class="go">....:         yield &#39;&#39;</span>
<span class="go">....:     else:</span>
<span class="go">....:         for k in range(l):</span>
<span class="go">....:             for w1 in dyck_words(k):</span>
<span class="go">....:                 for w2 in dyck_words(l-k-1):</span>
<span class="go">....:                     yield &#39;(&#39;+w1+&#39;)&#39;+w2</span>
</pre></div>
</div>
<p>Here are all the Dyck words of length <span class="math">\(4\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">dyck_words</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">[&#39;()()()()&#39;, &#39;()()(())&#39;, &#39;()(())()&#39;, &#39;()(()())&#39;, &#39;()((()))&#39;,</span>
<span class="go"> &#39;(())()()&#39;, &#39;(())(())&#39;, &#39;(()())()&#39;, &#39;((()))()&#39;, &#39;(()()())&#39;,</span>
<span class="go"> &#39;(()(()))&#39;, &#39;((())())&#39;, &#39;((()()))&#39;, &#39;(((())))&#39;]</span>
</pre></div>
</div>
<p>Counting them, we recover a well-known sequence:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">dyck_words</span><span class="p">(</span><span class="n">l</span><span class="p">))</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862]</span>
</pre></div>
</div>
<div class="topic" id="exo-iterators-catalan">
<p class="topic-title first">Exercise: complete binary tree iterator</p>
<p>Construct an iterator on the set <span class="math">\(C_n\)</span> of complete binary
trees with <span class="math">\(n\)</span> leaves
(see <a class="reference internal" href="#section-examples-catalan"><span class="std std-ref">Enumeration of trees using generating functions</span></a>).</p>
<p>Hint: <code class="docutils literal"><span class="pre">Sage</span></code> 4.8.2 does not yet have a native data structure to
represent complete binary trees. One simple way to represent them is
to define a formal variable <code class="docutils literal"><span class="pre">Leaf</span></code> for the leaves and a formal
2-ary function <code class="docutils literal"><span class="pre">Node</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;Leaf&#39;</span><span class="p">)</span>
<span class="go">Leaf</span>
<span class="gp">sage: </span><span class="n">function</span><span class="p">(</span><span class="s1">&#39;Node&#39;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Node</span>
</pre></div>
</div>
<p>The second tree in <a class="reference internal" href="#figure-examples-catalan-trees"><span class="std std-ref">Figure: The five complete binary trees with four leaves</span></a>
can be represented by the expression:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">tr</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">Leaf</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="n">Leaf</span><span class="p">,</span> <span class="n">Leaf</span><span class="p">)),</span> <span class="n">Leaf</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="constructions">
<span id="section-constructions"></span><h2>Constructions<a class="headerlink" href="#constructions" title="Permalink to this headline">¶</a></h2>
<p>We will now see how to construct new sets starting from these building
blocks. In fact, we have already begun to do this with the construction
of <span class="math">\(\mathcal P(\mathcal P(\mathcal P(\{1,2,3,4\})))\)</span> in the
previous section, and to construct the example of sets of cards in
<a class="reference internal" href="#section-examples"><span class="std std-ref">Initial examples</span></a>.</p>
<p>Consider a large Cartesian product:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">cartesian_product</span><span class="p">([</span><span class="n">Compositions</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">Permutations</span><span class="p">(</span><span class="mi">20</span><span class="p">)]);</span> <span class="n">C</span>
<span class="go">The Cartesian product of (Compositions of 8, Standard permutations of 20)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">311411457046609920000</span>
</pre></div>
</div>
<p>Clearly, it is impractical to construct the list of all the elements of this
Cartesian product! And, in the following example, <span class="math">\(H\)</span> is equipped with the
usual combinatorial operations and also its structure as a product group:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DihedralGroup</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">cartesian_product</span><span class="p">([</span><span class="n">G</span><span class="p">,</span><span class="n">G</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="ow">in</span> <span class="n">Groups</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span>
<span class="go">((1,2,3,4), (1,2,3,4))</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">*</span><span class="n">t</span>
<span class="go">((1,3)(2,4), (1,3)(2,4))</span>
</pre></div>
</div>
<p>We now construct the union of two existing disjoint sets:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">DisjointUnionEnumeratedSets</span><span class="p">(</span>
<span class="go">....:       [ Compositions(4), Permutations(3)] )</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">Disjoint union of Family (Compositions of 4,</span>
<span class="go">Standard permutations of 3)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">14</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2],</span>
<span class="go">[3, 1], [4], [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1],</span>
<span class="go">[3, 1, 2], [3, 2, 1]]</span>
</pre></div>
</div>
<p>It is also possible to take the union of more than two disjoint sets, or
even an infinite number of them. We will now construct the set of all
permutations, viewed as the union of the sets <span class="math">\(P_n\)</span> of
permutations of size <span class="math">\(n\)</span>. We begin by constructing the infinite
family <span class="math">\(F=(P_n)_{n\in N}\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Family</span><span class="p">(</span><span class="n">NonNegativeIntegers</span><span class="p">(),</span> <span class="n">Permutations</span><span class="p">);</span> <span class="n">F</span>
<span class="go">Lazy family (&lt;class &#39;sage.combinat.permutation.Permutations&#39;&gt;(i))_{i in Non negative integers}</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">Non negative integers</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">1000</span><span class="p">]</span>
<span class="go">Standard permutations of 1000</span>
</pre></div>
</div>
<p>Now we can construct the disjoint union <span class="math">\(\bigcup_{n\in \NN}P_n\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">U</span> <span class="o">=</span> <span class="n">DisjointUnionEnumeratedSets</span><span class="p">(</span><span class="n">F</span><span class="p">);</span> <span class="n">U</span>
<span class="go">Disjoint union of</span>
<span class="go">Lazy family (&lt;class &#39;sage.combinat.permutation.Permutations&#39;&gt;(i))_{i in Non negative integers}</span>
</pre></div>
</div>
<p>It is an infinite set:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">U</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">+Infinity</span>
</pre></div>
</div>
<p>which doesn’t prohibit iteration through its elements, though it will be
necessary to interrupt it at some point:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">U</span><span class="p">:</span>                <span class="c1"># not tested</span>
<span class="go">....:     print(p)</span>
<span class="go">[]</span>
<span class="go">[1]</span>
<span class="go">[1, 2]</span>
<span class="go">[2, 1]</span>
<span class="go">[1, 2, 3]</span>
<span class="go">[1, 3, 2]</span>
<span class="go">[2, 1, 3]</span>
<span class="go">[2, 3, 1]</span>
<span class="go">[3, 1, 2]</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>Note: the above set could also have been constructed directly with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">U</span> <span class="o">=</span> <span class="n">Permutations</span><span class="p">();</span> <span class="n">U</span>
<span class="go">Standard permutations</span>
</pre></div>
</div>
<div class="section" id="id4">
<h3>Summary<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Sage</span></code> provides a library of common enumerated sets, which can be
combined by standard constructions, giving a toolbox that is flexible
(but which could still be expanded). It is also possible to add new
building blocks to <code class="docutils literal"><span class="pre">Sage</span></code> with a few lines (see the code in
<code class="docutils literal"><span class="pre">FiniteEnumeratedSets().example()</span></code>). This is made possible by the
uniformity of the interfaces and the fact that <code class="docutils literal"><span class="pre">Sage</span></code> is based on an
object-oriented language. Also, very large or even infinite sets can
be manipulated thanks to lazy evaluation strategies (iterators, etc.).</p>
<p>There is no magic to any of this: under the hood, <code class="docutils literal"><span class="pre">Sage</span></code> applies the
usual rules (for example, that the cardinality of <span class="math">\(E\times E\)</span> is
<span class="math">\(|E|^2\)</span>); the added value comes from the capacity to manipulate
complicated constructions. The situation is comparable to <code class="docutils literal"><span class="pre">Sage</span></code>’s
implementation of differential calculus: <code class="docutils literal"><span class="pre">Sage</span></code> applies the usual
rules for differentiation of functions and their compositions, where
the added value comes from the possibility of manipulating complicated
formulas. In this sense, <code class="docutils literal"><span class="pre">Sage</span></code> implements a <em>calculus</em> of finite
enumerated sets.</p>
</div>
</div>
<div class="section" id="generic-algorithms">
<span id="section-generic"></span><h2>Generic algorithms<a class="headerlink" href="#generic-algorithms" title="Permalink to this headline">¶</a></h2>
<div class="section" id="lexicographic-generation-of-lists-of-integers">
<span id="section-generic-integerlistlex"></span><h3>Lexicographic generation of lists of integers<a class="headerlink" href="#lexicographic-generation-of-lists-of-integers" title="Permalink to this headline">¶</a></h3>
<p>Among the classic enumerated sets, especially in algebraic
combinatorics, a certain number are composed of lists of integers of
fixed sum, such as partitions, compositions, or integer vectors. These
examples can also have supplementary constraints added to them. Here are
some examples. We start with the integer vectors with sum <span class="math">\(10\)</span>
and length <span class="math">\(3\)</span>, with parts bounded below by <span class="math">\(2\)</span>,
<span class="math">\(4\)</span> and <span class="math">\(2\)</span> respectively:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">IntegerVectors</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">min_part</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_part</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="go">....:                inner=[2, 4, 2]).list()</span>
<span class="go">[[4, 4, 2], [3, 5, 2], [3, 4, 3], [2, 5, 3], [2, 4, 4]]</span>
</pre></div>
</div>
<p>The compositions of <span class="math">\(5\)</span> with each part at most <span class="math">\(3\)</span>, and
with length <span class="math">\(2\)</span> or <span class="math">\(3\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Compositions</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">max_part</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">....:              min_length=2, max_length=3).list()</span>
<span class="go">[[3, 2], [3, 1, 1], [2, 3], [2, 2, 1], [2, 1, 2], [1, 3, 1],</span>
<span class="go"> [1, 2, 2], [1, 1, 3]]</span>
</pre></div>
</div>
<p>The strictly decreasing partitions of <span class="math">\(5\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">max_slope</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[5], [4, 1], [3, 2]]</span>
</pre></div>
</div>
<p>These sets share the same underlying algorithmic structure, implemented
in the more general (and slightly more cumbersome) class
<code class="docutils literal"><span class="pre">IntegerListsLex</span></code>. This class models sets of vectors
<span class="math">\((\ell_0,\dots,\ell_k)\)</span> of non-negative integers, with
constraints on the sum and the length, and bounds on the parts and on
the consecutive differences between the parts. Here are some more
examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">IntegerListsLex</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">....:                 min_part=2, max_part=5,</span>
<span class="go">....:                 floor=[2, 4, 2]).list()</span>
<span class="go">[[4, 4, 2], [3, 5, 2], [3, 4, 3], [2, 5, 3], [2, 4, 4]]</span>

<span class="gp">sage: </span><span class="n">IntegerListsLex</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">min_part</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_part</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">....:                 min_length=2, max_length=3).list()</span>
<span class="go">[[3, 2], [3, 1, 1], [2, 3], [2, 2, 1], [2, 1, 2],</span>
<span class="go"> [1, 3, 1], [1, 2, 2], [1, 1, 3]]</span>

<span class="gp">sage: </span><span class="n">IntegerListsLex</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">min_part</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_slope</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[5], [4, 1], [3, 2]]</span>

<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Compositions</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[5], [4, 1], [3, 2], [2, 3], [1, 4]]</span>

<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">IntegerListsLex</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">min_part</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[5], [4, 1], [3, 2], [2, 3], [1, 4]]</span>
</pre></div>
</div>
<p>The point of the model of <code class="docutils literal"><span class="pre">IntegerListsLex</span></code> is in the compromise
between generality and efficiency. The main algorithm permits
iteration through the elements of such a set <span class="math">\(S\)</span> in reverse
lexicographic order with a good complexity in most practical use
cases. Roughly speaking, the time needed to iterate through all the
elements of <span class="math">\(S\)</span> is proportional to the number of elements, where the
proportion factor is controlled by the length <span class="math">\(l\)</span> of the longest
element of <span class="math">\(S\)</span>. In addition, the memory usage is also controlled by
<span class="math">\(l\)</span>, which is to say negligible in practice.</p>
<p>This algorithm is based on a very general principle for traversing a
decision tree, called <em>branch and bound</em>: at the top level, we run
through all the possible choices for <span class="math">\(\ell_0\)</span>; for each of these
choices, we run through all the possible choices for <span class="math">\(\ell_1\)</span>,
and so on. Mathematically speaking, we have put the structure of a
prefix tree on the elements of <span class="math">\(S\)</span>: a node of the tree at depth
<span class="math">\(k\)</span> corresponds to a prefix <span class="math">\(\ell_0,\dots,\ell_k\)</span> of one
(or more) elements of <span class="math">\(S\)</span> (see <a class="reference internal" href="#figure-prefix-tree-partitions"><span class="std std-ref">Figure: The prefix tree of the partitions of 5.</span></a>).</p>
<div class="figure" id="id10">
<span id="figure-prefix-tree-partitions"></span><a class="reference internal image-reference" href="../../_images/prefix-tree-partitions-5.png"><img alt="../../_images/prefix-tree-partitions-5.png" src="../../_images/prefix-tree-partitions-5.png" style="width: 361.5px; height: 351.0px;" /></a>
<p class="caption"><span class="caption-text">Figure: The prefix tree of the partitions of 5.</span></p>
</div>
<p>The usual problem with this type of approach is to avoid bad decisions
which lead to leaving the prefix tree and exploring dead branches;
this is particularly problematic because the growth of the number of
elements is usually exponential in the depth. It turns out that the
constraints listed above are simple enough to be able to reasonably
predict when a sequence <span class="math">\(\ell_0,\dots,\ell_k\)</span> is a prefix of some
element <span class="math">\(S\)</span>. Hence, most dead branches can be pruned.</p>
</div>
<div class="section" id="integer-points-in-polytopes">
<span id="section-generic-polytopes"></span><h3>Integer points in polytopes<a class="headerlink" href="#integer-points-in-polytopes" title="Permalink to this headline">¶</a></h3>
<p>Although the algorithm for iteration in <code class="docutils literal"><span class="pre">IntegerListsLex</span></code> is
efficient, its counting algorithm is naive: it just iterates over all
the elements.</p>
<p>There is an alternative approach to treating this problem: modelling the
desired lists of integers as the set of integer points of a polytope,
that is to say, the set of solutions with integer coordinates of a
system of linear inequalities. This is a very general context in which
there exist advanced counting algorithms (e.g. Barvinok), which are
implemented in libraries like <code class="docutils literal"><span class="pre">LattE</span></code>. Iteration does not pose a hard problem
in principle. However, there are two limitations that justify the
existence of <code class="docutils literal"><span class="pre">IntegerListsLex</span></code>. The first is theoretical: lattice
points in a polytope only allow modelling of problems of a fixed
dimension (length). The second is practical: at the moment only the
library <code class="docutils literal"><span class="pre">PALP</span></code> has a <code class="docutils literal"><span class="pre">Sage</span></code> interface, and though it offers multiple
capabilities for the study of polytopes, in the present application it
only produces a list of lattice points, without providing either an
iterator or non-naive counting:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">random_matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">rows</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">points</span><span class="p">()</span>                               <span class="c1"># random</span>
<span class="go">M(4, 1, 0),</span>
<span class="go">M(0, 3, 5),</span>
<span class="go">M(2, 2, 3),</span>
<span class="go">M(6, 1, 3),</span>
<span class="go">M(1, 3, 6),</span>
<span class="go">M(6, 2, 3),</span>
<span class="go">M(3, 2, 4),</span>
<span class="go">M(3, 2, 3),</span>
<span class="go">M(4, 2, 4),</span>
<span class="go">M(4, 2, 3),</span>
<span class="go">M(5, 2, 3)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>                                 <span class="c1"># random</span>
<span class="go">11</span>
</pre></div>
</div>
<p>This polytope can be visualized in 3D with <code class="docutils literal"><span class="pre">L.plot3d()</span></code> (see
<a class="reference internal" href="#figure-polytope"><span class="std std-ref">Figure: The polytope  and its integer points, in cross-eyed stereographic perspective.</span></a>).</p>
<div class="figure" id="id11">
<span id="figure-polytope"></span><a class="reference internal image-reference" href="../../_images/polytope.png"><img alt="../../_images/polytope.png" src="../../_images/polytope.png" style="width: 1068.0px; height: 528.75px;" /></a>
<p class="caption"><span class="caption-text">Figure: The polytope <span class="math">\(L\)</span> and its integer points, in cross-eyed stereographic perspective.</span></p>
</div>
</div>
<div class="section" id="species-decomposable-combinatorial-classes">
<span id="section-generic-species"></span><h3>Species, decomposable combinatorial classes<a class="headerlink" href="#species-decomposable-combinatorial-classes" title="Permalink to this headline">¶</a></h3>
<p>In <a class="reference internal" href="#section-examples-catalan"><span class="std std-ref">Enumeration of trees using generating functions</span></a>, we showed how to use the recursive
definition of binary trees to count them efficiently using generating
functions. The techniques we used there are very general, and apply
whenever the sets involved can be defined recursively (depending on
who you ask, such a set is called a <em>decomposable combinatorial class</em>
or, roughly speaking, a <em>combinatorial species</em>). This includes all
the types of trees, but also permutations, compositions, functional
graphs, etc.</p>
<p>Here, we illustrate just a few examples using the <code class="docutils literal"><span class="pre">Sage</span></code> library on
combinatorial species:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.species.library</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>We begin by redefining the complete binary trees; to do so, we stipulate
the recurrence relation directly on the sets:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BT</span> <span class="o">=</span> <span class="n">CombinatorialSpecies</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Leaf</span> <span class="o">=</span>  <span class="n">SingletonSpecies</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">BT</span><span class="o">.</span><span class="n">define</span><span class="p">(</span> <span class="n">Leaf</span> <span class="o">+</span> <span class="p">(</span><span class="n">BT</span><span class="o">*</span><span class="n">BT</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Now we can construct the set of trees with five nodes, list them, count
them...:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BT5</span> <span class="o">=</span> <span class="n">BT</span><span class="o">.</span><span class="n">isotypes</span><span class="p">([</span><span class="n">o</span><span class="p">]</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BT5</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">14</span>
<span class="gp">sage: </span><span class="n">BT5</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[o*(o*(o*(o*o))), o*(o*((o*o)*o)), o*((o*o)*(o*o)),</span>
<span class="go"> o*((o*(o*o))*o), o*(((o*o)*o)*o), (o*o)*(o*(o*o)),</span>
<span class="go"> (o*o)*((o*o)*o), (o*(o*o))*(o*o), ((o*o)*o)*(o*o),</span>
<span class="go"> (o*(o*(o*o)))*o, (o*((o*o)*o))*o, ((o*o)*(o*o))*o,</span>
<span class="go"> ((o*(o*o))*o)*o, (((o*o)*o)*o)*o]</span>
</pre></div>
</div>
<p>The trees are constructed using a generic recursive structure; the
display is therefore not wonderful. To do better, it would be necessary
to provide <code class="docutils literal"><span class="pre">Sage</span></code> with a more specialized data structure with the
desired display capabilities.</p>
<p>We recover the generating function for the Catalan numbers:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">BT</span><span class="o">.</span><span class="n">isotype_generating_series</span><span class="p">();</span> <span class="n">g</span>
<span class="go">x + x^2 + 2*x^3 + 5*x^4 + 14*x^5 + O(x^6)</span>
</pre></div>
</div>
<p>which is returned in the form of a lazy power series:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span>
<span class="go">227508830794229349661819540395688853956041682601541047340</span>
</pre></div>
</div>
<p>We finish with the Fibonacci words, which are binary words without two
consecutive “<span class="math">\(1\)</span>”s. They admit a natural recursive definition:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Eps</span> <span class="o">=</span>  <span class="n">EmptySetSpecies</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Z0</span>  <span class="o">=</span>  <span class="n">SingletonSpecies</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Z1</span>  <span class="o">=</span>  <span class="n">Eps</span><span class="o">*</span><span class="n">SingletonSpecies</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FW</span>  <span class="o">=</span> <span class="n">CombinatorialSpecies</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FW</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">Eps</span> <span class="o">+</span> <span class="n">Z0</span><span class="o">*</span><span class="n">FW</span>  <span class="o">+</span>  <span class="n">Z1</span><span class="o">*</span><span class="n">Eps</span> <span class="o">+</span> <span class="n">Z1</span><span class="o">*</span><span class="n">Z0</span><span class="o">*</span><span class="n">FW</span><span class="p">)</span>
</pre></div>
</div>
<p>The Fibonacci sequence is easily recognized here, hence the name:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">FW</span><span class="o">.</span><span class="n">isotype_generating_series</span><span class="p">()</span><span class="o">.</span><span class="n">coefficients</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span> <span class="n">L</span>
<span class="go">[1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">oeis</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>                                       <span class="c1"># optional -- internet</span>
<span class="go">0: A000045: Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.</span>
<span class="go">1: A212804: Expansion of (1-x)/(1-x-x^2).</span>
<span class="go">2: A132636: Fib(n) mod n^3.</span>
</pre></div>
</div>
<p>This is an immediate consequence of the recurrence relation. One can
also generate immediately all the Fibonacci words of a given length,
with the same limitations resulting from the generic display.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FW3</span> <span class="o">=</span> <span class="n">FW</span><span class="o">.</span><span class="n">isotypes</span><span class="p">([</span><span class="n">o</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">FW3</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[o*(o*(o*{})), o*(o*(({}*o)*{})), o*((({}*o)*o)*{}),</span>
<span class="go"> (({}*o)*o)*(o*{}), (({}*o)*o)*(({}*o)*{})]</span>
</pre></div>
</div>
</div>
<div class="section" id="graphs-up-to-isomorphism">
<span id="section-generic-isomorphism"></span><h3>Graphs up to isomorphism<a class="headerlink" href="#graphs-up-to-isomorphism" title="Permalink to this headline">¶</a></h3>
<p>We saw in <a class="reference internal" href="#section-bricks-divers"><span class="std std-ref">Some other finite enumerated sets</span></a> that <code class="docutils literal"><span class="pre">Sage</span></code> could generate
graphs and partial orders up to isomorphism. We will now describe the
underlying algorithm, which is the same in both cases, and covers a
substantially wider class of problems.</p>
<p>We begin by recalling some notions. A graph <span class="math">\(G=(V,E)\)</span> is a set
<span class="math">\(V\)</span> of vertices and a set <span class="math">\(E\)</span> of edges connecting these
vertices; an edge is described by a pair <span class="math">\(\{u,v\}\)</span> of distinct
vertices of <span class="math">\(V\)</span>. Such a graph is called labelled; its vertices
are typically numbered by considering <span class="math">\(V=\{1,2,3,4,5\}\)</span>.</p>
<p>In many problems, the labels on the vertices play no role. Typically a
chemist wants to study all the possible molecules with a given
composition, for example the alkanes with <span class="math">\(n=8\)</span> atoms of carbon
and <span class="math">\(2n+2=18\)</span> atoms of hydrogen. He therefore wants to find all
the graphs consisting of <span class="math">\(8\)</span> vertices with <span class="math">\(4\)</span> neighbours, and
<span class="math">\(18\)</span> vertices with a single neighbour. The different carbon atoms,
however, are all considered to be identical, and the same for
the hydrogen atoms. The problem of our chemist is not imaginary; this
type of application is actually at the origin of an important part of
the research in graph theory on isomorphism problems.</p>
<p>Working by hand on a small graph it is possible, as in the example of
<a class="reference internal" href="#section-bricks-divers"><span class="std std-ref">Some other finite enumerated sets</span></a>, to make a drawing, erase the labels, and
“forget” the geometrical information about the location of the
vertices in the plane. However, to represent a graph in a computer
program, it is necessary to introduce labels on the vertices so as to
be able to describe how the edges connect them together. To compensate
for the extra information which we have introduced, we then say that
two labelled graphs <span class="math">\(g_1\)</span> and <span class="math">\(g_2\)</span> are <em>isomorphic</em> if there is a
bijection from the vertices of <span class="math">\(g_1\)</span> to those of <span class="math">\(g_2\)</span>, which maps
bijectively the edges of <span class="math">\(g_1\)</span> to those of <span class="math">\(g_2\)</span>; an <em>unlabelled
graph</em> is then an equivalence class of labelled graphs.</p>
<p>In general, testing if two labelled graphs are isomorphic is expensive.
However, the number of graphs, even unlabelled, grows very
rapidly.  Nonetheless, it is possible to list unlabelled graphs very efficiently
considering their number. For example, the program <code class="docutils literal"><span class="pre">Nauty</span></code> can list the
<span class="math">\(12005168\)</span> simple graphs with <span class="math">\(10\)</span> vertices in
<span class="math">\(20\)</span> seconds.</p>
<p>As in <a class="reference internal" href="#section-generic-integerlistlex"><span class="std std-ref">Lexicographic generation of lists of integers</span></a>, the general principle
of the algorithm is to organize the objects to be enumerated into a tree
that one traverses.</p>
<p>For this, in each equivalence class of labelled graphs (that is to say,
for each unlabelled graph) one fixes a convenient canonical
representative. The following are the fundamental operations:</p>
<ul class="simple">
<li>Testing whether a labelled graph is canonical</li>
<li>Calculating the canonical representative of a labelled graph</li>
</ul>
<p>These unavoidable operations remain expensive; one therefore tries to
minimize the number of calls to them.</p>
<p>The canonical representatives are chosen in such a way that, for each
canonical labelled graph <span class="math">\(G\)</span>, there is a canonical choice of an edge
whose removal produces a canonical graph again, which is called the
father of <span class="math">\(G\)</span>. This property implies that it is possible to organize
the set of canonical representatives as a tree: at the root, the graph
with no edges; below it, its unique child, the graph with one edge;
then the graphs with two edges, and so on. The set of children of a
graph <span class="math">\(G\)</span> can be constructed by <em>augmentation</em>, adding an edge in all
the possible ways to <span class="math">\(G\)</span>, and then selecting, from among those graphs,
the ones that are still canonical <a class="footnote-reference" href="#id8" id="id5">[3]</a>. Recursively, one obtains all
the canonical graphs.</p>
<div class="figure" id="id12">
<img alt="../../_images/prefix-tree-graphs-4.png" src="../../_images/prefix-tree-graphs-4.png" />
<p class="caption"><span class="caption-text">Figure: The generation tree of simple graphs with <span class="math">\(4\)</span> vertices.</span></p>
</div>
<p>In what sense is this algorithm generic? Consider for example planar
graphs (graphs which can be drawn in the plane without edges crossing):
by removing an edge from a planar graph, one obtains another planar
graph; so planar graphs form a subtree of the previous tree. To generate
them, exactly the same algorithm can be used,
selecting only the children which are planar:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">graphs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">property</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">G</span><span class="p">:</span> <span class="n">G</span><span class="o">.</span><span class="n">is_planar</span><span class="p">())))</span>
<span class="go">....:  for n in range(7)]</span>
<span class="go">[1, 1, 2, 4, 11, 33, 142]</span>
</pre></div>
</div>
<p>In a similar fashion, one can generate any family of graphs closed
under deletion of an edge, and in particular any family characterized
by a forbidden subgraph. This includes for example forests (graphs
without cycles), bipartite graphs (graphs without odd cycles),
etc. This can be applied to generate:</p>
<ul class="simple">
<li>partial orders, via the bijection with Hasse diagrams which are
oriented graphs without cycles and without edges implied by the
transitivity of the order relation;</li>
<li>lattices (not implemented in <code class="docutils literal"><span class="pre">Sage</span></code>), via the bijection with the
meet semi-lattice obtained by deleting the maximal vertex; in this
case an augmentation by vertices rather than by edges is used.</li>
</ul>
<p>REFERENCES:</p>
<blockquote>
<div><table class="docutils citation" frame="void" id="cms2012" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[CMS2012]</a></td><td>Alexandre Casamayou, Nathann Cohen, Guillaume Connan, Thierry Dumont, Laurent Fousse, François Maltey, Matthias Meulien, Marc Mezzarobba, Clément Pernet, Nicolas M. Thiéry, Paul Zimmermann
<em>Calcul Mathématique avec Sage</em>
<a class="reference external" href="http://sagebook.gforge.inria.fr/">http://sagebook.gforge.inria.fr/</a></td></tr>
</tbody>
</table>
</div></blockquote>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Or at least that should be the case; there are still many corners to
clean up.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>Technical detail: <code class="docutils literal"><span class="pre">xrange</span></code> returns an iterator on
<span class="math">\(\{0,\dots,8\}\)</span> while <code class="docutils literal"><span class="pre">range</span></code> returns the corresponding
list. Starting in <code class="docutils literal"><span class="pre">Python</span></code> 3.0, <code class="docutils literal"><span class="pre">range</span></code> will behave like <code class="docutils literal"><span class="pre">xrange</span></code>, and
<code class="docutils literal"><span class="pre">xrange</span></code> will no longer be needed.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>In practice, an efficient implementation would exploit the symmetries
of <span class="math">\(G\)</span>, i.e., its automorphism group, to reduce the number of
children to explore, and to reduce the cost of each test of
canonicity.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Introduction to combinatorics in Sage</a><ul>
<li><a class="reference internal" href="#initial-examples">Initial examples</a><ul>
<li><a class="reference internal" href="#poker-and-probability">Poker and probability</a></li>
<li><a class="reference internal" href="#enumeration-of-trees-using-generating-functions">Enumeration of trees using generating functions</a><ul>
<li><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#common-enumerated-sets">Common enumerated sets</a><ul>
<li><a class="reference internal" href="#first-example-the-subsets-of-a-set">First example: the subsets of a set</a></li>
<li><a class="reference internal" href="#partitions-of-integers">Partitions of integers</a></li>
<li><a class="reference internal" href="#some-other-finite-enumerated-sets">Some other finite enumerated sets</a></li>
<li><a class="reference internal" href="#set-comprehension-and-iterators">Set comprehension and iterators</a><ul>
<li><a class="reference internal" href="#operations-on-iterators">Operations on iterators</a></li>
<li><a class="reference internal" href="#implementation-of-new-iterators">Implementation of new iterators</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#constructions">Constructions</a><ul>
<li><a class="reference internal" href="#id4">Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generic-algorithms">Generic algorithms</a><ul>
<li><a class="reference internal" href="#lexicographic-generation-of-lists-of-integers">Lexicographic generation of lists of integers</a></li>
<li><a class="reference internal" href="#integer-points-in-polytopes">Integer points in polytopes</a></li>
<li><a class="reference internal" href="#species-decomposable-combinatorial-classes">Species, decomposable combinatorial classes</a></li>
<li><a class="reference internal" href="#graphs-up-to-isomorphism">Graphs up to isomorphism</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="tuple.html"
                                  title="previous chapter">Tuples</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="vector_partition.html"
                                  title="next chapter">Vector Partitions</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/combinat/tutorial.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="vector_partition.html" title="Vector Partitions"
             >next</a> |</li>
        <li class="right" >
          <a href="tuple.html" title="Tuples"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Combinatorics</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../../module_list.html" >Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005--2016, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.4.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>