<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="Subsets of a Universe Defined by Predicates" href="condition_set.html" /><link rel="prev" title="Finite Enumerated Sets" href="finite_enumerated_set.html" />

    <meta name="generator" content="sphinx-4.4.0, furo 2022.06.21"/>
        <title>Recursively enumerated set - Sets</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=40978830699223671f4072448e654b5958f38b89" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom-furo.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZGD13B5572"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ZGD13B5572');
</script></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Sets</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logo_sagemath_black.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logo_sagemath_white.svg" alt="Dark Logo"/>
  </div>
  
      <span class="sidebar-brand-text">Sage 9.7 Reference Manual</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-home">
  <div class="sidebar-tree">
    <ul><li class="toctree-l1">
      <a class="reference internal" href="../../index.html">Home - Sets</a>
    </li></ul>
  </div>
</div><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="cartesian_product.html">Cartesian products</a></li>
<li class="toctree-l1"><a class="reference internal" href="family.html">Families</a></li>
<li class="toctree-l1"><a class="reference internal" href="set.html">Sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="disjoint_set.html">Disjoint-set data structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="disjoint_union_enumerated_sets.html">Disjoint union of enumerated sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="set_from_iterator.html">Enumerated set from iterator</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_enumerated_set.html">Finite Enumerated Sets</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Recursively enumerated set</a></li>
<li class="toctree-l1"><a class="reference internal" href="condition_set.html">Subsets of a Universe Defined by Predicates</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_set_maps.html">Maps between finite sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="finite_set_map_cy.html">Data structures for maps between finite sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="totally_ordered_finite_set.html">Totally Ordered Finite Sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="pythonclass.html">Set of all objects of a given Python class</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="integer_range.html">Integer Range</a></li>
<li class="toctree-l1"><a class="reference internal" href="positive_integers.html">Positive Integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="non_negative_integers.html">Non Negative Integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="primes.html">The set of prime numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="real_set.html">Subsets of the Real Line</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="recursively-enumerated-set">
<span id="sage-sets-recursively-enumerated-set"></span><h1>Recursively enumerated set<a class="headerlink" href="#recursively-enumerated-set" title="Permalink to this headline">#</a></h1>
<span class="target" id="module-sage.sets.recursively_enumerated_set"></span><p>A set <span class="math notranslate nohighlight">\(S\)</span> is called recursively enumerable if there is an algorithm that
enumerates the members of <span class="math notranslate nohighlight">\(S\)</span>. We consider here the recursively enumerated
sets that are described by some <code class="docutils literal notranslate"><span class="pre">seeds</span></code> and a successor function
<code class="docutils literal notranslate"><span class="pre">successors</span></code>.  The successor function may have some structure (symmetric,
graded, forest) or not. The elements of a set having a symmetric, graded or
forest structure can be enumerated uniquely without keeping all of them in
memory. Many kinds of iterators are provided in this module: depth first
search, breadth first search or elements of given depth.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Recursively_enumerable_set">Wikipedia article Recursively_enumerable_set</a>.</p>
<p>See documentation of <a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet"><code class="xref py py-func docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet()</span></code></a> below for the
description of the inputs.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li><p>Sébastien Labbé, April 2014, at Sage Days 57, Cernay-la-ville</p></li>
</ul>
<p>EXAMPLES:</p>
<section id="no-hypothesis-on-the-structure">
<h2>No hypothesis on the structure<a class="headerlink" href="#no-hypothesis-on-the-structure" title="Permalink to this headline">#</a></h2>
<p>What we mean by “no hypothesis” is that the set is not known
to be a forest, symmetric, or graded. However, it may have other
structure, like not containing an oriented cycle, that does not
help with the enumeration.</p>
<p>In this example, the seed is 0 and the successor function is either <code class="docutils literal notranslate"><span class="pre">+2</span></code>
or <code class="docutils literal notranslate"><span class="pre">+3</span></code>. This is the set of non negative linear combinations of 2 and 3:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">succ</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:[</span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">succ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">A recursively enumerated set (breadth first search)</span>
</pre></div>
</div>
<p>Breadth first search:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[0, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
</pre></div>
</div>
<p>Depth first search:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">depth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[0, 3, 6, 9, 12, 15, 18, 21, 24, 27]</span>
</pre></div>
</div>
</section>
<section id="symmetric-structure">
<h2>Symmetric structure<a class="headerlink" href="#symmetric-structure" title="Permalink to this headline">#</a></h2>
<p>The origin <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code> as seed and the upper, lower, left and right lattice
point as successor function. This function is symmetric since <span class="math notranslate nohighlight">\(p\)</span> is a
successor of <span class="math notranslate nohighlight">\(q\)</span> if and only if <span class="math notranslate nohighlight">\(q\)</span> is a successor or <span class="math notranslate nohighlight">\(p\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">succ</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">seeds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">(</span><span class="n">seeds</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="n">enumeration</span><span class="o">=</span><span class="s1">&#39;depth&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">A recursively enumerated set with a symmetric structure (depth first search)</span>
</pre></div>
</div>
<p>In this case, depth first search is the default enumeration for iteration:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it_depth</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it_depth</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9)]</span>
</pre></div>
</div>
<p>Breadth first search:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it_breadth</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it_breadth</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">13</span><span class="p">)]</span>
<span class="go">[(0, 0),</span>
<span class="go"> (-1, 0), (0, -1), (1, 0), (0, 1),</span>
<span class="go"> (-2, 0), (-1, -1), (-1, 1), (0, -2), (1, -1), (2, 0), (1, 1), (0, 2)]</span>
</pre></div>
</div>
<p>Levels (elements of given depth):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[(0, 0)]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[(-1, 0), (0, -1), (0, 1), (1, 0)]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[(-2, 0), (-1, -1), (-1, 1), (0, -2), (0, 2), (1, -1), (1, 1), (2, 0)]</span>
</pre></div>
</div>
</section>
<section id="graded-structure">
<h2>Graded structure<a class="headerlink" href="#graded-structure" title="Permalink to this headline">#</a></h2>
<p>Identity permutation as seed and <code class="docutils literal notranslate"><span class="pre">permutohedron_succ</span></code> as successor
function:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">succ</span> <span class="o">=</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;permutohedron_succ&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">seed</span> <span class="o">=</span> <span class="p">[</span><span class="n">Permutation</span><span class="p">([</span><span class="mf">1..5</span><span class="p">])]</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;graded&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span>
<span class="go">A recursively enumerated set with a graded structure (breadth first search)</span>
</pre></div>
</div>
<p>Depth first search iterator:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it_depth</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">depth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it_depth</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="go">[[1, 2, 3, 4, 5],</span>
<span class="go"> [1, 2, 3, 5, 4],</span>
<span class="go"> [1, 2, 5, 3, 4],</span>
<span class="go"> [1, 2, 5, 4, 3],</span>
<span class="go"> [1, 5, 2, 4, 3]]</span>
</pre></div>
</div>
<p>Breadth first search iterator:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it_breadth</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it_breadth</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="go">[[1, 2, 3, 4, 5],</span>
<span class="go"> [2, 1, 3, 4, 5],</span>
<span class="go"> [1, 3, 2, 4, 5],</span>
<span class="go"> [1, 2, 4, 3, 5],</span>
<span class="go"> [1, 2, 3, 5, 4]]</span>
</pre></div>
</div>
<p>Elements of given depth iterator:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">elements_of_depth_iterator</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="go">[[4, 5, 3, 2, 1], [5, 3, 4, 2, 1], [5, 4, 2, 3, 1], [5, 4, 3, 1, 2]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">elements_of_depth_iterator</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[[5, 4, 3, 2, 1]]</span>
</pre></div>
</div>
<p>Graded components (set of elements of the same depth):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[[1, 2, 3, 4, 5]]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[1, 2, 3, 5, 4], [1, 2, 4, 3, 5], [1, 3, 2, 4, 5], [2, 1, 3, 4, 5]]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="go">[[4, 5, 3, 2, 1], [5, 3, 4, 2, 1], [5, 4, 2, 3, 1], [5, 4, 3, 1, 2]]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[[5, 4, 3, 2, 1]]</span>
</pre></div>
</div>
</section>
<section id="forest-structure">
<h2>Forest structure<a class="headerlink" href="#forest-structure" title="Permalink to this headline">#</a></h2>
<p>The set of words over the alphabet <span class="math notranslate nohighlight">\(\{a,b\}\)</span> can be generated from the
empty word by appending letter <span class="math notranslate nohighlight">\(a\)</span> or <span class="math notranslate nohighlight">\(b\)</span> as a successor function. This set
has a forest structure:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">seeds</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">succ</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="p">[</span><span class="n">w</span><span class="o">+</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">w</span><span class="o">+</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">(</span><span class="n">seeds</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;forest&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">An enumerated set with a forest structure</span>
</pre></div>
</div>
<p>Depth first search iterator:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">depth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
<span class="go">[&#39;&#39;, &#39;a&#39;, &#39;aa&#39;, &#39;aaa&#39;, &#39;aaaa&#39;, &#39;aaaaa&#39;]</span>
</pre></div>
</div>
<p>Breadth first search iterator:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
<span class="go">[&#39;&#39;, &#39;a&#39;, &#39;b&#39;, &#39;aa&#39;, &#39;ab&#39;, &#39;ba&#39;]</span>
</pre></div>
</div>
</section>
<section id="example-forest-structure">
<h2>Example: Forest structure<a class="headerlink" href="#example-forest-structure" title="Permalink to this headline">#</a></h2>
<p>This example was provided by Florent Hivert.</p>
<p>How to define a set using those classes?</p>
<p>Only two things are necessary to define a set using a
<a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet</span></code></a> object (the other
classes being very similar):</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{picture}(-300,0)(600,0)
% Root
\put(0,0){\circle*{7}}
\put(0,10){\makebox(0,10){``\ ''}}
% First Children
\put(-150,-60){\makebox(0,10){``a''}}
\put(0,-60){\makebox(0,10){``b''}}
\put(150,-60){\makebox(0,10){``c''}}
\multiput(-150,-70)(150,0){3}{\circle*{7}}
% Second children
\put(-200,-130){\makebox(0,10){``aa''}}
\put(-150,-130){\makebox(0,10){``ab''}}
\put(-100,-130){\makebox(0,10){``ac''}}
\put(-50,-130){\makebox(0,10){``ba''}}
\put(0,-130){\makebox(0,10){``bb''}}
\put(50,-130){\makebox(0,10){``bc''}}
\put(100,-130){\makebox(0,10){``ca''}}
\put(150,-130){\makebox(0,10){``cb''}}
\put(200,-130){\makebox(0,10){``cc''}}
\multiput(-200,-140)(50,0){9}{\circle*{7}}
% Legend
\put(100,-5){\makebox(0,10)[l]{1) An initial element}}
\put(-250,-5){\makebox(0,10)[l]{2) A function of an element enumerating}}
\put(-235,-20){\makebox(0,10)[l]{its children (if any)}}
% Arrows
\thicklines
\put(0,-10){\vector(0,-1){30}}
\put(-15,-5){\vector(-2,-1){110}}
\put(15,-5){\vector(2,-1){110}}
\multiput(-150,-80)(150,0){3}{\vector(0,-1){30}}
\multiput(-160,-80)(150,0){3}{\vector(-1,-1){30}}
\multiput(-140,-80)(150,0){3}{\vector(1,-1){30}}
\put(90,0){\vector(-1,0){70}}
\put(-215,-30){\vector(1,-1){40}}
\end{picture}\]</div>
</div>
<p>For the previous example, the two necessary pieces of information are:</p>
<ul>
<li><p>the initial element <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>;</p></li>
<li><p>the function:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">lambda x: [x + letter for letter in [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
</li>
</ul>
<p>This would actually describe an <strong>infinite</strong> set, as such rules describes
“all words” on 3 letters. Hence, it is a good idea to replace the function by:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">lambda x: [x + letter for letter in [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] if len(x) &lt; 2 else []</span>
</pre></div>
</div>
<p>or even:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]:</span>
<span class="gp">....: </span>            <span class="k">yield</span> <span class="n">x</span><span class="o">+</span><span class="n">letter</span>
</pre></div>
</div>
<p>We can then create the <a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet</span></code></a> object with either:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="s1">&#39;&#39;</span><span class="p">],</span>
<span class="gp">....: </span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="n">letter</span> <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]]</span>
<span class="gp">....: </span>              <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="p">[],</span>
<span class="gp">....: </span>    <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;forest&#39;</span><span class="p">,</span> <span class="n">enumeration</span><span class="o">=</span><span class="s1">&#39;depth&#39;</span><span class="p">,</span>
<span class="gp">....: </span>    <span class="n">category</span><span class="o">=</span><span class="n">FiniteEnumeratedSets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[&#39;&#39;, &#39;a&#39;, &#39;aa&#39;, &#39;ab&#39;, &#39;ac&#39;, &#39;b&#39;, &#39;ba&#39;, &#39;bb&#39;, &#39;bc&#39;, &#39;c&#39;, &#39;ca&#39;, &#39;cb&#39;, &#39;cc&#39;]</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="s1">&#39;&#39;</span><span class="p">],</span> <span class="n">children</span><span class="p">,</span>
<span class="gp">....: </span>    <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;forest&#39;</span><span class="p">,</span> <span class="n">enumeration</span><span class="o">=</span><span class="s1">&#39;depth&#39;</span><span class="p">,</span>
<span class="gp">....: </span>    <span class="n">category</span><span class="o">=</span><span class="n">FiniteEnumeratedSets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[&#39;&#39;, &#39;a&#39;, &#39;aa&#39;, &#39;ab&#39;, &#39;ac&#39;, &#39;b&#39;, &#39;ba&#39;, &#39;bb&#39;, &#39;bc&#39;, &#39;c&#39;, &#39;ca&#39;, &#39;cb&#39;, &#39;cc&#39;]</span>
</pre></div>
</div>
</section>
<section id="example-forest-structure-2">
<h2>Example: Forest structure 2<a class="headerlink" href="#example-forest-structure-2" title="Permalink to this headline">#</a></h2>
<p>This example was provided by Florent Hivert.</p>
<p>Here is a little more involved example. We want to iterate through all
permutations of a given set <span class="math notranslate nohighlight">\(S\)</span>. One solution is to take elements of <span class="math notranslate nohighlight">\(S\)</span> one
by one an insert them at every positions. So a node of the generating tree
contains two pieces of information:</p>
<ul class="simple">
<li><p>the list <code class="docutils literal notranslate"><span class="pre">lst</span></code> of already inserted element;</p></li>
<li><p>the set <code class="docutils literal notranslate"><span class="pre">st</span></code> of the yet to be inserted element.</p></li>
</ul>
<p>We want to generate a permutation only if <code class="docutils literal notranslate"><span class="pre">st</span></code> is empty (leaves on the
tree). Also suppose for the sake of the example, that instead of list we want
to generate tuples. This selection of some nodes and final mapping of a
function to the element is done by the <code class="docutils literal notranslate"><span class="pre">post_process</span> <span class="pre">=</span> <span class="pre">f</span></code> argument. The
convention is that the generated elements are the <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">:=</span> <span class="pre">f(n)</span></code>, except when
<code class="docutils literal notranslate"><span class="pre">s</span></code> not <code class="docutils literal notranslate"><span class="pre">None</span></code> when no element is generated at all. Here is the code:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">st</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span>
<span class="gp">....: </span>    <span class="n">st</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="c1"># make a copy</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="n">st</span><span class="p">:</span>
<span class="gp">....: </span>       <span class="n">el</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="gp">....: </span>       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">....: </span>           <span class="k">yield</span> <span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">el</span><span class="p">]</span><span class="o">+</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">st</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">children</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">})))</span>
<span class="go">[([9, 1, 2], {3, 7}), ([1, 9, 2], {3, 7}), ([1, 2, 9], {3, 7})]</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">post_process</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span> <span class="k">else</span> <span class="kc">None</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">(</span> <span class="p">[([],</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">})],</span>
<span class="gp">....: </span>    <span class="n">children</span><span class="p">,</span> <span class="n">post_process</span><span class="o">=</span><span class="n">post_process</span><span class="p">,</span>
<span class="gp">....: </span>    <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;forest&#39;</span><span class="p">,</span> <span class="n">enumeration</span><span class="o">=</span><span class="s1">&#39;depth&#39;</span><span class="p">,</span>
<span class="gp">....: </span>    <span class="n">category</span><span class="o">=</span><span class="n">FiniteEnumeratedSets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[(6, 3, 1, 8), (3, 6, 1, 8), (3, 1, 6, 8), (3, 1, 8, 6), (6, 1, 3, 8),</span>
<span class="go"> (1, 6, 3, 8), (1, 3, 6, 8), (1, 3, 8, 6), (6, 1, 8, 3), (1, 6, 8, 3),</span>
<span class="go"> (1, 8, 6, 3), (1, 8, 3, 6), (6, 3, 8, 1), (3, 6, 8, 1), (3, 8, 6, 1),</span>
<span class="go"> (3, 8, 1, 6), (6, 8, 3, 1), (8, 6, 3, 1), (8, 3, 6, 1), (8, 3, 1, 6),</span>
<span class="go"> (6, 8, 1, 3), (8, 6, 1, 3), (8, 1, 6, 3), (8, 1, 3, 6)]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">24</span>
</pre></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet">
<span class="sig-prename descclassname"><span class="pre">sage.sets.recursively_enumerated_set.</span></span><span class="sig-name descname"><span class="pre">RecursivelyEnumeratedSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seeds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">successors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">structure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">enumeration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_process</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">facade</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">category</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet" title="Permalink to this definition">#</a></dt>
<dd><p>Return a recursively enumerated set.</p>
<p>A set <span class="math notranslate nohighlight">\(S\)</span> is called recursively enumerable if there is an algorithm that
enumerates the members of <span class="math notranslate nohighlight">\(S\)</span>. We consider here the recursively
enumerated set that are described by some <code class="docutils literal notranslate"><span class="pre">seeds</span></code> and a successor
function <code class="docutils literal notranslate"><span class="pre">successors</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(U\)</span> be a set and <code class="docutils literal notranslate"><span class="pre">successors</span></code> <span class="math notranslate nohighlight">\(:U \to 2^U\)</span> be a successor function
associating to each element of <span class="math notranslate nohighlight">\(U\)</span> a subset of <span class="math notranslate nohighlight">\(U\)</span>. Let <code class="docutils literal notranslate"><span class="pre">seeds</span></code> be a
subset of <span class="math notranslate nohighlight">\(U\)</span>. Let <span class="math notranslate nohighlight">\(S\subseteq U\)</span> be the set of elements of <span class="math notranslate nohighlight">\(U\)</span> that
can be reached from a seed by applying recursively the <code class="docutils literal notranslate"><span class="pre">successors</span></code>
function. This class provides different kinds of iterators (breadth first,
depth first, elements of given depth, etc.) for the elements of <span class="math notranslate nohighlight">\(S\)</span>.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Recursively_enumerable_set">Wikipedia article Recursively_enumerable_set</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">seeds</span></code> – list (or iterable) of hashable objects</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">successors</span></code> – function (or callable) returning a list (or iterable) of
hashable objects</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">structure</span></code> – string (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>), structure of the
set, possible values are:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> – nothing is known about the structure of the set.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'forest'</span></code> – if the <code class="docutils literal notranslate"><span class="pre">successors</span></code> function generates a <em>forest</em>, that
is, each element can be reached uniquely from a seed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'graded'</span></code> – if the <code class="docutils literal notranslate"><span class="pre">successors</span></code> function is <em>graded</em>, that is, all
paths from a seed to a given element have equal length.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'symmetric'</span></code> – if the relation is <em>symmetric</em>, that is,
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">in</span> <span class="pre">successors(x)</span></code> if and only if <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">successors(y)</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">enumeration</span></code> – <code class="docutils literal notranslate"><span class="pre">'depth'</span></code>, <code class="docutils literal notranslate"><span class="pre">'breadth'</span></code>, <code class="docutils literal notranslate"><span class="pre">'naive'</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code>
(optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>). The default enumeration for the
<code class="docutils literal notranslate"><span class="pre">__iter__</span></code> function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_depth</span></code> – integer (optional, default: <code class="docutils literal notranslate"><span class="pre">float(&quot;inf&quot;)</span></code>), limit
the search to a certain depth, currently works only for breadth first
search</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">post_process</span></code> – (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>), for forest only</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">facade</span></code> – (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">category</span></code> – (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<p>A recursive set with no other information:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">A recursively enumerated set (breadth first search)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[0, 3, 5, 6, 8, 10, 9, 11, 13, 15]</span>
</pre></div>
</div>
<p>A recursive set with a forest structure:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;forest&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">An enumerated set with a forest structure</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">depth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
<span class="go">[1, 2, 4, 8, 16, 32, 64]</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7]</span>
</pre></div>
</div>
<p>A recursive set given by a symmetric relation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">A recursively enumerated set with a symmetric structure (breadth first search)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
<span class="go">[10, 15, 9, 11, 14, 16, 8]</span>
</pre></div>
</div>
<p>A recursive set given by a graded relation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">I</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;graded&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">A recursively enumerated set with a graded structure (breadth first search)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
<span class="go">[0, 1, I, 2, I + 1, 2*I, 3]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If you do not set the good structure, you might obtain bad results,
like elements generated twice:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;graded&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
<span class="go">[0, -1, 1, -2, 0, 2, -3]</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.sets.recursively_enumerated_set.</span></span><span class="sig-name descname"><span class="pre">RecursivelyEnumeratedSet_forest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">roots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">children</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_process</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'depth'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">facade</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">category</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Parents and Elements v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.parent.Parent</span></code></a></p>
<p>The enumerated set of the nodes of the forest having the given
<code class="docutils literal notranslate"><span class="pre">roots</span></code>, and where <code class="docutils literal notranslate"><span class="pre">children(x)</span></code> returns the children of the
node <code class="docutils literal notranslate"><span class="pre">x</span></code> of the forest.</p>
<p>See also <a class="reference external" href="../../../combinat/sage/combinat/backtrack.html#sage.combinat.backtrack.GenericBacktracker" title="(in Combinatorics v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.backtrack.GenericBacktracker</span></code></a>,
<a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded"><code class="xref py py-class docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet_graded</span></code></a>, and
<a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet_symmetric</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">roots</span></code> – a list (or iterable)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">children</span></code> – a function returning a list (or iterable, or iterator)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">post_process</span></code> – a function defined over the nodes of the
forest (default: no post processing)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – <code class="docutils literal notranslate"><span class="pre">'depth'</span></code> or <code class="docutils literal notranslate"><span class="pre">'breadth'</span></code> (default: <code class="docutils literal notranslate"><span class="pre">'depth'</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">category</span></code> – a category (default: <a class="reference external" href="../../../categories/sage/categories/enumerated_sets.html#sage.categories.enumerated_sets.EnumeratedSets" title="(in Category Framework v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">EnumeratedSets</span></code></a>)</p></li>
</ul>
<p>The option <code class="docutils literal notranslate"><span class="pre">post_process</span></code> allows for customizing the nodes that
are actually produced. Furthermore, if <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> returns <code class="docutils literal notranslate"><span class="pre">None</span></code>,
then <code class="docutils literal notranslate"><span class="pre">x</span></code> won’t be output at all.</p>
<p>EXAMPLES:</p>
<p>We construct the set of all binary sequences of length at most
three, and list them:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">(</span> <span class="p">[[]],</span>
<span class="gp">....: </span>    <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="p">[],</span>
<span class="gp">....: </span>    <span class="n">category</span><span class="o">=</span><span class="n">FiniteEnumeratedSets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[],</span>
<span class="go"> [0], [0, 0], [0, 0, 0], [0, 0, 1], [0, 1], [0, 1, 0], [0, 1, 1],</span>
<span class="go"> [1], [1, 0], [1, 0, 0], [1, 0, 1], [1, 1], [1, 1, 0], [1, 1, 1]]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet_forest</span></code> needs to be explicitly told that the set is
finite for the following to work:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of finite enumerated sets</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">15</span>
</pre></div>
</div>
<p>We proceed with the set of all lists of letters in <code class="docutils literal notranslate"><span class="pre">0,1,2</span></code>
without repetitions, ordered by increasing length (i.e. using a
breadth first search through the tree):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="n">tb</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">(</span> <span class="p">[[]],</span>
<span class="gp">....: </span>      <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">l</span><span class="p">],</span>
<span class="gp">....: </span>      <span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;breadth&#39;</span><span class="p">,</span>
<span class="gp">....: </span>      <span class="n">category</span><span class="o">=</span><span class="n">FiniteEnumeratedSets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">tb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">tb</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">16</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
<span class="go">[[],</span>
<span class="go"> [0], [1], [2],</span>
<span class="go"> [0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1],</span>
<span class="go"> [0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]]</span>
</pre></div>
</div>
<p>For infinite sets, this option should be set carefully to ensure
that all elements are actually generated. The following example
builds the set of all ordered pairs <span class="math notranslate nohighlight">\((i,j)\)</span> of nonnegative
integers such that <span class="math notranslate nohighlight">\(j\leq 1\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span>
<span class="gp">....: </span>                 <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)]</span>
<span class="gp">....: </span>                           <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
</pre></div>
</div>
<p>With a depth first search, only the elements of the form <span class="math notranslate nohighlight">\((i,0)\)</span>
are generated:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">depth_search</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">depth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">depth_search</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
<span class="go">[(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)]</span>
</pre></div>
</div>
<p>Using instead breadth first search gives the usual anti-diagonal
iterator:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">breadth_search</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">breadth_search</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">)]</span>
<span class="go">[(0, 0),</span>
<span class="go"> (1, 0), (0, 1),</span>
<span class="go"> (2, 0), (1, 1), (0, 2),</span>
<span class="go"> (3, 0), (2, 1), (1, 2), (0, 3),</span>
<span class="go"> (4, 0), (3, 1), (2, 2), (1, 3), (0, 4)]</span>
</pre></div>
</div>
<p class="rubric">Deriving subclasses</p>
<p>The class of a parent <span class="math notranslate nohighlight">\(A\)</span> may derive from <a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest"><code class="xref py py-class docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet_forest</span></code></a> so
that <span class="math notranslate nohighlight">\(A\)</span> can benefit from enumeration tools. As a running example,
we consider the problem of enumerating integers whose binary
expansion have at most three nonzero digits. For example, <span class="math notranslate nohighlight">\(3 =
2^1 + 2^0\)</span> has two nonzero digits. <span class="math notranslate nohighlight">\(15 = 2^3 + 2^2 + 2^1 + 2^0\)</span>
has four nonzero digits. In fact, <span class="math notranslate nohighlight">\(15\)</span> is the smallest integer
which is not in the enumerated set.</p>
<p>To achieve this, we use <code class="docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet_forest</span></code> to enumerate binary tuples
with at most three nonzero digits, apply a post processing to
recover the corresponding integers, and discard tuples finishing
by zero.</p>
<p>A first approach is to pass the <code class="docutils literal notranslate"><span class="pre">roots</span></code> and <code class="docutils literal notranslate"><span class="pre">children</span></code>
functions as arguments to <code class="xref py py-meth docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet_forest.__init__()</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">RecursivelyEnumeratedSet_forest</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[()],</span>
<span class="gp">....: </span>            <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">x</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">,)]</span> <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="p">[],</span>
<span class="gp">....: </span>            <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">^</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span> <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
<span class="gp">....: </span>            <span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;breadth&#39;</span><span class="p">,</span>
<span class="gp">....: </span>            <span class="n">category</span><span class="o">=</span><span class="n">InfiniteEnumeratedSets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">MyForest</span> <span class="o">=</span> <span class="n">A</span><span class="p">();</span> <span class="n">MyForest</span>
<span class="go">An enumerated set with a forest structure</span>
<span class="gp">sage: </span><span class="n">MyForest</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of infinite enumerated sets</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">MyForest</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">)]</span>
<span class="go">[1, 2, 3, 4, 6, 5, 7, 8, 12, 10, 14, 9, 13, 11, 16, 24, 20, 28, 18, 26, 22, 17, 25, 21, 19, 32, 48, 40, 56, 36]</span>
</pre></div>
</div>
<p>An alternative approach is to implement <code class="docutils literal notranslate"><span class="pre">roots</span></code> and <code class="docutils literal notranslate"><span class="pre">children</span></code>
as methods of the subclass (in fact they could also be attributes
of <span class="math notranslate nohighlight">\(A\)</span>). Namely, <code class="docutils literal notranslate"><span class="pre">A.roots()</span></code> must return an iterable containing
the enumeration generators, and <code class="docutils literal notranslate"><span class="pre">A.children(x)</span></code> must return an
iterable over the children of <span class="math notranslate nohighlight">\(x\)</span>. Optionally, <span class="math notranslate nohighlight">\(A\)</span> can have a
method or attribute such that <code class="docutils literal notranslate"><span class="pre">A.post_process(x)</span></code> returns the
desired output for the node <code class="docutils literal notranslate"><span class="pre">x</span></code> of the tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">RecursivelyEnumeratedSet_forest</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;breadth&#39;</span><span class="p">,</span>
<span class="gp">....: </span>                              <span class="n">category</span><span class="o">=</span><span class="n">InfiniteEnumeratedSets</span><span class="p">())</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">roots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="p">[()]</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">x</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">,)]</span>
<span class="gp">....: </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="p">[]</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">post_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="kc">None</span>
<span class="gp">....: </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">^</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">MyForest</span> <span class="o">=</span> <span class="n">A</span><span class="p">();</span> <span class="n">MyForest</span>
<span class="go">An enumerated set with a forest structure</span>
<span class="gp">sage: </span><span class="n">MyForest</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of infinite enumerated sets</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">MyForest</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">)]</span>
<span class="go">[1, 2, 3, 4, 6, 5, 7, 8, 12, 10, 14, 9, 13, 11, 16, 24, 20, 28, 18, 26, 22, 17, 25, 21, 19, 32, 48, 40, 56, 36]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>A <a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest"><code class="xref py py-class docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet_forest</span></code></a> instance is picklable if and only if
the input functions are themselves picklable. This excludes
anonymous or interactively defined functions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">children</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">InfiniteEnumeratedSets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">dumps</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">PicklingError: Can&#39;t pickle &lt;...function...&gt;: attribute lookup ... failed</span>
</pre></div>
</div>
<p>Let us now fake <code class="docutils literal notranslate"><span class="pre">children</span></code> being defined in a Python module:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">children</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">children</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">InfiniteEnumeratedSets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
<span class="go">An enumerated set with a forest structure</span>
</pre></div>
</div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.breadth_first_search_iterator">
<span class="sig-name descname"><span class="pre">breadth_first_search_iterator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.breadth_first_search_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Return a breadth first search iterator over the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code></p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">([[]],</span>
<span class="gp">....: </span>                 <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="p">[])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">())</span>
<span class="go">[[], [0], [1], [0, 0], [0, 1], [1, 0], [1, 1], [0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 1, 1], [1, 0, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1]]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span>
<span class="gp">....: </span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="p">[(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)],</span>
<span class="gp">....: </span><span class="n">post_process</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="k">if</span> <span class="p">((</span><span class="n">is_prime</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="ow">and</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
<span class="go">[(5, 3), (7, 5), (13, 11), (19, 17), (31, 29), (43, 41), (61, 59)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.children">
<span class="sig-name descname"><span class="pre">children</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.children" title="Permalink to this definition">#</a></dt>
<dd><p>Return the children of the element <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
<p>The result can be a list, an iterable, an iterator, or even a
generator.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">children</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))]</span>
<span class="go">[(1, 0), (0, 1)]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">children</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))]</span>
<span class="go">[(2, 0), (1, 1)]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">children</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))]</span>
<span class="go">[(1, 2)]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">children</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">))]</span>
<span class="go">[(4, 2)]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">children</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">))]</span>
<span class="go">[(5, 0), (4, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.depth_first_search_iterator">
<span class="sig-name descname"><span class="pre">depth_first_search_iterator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.depth_first_search_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Return a depth first search iterator over the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code></p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">([[]],</span>
<span class="gp">....: </span>                 <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="p">[])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">depth_first_search_iterator</span><span class="p">())</span>
<span class="go">[[], [0], [0, 0], [0, 0, 0], [0, 0, 1], [0, 1], [0, 1, 0], [0, 1, 1], [1], [1, 0], [1, 0, 0], [1, 0, 1], [1, 1], [1, 1, 0], [1, 1, 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.elements_of_depth_iterator">
<span class="sig-name descname"><span class="pre">elements_of_depth_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.elements_of_depth_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Return an iterator over the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> of given depth.
An element of depth <span class="math notranslate nohighlight">\(n\)</span> can be obtained applying <span class="math notranslate nohighlight">\(n\)</span> times the
children function from a root.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span> <span class="p">,</span>
<span class="gp">....: </span>       <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="p">[(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)],</span>
<span class="gp">....: </span>       <span class="n">post_process</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="k">if</span> <span class="p">((</span><span class="n">is_prime</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="gp">....: </span>                                       <span class="ow">and</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">elements_of_depth_iterator</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">(5, 3)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">(</span><span class="n">NN</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="p">[],</span>
<span class="gp">....: </span>                     <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_prime</span><span class="p">()</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">elements_of_depth_iterator</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
<span class="go">[4, 9, 25, 49, 121]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.map_reduce">
<span class="sig-name descname"><span class="pre">map_reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">map_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.map_reduce" title="Permalink to this definition">#</a></dt>
<dd><p>Apply a Map/Reduce algorithm on <code class="docutils literal notranslate"><span class="pre">self</span></code></p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">map_function</span></code> – a function from the element of <code class="docutils literal notranslate"><span class="pre">self</span></code> to some
set with a reduce operation (e.g.: a monoid). The default value is
the constant function <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reduce_function</span></code> – the reduce function (e.g.: the addition of a
monoid). The default value is <code class="docutils literal notranslate"><span class="pre">+</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reduce_init</span></code> – the initialisation of the reduction (e.g.: the
neutral element of the monoid). The default value is <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the effect of the default values is to compute the cardinality
of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">seeds</span> <span class="o">=</span> <span class="p">[([</span><span class="n">i</span><span class="p">],</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">succ</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nb">list</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="n">t</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="p">[(</span><span class="nb">list</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">sum</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">last</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">(</span><span class="n">seeds</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span>
<span class="gp">....: </span>                      <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;forest&#39;</span><span class="p">,</span> <span class="n">enumeration</span><span class="o">=</span><span class="s1">&#39;depth&#39;</span><span class="p">)</span>

<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">map_function</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">li</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">t</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">y</span> <span class="o">^</span> <span class="nb">sum</span>
<span class="gp">sage: </span><span class="n">reduce_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">map_reduce</span><span class="p">(</span><span class="n">map_function</span><span class="p">,</span> <span class="n">reduce_function</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">y^45 + y^44 + y^43 + 2*y^42 + 2*y^41 + 3*y^40 + 4*y^39 + 5*y^38 + 6*y^37 + 8*y^36 + 9*y^35 + 10*y^34 + 12*y^33 + 13*y^32 + 15*y^31 + 17*y^30 + 18*y^29 + 19*y^28 + 21*y^27 + 21*y^26 + 22*y^25 + 23*y^24 + 23*y^23 + 23*y^22 + 23*y^21 + 22*y^20 + 21*y^19 + 21*y^18 + 19*y^17 + 18*y^16 + 17*y^15 + 15*y^14 + 13*y^13 + 12*y^12 + 10*y^11 + 9*y^10 + 8*y^9 + 6*y^8 + 5*y^7 + 4*y^6 + 3*y^5 + 2*y^4 + 2*y^3 + y^2 + y</span>
</pre></div>
</div>
<p>Here is an example with the default values:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">map_reduce</span><span class="p">()</span>
<span class="go">511</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="../../../parallel/sage/parallel/map_reduce.html#module-sage.parallel.map_reduce" title="(in Parallel Computing v9.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.parallel.map_reduce</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.roots">
<span class="sig-name descname"><span class="pre">roots</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.roots" title="Permalink to this definition">#</a></dt>
<dd><p>Return an iterable over the roots of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">roots</span><span class="p">()]</span>
<span class="go">[(0, 0)]</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">roots</span><span class="p">()]</span>
<span class="go">[(0, 0), (1, 1)]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.sets.recursively_enumerated_set.</span></span><span class="sig-name descname"><span class="pre">RecursivelyEnumeratedSet_generic</span></span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Parents and Elements v9.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.parent.Parent</span></code></a></p>
<p>A generic recursively enumerated set.</p>
<p>For more information, see <a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet"><code class="xref py py-func docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet()</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:[</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Different structure for the sets:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">A recursively enumerated set (breadth first search)</span>
<span class="gp">sage: </span><span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;graded&#39;</span><span class="p">)</span>
<span class="go">A recursively enumerated set with a graded structure (breadth first search)</span>
<span class="gp">sage: </span><span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="go">A recursively enumerated set with a symmetric structure (breadth first search)</span>
<span class="gp">sage: </span><span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;forest&#39;</span><span class="p">)</span>
<span class="go">An enumerated set with a forest structure</span>
</pre></div>
</div>
<p>Different default enumeration algorithms:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">enumeration</span><span class="o">=</span><span class="s1">&#39;breadth&#39;</span><span class="p">)</span>
<span class="go">A recursively enumerated set (breadth first search)</span>
<span class="gp">sage: </span><span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">enumeration</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">A recursively enumerated set (naive search)</span>
<span class="gp">sage: </span><span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">enumeration</span><span class="o">=</span><span class="s1">&#39;depth&#39;</span><span class="p">)</span>
<span class="go">A recursively enumerated set (depth first search)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.breadth_first_search_iterator">
<span class="sig-name descname"><span class="pre">breadth_first_search_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.breadth_first_search_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Iterate on the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> (breadth first).</p>
<p>This code remembers every element generated.</p>
<p>The elements are guaranteed to be enumerated in the order in which they
are first visited (left-to-right traversal).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">max_depth</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">self._max_depth</span></code>) specifies the
maximal depth to which elements are computed</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[0, 3, 5, 6, 8, 10, 9, 11, 13, 15]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.depth_first_search_iterator">
<span class="sig-name descname"><span class="pre">depth_first_search_iterator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.depth_first_search_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Iterate on the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> (depth first).</p>
<p>This code remembers every elements generated.</p>
<p>The elements are traversed right-to-left, so the last element returned
by the successor function is visited first.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Depth-first_search">Wikipedia article Depth-first_search</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">depth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[0, 5, 10, 15, 20, 25, 30, 35, 40, 45]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.elements_of_depth_iterator">
<span class="sig-name descname"><span class="pre">elements_of_depth_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.elements_of_depth_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Iterate over the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> of given depth.</p>
<p>An element of depth <span class="math notranslate nohighlight">\(n\)</span> can be obtained applying <span class="math notranslate nohighlight">\(n\)</span> times the
successor function to a seed.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">depth</span></code> – integer</p></li>
</ul>
<p>OUTPUT:</p>
<p>An iterator.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">elements_of_depth_iterator</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">[3, 7, 8, 12]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.graded_component">
<span class="sig-name descname"><span class="pre">graded_component</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.graded_component" title="Permalink to this definition">#</a></dt>
<dd><p>Return the graded component of given depth.</p>
<p>This method caches each lower graded component.</p>
<p>A graded component is a set of elements of the same depth where the
depth of an element is its minimal distance to a root.</p>
<p>It is currently implemented only for graded or symmetric structure.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">depth</span></code> – integer</p></li>
</ul>
<p>OUTPUT:</p>
<p>A set.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: graded_component_iterator method currently implemented only for graded or symmetric structure</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.graded_component_iterator">
<span class="sig-name descname"><span class="pre">graded_component_iterator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.graded_component_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Iterate over the graded components of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>A graded component is a set of elements of the same depth.</p>
<p>It is currently implemented only for graded or symmetric structure.</p>
<p>OUTPUT:</p>
<p>An iterator of sets.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">graded_component_iterator</span><span class="p">()</span>    <span class="c1"># todo: not implemented</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.naive_search_iterator">
<span class="sig-name descname"><span class="pre">naive_search_iterator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.naive_search_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Iterate on the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> (in no particular order).</p>
<p>This code remembers every elements generated.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.seeds">
<span class="sig-name descname"><span class="pre">seeds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.seeds" title="Permalink to this definition">#</a></dt>
<dd><p>Return an iterable over the seeds of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">seeds</span><span class="p">()</span>
<span class="go">[1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.successors">
<span class="sig-name descname"><span class="pre">successors</span></span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.successors" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.to_digraph">
<span class="sig-name descname"><span class="pre">to_digraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multiedges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.to_digraph" title="Permalink to this definition">#</a></dt>
<dd><p>Return the directed graph of the recursively enumerated set.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">max_depth</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">self._max_depth</span></code>) specifies the
maximal depth for which outgoing edges of elements are computed</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">loops</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) option for the digraph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">multiedges</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) option of the digraph</p></li>
</ul>
<p>OUTPUT:</p>
<p>A directed graph</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If the set is infinite, this will loop forever unless <code class="docutils literal notranslate"><span class="pre">max_depth</span></code>
is finite.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">child</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">8</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">child</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">to_digraph</span><span class="p">()</span>
<span class="go">Looped multi-digraph on 10 vertices</span>
</pre></div>
</div>
<p>Digraph of an recursively enumerated set with a symmetric structure of
infinite cardinality using <code class="docutils literal notranslate"><span class="pre">max_depth</span></code> argument:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">succ</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">seeds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">(</span><span class="n">seeds</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">to_digraph</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Looped multi-digraph on 41 vertices</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">max_depth</span></code> argument can be given at the creation of the set:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">(</span><span class="n">seeds</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">to_digraph</span><span class="p">()</span>
<span class="go">Looped multi-digraph on 25 vertices</span>
</pre></div>
</div>
<p>Digraph of an recursively enumerated set with a graded structure:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">I</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;graded&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">to_digraph</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Looped multi-digraph on 21 vertices</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.sets.recursively_enumerated_set.</span></span><span class="sig-name descname"><span class="pre">RecursivelyEnumeratedSet_graded</span></span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic</span></code></a></p>
<p>Generic tool for constructing ideals of a graded relation.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">seeds</span></code> – list (or iterable) of hashable objects</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">successors</span></code> – function (or callable) returning a list (or iterable)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">enumeration</span></code> – <code class="docutils literal notranslate"><span class="pre">'depth'</span></code>, <code class="docutils literal notranslate"><span class="pre">'breadth'</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_depth</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">float(&quot;inf&quot;)</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;graded&#39;</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">A recursively enumerated set with a graded structure (breadth first</span>
<span class="go">search) with max_depth=3</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">[(0, 0),</span>
<span class="go"> (1, 0), (0, 1),</span>
<span class="go"> (2, 0), (1, 1), (0, 2),</span>
<span class="go"> (3, 0), (2, 1), (1, 2), (0, 3)]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded.breadth_first_search_iterator">
<span class="sig-name descname"><span class="pre">breadth_first_search_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded.breadth_first_search_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Iterate on the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> (breadth first).</p>
<p>This iterator makes use of the graded structure by remembering only
the elements of the current depth.</p>
<p>The elements are guaranteed to be enumerated in the order in which they
are first visited (left-to-right traversal).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">max_depth</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">self._max_depth</span></code>) specifies the
maximal depth to which elements are computed</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;graded&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
<span class="go">[(0, 0),</span>
<span class="go"> (1, 0), (0, 1),</span>
<span class="go"> (2, 0), (1, 1), (0, 2),</span>
<span class="go"> (3, 0), (2, 1), (1, 2), (0, 3)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded.graded_component">
<span class="sig-name descname"><span class="pre">graded_component</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded.graded_component" title="Permalink to this definition">#</a></dt>
<dd><p>Return the graded component of given depth.</p>
<p>This method caches each lower graded component. See
<a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded.graded_component_iterator" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded.graded_component_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graded_component_iterator()</span></code></a> to generate each graded component
without caching the previous ones.</p>
<p>A graded component is a set of elements of the same depth where the
depth of an element is its minimal distance to a root.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">depth</span></code> – integer</p></li>
</ul>
<p>OUTPUT:</p>
<p>A set.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">I</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;graded&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="go">[0]</span>
<span class="go">[I, 1]</span>
<span class="go">[2*I, I + 1, 2]</span>
<span class="go">[3*I, 2*I + 1, I + 2, 3]</span>
<span class="go">[4*I, 3*I + 1, 2*I + 2, I + 3, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded.graded_component_iterator">
<span class="sig-name descname"><span class="pre">graded_component_iterator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded.graded_component_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Iterate over the graded components of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>A graded component is a set of elements of the same depth.</p>
<p>The algorithm remembers only the current graded component generated
since the structure is graded.</p>
<p>OUTPUT:</p>
<p>An iterator of sets.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;graded&#39;</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">graded_component_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>
<span class="go">[(0, 0)]</span>
<span class="go">[(0, 1), (1, 0)]</span>
<span class="go">[(0, 2), (1, 1), (2, 0)]</span>
<span class="go">[(0, 3), (1, 2), (2, 1), (3, 0)]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.sets.recursively_enumerated_set.</span></span><span class="sig-name descname"><span class="pre">RecursivelyEnumeratedSet_symmetric</span></span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic</span></code></a></p>
<p>Generic tool for constructing ideals of a symmetric relation.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">seeds</span></code> – list (or iterable) of hashable objects</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">successors</span></code> – function (or callable) returning a list (or iterable)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">enumeration</span></code> – <code class="docutils literal notranslate"><span class="pre">'depth'</span></code>, <code class="docutils literal notranslate"><span class="pre">'breadth'</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_depth</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">float(&quot;inf&quot;)</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">A recursively enumerated set with a symmetric structure (breadth first search)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
<span class="go">[0, -1, 1, -2, 2, -3, 3]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric.breadth_first_search_iterator">
<span class="sig-name descname"><span class="pre">breadth_first_search_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric.breadth_first_search_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Iterate on the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> (breadth first).</p>
<p>This iterator makes use of the graded structure by remembering only
the last two graded components since the structure is symmetric.</p>
<p>The elements are guaranteed to be enumerated in the order in which they
are first visited (left-to-right traversal).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">max_depth</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">self._max_depth</span></code>) specifies the
maximal depth to which elements are computed</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">2</span><span class="p">));</span> <span class="n">s</span>
<span class="go">[(0, 0),</span>
<span class="go"> (-1, 0), (0, -1), (1, 0), (0, 1),</span>
<span class="go"> (-2, 0), (-1, -1), (-1, 1), (0, -2), (1, -1), (2, 0), (1, 1), (0, 2)]</span>
</pre></div>
</div>
<p>This iterator is used by default for symmetric structure:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">==</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">13</span><span class="p">)]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric.graded_component">
<span class="sig-name descname"><span class="pre">graded_component</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric.graded_component" title="Permalink to this definition">#</a></dt>
<dd><p>Return the graded component of given depth.</p>
<p>This method caches each lower graded component. See
<a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric.graded_component_iterator" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric.graded_component_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graded_component_iterator()</span></code></a> to generate each graded component
without caching the previous ones.</p>
<p>A graded component is a set of elements of the same depth where the
depth of an element is its minimal distance to a root.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">depth</span></code> – integer</p></li>
</ul>
<p>OUTPUT:</p>
<p>A set.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="go">[10, 15]</span>
<span class="go">[9, 11, 14, 16]</span>
<span class="go">[8, 12, 13, 17]</span>
<span class="go">[7, 18]</span>
<span class="go">[6, 19]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric.graded_component_iterator">
<span class="sig-name descname"><span class="pre">graded_component_iterator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric.graded_component_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Iterate over the graded components of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>A graded component is a set of elements of the same depth.</p>
<p>The enumeration remembers only the last two graded components
generated since the structure is symmetric.</p>
<p>OUTPUT:</p>
<p>An iterator of sets.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">10</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">graded_component_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="go">[[10], [9, 11], [8, 12], [7, 13], [6, 14]]</span>
</pre></div>
</div>
<p>Starting with two generators:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">graded_component_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="go">[[5, 10], [4, 6, 9, 11], [3, 7, 8, 12], [2, 13], [1, 14]]</span>
</pre></div>
</div>
<p>Gaussian integers:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">I</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">graded_component_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
<span class="go">[[0],</span>
<span class="go"> [I, 1],</span>
<span class="go"> [2*I, I + 1, 2],</span>
<span class="go"> [3*I, 2*I + 1, I + 2, 3],</span>
<span class="go"> [4*I, 3*I + 1, 2*I + 2, I + 3, 4],</span>
<span class="go"> [5*I, 4*I + 1, 3*I + 2, 2*I + 3, I + 4, 5],</span>
<span class="go"> [6*I, 5*I + 1, 4*I + 2, 3*I + 3, 2*I + 4, I + 5, 6]]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.sets.recursively_enumerated_set.search_forest_iterator">
<span class="sig-prename descclassname"><span class="pre">sage.sets.recursively_enumerated_set.</span></span><span class="sig-name descname"><span class="pre">search_forest_iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">roots</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">children</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'depth'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.search_forest_iterator" title="Permalink to this definition">#</a></dt>
<dd><p>Return an iterator on the nodes of the forest having the given
roots, and where <code class="docutils literal notranslate"><span class="pre">children(x)</span></code> returns the children of the node <code class="docutils literal notranslate"><span class="pre">x</span></code>
of the forest.  Note that every node of the tree is returned,
not simply the leaves.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">roots</span></code> – a list (or iterable)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">children</span></code> – a function returning a list (or iterable)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – <code class="docutils literal notranslate"><span class="pre">'depth'</span></code> or <code class="docutils literal notranslate"><span class="pre">'breadth'</span></code> (default: <code class="docutils literal notranslate"><span class="pre">'depth'</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<p>We construct the prefix tree of binary sequences of length at most
three, and enumerate its nodes:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">search_forest_iterator</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">search_forest_iterator</span><span class="p">([[]],</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="gp">....: </span>                                  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="p">[]))</span>
<span class="go">[[], [0], [0, 0], [0, 0, 0], [0, 0, 1], [0, 1], [0, 1, 0],</span>
<span class="go"> [0, 1, 1], [1], [1, 0], [1, 0, 0], [1, 0, 1], [1, 1], [1, 1, 0], [1, 1, 1]]</span>
</pre></div>
</div>
<p>By default, the nodes are iterated through by depth first search.
We can instead use a breadth first search (increasing depth):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">search_forest_iterator</span><span class="p">([[]],</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="gp">....: </span>                                  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="p">[],</span>
<span class="gp">....: </span>                            <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;breadth&#39;</span><span class="p">))</span>
<span class="go">[[],</span>
<span class="go"> [0], [1],</span>
<span class="go"> [0, 0], [0, 1], [1, 0], [1, 1],</span>
<span class="go"> [0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 1, 1],</span>
<span class="go"> [1, 0, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1]]</span>
</pre></div>
</div>
<p>This allows for iterating trough trees of infinite depth:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">search_forest_iterator</span><span class="p">([[]],</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;breadth&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[[],</span>
<span class="go"> [0], [1], [0, 0], [0, 1], [1, 0], [1, 1],</span>
<span class="go"> [0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 1, 1],</span>
<span class="go"> [1, 0, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1],</span>
<span class="go"> [0, 0, 0, 0]]</span>
</pre></div>
</div>
<p>Here is an iterator through the prefix tree of sequences of
letters in <span class="math notranslate nohighlight">\(0,1,2\)</span> without repetitions, sorted by length; the
leaves are therefore permutations:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">search_forest_iterator</span><span class="p">([[]],</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">l</span><span class="p">],</span>
<span class="gp">....: </span>                            <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;breadth&#39;</span><span class="p">))</span>
<span class="go">[[],</span>
<span class="go"> [0], [1], [2],</span>
<span class="go"> [0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1],</span>
<span class="go"> [0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]]</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="condition_set.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Subsets of a Universe Defined by Predicates</div>
              </div>
              <svg><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="finite_enumerated_set.html">
              <svg><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Finite Enumerated Sets</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2005--2022, The Sage Development Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            Contents
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Recursively enumerated set</a><ul>
<li><a class="reference internal" href="#no-hypothesis-on-the-structure">No hypothesis on the structure</a></li>
<li><a class="reference internal" href="#symmetric-structure">Symmetric structure</a></li>
<li><a class="reference internal" href="#graded-structure">Graded structure</a></li>
<li><a class="reference internal" href="#forest-structure">Forest structure</a></li>
<li><a class="reference internal" href="#example-forest-structure">Example: Forest structure</a></li>
<li><a class="reference internal" href="#example-forest-structure-2">Example: Forest structure 2</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    <script src="../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"ZZ": "\\Bold{Z}", "NN": "\\Bold{N}", "RR": "\\Bold{R}", "CC": "\\Bold{C}", "QQ": "\\Bold{Q}", "QQbar": "\\overline{\\QQ}", "GF": ["\\Bold{F}_{#1}", 1], "Zp": ["\\Bold{Z}_{#1}", 1], "Qp": ["\\Bold{Q}_{#1}", 1], "Zmod": ["\\ZZ/#1\\ZZ", 1], "CDF": "\\Bold{C}", "CIF": "\\Bold{C}", "CLF": "\\Bold{C}", "RDF": "\\Bold{R}", "RIF": "\\Bold{I} \\Bold{R}", "RLF": "\\Bold{R}", "SL": "\\mathrm{SL}", "PSL": "\\mathrm{PSL}", "Bold": ["\\mathbf{#1}", 1]}, "inlineMath": [["$", "$"], ["\\(", "\\)"]], "maxBuffer": 51200, "autoload": {"color": [], "colorv2": ["color"]}}}</script>
    <script defer="defer" src="../../../_static/mathjax/tex-chtml.js"></script>
    </body>
</html>