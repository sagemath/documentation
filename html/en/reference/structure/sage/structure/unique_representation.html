<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Unique Representation &mdash; Sage Reference Manual v7.1: Basic Structures</title>
    
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v7.1: Basic Structures" href="../../index.html" />
    <link rel="next" title="Factory for cached representations" href="factory.html" />
    <link rel="prev" title="Whether or not computations are provably correct by default" href="../misc/proof.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="factory.html" title="Factory for cached representations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../misc/proof.html" title="Whether or not computations are provably correct by default"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Basic Structures</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="unique-representation">
<span id="sage-structure-unique-representation"></span><h1>Unique Representation<a class="headerlink" href="#unique-representation" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.structure.unique_representation"></span><p>Abstract classes for cached and unique representation behavior.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="factory.html#sage.structure.factory.UniqueFactory" title="sage.structure.factory.UniqueFactory"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.factory.UniqueFactory</span></tt></a></p>
</div>
<p>AUTHORS:</p>
<ul class="simple">
<li>Nicolas M. Thiery (2008): Original version.</li>
<li>Simon A. King (2013-02): Separate cached and unique representation.</li>
<li>Simon A. King (2013-08): Extended documentation.</li>
</ul>
<div class="section" id="what-is-a-cached-representation">
<h2>What is a cached representation?<a class="headerlink" href="#what-is-a-cached-representation" title="Permalink to this headline">¶</a></h2>
<p>Instances of a class have a <em>cached representation behavior</em> when several
instances constructed with the same arguments share the same memory
representation. For example, calling twice:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>to create the symmetric group on six elements gives back the same
object:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="ow">is</span> <span class="n">H</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This is a standard design pattern. Besides saving memory, it allows for
sharing cached data (say representation theoretical information about a
group). And of course a look-up in the cache is faster than the creation of a
new object.</p>
<div class="section" id="implementing-a-cached-representation">
<h3>Implementing a cached representation<a class="headerlink" href="#implementing-a-cached-representation" title="Permalink to this headline">¶</a></h3>
<p>Sage provides two standard ways to create a cached representation:
<a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a> and
<a class="reference internal" href="factory.html#sage.structure.factory.UniqueFactory" title="sage.structure.factory.UniqueFactory"><tt class="xref py py-class docutils literal"><span class="pre">UniqueFactory</span></tt></a>. Note that, in spite of its
name, <a class="reference internal" href="factory.html#sage.structure.factory.UniqueFactory" title="sage.structure.factory.UniqueFactory"><tt class="xref py py-class docutils literal"><span class="pre">UniqueFactory</span></tt></a> does not ensure <em>unique</em>
representation behaviour, which will be explained below.</p>
<div class="section" id="using-cachedrepresentation">
<h4>Using <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a><a class="headerlink" href="#using-cachedrepresentation" title="Permalink to this headline">¶</a></h4>
<p>It is often very easy to use <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a>: One simply writes
a Python class and adds <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a> to the list of base
classes. If one does so, then the arguments used to create an instance of this
class will by default also be used as keys for the cache:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.structure.unique_representation</span> <span class="kn">import</span> <span class="n">CachedRepresentation</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="go">....:     def __init__(self, a, b=0):</span>
<span class="go">....:         self.a = a</span>
<span class="go">....:         self.b = b</span>
<span class="go">....:     def __repr__(self):</span>
<span class="go">....:         return &quot;C(%s, %s)&quot;%(self.a, self.b)</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In addition, pickling just works, provided that Python is able to look up the
class. Hence, in the following two lines, we explicitly put the class into the
<tt class="docutils literal"><span class="pre">__main__</span></tt> module. This is needed in doctests, but not in an interactive
session:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">C</span>
<span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Often, this very easy approach is sufficient for applications. However, there
are some pitfalls. Since the arguments are used for caching, all arguments
must be hashable, i.e., must be valid as dictionary keys:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="go">C((1, 2), 0)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">unhashable type: &#39;list&#39;</span>
</pre></div>
</div>
<p>In addition, equivalent ways of providing the arguments are <em>not</em>
automatically normalised when forming the cache key, and hence different but
equivalent arguments may yield distinct instances:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">repr</span><span class="p">(</span><span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="nb">repr</span><span class="p">(</span><span class="n">C</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>It should also be noted that the arguments are compared by equality, not by
identity. This is often desired, but can imply subtle problems. For example,
since <tt class="docutils literal"><span class="pre">C(1)</span></tt> already is in the cache, and since the unit elements in
different finite fields are all equal to the integer one, we find:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">)(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">)(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">)(</span><span class="mi">1</span><span class="p">))</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">)(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>But <tt class="docutils literal"><span class="pre">C(2)</span></tt> is not in the cache, and the number two is not equal in different
finite fields (i. e., <tt class="docutils literal"><span class="pre">GF(5)(2)</span> <span class="pre">==</span> <span class="pre">GF(3)(2)</span></tt> returns as <tt class="docutils literal"><span class="pre">False</span></tt>), even
though it is equal to the number two in the ring of integers (
<tt class="docutils literal"><span class="pre">GF(5)(2)</span> <span class="pre">==</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">GF(3)(2)</span></tt> returns as <tt class="docutils literal"><span class="pre">True</span></tt>; equality is not transitive
when comparing elements of <em>distinct</em> algebraic structures!!). Hence, we
have:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">)(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">)(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">)(</span><span class="mi">2</span><span class="p">))</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">)(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="section" id="normalising-the-arguments">
<h5>Normalising the arguments<a class="headerlink" href="#normalising-the-arguments" title="Permalink to this headline">¶</a></h5>
<p><a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a> uses the metaclass
<a class="reference external" href="../../../misc/sage/misc/classcall_metaclass.html#sage.misc.classcall_metaclass.ClasscallMetaclass" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">ClasscallMetaclass</span></tt></a>. Its
<tt class="docutils literal"><span class="pre">__classcall__</span></tt> method is a
<a class="reference external" href="../../../misc/sage/misc/cachefunc.html#sage.misc.cachefunc.WeakCachedFunction" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">WeakCachedFunction</span></tt></a>.  This function creates an
instance of the given class using the given arguments, unless it finds the
result in the cache. This has the following implications:</p>
<ul class="simple">
<li>The arguments must be valid dictionary keys (i.e., they must be hashable;
see above).</li>
<li>It is a weak cache, hence, if the user does not keep a reference to the
resulting instance, then it may be removed from the cache during garbage
collection.</li>
<li>It is possible to preprocess the input arguments by implementing a
<tt class="docutils literal"><span class="pre">__classcall__</span></tt> or a <tt class="docutils literal"><span class="pre">__classcall_private__</span></tt> method, but in order to
benefit from caching, <tt class="xref py py-meth docutils literal"><span class="pre">CachedRepresentation.__classcall__()</span></tt> should at
some point be called.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>For technical reasons, it is needed that <tt class="docutils literal"><span class="pre">__classcall__</span></tt> respectively
<tt class="docutils literal"><span class="pre">__classcall_private__</span></tt> are &#8220;static methods&#8221;, i.e., they are callable
objects that do not bind to an instance or class. For example, a
<tt class="xref py py-class docutils literal"><span class="pre">cached_function</span></tt> can be used here, because it
is callable, but does not bind to an instance or class, because it has no
<tt class="docutils literal"><span class="pre">__get__()</span></tt> method. A usual Python function, however, has a
<tt class="docutils literal"><span class="pre">__get__()</span></tt> method and would thus under normal circumstances bind to an
instance or class, and thus the instance or class would be passed to the
function as the first argument. To prevent a callable object from being
bound to the instance or class, one can prepend the <tt class="docutils literal"><span class="pre">&#64;staticmethod</span></tt>
decorator to the definition; see <tt class="xref py py-class docutils literal"><span class="pre">staticmethod</span></tt>.</p>
<p class="last">For more on Python&#8217;s <tt class="docutils literal"><span class="pre">__get__()</span></tt> method, see:
<a class="reference external" href="http://docs.python.org/2/howto/descriptor.html">http://docs.python.org/2/howto/descriptor.html</a></p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If there is preprocessing, then the preprocessed arguments
passed to <tt class="xref py py-meth docutils literal"><span class="pre">CachedRepresentation.__classcall__()</span></tt> must be invariant
under the preprocessing. That is to say, preprocessing the input
arguments twice must have the same effect as preprocessing the input
arguments only once. That is to say, the preprocessing must be idempotent.</p>
</div>
<p>The reason for this warning lies in the way pickling is implemented. If the
preprocessed arguments are passed to
<tt class="xref py py-meth docutils literal"><span class="pre">CachedRepresentation.__classcall__()</span></tt>, then the resulting instance will
store the <em>preprocessed</em> arguments in some attribute, and will use them for
pickling. If the pickle is unpickled, then preprocessing is applied to the
preprocessed arguments&#8212;and this second round of preprocessing must not
change the arguments further, since otherwise a different instance would be
created.</p>
<p>We illustrate the warning by an example. Imagine that one has instances that
are created with an integer-valued argument, but only depend on the <em>square</em>
of the argument. It would be a mistake to square the given argument during
preprocessing:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">WrongUsage</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="go">....:     @staticmethod</span>
<span class="go">....:     def __classcall__(cls, n):</span>
<span class="go">....:         return super(WrongUsage,cls).__classcall__(cls, n^2)</span>
<span class="go">....:     def __init__(self, n):</span>
<span class="go">....:         self.n = n</span>
<span class="go">....:     def __repr__(self):</span>
<span class="go">....:         return &quot;Something(%d)&quot;%self.n</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">WrongUsage</span> <span class="o">=</span> <span class="n">WrongUsage</span> <span class="c1"># This is only needed in doctests</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">WrongUsage</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">w</span>
<span class="go">Something(9)</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">_reduction</span>
<span class="go">(&lt;class &#39;__main__.WrongUsage&#39;&gt;, (9,), {})</span>
</pre></div>
</div>
<p>Indeed, the reduction data are obtained from the preprocessed argument. By
consequence, if the resulting instance is pickled and unpickled, the argument
gets squared <em>again</em>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
<span class="go">Something(81)</span>
</pre></div>
</div>
<p>Instead, the preprocessing should only take the absolute value of the given
argument, while the squaring should happen inside of the <tt class="docutils literal"><span class="pre">__init__</span></tt> method,
where it won&#8217;t mess with the cache:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">BetterUsage</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="go">....:     @staticmethod</span>
<span class="go">....:     def __classcall__(cls, n):</span>
<span class="go">....:         return super(BetterUsage, cls).__classcall__(cls, abs(n))</span>
<span class="go">....:     def __init__(self, n):</span>
<span class="go">....:         self.n = n^2</span>
<span class="go">....:     def __repr__(self):</span>
<span class="go">....:         return &quot;SomethingElse(%d)&quot;%self.n</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">BetterUsage</span> <span class="o">=</span> <span class="n">BetterUsage</span> <span class="c1"># This is only needed in doctests</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BetterUsage</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">b</span>
<span class="go">SomethingElse(9)</span>
<span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="ow">is</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="ow">is</span> <span class="n">BetterUsage</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In our next example, we create a cached representation class <tt class="docutils literal"><span class="pre">C</span></tt> that
returns an instance of a sub-class <tt class="docutils literal"><span class="pre">C1</span></tt> or <tt class="docutils literal"><span class="pre">C2</span></tt> depending on the given
arguments. This is implemented in a static <tt class="docutils literal"><span class="pre">__classcall_private__</span></tt> method of
<tt class="docutils literal"><span class="pre">C</span></tt>, letting it choose the sub-class according to the given arguments. Since
a <tt class="docutils literal"><span class="pre">__classcall_private__</span></tt> method will be ignored on sub-classes, the caching
of <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a> is available to both <tt class="docutils literal"><span class="pre">C1</span></tt> and <tt class="docutils literal"><span class="pre">C2</span></tt>. But
for illustration, we overload the static <tt class="docutils literal"><span class="pre">__classcall__</span></tt> method on <tt class="docutils literal"><span class="pre">C2</span></tt>,
doing some argument preprocessing. We also create a sub-class <tt class="docutils literal"><span class="pre">C2b</span></tt> of
<tt class="docutils literal"><span class="pre">C2</span></tt>, demonstrating that the <tt class="docutils literal"><span class="pre">__classcall__</span></tt> method is used on the
sub-class (in contrast to a <tt class="docutils literal"><span class="pre">__classcall_private__</span></tt> method!).</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="go">....:     @staticmethod</span>
<span class="go">....:     def __classcall_private__(cls, n, implementation=0):</span>
<span class="go">....:         if not implementation:</span>
<span class="go">....:             return C.__classcall__(cls, n)</span>
<span class="go">....:         if implementation==1:</span>
<span class="go">....:             return C1(n)</span>
<span class="go">....:         if implementation&gt;1:</span>
<span class="go">....:             return C2(n,implementation)</span>
<span class="go">....:     def __init__(self, n):</span>
<span class="go">....:         self.n = n</span>
<span class="go">....:     def __repr__(self):</span>
<span class="go">....:         return &quot;C(%d, 0)&quot;%self.n</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">C1</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
<span class="go">....:     def __repr__(self):</span>
<span class="go">....:         return &quot;C1(%d)&quot;%self.n</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">C2</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
<span class="go">....:     @staticmethod</span>
<span class="go">....:     def __classcall__(cls, n, implementation=0):</span>
<span class="go">....:         if implementation:</span>
<span class="go">....:             return super(C2, cls).__classcall__(cls, (n,)*implementation)</span>
<span class="go">....:         return super(C2, cls).__classcall__(cls, n)</span>
<span class="go">....:     def __init__(self, t):</span>
<span class="go">....:         self.t = t</span>
<span class="go">....:     def __repr__(self):</span>
<span class="go">....:         return &quot;C2(%s)&quot;%repr(self.t)</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">C2b</span><span class="p">(</span><span class="n">C2</span><span class="p">):</span>
<span class="go">....:     def __repr__(self):</span>
<span class="go">....:         return &quot;C2b(%s)&quot;%repr(self.t)</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">C2</span> <span class="o">=</span> <span class="n">C2</span>      <span class="c1"># not needed in an interactive session</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">C2b</span> <span class="o">=</span> <span class="n">C2b</span>
</pre></div>
</div>
<p>In the above example, <tt class="docutils literal"><span class="pre">C</span></tt> drops the argument <tt class="docutils literal"><span class="pre">implementation</span></tt> if it
evaluates to <tt class="docutils literal"><span class="pre">False</span></tt>, and since the cached <tt class="docutils literal"><span class="pre">__classcall__</span></tt> is called in
this case, we have:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">C(1, 0)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">,[])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>(Note that we were able to bypass the issue of arguments having to be
hashable by catching the empty list <tt class="docutils literal"><span class="pre">[]</span></tt> during preprocessing in the
<tt class="docutils literal"><span class="pre">__classcall_private__</span></tt> method. Similarly, unhashable arguments can
be made hashable &#8211; e. g., lists normalized to tuples &#8211; in the
<tt class="docutils literal"><span class="pre">__classcall_private__</span></tt> method before they are further delegated to
<tt class="docutils literal"><span class="pre">__classcall__</span></tt>. See
<a class="reference external" href="../../../combinat/sage/combinat/crystals/elementary_crystals.html#sage.combinat.crystals.elementary_crystals.TCrystal" title="(in Sage Reference Manual: Combinatorics v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">TCrystal</span></tt></a> for an
example.)</p>
<p>If we call <tt class="docutils literal"><span class="pre">C1</span></tt> directly or if we provide <tt class="docutils literal"><span class="pre">implementation=1</span></tt> to <tt class="docutils literal"><span class="pre">C</span></tt>, we
obtain an instance of <tt class="docutils literal"><span class="pre">C1</span></tt>. Since it uses the <tt class="docutils literal"><span class="pre">__classcall__</span></tt> method
inherited from <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a>, the resulting instances are
cached:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C1</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">C1(2)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">C1(2)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="n">C1</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The class <tt class="docutils literal"><span class="pre">C2</span></tt> preprocesses the input arguments. Instances can, again, be
obtained directly or by calling <tt class="docutils literal"><span class="pre">C</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">C2((1, 1, 1))</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="ow">is</span> <span class="n">C2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The argument preprocessing of <tt class="docutils literal"><span class="pre">C2</span></tt> is inherited by <tt class="docutils literal"><span class="pre">C2b</span></tt>, since
<tt class="docutils literal"><span class="pre">__classcall__</span></tt> and not <tt class="docutils literal"><span class="pre">__classcall_private__</span></tt> is used. Pickling works,
since the preprocessing of arguments is idempotent:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c2b</span> <span class="o">=</span> <span class="n">C2b</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span> <span class="n">c2b</span>
<span class="go">C2b((2, 2, 2))</span>
<span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">c2b</span><span class="p">))</span> <span class="ow">is</span> <span class="n">c2b</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="using-uniquefactory">
<h4>Using <a class="reference internal" href="factory.html#sage.structure.factory.UniqueFactory" title="sage.structure.factory.UniqueFactory"><tt class="xref py py-class docutils literal"><span class="pre">UniqueFactory</span></tt></a><a class="headerlink" href="#using-uniquefactory" title="Permalink to this headline">¶</a></h4>
<p>For creating a cached representation using a factory, one has to</p>
<ul class="simple">
<li>create a class <em>separately</em> from the factory. This class <strong>must</strong> inherit
from <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt>. Its instances <strong>must</strong> allow attribute assignment.</li>
<li>write a method <tt class="docutils literal"><span class="pre">create_key</span></tt> (or <tt class="docutils literal"><span class="pre">create_key_and_extra_args</span></tt>) that
creates the cache key from the given arguments.</li>
<li>write a method <tt class="docutils literal"><span class="pre">create_object</span></tt> that creates an instance of the class
from a given cache key.</li>
<li>create an instance of the factory with a name that allows to conclude where
it is defined.</li>
</ul>
<p>An example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">....:     def __init__(self, t):</span>
<span class="go">....:         self.t = t</span>
<span class="go">....:     def __repr__(self):</span>
<span class="go">....:         return &quot;C%s&quot;%repr(self.t)</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.structure.factory</span> <span class="kn">import</span> <span class="n">UniqueFactory</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFactory</span><span class="p">(</span><span class="n">UniqueFactory</span><span class="p">):</span>
<span class="go">....:     def create_key(self, n, m=None):</span>
<span class="go">....:         if isinstance(n, (tuple,list)) and m is None:</span>
<span class="go">....:             return tuple(n)</span>
<span class="go">....:         return (n,)*m</span>
<span class="go">....:     def create_object(self, version, key, **extra_args):</span>
<span class="go">....:         # We ignore version and extra_args</span>
<span class="go">....:         return C(key)</span>
<span class="go">....:</span>
</pre></div>
</div>
<p>Now, we define an instance of the factory, stating that it can be found under
the name <tt class="docutils literal"><span class="pre">&quot;F&quot;</span></tt> in the <tt class="docutils literal"><span class="pre">__main__</span></tt> module. By consequence, pickling works:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">MyFactory</span><span class="p">(</span><span class="s2">&quot;__main__.F&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="n">F</span>                <span class="c1"># not needed in an interactive session</span>
<span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">F</span><span class="p">))</span> <span class="ow">is</span> <span class="n">F</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can now create <em>cached</em> instances of <tt class="docutils literal"><span class="pre">C</span></tt> by calling the factory. The
cache only takes into account the key computed with the method <tt class="docutils literal"><span class="pre">create_key</span></tt>
that we provided. Hence, different given arguments may result in the same
instance. Note that, again, the cache is weak, hence, the instance might be
removed from the cache during garbage collection, unless an external reference
is preserved.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="n">a</span>
<span class="go">C(1, 1)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="ow">is</span> <span class="n">F</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p><strong>If</strong> the class of the returned instances is a sub-class of <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt>,
and <strong>if</strong> the resulting instance allows attribute assignment, then pickling
of the resulting instances is automatically provided for, and respects the
cache.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This is because an attribute is stored that explains how the instance was
created:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">_factory_data</span>
<span class="go">(&lt;class &#39;__main__.MyFactory&#39;&gt;, (...), (1, 1), {})</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If a class is used that does not inherit from <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt> then unique
pickling is <em>not</em> provided.</p>
</div>
<p>Caching is only available if the factory is called. If an instance of the
class is directly created, then the cache is not used:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">C(1, 1)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">False</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="comparing-the-two-ways-of-implementing-a-cached-representation">
<h3>Comparing the two ways of implementing a cached representation<a class="headerlink" href="#comparing-the-two-ways-of-implementing-a-cached-representation" title="Permalink to this headline">¶</a></h3>
<p>In this sub-section, we discuss advantages and disadvantages of the two ways
of implementing a cached representation, depending on the type of application.</p>
<div class="section" id="simplicity-and-transparency">
<h4>Simplicity and transparency<a class="headerlink" href="#simplicity-and-transparency" title="Permalink to this headline">¶</a></h4>
<p>In many cases, turning a class into a cached representation requires nothing
more than adding <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a> to the list of base classes of
this class. This is, of course, a very easy and convenient way. Writing a
factory would involve a lot more work.</p>
<p>If preprocessing of the arguments is needed, then we have seen how to do this
by a <tt class="docutils literal"><span class="pre">__classcall_private__</span></tt> or <tt class="docutils literal"><span class="pre">__classcall__</span></tt> method. But these are
double underscore methods and hence, for example, invisible in the
automatically created reference manual. Moreover, preprocessing <em>and</em> caching
are implemented in the same method, which might be confusing. In a unique
factory, these two tasks are cleanly implemented in two separate methods.
With a factory, it is possible to create the resulting instance by arguments
that are different from the key used for caching. This is significantly
restricted with CachedRepresentation due to the requirement that argument
preprocessing be idempotent.</p>
<p>Hence, if advanced preprocessing is needed, then
<a class="reference internal" href="factory.html#sage.structure.factory.UniqueFactory" title="sage.structure.factory.UniqueFactory"><tt class="xref py py-class docutils literal"><span class="pre">UniqueFactory</span></tt></a> might be easier and more
transparent to use than <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a>.</p>
</div>
<div class="section" id="class-inheritance">
<h4>Class inheritance<a class="headerlink" href="#class-inheritance" title="Permalink to this headline">¶</a></h4>
<p>Using <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a> has the advantage that one has a class and
creates cached instances of this class by the usual Python syntax:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">SymmetricGroup</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">unique_representation</span><span class="o">.</span><span class="n">CachedRepresentation</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">SymmetricGroup</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In contrast, a factory is just a callable object that returns something that
has absolutely nothing to do with the factory, and may in fact return
instances of quite different classes:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">GF</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">UniqueFactory</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K5</span> <span class="o">=</span> <span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">K5</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.rings.finite_rings.finite_field_prime_modn.FiniteField_prime_modn_with_category&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">K25</span> <span class="o">=</span> <span class="n">GF</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">K25</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.rings.finite_rings.finite_field_givaro.FiniteField_givaro_with_category&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">Kp</span> <span class="o">=</span> <span class="n">GF</span><span class="p">(</span><span class="n">next_prime_power</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">Kp</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.rings.finite_rings.finite_field_pari_ffelt.FiniteField_pari_ffelt_with_category&#39;&gt;</span>
</pre></div>
</div>
<p>This can be confusing to the user. Namely, the user might determine the class
of an instance and try to create further instances by calling the class rather
than the factory&#8212;which is a mistake since it works around the cache (and
also since the class might be more restrictive than the factory &#8211; i. e., the
type of <tt class="docutils literal"><span class="pre">K5</span></tt> in the above doctest cannot be called on a prime power which
is not a prime). This mistake can more easily be avoided by using
<a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a>.</p>
<p>We have seen above that one can easily create new cached-representation
classes by subclassing an existing cached-representation class, even making
use of an existing argument preprocess. This would be much more complicated
with a factory. Namely, one would need to rewrite old factories making them
aware of the new classes, and/or write new factories for the new classes.</p>
</div>
<div class="section" id="python-versus-extension-classes">
<h4>Python versus extension classes<a class="headerlink" href="#python-versus-extension-classes" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a> uses a metaclass, namely
<a class="reference external" href="../../../misc/sage/misc/classcall_metaclass.html#sage.misc.classcall_metaclass.ClasscallMetaclass" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">ClasscallMetaclass</span></tt></a>. Hence, it can
currently not be a Cython extension class. Moreover, it is supposed to be used
by providing it as a base class. But in typical applications, one also has
another base class, say, <a class="reference internal" href="parent.html#sage.structure.parent.Parent" title="sage.structure.parent.Parent"><tt class="xref py py-class docutils literal"><span class="pre">Parent</span></tt></a>. Hence, one
would like to create a class with at least two base classes, which is
currently impossible in Cython extension classes.</p>
<p>In other words, when using <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a>, one must work with
Python classes. These can be defined in Cython code (<tt class="docutils literal"><span class="pre">.pyx</span></tt> files) and can
thus benefit from Cython&#8217;s speed inside of their methods, but they must not be
<tt class="docutils literal"><span class="pre">cdef</span> <span class="pre">class</span></tt> and can thus not use <tt class="docutils literal"><span class="pre">cdef</span></tt> attributes or methods.</p>
<p>Such restrictions do not exist when using a factory. However, if attribute
assignment does not work, then the automatic pickling provided by
<a class="reference internal" href="factory.html#sage.structure.factory.UniqueFactory" title="sage.structure.factory.UniqueFactory"><tt class="xref py py-class docutils literal"><span class="pre">UniqueFactory</span></tt></a> will not be available.</p>
</div>
</div>
</div>
<div class="section" id="what-is-a-unique-representation">
<h2>What is a unique representation?<a class="headerlink" href="#what-is-a-unique-representation" title="Permalink to this headline">¶</a></h2>
<p>Instances of a class have a <em>unique instance behavior</em> when instances of this
class evaluate equal if and only if they are identical. Sage provides the base
class <a class="reference external" href="../../../misc/sage/misc/fast_methods.html#sage.misc.fast_methods.WithEqualityById" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">WithEqualityById</span></tt></a>, which provides
comparison by identity and a hash that is determined by the memory address of
the instance. Both the equality test and the hash are implemented in Cython
and are very fast, even when one has a Python class inheriting from
<a class="reference external" href="../../../misc/sage/misc/fast_methods.html#sage.misc.fast_methods.WithEqualityById" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">WithEqualityById</span></tt></a>.</p>
<p>In many applications, one wants to combine unique instance and cached
representation behaviour. This is called <em>unique representation</em> behaviour.
We have seen above that symmetric groups have a <em>cached</em> representation
behaviour. However, they do not show the <em>unique</em> representation behaviour,
since they are equal to groups created in a totally different way, namely to
subgroups:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G3</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgroup</span><span class="p">([</span><span class="n">G</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">)),</span><span class="n">G</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="ow">is</span> <span class="n">G3</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">G3</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">==</span> <span class="n">G3</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The unique representation behaviour can conveniently be implemented with a
class that inherits from <a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">UniqueRepresentation</span></tt></a>: By adding
<a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">UniqueRepresentation</span></tt></a> to the base classes, the class will
simultaneously inherit from <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a> and from
<a class="reference external" href="../../../misc/sage/misc/fast_methods.html#sage.misc.fast_methods.WithEqualityById" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">WithEqualityById</span></tt></a>.</p>
<p>For example, a symmetric function algebra is uniquely determined by the base
ring. Thus, it is reasonable to use <a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">UniqueRepresentation</span></tt></a> in this
case:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">CC</span><span class="p">),</span> <span class="n">SymmetricFunctions</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">,</span> <span class="n">UniqueRepresentation</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p><a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">UniqueRepresentation</span></tt></a> differs from <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a> only
by adding <a class="reference external" href="../../../misc/sage/misc/fast_methods.html#sage.misc.fast_methods.WithEqualityById" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">WithEqualityById</span></tt></a> as a base
class. Hence, the above examples of argument preprocessing work for
<a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">UniqueRepresentation</span></tt></a> as well.</p>
<p>Note that a cached representation created with
<a class="reference internal" href="factory.html#sage.structure.factory.UniqueFactory" title="sage.structure.factory.UniqueFactory"><tt class="xref py py-class docutils literal"><span class="pre">UniqueFactory</span></tt></a> does <em>not</em> automatically
provide unique representation behaviour, in spite of its name! Hence, for
unique representation behaviour, one has to implement hash and equality test
accordingly, for example by inheriting from
<a class="reference external" href="../../../misc/sage/misc/fast_methods.html#sage.misc.fast_methods.WithEqualityById" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">WithEqualityById</span></tt></a>.</p>
<dl class="class">
<dt id="sage.structure.unique_representation.CachedRepresentation">
<em class="property">class </em><tt class="descclassname">sage.structure.unique_representation.</tt><tt class="descname">CachedRepresentation</tt><a class="headerlink" href="#sage.structure.unique_representation.CachedRepresentation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Classes derived from CachedRepresentation inherit a weak cache for their
instances.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If this class is used as a base class, then instances are (weakly)
cached, according to the arguments used to create the instance.
Pickling is provided, of course by using the cache.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Using this class, one can have arbitrary hash and comparison.
Hence, <em>unique</em> representation behaviour is <em>not</em> provided.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">UniqueRepresentation</span></tt></a>, <a class="reference internal" href="#module-sage.structure.unique_representation" title="sage.structure.unique_representation"><tt class="xref py py-mod docutils literal"><span class="pre">unique_representation</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<p>Providing a class with a weak cache for the instances is easy: Just
inherit from <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.structure.unique_representation</span> <span class="kn">import</span> <span class="n">CachedRepresentation</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="go">....:     # all the rest as usual</span>
<span class="go">....:     pass</span>
</pre></div>
</div>
<p>We start with a simple class whose constructor takes a single
value as argument (TODO: find a more meaningful example):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="go">....:     def __init__(self, value):</span>
<span class="go">....:         self.value = value</span>
<span class="go">....:     def __cmp__(self, other):</span>
<span class="go">....:         c = cmp(type(self),type(other))</span>
<span class="go">....:         if c: return c</span>
<span class="go">....:         return cmp(self.value, other.value)</span>
</pre></div>
</div>
<p>Two coexisting instances of <tt class="docutils literal"><span class="pre">MyClass</span></tt> created with the same argument data
are guaranteed to share the same identity. Since <a class="reference external" href="http://trac.sagemath.org/12215">trac ticket #12215</a>, this is
only the case if there is some strong reference to the returned instance,
since otherwise it may be garbage collected:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="ow">is</span> <span class="n">y</span>               <span class="c1"># There is a strong reference</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="ow">is</span> <span class="n">z</span>
<span class="go">False</span>
</pre></div>
</div>
<p>In particular, modifying any one of them modifies the other
(reference effect):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">value</span>
<span class="go">(3, 3)</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">value</span>
<span class="go">(1, 1)</span>
</pre></div>
</div>
<p>The arguments can consist of any combination of positional or keyword
arguments, as taken by a usual <a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__init__" title="(in Python v2.7)"><tt class="xref py py-meth docutils literal"><span class="pre">__init__</span></tt></a>
function. However, all values passed in should be hashable:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MyClass</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">unhashable type: &#39;list&#39;</span>
</pre></div>
</div>
<p class="rubric">Argument preprocessing</p>
<p>Sometimes, one wants to do some preprocessing on the arguments, to
put them in some canonical form. The following example illustrates
how to achieve this; it takes as argument any iterable, and
canonicalizes it into a tuple (which is hashable!):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass2</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="go">....:     @staticmethod</span>
<span class="go">....:     def __classcall__(cls, iterable):</span>
<span class="go">....:         t = tuple(iterable)</span>
<span class="go">....:         return super(MyClass2, cls).__classcall__(cls, t)</span>
<span class="go">....:</span>
<span class="go">....:     def __init__(self, value):</span>
<span class="go">....:         self.value = value</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass2</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">MyClass2</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">MyClass2</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">value</span>
<span class="go">(1, 2, 3)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="ow">is</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="ow">is</span> <span class="n">z</span>
<span class="go">(True, True)</span>
</pre></div>
</div>
<p>A similar situation arises when the constructor accepts default
values for some of its parameters. Alas, the obvious
implementation does not work:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass3</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="go">....:     def __init__(self, value = 3):</span>
<span class="go">....:         self.value = value</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">MyClass3</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="ow">is</span> <span class="n">MyClass3</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Instead, one should do:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass3</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">):</span>
<span class="go">....:     @staticmethod</span>
<span class="go">....:     def __classcall__(cls, value = 3):</span>
<span class="go">....:         return super(MyClass3, cls).__classcall__(cls, value)</span>
<span class="go">....:</span>
<span class="go">....:     def __init__(self, value):</span>
<span class="go">....:         self.value = value</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">MyClass3</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="ow">is</span> <span class="n">MyClass3</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A bit of explanation is in order. First, the call <tt class="docutils literal"><span class="pre">MyClass2([1,2,3])</span></tt>
triggers a call to <tt class="docutils literal"><span class="pre">MyClass2.__classcall__(MyClass2,</span> <span class="pre">[1,2,3])</span></tt>. This is
an extension of the standard Python behavior, needed by
<a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a>, and implemented by the
<a class="reference external" href="../../../misc/sage/misc/classcall_metaclass.html#sage.misc.classcall_metaclass.ClasscallMetaclass" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">ClasscallMetaclass</span></tt></a>. Then,
<tt class="docutils literal"><span class="pre">MyClass2.__classcall__</span></tt> does the desired transformations on the
arguments. Finally, it uses <tt class="docutils literal"><span class="pre">super</span></tt> to call the default implementation
of <tt class="docutils literal"><span class="pre">__classcall__</span></tt> provided by <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a>. This one
in turn handles the caching and, if needed, constructs and initializes a
new object in the class using <a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__new__" title="(in Python v2.7)"><tt class="xref py py-meth docutils literal"><span class="pre">__new__</span></tt></a> and
<a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__init__" title="(in Python v2.7)"><tt class="xref py py-meth docutils literal"><span class="pre">__init__</span></tt></a> as usual.</p>
<p>Constraints:</p>
<ul class="simple">
<li><tt class="xref py py-meth docutils literal"><span class="pre">__classcall__()</span></tt> is a staticmethod (like, implicitly,
<a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__new__" title="(in Python v2.7)"><tt class="xref py py-meth docutils literal"><span class="pre">__new__</span></tt></a>)</li>
<li>the preprocessing on the arguments should be idempotent. That is, if
<tt class="docutils literal"><span class="pre">MyClass2.__classcall__(&lt;arguments&gt;)</span></tt> calls
<tt class="docutils literal"><span class="pre">CachedRepresentation.__classcall__(&lt;preprocessed_arguments&gt;)</span></tt>, then
<tt class="docutils literal"><span class="pre">MyClass2.__classcall__(&lt;preprocessed_arguments&gt;)</span></tt> should also result
in a call to <tt class="docutils literal"><span class="pre">CachedRepresentation.__classcall__(&lt;preprocessed_arguments&gt;)</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">MyClass2.__classcall__</span></tt> should return the result of
<tt class="xref py py-meth docutils literal"><span class="pre">CachedRepresentation.__classcall__()</span></tt> without modifying it.</li>
</ul>
<p>Other than that <tt class="docutils literal"><span class="pre">MyClass2.__classcall__</span></tt> may play any tricks, like
acting as a factory and returning objects from other classes.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">It is possible, but strongly discouraged, to let the <tt class="docutils literal"><span class="pre">__classcall__</span></tt>
method of a class <tt class="docutils literal"><span class="pre">C</span></tt> return objects that are not instances of
<tt class="docutils literal"><span class="pre">C</span></tt>. Of course, instances of a <em>subclass</em> of <tt class="docutils literal"><span class="pre">C</span></tt> are fine. Compare
the examples in <a class="reference internal" href="#module-sage.structure.unique_representation" title="sage.structure.unique_representation"><tt class="xref py py-mod docutils literal"><span class="pre">unique_representation</span></tt></a>.</p>
</div>
<p>We illustrate what is meant by an &#8220;idempotent&#8221; preprocessing. Imagine
that one has instances that are created with an integer-valued argument,
but only depend on the <em>square</em> of the argument. It would be a mistake to
square the given argument during preprocessing:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">WrongUsage</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="go">....:     @staticmethod</span>
<span class="go">....:     def __classcall__(cls, n):</span>
<span class="go">....:         return super(WrongUsage,cls).__classcall__(cls, n^2)</span>
<span class="go">....:     def __init__(self, n):</span>
<span class="go">....:         self.n = n</span>
<span class="go">....:     def __repr__(self):</span>
<span class="go">....:         return &quot;Something(%d)&quot;%self.n</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">WrongUsage</span> <span class="o">=</span> <span class="n">WrongUsage</span> <span class="c1"># This is only needed in doctests</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">WrongUsage</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">w</span>
<span class="go">Something(9)</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">_reduction</span>
<span class="go">(&lt;class &#39;__main__.WrongUsage&#39;&gt;, (9,), {})</span>
</pre></div>
</div>
<p>Indeed, the reduction data are obtained from the preprocessed
arguments. By consequence, if the resulting instance is pickled and
unpickled, the argument gets squared <em>again</em>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
<span class="go">Something(81)</span>
</pre></div>
</div>
<p>Instead, the preprocessing should only take the absolute value of the
given argument, while the squaring should happen inside of the
<tt class="docutils literal"><span class="pre">__init__</span></tt> method, where it won&#8217;t mess with the cache:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">BetterUsage</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="go">....:     @staticmethod</span>
<span class="go">....:     def __classcall__(cls, n):</span>
<span class="go">....:         return super(BetterUsage, cls).__classcall__(cls, abs(n))</span>
<span class="go">....:     def __init__(self, n):</span>
<span class="go">....:         self.n = n^2</span>
<span class="go">....:     def __repr__(self):</span>
<span class="go">....:         return &quot;SomethingElse(%d)&quot;%self.n</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">BetterUsage</span> <span class="o">=</span> <span class="n">BetterUsage</span> <span class="c1"># This is only needed in doctests</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BetterUsage</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">b</span>
<span class="go">SomethingElse(9)</span>
<span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="ow">is</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="ow">is</span> <span class="n">BetterUsage</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">Cached representation and mutability</p>
<p><a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a> is primarily intended for implementing
objects which are (at least semantically) immutable. This is in
particular assumed by the default implementations of <tt class="docutils literal"><span class="pre">copy</span></tt> and
<tt class="docutils literal"><span class="pre">deepcopy</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="gp">sage: </span><span class="n">deepcopy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
<p>However, in contrast to <a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">UniqueRepresentation</span></tt></a>, using
<a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a> allows for a comparison that is not by
identity:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Now <tt class="docutils literal"><span class="pre">t</span></tt> and <tt class="docutils literal"><span class="pre">z</span></tt> are non-identical, but equal:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">z</span><span class="o">.</span><span class="n">value</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">==</span> <span class="n">z</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="ow">is</span> <span class="n">z</span>
<span class="go">False</span>
</pre></div>
</div>
<p class="rubric">More on cached representation and identity</p>
<p><a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a> is implemented by means of a cache. This
cache uses weak references. Hence, when all other references to, say,
<tt class="docutils literal"><span class="pre">MyClass(1)</span></tt> have been deleted, the instance is actually deleted from
memory. A later call to <tt class="docutils literal"><span class="pre">MyClass(1)</span></tt> reconstructs the instance from
scratch.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">SomeClass</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">):</span>
<span class="go">....:     def __init__(self, i):</span>
<span class="go">....:         print &quot;creating new instance for argument %s&quot;%i</span>
<span class="go">....:         self.i = i</span>
<span class="go">....:     def __del__(self):</span>
<span class="go">....:         print &quot;deleting instance for argument %s&quot;%self.i</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">O</span> <span class="o">=</span> <span class="n">SomeClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">creating new instance for argument 1</span>
<span class="gp">sage: </span><span class="n">O</span> <span class="ow">is</span> <span class="n">SomeClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">O</span> <span class="ow">is</span> <span class="n">SomeClass</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">creating new instance for argument 2</span>
<span class="go">deleting instance for argument 2</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="k">del</span> <span class="n">O</span>
<span class="go">deleting instance for argument 1</span>
<span class="gp">sage: </span><span class="n">O</span> <span class="o">=</span> <span class="n">SomeClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">creating new instance for argument 1</span>
<span class="gp">sage: </span><span class="k">del</span> <span class="n">O</span>
<span class="go">deleting instance for argument 1</span>
</pre></div>
</div>
<p class="rubric">Cached representation and pickling</p>
<p>The default Python pickling implementation (by reconstructing an object
from its class and dictionary, see &#8220;The pickle protocol&#8221; in the Python
Library Reference) does not preserve cached representation, as Python has
no chance to know whether and where the same object already exists.</p>
<p><a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a> tries to ensure appropriate pickling by
implementing a <a class="reference external" href="https://docs.python.org/library/pickle.html#object.__reduce__" title="(in Python v2.7)"><tt class="xref py py-meth docutils literal"><span class="pre">__reduce__</span></tt></a> method returning the
arguments passed to the constructor:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span>             <span class="c1"># Fake MyClass being defined in a python module</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">MyClass</span> <span class="o">=</span> <span class="n">MyClass</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
<p><a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a> uses the <a class="reference external" href="https://docs.python.org/library/pickle.html#object.__reduce__" title="(in Python v2.7)"><tt class="xref py py-meth docutils literal"><span class="pre">__reduce__</span></tt></a> pickle protocol rather than <a class="reference external" href="https://docs.python.org/library/pickle.html#object.__getnewargs__" title="(in Python v2.7)"><tt class="xref py py-meth docutils literal"><span class="pre">__getnewargs__</span></tt></a> because the latter does not handle keyword
arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">__reduce__</span><span class="p">()</span>
<span class="go">(&lt;function unreduce at ...&gt;, (&lt;class &#39;__main__.MyClass&#39;&gt;, (), {&#39;value&#39;: 1}))</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="ow">is</span> <span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The default implementation of <a class="reference external" href="https://docs.python.org/library/pickle.html#object.__reduce__" title="(in Python v2.7)"><tt class="xref py py-meth docutils literal"><span class="pre">__reduce__</span></tt></a>
in <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a> requires to store the constructor&#8217;s
arguments in the instance dictionary upon construction:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">__dict__</span>
<span class="go">{&#39;_reduction&#39;: (&lt;class &#39;__main__.MyClass&#39;&gt;, (), {&#39;value&#39;: 1}), &#39;value&#39;: 1}</span>
</pre></div>
</div>
<p>It is often easy in a derived subclass to reconstruct the constructor&#8217;s
arguments from the instance data structure. When this is the case,
<a class="reference external" href="https://docs.python.org/library/pickle.html#object.__reduce__" title="(in Python v2.7)"><tt class="xref py py-meth docutils literal"><span class="pre">__reduce__</span></tt></a> should be overridden; automagically
the arguments won&#8217;t be stored anymore:</p>
<div class="last highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass3</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">):</span>
<span class="go">....:     def __init__(self, value):</span>
<span class="go">....:         self.value = value</span>
<span class="go">....:</span>
<span class="go">....:     def __reduce__(self):</span>
<span class="go">....:         return (MyClass3, (self.value,))</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span><span class="p">;</span> <span class="n">__main__</span><span class="o">.</span><span class="n">MyClass3</span> <span class="o">=</span> <span class="n">MyClass3</span>  <span class="c1"># Fake MyClass3 being defined in a python module</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass3</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">__dict__</span>
<span class="go">{&#39;value&#39;: 1}</span>
</pre></div>
</div>
</div>
<p class="rubric">Migrating classes to <tt class="docutils literal"><span class="pre">CachedRepresentation</span></tt> and unpickling</p>
<p>We check that, when migrating a class to <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a>,
older pickles can still be reasonably unpickled. Let us create a
(new style) class, and pickle one of its instances:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass4</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">....:     def __init__(self, value):</span>
<span class="go">....:         self.value = value</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span><span class="p">;</span> <span class="n">__main__</span><span class="o">.</span><span class="n">MyClass4</span> <span class="o">=</span> <span class="n">MyClass4</span>  <span class="c1"># Fake MyClass4 being defined in a python module</span>
<span class="gp">sage: </span><span class="n">pickle</span> <span class="o">=</span> <span class="n">dumps</span><span class="p">(</span><span class="n">MyClass4</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>It can be unpickled:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">value</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Now, we upgrade the class to derive from <a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">UniqueRepresentation</span></tt></a>,
which inherits from <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass4</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="nb">object</span><span class="p">):</span>
<span class="go">....:     def __init__(self, value):</span>
<span class="go">....:         self.value = value</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span><span class="p">;</span> <span class="n">__main__</span><span class="o">.</span><span class="n">MyClass4</span> <span class="o">=</span> <span class="n">MyClass4</span>  <span class="c1"># Fake MyClass4 being defined in a python module</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">MyClass4</span> <span class="o">=</span> <span class="n">MyClass4</span>
</pre></div>
</div>
<p>The pickle can still be unpickled:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">value</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Note however that, for the reasons explained above, unique
representation is not guaranteed in this case:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">y</span> <span class="ow">is</span> <span class="n">MyClass4</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Illustrate how this can be fixed on a case by case basis.</p>
</div>
<p>Now, we redo the same test for a class deriving from SageObject:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass4</span><span class="p">(</span><span class="n">SageObject</span><span class="p">):</span>
<span class="go">....:     def __init__(self, value):</span>
<span class="go">....:         self.value = value</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span><span class="p">;</span> <span class="n">__main__</span><span class="o">.</span><span class="n">MyClass4</span> <span class="o">=</span> <span class="n">MyClass4</span>  <span class="c1"># Fake MyClass4 being defined in a python module</span>
<span class="gp">sage: </span><span class="n">pickle</span> <span class="o">=</span> <span class="n">dumps</span><span class="p">(</span><span class="n">MyClass4</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

<span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass4</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="n">SageObject</span><span class="p">):</span>
<span class="go">....:     def __init__(self, value):</span>
<span class="go">....:         self.value = value</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">MyClass4</span> <span class="o">=</span> <span class="n">MyClass4</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">value</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Caveat: unpickling instances of a formerly old-style class is not supported yet by default:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass4</span><span class="p">:</span>
<span class="go">....:     def __init__(self, value):</span>
<span class="go">....:         self.value = value</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span><span class="p">;</span> <span class="n">__main__</span><span class="o">.</span><span class="n">MyClass4</span> <span class="o">=</span> <span class="n">MyClass4</span>  <span class="c1"># Fake MyClass4 being defined in a python module</span>
<span class="gp">sage: </span><span class="n">pickle</span> <span class="o">=</span> <span class="n">dumps</span><span class="p">(</span><span class="n">MyClass4</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

<span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass4</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="n">SageObject</span><span class="p">):</span>
<span class="go">....:     def __init__(self, value):</span>
<span class="go">....:         self.value = value</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">MyClass4</span> <span class="o">=</span> <span class="n">MyClass4</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="p">)</span>  <span class="c1"># todo: not implemented</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">value</span>            <span class="c1"># todo: not implemented</span>
<span class="go">1</span>
</pre></div>
</div>
<p class="rubric">Rationale for the current implementation</p>
<p><a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a> and derived classes use the
<a class="reference external" href="../../../misc/sage/misc/classcall_metaclass.html#sage.misc.classcall_metaclass.ClasscallMetaclass" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">ClasscallMetaclass</span></tt></a>
of the standard Python type. The following example explains why.</p>
<p>We define a variant of <tt class="docutils literal"><span class="pre">MyClass</span></tt> where the calls to
<a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__init__" title="(in Python v2.7)"><tt class="xref py py-meth docutils literal"><span class="pre">__init__</span></tt></a> are traced:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="go">....:     def __init__(self, value):</span>
<span class="go">....:         print &quot;initializing object&quot;</span>
<span class="go">....:         self.value = value</span>
<span class="go">....:</span>
</pre></div>
</div>
<p>Let us create an object twice:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">initializing object</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>As desired the <a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__init__" title="(in Python v2.7)"><tt class="xref py py-meth docutils literal"><span class="pre">__init__</span></tt></a> method was only called
the first time, which is an important feature.</p>
<p>As far as we can tell, this is not achievable while just using
<a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__new__" title="(in Python v2.7)"><tt class="xref py py-meth docutils literal"><span class="pre">__new__</span></tt></a> and <a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__init__" title="(in Python v2.7)"><tt class="xref py py-meth docutils literal"><span class="pre">__init__</span></tt></a> (as
defined by type; see Section <a class="reference external" href="https://docs.python.org/release/2.7.10/reference/datamodel.html#basic-customization">Basic Customization</a> in the Python Reference
Manual). Indeed, <a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__init__" title="(in Python v2.7)"><tt class="xref py py-meth docutils literal"><span class="pre">__init__</span></tt></a> is called
systematically on the result of <a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__new__" title="(in Python v2.7)"><tt class="xref py py-meth docutils literal"><span class="pre">__new__</span></tt></a> whenever
the result is an instance of the class.</p>
<p>Another difficulty is that argument preprocessing (as in the example
above) cannot be handled by <a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__new__" title="(in Python v2.7)"><tt class="xref py py-meth docutils literal"><span class="pre">__new__</span></tt></a>, since the
unprocessed arguments will be passed down to
<a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__init__" title="(in Python v2.7)"><tt class="xref py py-meth docutils literal"><span class="pre">__init__</span></tt></a>.</p>
</dd></dl>

<dl class="class">
<dt id="sage.structure.unique_representation.UniqueRepresentation">
<em class="property">class </em><tt class="descclassname">sage.structure.unique_representation.</tt><tt class="descname">UniqueRepresentation</tt><a class="headerlink" href="#sage.structure.unique_representation.UniqueRepresentation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.unique_representation.CachedRepresentation</span></tt></a>, <a class="reference external" href="../../../misc/sage/misc/fast_methods.html#sage.misc.fast_methods.WithEqualityById" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.misc.fast_methods.WithEqualityById</span></tt></a></p>
<p>Classes derived from UniqueRepresentation inherit a unique
representation behavior for their instances.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#module-sage.structure.unique_representation" title="sage.structure.unique_representation"><tt class="xref py py-mod docutils literal"><span class="pre">unique_representation</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<p>The short story: to construct a class whose instances have a
unique representation behavior one just has to do:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">):</span>
<span class="go">....:     # all the rest as usual</span>
<span class="go">....:     pass</span>
</pre></div>
</div>
<p>Everything below is for the curious or for advanced usage.</p>
<p class="rubric">What is unique representation?</p>
<p>Instances of a class have a <em>unique representation behavior</em> when
instances evaluate equal if and only if they are identical (i.e., share
the same memory representation), if and only if they were created using
equal arguments. For example, calling twice:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
</pre></div>
</div>
<p>to create the symmetric function algebra over <span class="math">\(\QQ\)</span> actually gives back the
same object:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">==</span> <span class="n">g</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="ow">is</span> <span class="n">g</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This is a standard design pattern. It allows for sharing cached data (say
representation theoretical information about a group) as well as for very
fast hashing and equality testing. This behaviour is typically desirable
for parents and categories. It can also be useful for intensive
computations where one wants to cache all the operations on a small set of
elements (say the multiplication table of a small group), and access this
cache as quickly as possible.</p>
<p><a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">UniqueRepresentation</span></tt></a> is very easy to use: a class just needs to
derive from it, or make sure some of its super classes does. Also, it
groups together the class and the factory in a single gadget:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">CC</span><span class="p">),</span> <span class="n">SymmetricFunctions</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">,</span> <span class="n">UniqueRepresentation</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This nice behaviour is not available when one just uses a factory:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">GF</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">isinstance() arg 2 must be a class, type, or tuple of classes and types</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">GF</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">UniqueFactory</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In addition, <a class="reference internal" href="factory.html#sage.structure.factory.UniqueFactory" title="sage.structure.factory.UniqueFactory"><tt class="xref py py-class docutils literal"><span class="pre">UniqueFactory</span></tt></a> only provides
the <em>cached</em> representation behaviour, but not the <em>unique</em> representation
behaviour&#8212;the examples in <a class="reference internal" href="#module-sage.structure.unique_representation" title="sage.structure.unique_representation"><tt class="xref py py-mod docutils literal"><span class="pre">unique_representation</span></tt></a>
explain this difference.</p>
<p>On the other hand, the <a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">UniqueRepresentation</span></tt></a> class is more
intrusive, as it imposes a behavior (and a metaclass) on all the
subclasses. In particular, the unique representation behaviour is imposed
on <em>all</em> subclasses (unless the <tt class="docutils literal"><span class="pre">__classcall__</span></tt> method is overloaded and
not called in the subclass, which is not recommended). Its implementation
is also more technical, which leads to some subtleties.</p>
<p>EXAMPLES:</p>
<p>We start with a simple class whose constructor takes a single value as
argument. This pattern is similar to what is done in
<a class="reference external" href="../../../combinat/sage/combinat/sf/sf.html#sage.combinat.sf.sf.SymmetricFunctions" title="(in Sage Reference Manual: Combinatorics v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.sf.sf.SymmetricFunctions</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">):</span>
<span class="go">....:     def __init__(self, value):</span>
<span class="go">....:         self.value = value</span>
<span class="go">....:     def __cmp__(self, other):</span>
<span class="go">....:         c = cmp(type(self),type(other))</span>
<span class="go">....:         if c: return c</span>
<span class="go">....:         print &quot;custom cmp&quot;</span>
<span class="go">....:         return cmp(self.value, other.value)</span>
<span class="go">....:</span>
</pre></div>
</div>
<p>Two coexisting instances of <tt class="docutils literal"><span class="pre">MyClass</span></tt> created with the same argument
data are guaranteed to share the same identity. Since <a class="reference external" href="http://trac.sagemath.org/12215">trac ticket #12215</a>, this
is only the case if there is some strong reference to the returned
instance, since otherwise it may be garbage collected:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="ow">is</span> <span class="n">y</span>               <span class="c1"># There is a strong reference</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="ow">is</span> <span class="n">z</span>
<span class="go">False</span>
</pre></div>
</div>
<p>In particular, modifying any one of them modifies the other
(reference effect):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">value</span>
<span class="go">(3, 3)</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">value</span>
<span class="go">(1, 1)</span>
</pre></div>
</div>
<p>Rich comparison by identity is used when possible (hence, for <tt class="docutils literal"><span class="pre">==</span></tt>, for
<tt class="docutils literal"><span class="pre">!=</span></tt>, and for identical arguments in the case of <tt class="docutils literal"><span class="pre">&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;=</span></tt>, <tt class="docutils literal"><span class="pre">&gt;=</span></tt>
and <tt class="docutils literal"><span class="pre">&gt;</span></tt>), which is as fast as it can get. Only if identity is not enough
to decide the answer of a comparison, the custom comparison is called:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">==</span> <span class="n">z</span><span class="p">,</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">z</span>
<span class="go">(False, False)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">x</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">!=</span> <span class="n">z</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">z</span>
<span class="go">custom cmp</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">z</span>
<span class="go">custom cmp</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A hash function equivalent to <a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__hash__" title="(in Python v2.7)"><tt class="xref py py-meth docutils literal"><span class="pre">object.__hash__()</span></tt></a> is used, which is
compatible with comparison by identity. However this means that the hash
function may change in between Sage sessions, or even within the same Sage
session.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">hash</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">object</span><span class="o">.</span><span class="n">__hash__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">It is possible to inherit from
<a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">UniqueRepresentation</span></tt></a>
and then overload comparison in a way that destroys the unique
representation property. We strongly recommend against it!  You should
use <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><tt class="xref py py-class docutils literal"><span class="pre">CachedRepresentation</span></tt></a>
instead.</p>
</div>
<p class="rubric">Mixing super types and super classes</p>
<p>TESTS:</p>
<p>For the record, this test did fail with previous implementation
attempts:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">bla</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="n">SageObject</span><span class="p">):</span>
<span class="go">....:     pass</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">bla</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.structure.unique_representation.unreduce">
<tt class="descclassname">sage.structure.unique_representation.</tt><tt class="descname">unreduce</tt><big>(</big><em>cls</em>, <em>args</em>, <em>keywords</em><big>)</big><a class="headerlink" href="#sage.structure.unique_representation.unreduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls a class on the given arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">unique_representation</span><span class="o">.</span><span class="n">unreduce</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">{})</span>
<span class="go">1</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">should reuse something preexisting ...</p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Unique Representation</a><ul>
<li><a class="reference internal" href="#what-is-a-cached-representation">What is a cached representation?</a><ul>
<li><a class="reference internal" href="#implementing-a-cached-representation">Implementing a cached representation</a><ul>
<li><a class="reference internal" href="#using-cachedrepresentation">Using <tt class="docutils literal"><span class="pre">CachedRepresentation</span></tt></a><ul>
<li><a class="reference internal" href="#normalising-the-arguments">Normalising the arguments</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-uniquefactory">Using <tt class="docutils literal"><span class="pre">UniqueFactory</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#comparing-the-two-ways-of-implementing-a-cached-representation">Comparing the two ways of implementing a cached representation</a><ul>
<li><a class="reference internal" href="#simplicity-and-transparency">Simplicity and transparency</a></li>
<li><a class="reference internal" href="#class-inheritance">Class inheritance</a></li>
<li><a class="reference internal" href="#python-versus-extension-classes">Python versus extension classes</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#what-is-a-unique-representation">What is a unique representation?</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="../misc/proof.html"
                                  title="previous chapter">Whether or not computations are provably correct by default</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="factory.html"
                                  title="next chapter">Factory for cached representations</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/structure/unique_representation.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="factory.html" title="Factory for cached representations"
             >next</a> |</li>
        <li class="right" >
          <a href="../misc/proof.html" title="Whether or not computations are provably correct by default"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Basic Structures</a> &raquo;</li>
 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2016, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>