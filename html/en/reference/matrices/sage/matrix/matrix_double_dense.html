<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="Dense matrices over the Real Double Field using NumPy" href="matrix_real_double_dense.html" /><link rel="prev" title="Sparse rational matrices" href="matrix_rational_sparse.html" />

    <meta name="generator" content="sphinx-5.2.3, furo 2022.09.29"/>
        <title>Dense matrices using a NumPy backend - Matrices and Spaces of Matrices</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=d81277517bee4d6b0349d71bb2661d4890b5617c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom-furo.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZGD13B5572"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ZGD13B5572');
</script></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Matrices and Spaces of Matrices</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logo_sagemath_black.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logo_sagemath_white.svg" alt="Dark Logo"/>
  </div>
  
      <span class="sidebar-brand-text">Sage 9.8 Reference Manual</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-home">
  <div class="sidebar-tree">
    <ul><li class="toctree-l1">
      <a class="reference internal" href="../../index.html">Home - Matrices and Spaces of Matrices</a>
    </li></ul>
  </div>
</div><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="matrix_space.html">Matrix Spaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="constructor.html">General matrix Constructor and display options</a></li>
<li class="toctree-l1"><a class="reference internal" href="special.html">Constructors for special matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="args.html">Helpers for creating matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="docs.html">Matrices over an arbitrary ring</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix0.html">Base class for matrices, part 0</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix1.html">Base class for matrices, part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix2.html">Base class for matrices, part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="strassen.html">Generic Asymptotically Fast Strassen Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="berlekamp_massey.html">Minimal Polynomials of Linear Recurrence Sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_dense.html">Base class for dense matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_sparse.html">Base class for sparse matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_generic_dense.html">Dense Matrices over a general ring</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_generic_sparse.html">Sparse Matrices over a general ring</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_integer_dense.html">Dense matrices over the integer ring</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_integer_sparse.html">Sparse integer matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_integer_dense_hnf.html">Modular algorithm to compute Hermite normal forms of integer matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_integer_dense_saturation.html">Saturation over ZZ</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_rational_dense.html">Dense matrices over the rational field</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_rational_sparse.html">Sparse rational matrices</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Dense matrices using a NumPy backend</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_real_double_dense.html">Dense matrices over the Real Double Field using NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_mod2_dense.html">Dense matrices over GF(2) using the M4RI library</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_gf2e_dense.html">Dense matrices over <span class="math notranslate nohighlight">\(\GF{2^e}\)</span> for <span class="math notranslate nohighlight">\(2 \leq e \leq 16\)</span> using the M4RIE library</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_modn_dense_double.html">Dense matrices over <span class="math notranslate nohighlight">\(\ZZ/n\ZZ\)</span> for <span class="math notranslate nohighlight">\(n &lt; 2^{23}\)</span> using LinBox’s <code class="docutils literal notranslate"><span class="pre">Modular&lt;double&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_modn_dense_float.html">Dense matrices over <span class="math notranslate nohighlight">\(\ZZ/n\ZZ\)</span> for <span class="math notranslate nohighlight">\(n &lt; 2^{11}\)</span> using LinBox’s <code class="docutils literal notranslate"><span class="pre">Modular&lt;float&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_modn_sparse.html">Sparse matrices over <span class="math notranslate nohighlight">\(\ZZ/n\ZZ\)</span> for <span class="math notranslate nohighlight">\(n\)</span> small</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_symbolic_dense.html">Symbolic matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_complex_double_dense.html">Dense matrices over the Complex Double Field using NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_complex_ball_dense.html">Arbitrary precision complex ball matrices using Arb</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_polynomial_dense.html">Dense matrices over univariate polynomials over fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_mpolynomial_dense.html">Dense matrices over multivariate polynomials over fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_cyclo_dense.html">Matrices over Cyclotomic Fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="operation_table.html">Operation Tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="action.html">Actions used by the coercion model for matrix and vector multiplications</a></li>
<li class="toctree-l1"><a class="reference internal" href="change_ring.html">Functions for changing the base ring of matrices quickly</a></li>
<li class="toctree-l1"><a class="reference internal" href="echelon_matrix.html">Echelon matrices over finite fields.</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_misc.html">Miscellaneous matrix functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_window.html">Matrix windows</a></li>
<li class="toctree-l1"><a class="reference internal" href="misc.html">Misc matrix algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="symplectic_basis.html">Calculate symplectic bases for matrices over fields and the integers.</a></li>
<li class="toctree-l1"><a class="reference internal" href="compute_J_ideal.html"><span class="math notranslate nohighlight">\(J\)</span>-ideals of matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmark.html">Benchmarks for matrices</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="dense-matrices-using-a-numpy-backend">
<span id="sage-matrix-matrix-double-dense"></span><h1>Dense matrices using a NumPy backend<a class="headerlink" href="#dense-matrices-using-a-numpy-backend" title="Permalink to this heading">#</a></h1>
<span class="target" id="module-sage.matrix.matrix_double_dense"></span><p>This serves as a base class for dense matrices over
Real Double Field and Complex Double Field.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li><p>Jason Grout, Sep 2008: switch to NumPy backend, factored out the Matrix_double_dense class</p></li>
<li><p>Josh Kantor</p></li>
<li><p>William Stein: many bug fixes and touch ups.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">Mat</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[1.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0]</span>
</pre></div>
</div>
<p>We deal with the case of zero rows or zero columns:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">MatrixSpace</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">zero_matrix</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.matrix.matrix_double_dense.</span></span><span class="sig-name descname"><span class="pre">Matrix_double_dense</span></span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Matrix_numpy_dense</span></code></p>
<p>Base class for matrices over the Real Double Field and the Complex
Double Field.  These are supposed to be fast matrix operations
using C doubles. Most operations are implemented using numpy which
will call the underlying BLAS on the system.</p>
<p>This class cannot be instantiated on its own.  The numpy matrix
creation depends on several variables that are set in the
subclasses.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">**</span><span class="mi">2</span>
<span class="go">[ 7.0 10.0]</span>
<span class="go">[15.0 22.0]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>        <span class="c1"># rel tol 1e-15</span>
<span class="go">[-1.9999999999999996  0.9999999999999998]</span>
<span class="go">[ 1.4999999999999998 -0.4999999999999999]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.LU">
<span class="sig-name descname"><span class="pre">LU</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.LU" title="Permalink to this definition">#</a></dt>
<dd><p>Return a decomposition of the (row-permuted) matrix as a product of
a lower-triangular matrix (“L”) and an upper-triangular matrix (“U”).</p>
<p>OUTPUT:</p>
<p>For an <span class="math notranslate nohighlight">\(m\times n\)</span> matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> this method returns a triple of
immutable matrices <code class="docutils literal notranslate"><span class="pre">P,</span> <span class="pre">L,</span> <span class="pre">U</span></code> such that</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">P*L*U</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">P</span></code> is a square permutation matrix, of size <span class="math notranslate nohighlight">\(m\times m\)</span>,
so is all zeroes, but with exactly a single one in each
row and each column.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">L</span></code> is lower-triangular, square of size <span class="math notranslate nohighlight">\(m\times m\)</span>,
with every diagonal entry equal to one.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">U</span></code> is upper-triangular with size <span class="math notranslate nohighlight">\(m\times n\)</span>, i.e.
entries below the “diagonal” are all zero.</p></li>
</ul>
<p>The computed decomposition is cached and returned on
subsequent calls, thus requiring the results to be immutable.</p>
<p>Effectively, <code class="docutils literal notranslate"><span class="pre">P</span></code> permutes the rows of <code class="docutils literal notranslate"><span class="pre">A</span></code>.  Then <code class="docutils literal notranslate"><span class="pre">L</span></code>
can be viewed as a sequence of row operations on this matrix,
where each operation is adding a multiple of a row to a
subsequent row.  There is no scaling (thus 1’s on the diagonal
of <code class="docutils literal notranslate"><span class="pre">L</span></code>) and no row-swapping (<code class="docutils literal notranslate"><span class="pre">P</span></code> does that).  As a result
<code class="docutils literal notranslate"><span class="pre">U</span></code> is close to being the result of Gaussian-elimination.
However, round-off errors can make it hard to determine
the zero entries of <code class="docutils literal notranslate"><span class="pre">U</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The behaviour of <code class="docutils literal notranslate"><span class="pre">LU()</span></code> has changed in Sage version 9.1.
Earlier, <code class="docutils literal notranslate"><span class="pre">LU()</span></code> returned <code class="docutils literal notranslate"><span class="pre">P,L,U</span></code> such that <code class="docutils literal notranslate"><span class="pre">P*A=L*U</span></code>,
where <code class="docutils literal notranslate"><span class="pre">P</span></code> represents the permutation and is
the matrix inverse of the <code class="docutils literal notranslate"><span class="pre">P</span></code> returned by this method.
The computation of this matrix inverse can be accomplished
quickly with just a transpose as the matrix is orthogonal/unitary.</p>
<p>For details see <a class="reference external" href="https://trac.sagemath.org/18365">trac ticket #18365</a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">U</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">LU</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">U</span> <span class="c1"># rel tol 2e-16</span>
<span class="go">[ 0.0  1.0  2.0  3.0]</span>
<span class="go">[ 4.0  5.0  6.0  7.0]</span>
<span class="go">[ 8.0  9.0 10.0 11.0]</span>
<span class="go">[12.0 13.0 14.0 15.0]</span>
</pre></div>
</div>
<p>Below example illustrates the change in behaviour of <code class="docutils literal notranslate"><span class="pre">LU()</span></code>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">P</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">U</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-14</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">P</span><span class="o">*</span><span class="n">m</span> <span class="o">-</span> <span class="n">L</span><span class="o">*</span><span class="n">U</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-14</span>
<span class="go">False</span>
</pre></div>
</div>
<p><a class="reference external" href="https://trac.sagemath.org/10839">trac ticket #10839</a> made this routine available for rectangular matrices.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">));</span> <span class="n">A</span>
<span class="go">[ 0.0  1.0  2.0  3.0  4.0  5.0]</span>
<span class="go">[ 6.0  7.0  8.0  9.0 10.0 11.0]</span>
<span class="go">[12.0 13.0 14.0 15.0 16.0 17.0]</span>
<span class="go">[18.0 19.0 20.0 21.0 22.0 23.0]</span>
<span class="go">[24.0 25.0 26.0 27.0 28.0 29.0]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LU</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span>
<span class="go">[0.0 1.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0 1.0]</span>
<span class="go">[0.0 0.0 1.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 1.0 0.0]</span>
<span class="go">[1.0 0.0 0.0 0.0 0.0]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Use zero_at(0) to get rid of signed zeros</span>
<span class="go">[ 1.0  0.0  0.0  0.0  0.0]</span>
<span class="go">[ 0.0  1.0  0.0  0.0  0.0]</span>
<span class="go">[ 0.5  0.5  1.0  0.0  0.0]</span>
<span class="go">[0.75 0.25  0.0  1.0  0.0]</span>
<span class="go">[0.25 0.75  0.0  0.0  1.0]</span>
<span class="gp">sage: </span><span class="n">U</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Use zero_at(0) to get rid of signed zeros</span>
<span class="go">[24.0 25.0 26.0 27.0 28.0 29.0]</span>
<span class="go">[ 0.0  1.0  2.0  3.0  4.0  5.0]</span>
<span class="go">[ 0.0  0.0  0.0  0.0  0.0  0.0]</span>
<span class="go">[ 0.0  0.0  0.0  0.0  0.0  0.0]</span>
<span class="go">[ 0.0  0.0  0.0  0.0  0.0  0.0]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">*</span><span class="n">A</span><span class="o">-</span><span class="n">L</span><span class="o">*</span><span class="n">U</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0 0.0]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">U</span>
<span class="go">[ 0.0  1.0  2.0  3.0  4.0  5.0]</span>
<span class="go">[ 6.0  7.0  8.0  9.0 10.0 11.0]</span>
<span class="go">[12.0 13.0 14.0 15.0 16.0 17.0]</span>
<span class="go">[18.0 19.0 20.0 21.0 22.0 23.0]</span>
<span class="go">[24.0 25.0 26.0 27.0 28.0 29.0]</span>
</pre></div>
</div>
<p>Trivial cases return matrices of the right size and
characteristics.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LU</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 5 by 5 dense matrices over Real Double Field</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 5 by 5 dense matrices over Real Double Field</span>
<span class="gp">sage: </span><span class="n">U</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 5 by 0 dense matrices over Real Double Field</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">-</span><span class="n">P</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">U</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>The results are immutable since they are cached.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">LU</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">    ...</span>
<span class="go">ValueError: matrix is immutable; please change a copy instead (i.e., use copy(M) to change a copy of M).</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">    ...</span>
<span class="go">ValueError: matrix is immutable; please change a copy instead (i.e., use copy(M) to change a copy of M).</span>
<span class="gp">sage: </span><span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">    ...</span>
<span class="go">ValueError: matrix is immutable; please change a copy instead (i.e., use copy(M) to change a copy of M).</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.LU_valid">
<span class="sig-name descname"><span class="pre">LU_valid</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.LU_valid" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the LU form of this matrix has
already been computed.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">random_matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="p">;</span> <span class="n">A</span><span class="o">.</span><span class="n">LU_valid</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LU</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">LU_valid</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.QR">
<span class="sig-name descname"><span class="pre">QR</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.QR" title="Permalink to this definition">#</a></dt>
<dd><p>Return a factorization into a unitary matrix and an
upper-triangular matrix.</p>
<p>INPUT:</p>
<p>Any matrix over <code class="docutils literal notranslate"><span class="pre">RDF</span></code> or <code class="docutils literal notranslate"><span class="pre">CDF</span></code>.</p>
<p>OUTPUT:</p>
<p><code class="docutils literal notranslate"><span class="pre">Q</span></code>, <code class="docutils literal notranslate"><span class="pre">R</span></code> – a pair of matrices such that if <span class="math notranslate nohighlight">\(A\)</span>
is the original matrix, then</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[A = QR, \quad Q^\ast Q = I\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(R\)</span> is upper-triangular.  <span class="math notranslate nohighlight">\(Q^\ast\)</span> is the
conjugate-transpose in the complex case, and just
the transpose in the real case. So <span class="math notranslate nohighlight">\(Q\)</span> is a unitary
matrix (or rather, orthogonal, in the real case),
or equivalently <span class="math notranslate nohighlight">\(Q\)</span> has orthogonal columns.  For a
matrix of full rank this factorization is unique
up to adjustments via multiples of rows and columns
by multiples with scalars having modulus <span class="math notranslate nohighlight">\(1\)</span>.  So
in the full-rank case, <span class="math notranslate nohighlight">\(R\)</span> is unique if the diagonal
entries are required to be positive real numbers.</p>
<p>The resulting decomposition is cached.</p>
<p>ALGORITHM:</p>
<p>Calls “linalg.qr” from SciPy, which is in turn an
interface to LAPACK routines.</p>
<p>EXAMPLES:</p>
<p>Over the reals, the inverse of <code class="docutils literal notranslate"><span class="pre">Q</span></code> is its transpose,
since including a conjugate has no effect.  In the real
case, we say <code class="docutils literal notranslate"><span class="pre">Q</span></code> is orthogonal.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">QR</span><span class="p">()</span>
</pre></div>
</div>
<p>At this point, <code class="docutils literal notranslate"><span class="pre">Q</span></code> is only well-defined up to the
signs of its columns, and similarly for <code class="docutils literal notranslate"><span class="pre">R</span></code> and its
rows, so we normalize them:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Qnorm</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_normalize_columns</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Rnorm</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">_normalize_rows</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Qnorm</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">10</span><span class="o">^-</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[ 0.458831  0.126051  0.381212  0.394574   0.68744]</span>
<span class="go">[ 0.458831  -0.47269 -0.051983 -0.717294  0.220963]</span>
<span class="go">[-0.229416 -0.661766  0.661923  0.180872 -0.196411]</span>
<span class="go">[-0.688247 -0.189076 -0.204468  -0.09663  0.662889]</span>
<span class="go">[ 0.229416 -0.535715 -0.609939  0.536422 -0.024551]</span>
<span class="gp">sage: </span><span class="n">Rnorm</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">10</span><span class="o">^-</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[ 4.358899 -0.458831 13.076697  6.194225  2.982405]</span>
<span class="go">[      0.0  1.670172  0.598741  -1.29202  6.207997]</span>
<span class="go">[      0.0       0.0  5.444402  5.468661 -0.682716]</span>
<span class="go">[      0.0       0.0       0.0  1.027626   -3.6193]</span>
<span class="go">[      0.0       0.0       0.0       0.0  0.024551]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>  <span class="c1"># tol 1e-14</span>
<span class="go">[0.9999999999999994                0.0                0.0                0.0                0.0]</span>
<span class="go">[               0.0                1.0                0.0                0.0                0.0]</span>
<span class="go">[               0.0                0.0 0.9999999999999999                0.0                0.0]</span>
<span class="go">[               0.0                0.0                0.0 0.9999999999999998                0.0]</span>
<span class="go">[               0.0                0.0                0.0                0.0 1.0000000000000002]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">R</span> <span class="o">-</span> <span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">10</span><span class="o">^-</span><span class="mi">14</span><span class="p">)</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0]</span>
</pre></div>
</div>
<p>Now over the complex numbers, demonstrating that the SciPy libraries
are (properly) using the Hermitian inner product, so that <code class="docutils literal notranslate"><span class="pre">Q</span></code> is
a unitary matrix (its inverse is the conjugate-transpose).</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">I</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">I</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="n">I</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="n">I</span> <span class="o">+</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="n">I</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="n">I</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">I</span> <span class="o">+</span> <span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">QR</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">_normalize_columns</span><span class="p">()</span>  <span class="c1"># tol 1e-6</span>
<span class="go">[                           0.7302967433402214    0.20705664550556482 + 0.5383472783144685*I   0.24630498099986423 - 0.07644563587232917*I   0.23816176831943323 - 0.10365960327796941*I]</span>
<span class="go">[                         -0.09128709291752768  -0.20705664550556482 - 0.37787837804765584*I   0.37865595338630315 - 0.19522214955246678*I    0.7012444502144682 - 0.36437116509865947*I]</span>
<span class="go">[  -0.6390096504226938 - 0.09128709291752768*I    0.17082173254209104 + 0.6677576817554466*I -0.03411475806452064 + 0.040901987417671426*I   0.31401710855067644 - 0.08251917187054114*I]</span>
<span class="go">[ -0.18257418583505536 - 0.09128709291752768*I  -0.03623491296347384 + 0.07246982592694771*I    0.8632284069415112 + 0.06322839976356195*I  -0.44996948676115206 - 0.01161191812089182*I]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">_normalize_rows</span><span class="p">()</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1e-15</span><span class="p">)</span>  <span class="c1"># tol 1e-6</span>
<span class="go">[                        10.954451150103322                      -1.9170289512680814*I   5.385938482134133 - 2.1908902300206643*I -0.2738612787525829 - 2.1908902300206643*I]</span>
<span class="go">[                                       0.0                            4.8295962564173  -0.8696379111233719 - 5.864879483945123*I  0.993871898426711 - 0.30540855212070794*I]</span>
<span class="go">[                                       0.0                                        0.0                          12.00160760935814 -0.2709533402297273 + 0.4420629644486325*I]</span>
<span class="go">[                                       0.0                                        0.0                                        0.0                         1.9429639442589917]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">*</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1e-15</span><span class="p">)</span>  <span class="c1"># tol 1e-15</span>
<span class="go">[               1.0                0.0                0.0                0.0]</span>
<span class="go">[               0.0 0.9999999999999994                0.0                0.0]</span>
<span class="go">[               0.0                0.0 1.0000000000000002                0.0]</span>
<span class="go">[               0.0                0.0                0.0 1.0000000000000004]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">R</span> <span class="o">-</span> <span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">10</span><span class="o">^-</span><span class="mi">14</span><span class="p">)</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
</pre></div>
</div>
<p>An example of a rectangular matrix that is also rank-deficient.
If you run this example yourself, you may see a very small, nonzero
entries in the third row, in the third column, even though the exact
version of the matrix has rank 2.  The final two columns of <code class="docutils literal notranslate"><span class="pre">Q</span></code>
span the left kernel of <code class="docutils literal notranslate"><span class="pre">A</span></code> (as evidenced by the two zero rows of
<code class="docutils literal notranslate"><span class="pre">R</span></code>).  Different platforms will compute different bases for this
left kernel, so we do not exhibit the actual matrix.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Arat</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>                   <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">....: </span>                   <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>                   <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Arat</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Arat</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">CDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">QR</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">_normalize_rows</span><span class="p">()</span>  <span class="c1"># abs tol 1e-14</span>
<span class="go">[     5.567764362830022    -2.6940795304016243     2.6940795304016243]</span>
<span class="go">[                   0.0     3.5695847775155825    -3.5695847775155825]</span>
<span class="go">[                   0.0                    0.0 2.4444034681064287e-16]</span>
<span class="go">[                   0.0                    0.0                    0.0]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate_transpose</span><span class="p">()</span><span class="o">*</span><span class="n">Q</span><span class="p">)</span>  <span class="c1"># abs tol 1e-14</span>
<span class="go">[     1.0000000000000002  -5.185196889911925e-17 -4.1457180570414476e-17  -2.909388767229071e-17]</span>
<span class="go">[ -5.185196889911925e-17      1.0000000000000002  -9.286869233696149e-17 -1.1035822863186828e-16]</span>
<span class="go">[-4.1457180570414476e-17  -9.286869233696149e-17                     1.0  4.4159215672155694e-17]</span>
<span class="go">[ -2.909388767229071e-17 -1.1035822863186828e-16  4.4159215672155694e-17                     1.0]</span>
</pre></div>
</div>
<p>Results are cached, meaning they are immutable matrices.
Make a copy if you need to manipulate a result.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">random_matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">QR</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: matrix is immutable; please change a copy instead (i.e., use copy(M) to change a copy of M).</span>
<span class="gp">sage: </span><span class="n">Qcopy</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Qcopy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">679</span>
<span class="gp">sage: </span><span class="n">Qcopy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">679.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.SVD">
<span class="sig-name descname"><span class="pre">SVD</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.SVD" title="Permalink to this definition">#</a></dt>
<dd><p>Return the singular value decomposition of this matrix.</p>
<p>The U and V matrices are not unique and may be returned with different
values in the future or on different systems. The S matrix is unique
and contains the singular values in descending order.</p>
<p>The computed decomposition is cached and returned on subsequent calls.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p>A – a matrix</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>U, S, V – immutable matrices such that <span class="math notranslate nohighlight">\(A = U*S*V.conj().transpose()\)</span>
where U and V are orthogonal and S is zero off of the diagonal.</p></li>
</ul>
<p>Note that if self is m-by-n, then the dimensions of the
matrices that this returns are (m,m), (m,n), and (n, n).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If all you need is the singular values of the matrix, see
the more convenient <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.singular_values" title="sage.matrix.matrix_double_dense.Matrix_double_dense.singular_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">singular_values()</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">SVD</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">U</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">V</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>  <span class="c1"># tol 1e-14</span>
<span class="go">[0.9999999999999993 1.9999999999999987  3.000000000000001  4.000000000000002]</span>
<span class="go">[ 4.999999999999998  5.999999999999998  6.999999999999998                8.0]</span>
<span class="go">[ 8.999999999999998  9.999999999999996 10.999999999999998               12.0]</span>
<span class="go">[12.999999999999998               14.0               15.0               16.0]</span>
</pre></div>
</div>
<p>A non-square example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">));</span> <span class="n">m</span>
<span class="go">[1.0 2.0 3.0]</span>
<span class="go">[4.0 5.0 6.0]</span>
<span class="gp">sage: </span><span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">SVD</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">U</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">V</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>  <span class="c1"># tol 1e-14</span>
<span class="go">[0.9999999999999994 1.9999999999999998  2.999999999999999]</span>
<span class="go">[ 4.000000000000001  5.000000000000002  6.000000000000001]</span>
</pre></div>
</div>
<p>S contains the singular values:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">[ 9.508    0.0    0.0]</span>
<span class="go">[   0.0 0.7729    0.0]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">N</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">digits</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()]</span>
<span class="go">[9.508, 0.7729]</span>
</pre></div>
</div>
<p>U and V are orthogonal matrices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">U</span> <span class="c1"># random, SVD is not unique</span>
<span class="go">[-0.386317703119 -0.922365780077]</span>
<span class="go">[-0.922365780077  0.386317703119]</span>
<span class="go">[-0.274721127897 -0.961523947641]</span>
<span class="go">[-0.961523947641  0.274721127897]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">U</span><span class="o">*</span><span class="n">U</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>  <span class="c1"># tol 1e-15</span>
<span class="go">[               1.0                0.0]</span>
<span class="go">[               0.0 1.0000000000000004]</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="c1"># random, SVD is not unique</span>
<span class="go">[-0.428667133549  0.805963908589  0.408248290464]</span>
<span class="go">[-0.566306918848  0.112382414097 -0.816496580928]</span>
<span class="go">[-0.703946704147 -0.581199080396  0.408248290464]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="n">V</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>  <span class="c1"># tol 1e-15</span>
<span class="go">[0.9999999999999999                0.0                0.0]</span>
<span class="go">[               0.0                1.0                0.0]</span>
<span class="go">[               0.0                0.0 0.9999999999999999]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.cholesky">
<span class="sig-name descname"><span class="pre">cholesky</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.cholesky" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Cholesky factorization of a matrix that
is real symmetric, or complex Hermitian.</p>
<p>INPUT:</p>
<p>Any square matrix with entries from <code class="docutils literal notranslate"><span class="pre">RDF</span></code> that is symmetric, or
with entries from <code class="docutils literal notranslate"><span class="pre">CDF</span></code> that is Hermitian.  The matrix must
be positive definite for the Cholesky decomposition to exist.</p>
<p>OUTPUT:</p>
<p>For a matrix <span class="math notranslate nohighlight">\(A\)</span> the routine returns a lower triangular
matrix <span class="math notranslate nohighlight">\(L\)</span> such that,</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[A = LL^\ast\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(L^\ast\)</span> is the conjugate-transpose in the complex case,
and just the transpose in the real case.  If the matrix fails
to be positive definite (perhaps because it is not symmetric
or Hermitian), then this function raises a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
<p>IMPLEMENTATION:</p>
<p>The existence of a Cholesky decomposition and the
positive definite property are equivalent.  So this
method and the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_positive_definite" title="sage.matrix.matrix_double_dense.Matrix_double_dense.is_positive_definite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_positive_definite()</span></code></a> method compute and
cache both the Cholesky decomposition and the
positive-definiteness.  So the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_positive_definite" title="sage.matrix.matrix_double_dense.Matrix_double_dense.is_positive_definite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_positive_definite()</span></code></a>
method or catching a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> from the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.cholesky" title="sage.matrix.matrix_double_dense.Matrix_double_dense.cholesky"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cholesky()</span></code></a>
method are equally expensive computationally and if the
decomposition exists, it is cached as a side-effect of either
routine.</p>
<p>EXAMPLES:</p>
<p>A real matrix that is symmetric, Hermitian, and positive definite:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,[[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>    <span class="mi">1</span><span class="p">,</span>     <span class="mi">1</span><span class="p">,</span>     <span class="mi">1</span><span class="p">],</span>
<span class="gp">....: </span>                <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>   <span class="mi">31</span><span class="p">,</span>   <span class="mi">121</span><span class="p">,</span>   <span class="mi">341</span><span class="p">],</span>
<span class="gp">....: </span>                <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span>  <span class="mi">341</span><span class="p">,</span>  <span class="mi">1555</span><span class="p">,</span>  <span class="mi">4681</span><span class="p">],</span>
<span class="gp">....: </span>                <span class="p">[</span> <span class="mi">1</span><span class="p">,</span><span class="mi">121</span><span class="p">,</span> <span class="mi">1555</span><span class="p">,</span>  <span class="mi">7381</span><span class="p">,</span> <span class="mi">22621</span><span class="p">],</span>
<span class="gp">....: </span>                <span class="p">[</span> <span class="mi">1</span><span class="p">,</span><span class="mi">341</span><span class="p">,</span> <span class="mi">4681</span><span class="p">,</span> <span class="mi">22621</span><span class="p">,</span> <span class="mi">69905</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cholesky</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">10</span><span class="o">^-</span><span class="mi">10</span><span class="p">)</span>
<span class="go">[   1.0    0.0         0.0        0.0     0.0]</span>
<span class="go">[   1.0    2.0         0.0        0.0     0.0]</span>
<span class="go">[   1.0   15.0   10.723805        0.0     0.0]</span>
<span class="go">[   1.0   60.0   60.985814   7.792973     0.0]</span>
<span class="go">[   1.0  170.0  198.623524  39.366567  1.7231]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="n">L</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">10</span><span class="o">^-</span><span class="mi">10</span><span class="p">)</span>
<span class="go">[ 1.0     1.0     1.0     1.0     1.0]</span>
<span class="go">[ 1.0     5.0    31.0   121.0   341.0]</span>
<span class="go">[ 1.0    31.0   341.0  1555.0  4681.0]</span>
<span class="go">[ 1.0   121.0  1555.0  7381.0 22621.0]</span>
<span class="go">[ 1.0   341.0  4681.0 22621.0 69905.0]</span>
</pre></div>
</div>
<p>A complex matrix that is Hermitian and positive definite.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span>        <span class="mi">23</span><span class="p">,</span>  <span class="mi">17</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">24</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">25</span><span class="p">,</span>     <span class="mi">21</span><span class="o">*</span><span class="n">I</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span> <span class="o">-</span><span class="mi">17</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span>        <span class="mi">38</span><span class="p">,</span> <span class="o">-</span><span class="mi">69</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">7</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">15</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">24</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">69</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">89</span><span class="p">,</span>        <span class="mi">976</span><span class="p">,</span> <span class="mi">24</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span>     <span class="o">-</span><span class="mi">21</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span>  <span class="o">-</span><span class="mi">24</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">6</span><span class="p">,</span>       <span class="mi">28</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">cholesky</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">10</span><span class="o">^-</span><span class="mi">10</span><span class="p">)</span>
<span class="go">[               4.795832                     0.0                    0.0       0.0]</span>
<span class="go">[  0.625543 - 3.544745*I                5.004346                    0.0       0.0]</span>
<span class="go">[   5.21286 - 5.004346*I 13.588189 + 10.721116*I              24.984023       0.0]</span>
<span class="go">[            -4.378803*I  -0.104257 - 0.851434*I  -0.21486 + 0.371348*I  2.811799]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="n">L</span><span class="o">.</span><span class="n">conjugate_transpose</span><span class="p">())</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">10</span><span class="o">^-</span><span class="mi">10</span><span class="p">)</span>
<span class="go">[         23.0  3.0 + 17.0*I 25.0 + 24.0*I        21.0*I]</span>
<span class="go">[ 3.0 - 17.0*I          38.0 89.0 - 69.0*I  15.0 + 7.0*I]</span>
<span class="go">[25.0 - 24.0*I 89.0 + 69.0*I         976.0  6.0 + 24.0*I]</span>
<span class="go">[      -21.0*I  15.0 - 7.0*I  6.0 - 24.0*I          28.0]</span>
</pre></div>
</div>
<p>This routine will recognize when the input matrix is not
positive definite.  The negative eigenvalues are an
equivalent indicator.  (Eigenvalues of a Hermitian matrix
must be real, so there is no loss in ignoring the imprecise
imaginary parts).</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span> <span class="mi">3</span><span class="p">,</span>  <span class="o">-</span><span class="mi">6</span><span class="p">,</span>   <span class="mi">9</span><span class="p">,</span>   <span class="mi">6</span><span class="p">,</span>  <span class="o">-</span><span class="mi">9</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span>  <span class="mi">11</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="o">-</span><span class="mi">11</span><span class="p">,</span>  <span class="mi">17</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span> <span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span><span class="p">,</span>  <span class="mi">28</span><span class="p">,</span>  <span class="mi">16</span><span class="p">,</span> <span class="o">-</span><span class="mi">40</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span> <span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">11</span><span class="p">,</span>  <span class="mi">16</span><span class="p">,</span>   <span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">19</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span>  <span class="mi">17</span><span class="p">,</span> <span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="o">-</span><span class="mi">19</span><span class="p">,</span>  <span class="mi">68</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()</span>
<span class="go">[108.07..., 13.02..., -0.02..., -0.70..., -1.37...]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">cholesky</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: matrix is not positive definite</span>

<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span>      <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>       <span class="mi">8</span><span class="p">,</span>    <span class="mi">10</span><span class="o">*</span><span class="n">I</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>   <span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>      <span class="o">-</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">ev</span><span class="o">.</span><span class="n">real</span><span class="p">()</span> <span class="k">for</span> <span class="n">ev</span> <span class="ow">in</span> <span class="n">B</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()]</span>
<span class="go">[15.88..., 0.08..., -8.97...]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">cholesky</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: matrix is not positive definite</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.condition">
<span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'frob'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.condition" title="Permalink to this definition">#</a></dt>
<dd><p>Return the condition number of a square nonsingular matrix.</p>
<p>Roughly speaking, this is a measure of how sensitive
the matrix is to round-off errors in numerical computations.
The minimum possible value is 1.0, and larger numbers indicate
greater sensitivity.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code> - default: ‘frob’ - controls which norm is used
to compute the condition number, allowable values are
‘frob’ (for the Frobenius norm), integers -2, -1, 1, 2,
positive and negative infinity. See output discussion
for specifics.</p></li>
</ul>
<p>OUTPUT:</p>
<p>The condition number of a matrix is the product of a norm
of the matrix times the norm of the inverse of the matrix.
This requires that the matrix be square and invertible
(nonsingular, full rank).</p>
<p>Returned value is a double precision floating point value
in <code class="docutils literal notranslate"><span class="pre">RDF</span></code>, or <code class="docutils literal notranslate"><span class="pre">Infinity</span></code>.  Row and column sums described below are
sums of the absolute values of the entries, where the
absolute value of the complex number <span class="math notranslate nohighlight">\(a+bi\)</span> is <span class="math notranslate nohighlight">\(\sqrt{a^2+b^2}\)</span>.
Singular values are the “diagonal” entries of the “S” matrix in
the singular value decomposition.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">'frob'</span></code>: the default norm employed in computing
the condition number, the Frobenius norm, which for a
matrix <span class="math notranslate nohighlight">\(A=(a_{ij})\)</span> computes</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\left(\sum_{i,j}\left\lvert{a_{i,j}}\right\rvert^2\right)^{1/2}\]</div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">'sv'</span></code>: the quotient of the maximal and minimal singular value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">Infinity</span></code> or <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">oo</span></code>: the maximum row sum.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">-Infinity</span></code> or <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">-oo</span></code>: the minimum column sum.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">1</span></code>: the maximum column sum.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">-1</span></code>: the minimum column sum.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">2</span></code>: the 2-norm, equal to the maximum singular value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">-2</span></code>: the minimum singular value.</p></li>
</ul>
<p>ALGORITHM:</p>
<p>Computation is performed by the <code class="docutils literal notranslate"><span class="pre">cond()</span></code> function of
the SciPy/NumPy library.</p>
<p>EXAMPLES:</p>
<p>First over the reals.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">)]);</span> <span class="n">A</span>
<span class="go">[   0.0   0.25    2.0   6.75]</span>
<span class="go">[  16.0  31.25   54.0  85.75]</span>
<span class="go">[ 128.0 182.25  250.0 332.75]</span>
<span class="go">[ 432.0 549.25  686.0 843.75]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">()</span>
<span class="go">9923.88955...</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="s1">&#39;frob&#39;</span><span class="p">)</span>
<span class="go">9923.88955...</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">Infinity</span><span class="p">)</span>  <span class="c1"># tol 3e-14</span>
<span class="go">22738.50000000045</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="n">Infinity</span><span class="p">)</span>  <span class="c1"># tol 2e-14</span>
<span class="go">17.50000000000028</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">12139.21...</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># tol 2e-14</span>
<span class="go">550.0000000000093</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">9897.8088...</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.000101032462...</span>
</pre></div>
</div>
<p>And over the complex numbers.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)]);</span> <span class="n">B</span>
<span class="go">[         0.0  1.0 + 1.0*I  2.0 + 4.0*I]</span>
<span class="go">[ 3.0 + 9.0*I 4.0 + 16.0*I 5.0 + 25.0*I]</span>
<span class="go">[6.0 + 36.0*I 7.0 + 49.0*I 8.0 + 64.0*I]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">condition</span><span class="p">()</span>
<span class="go">203.851798...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="s1">&#39;frob&#39;</span><span class="p">)</span>
<span class="go">203.851798...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">Infinity</span><span class="p">)</span>
<span class="go">369.55630...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="n">Infinity</span><span class="p">)</span>
<span class="go">5.46112969...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">289.251481...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">20.4566639...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">202.653543...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.00493453005...</span>
</pre></div>
</div>
<p>Hilbert matrices are famously ill-conditioned, while
an identity matrix can hit the minimum with the right norm.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">()</span>  <span class="c1"># tol 2e-4</span>
<span class="go">16332197709146.014</span>
<span class="gp">sage: </span><span class="nb">id</span> <span class="o">=</span> <span class="n">identity_matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">id</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>Return values are in <span class="math notranslate nohighlight">\(RDF\)</span>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">()</span> <span class="ow">in</span> <span class="n">RDF</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Rectangular and singular matrices raise errors if p is not ‘sv’.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: matrix must be square if p is not &#39;sv&#39;, not 2 x 3</span>

<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="s1">&#39;sv&#39;</span><span class="p">)</span>
<span class="go">7.34...</span>

<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">25</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_singular</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">CDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">condition</span><span class="p">()</span>
<span class="go">+Infinity</span>
</pre></div>
</div>
<p>Improper values of <code class="docutils literal notranslate"><span class="pre">p</span></code> are caught.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="s1">&#39;bogus&#39;</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: condition number &#39;p&#39; must be +/- infinity, &#39;frob&#39;, &#39;sv&#39; or an integer, not bogus</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">632</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: condition number integer values of &#39;p&#39; must be -2, -1, 1 or 2, not 632</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.conjugate">
<span class="sig-name descname"><span class="pre">conjugate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Return the conjugate of this matrix, i.e. the matrix whose entries are
the conjugates of the entries of self.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="o">+</span><span class="n">I</span><span class="p">,</span> <span class="mi">3</span><span class="o">-</span><span class="n">I</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
<span class="go">[1.0 - 1.0*I 3.0 + 1.0*I]</span>
<span class="go">[        0.0      -2.0*I]</span>
</pre></div>
</div>
<p>There is a shorthand notation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">C</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Conjugates work (trivially) for real matrices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">==</span> <span class="n">B</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.determinant">
<span class="sig-name descname"><span class="pre">determinant</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.determinant" title="Permalink to this definition">#</a></dt>
<dd><p>Return the determinant of self.</p>
<p>ALGORITHM:</p>
<p>Use numpy</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span> <span class="n">m</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
<span class="go">-2.0</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">0</span><span class="p">,[]);</span> <span class="n">m</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
<span class="go">1.0</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span> <span class="n">m</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: self must be a square matrix</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvalues">
<span class="sig-name descname"><span class="pre">eigenvalues</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">homogeneous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvalues" title="Permalink to this definition">#</a></dt>
<dd><p>Return a list of ordinary or generalized eigenvalues.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self</span></code> - a square matrix</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> – a square matrix <span class="math notranslate nohighlight">\(B\)</span> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) in a generalized
eigenvalue problem; if <code class="docutils literal notranslate"><span class="pre">None</span></code>, an ordinary eigenvalue problem is
solved; if <code class="docutils literal notranslate"><span class="pre">algorithm</span></code> is <code class="docutils literal notranslate"><span class="pre">'symmetric'</span></code> or <code class="docutils literal notranslate"><span class="pre">'hermitian'</span></code>, <span class="math notranslate nohighlight">\(B\)</span>
must be real symmetric or hermitian positive definite, respectively</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> - default: <code class="docutils literal notranslate"><span class="pre">'default'</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'default'</span></code> - applicable to any matrix
with double-precision floating point entries.
Uses the <code class="xref py py-meth docutils literal notranslate"><span class="pre">eigvals()</span></code> method from SciPy.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'symmetric'</span></code> - converts the matrix into a real matrix
(i.e. with entries from <code class="xref py py-class docutils literal notranslate"><span class="pre">RDF</span></code>),
then applies the algorithm for Hermitian matrices.  This
algorithm can be significantly faster than the
<code class="docutils literal notranslate"><span class="pre">'default'</span></code> algorithm.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'hermitian'</span></code> - uses the <code class="xref py py-meth docutils literal notranslate"><span class="pre">eigh()</span></code> method
from SciPy, which applies only to real symmetric or complex
Hermitian matrices.  Since Hermitian is defined as a matrix
equaling its conjugate-transpose, for a matrix with real
entries this property is equivalent to being symmetric.
This algorithm can be significantly faster than the
<code class="docutils literal notranslate"><span class="pre">'default'</span></code> algorithm.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">'tol'</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); if set to a value other than
<code class="docutils literal notranslate"><span class="pre">None</span></code>, this is interpreted as a small real number used to aid in
grouping eigenvalues that are numerically similar, but is ignored
when <code class="docutils literal notranslate"><span class="pre">homogeneous</span></code> is set.  See the output description for more
information.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">homogeneous</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, use
homogeneous coordinates for the output
(see <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_right" title="sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_right"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eigenvectors_right()</span></code></a> for details)</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When using the <code class="docutils literal notranslate"><span class="pre">'symmetric'</span></code> or <code class="docutils literal notranslate"><span class="pre">'hermitian'</span></code> algorithms,
no check is made on the input matrix, and only the entries below,
and on, the main diagonal are employed in the computation.</p>
<p>Methods such as <code class="xref py py-meth docutils literal notranslate"><span class="pre">is_symmetric()</span></code> and <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_hermitian" title="sage.matrix.matrix_double_dense.Matrix_double_dense.is_hermitian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_hermitian()</span></code></a>
could be used to verify this beforehand.</p>
</div>
<p>OUTPUT:</p>
<p>Default output for a square matrix of size <span class="math notranslate nohighlight">\(n\)</span> is a list of <span class="math notranslate nohighlight">\(n\)</span>
eigenvalues from the complex double field,
<code class="xref py py-class docutils literal notranslate"><span class="pre">CDF</span></code>.  If the <code class="docutils literal notranslate"><span class="pre">'symmetric'</span></code>
or <code class="docutils literal notranslate"><span class="pre">'hermitian'</span></code> algorithms are chosen, the returned eigenvalues
are from the real double field,
<code class="xref py py-class docutils literal notranslate"><span class="pre">RDF</span></code>.</p>
<p>If a tolerance is specified, an attempt is made to group eigenvalues
that are numerically similar.  The return is then a list of pairs,
where each pair is an eigenvalue followed by its multiplicity.
The eigenvalue reported is the mean of the eigenvalues computed,
and these eigenvalues are contained in an interval (or disk) whose
radius is less than <code class="docutils literal notranslate"><span class="pre">5*tol</span></code> for <span class="math notranslate nohighlight">\(n &lt; 10,000\)</span> in the worst case.</p>
<p>More precisely, for an <span class="math notranslate nohighlight">\(n\times n\)</span> matrix, the diameter of the
interval containing similar eigenvalues could be as large as sum
of the reciprocals of the first <span class="math notranslate nohighlight">\(n\)</span> integers times <code class="docutils literal notranslate"><span class="pre">tol</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Use caution when using the  <code class="docutils literal notranslate"><span class="pre">tol</span></code> parameter to group
eigenvalues.  See the examples below to see how this can go wrong.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">ev</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">();</span> <span class="n">ev</span>
<span class="go">[-0.372281323..., 5.37228132...]</span>
<span class="gp">sage: </span><span class="n">ev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Complex Double Field</span>

<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">)</span>
<span class="go">[1.0*I, -1.0*I]</span>

<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">I</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="n">I</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()</span>
<span class="go">[-0.624810533... + 1.30024259...*I, 0.624810533... - 0.30024259...*I]</span>
</pre></div>
</div>
<p>The adjacency matrix of a graph will be symmetric, and the
eigenvalues will be real.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">RDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ev</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">);</span> <span class="n">ev</span>  <span class="c1"># tol 1e-14</span>
<span class="go">[-2.0, -2.0, -2.0, -2.0, 1.0, 1.0, 1.0, 1.0, 1.0, 3.0]</span>
<span class="gp">sage: </span><span class="n">ev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Real Double Field</span>
</pre></div>
</div>
<p>The matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> is “random”, but the construction of <code class="docutils literal notranslate"><span class="pre">C</span></code>
provides a positive-definite Hermitian matrix.  Note that
the eigenvalues of a Hermitian matrix are real, and the
eigenvalues of a positive-definite matrix will be positive.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span> <span class="mi">4</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span>  <span class="mi">8</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">7</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">....: </span>            <span class="p">[</span> <span class="mi">7</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span>
<span class="gp">....: </span>            <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">6</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">6</span><span class="p">,</span>  <span class="mi">5</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span>  <span class="o">-</span><span class="n">I</span> <span class="o">-</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">....: </span>            <span class="p">[</span> <span class="mi">5</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">6</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>    <span class="n">I</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="n">I</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">conjugate_transpose</span><span class="p">())</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">CDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ev</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;hermitian&#39;</span><span class="p">);</span> <span class="n">ev</span>
<span class="go">[2.68144025..., 49.5167998..., 274.086188..., 390.71557...]</span>
<span class="gp">sage: </span><span class="n">ev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Real Double Field</span>
</pre></div>
</div>
<p>A tolerance can be given to aid in grouping eigenvalues that
are similar numerically.  However, if the parameter is too small
it might split too finely.  Too large, and it can go wrong very
badly.  Use with care.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">spectrum</span><span class="p">()</span>
<span class="go">[3, 1, 1, 1, 1, 1, -2, -2, -2, -2]</span>

<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">RDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">)</span>  <span class="c1"># tol 1e-15</span>
<span class="go">[(-2.0, 4), (1.0, 5), (3.0, 1)]</span>

<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">2.5</span><span class="p">)</span>  <span class="c1"># tol 1e-15</span>
<span class="go">[(-2.0, 4), (1.3333333333333333, 6)]</span>
</pre></div>
</div>
<p>An (extreme) example of properly grouping similar eigenvalues.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HigmanSimsGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">RDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">)</span>  <span class="c1"># tol 2e-15</span>
<span class="go">[(-8.0, 22), (2.0, 77), (22.0, 1)]</span>
</pre></div>
</div>
<p>In this generalized eigenvalue problem, the homogeneous coordinates
explain the output obtained for the eigenvalues:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>  <span class="c1"># tol 1e-14</span>
<span class="go">[0.0769230769230769, +infinity]</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">homogeneous</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> <span class="n">E</span>  <span class="c1"># random</span>
<span class="go">[(0.9999999999999999, 13.000000000000002), (0.9999999999999999, 0.0)]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">alpha</span><span class="o">/</span><span class="n">beta</span> <span class="k">for</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span> <span class="ow">in</span> <span class="n">E</span><span class="p">]</span>  <span class="c1"># tol 1e-14</span>
<span class="go">[0.0769230769230769, NaN + NaN*I]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_left" title="sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_left"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eigenvectors_left()</span></code></a>,
<a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_right" title="sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_right"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eigenvectors_right()</span></code></a>,
<a class="reference internal" href="matrix2.html#sage.matrix.matrix2.Matrix.eigenmatrix_left" title="sage.matrix.matrix2.Matrix.eigenmatrix_left"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Matrix.eigenmatrix_left()</span></code></a>,
<a class="reference internal" href="matrix2.html#sage.matrix.matrix2.Matrix.eigenmatrix_right" title="sage.matrix.matrix2.Matrix.eigenmatrix_right"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Matrix.eigenmatrix_right()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_left">
<span class="sig-name descname"><span class="pre">eigenvectors_left</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">homogeneous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_left" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the ordinary or generalized left eigenvectors of a matrix of
double precision real or complex numbers (i.e. <code class="docutils literal notranslate"><span class="pre">RDF</span></code> or <code class="docutils literal notranslate"><span class="pre">CDF</span></code>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> – a square matrix <span class="math notranslate nohighlight">\(B\)</span> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) in a generalized
eigenvalue problem; if <code class="docutils literal notranslate"><span class="pre">None</span></code>, an ordinary eigenvalue problem is
solved</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">homogeneous</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, use
homogeneous coordinates for the eigenvalues in the output</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of triples, each of the form <code class="docutils literal notranslate"><span class="pre">(e,[v],1)</span></code>,
where <code class="docutils literal notranslate"><span class="pre">e</span></code> is the eigenvalue, and <code class="docutils literal notranslate"><span class="pre">v</span></code> is an associated
left eigenvector such that</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[v A = e v.\]</div>
</div>
<p>If the matrix <span class="math notranslate nohighlight">\(A\)</span> is of size <span class="math notranslate nohighlight">\(n\)</span>, then there are <span class="math notranslate nohighlight">\(n\)</span> triples.</p>
<p>If a matrix <span class="math notranslate nohighlight">\(B\)</span> is passed as optional argument, the output is a
solution to the generalized eigenvalue problem such that</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[v A = e v B.\]</div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">homogeneous</span></code> is set, each eigenvalue is returned as a tuple
<span class="math notranslate nohighlight">\((\alpha, \beta)\)</span> of homogeneous coordinates such that</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\beta v A = \alpha v B.\]</div>
</div>
<p>The format of the output is designed to match the format
for exact results.  However, since matrices here have numerical
entries, the resulting eigenvalues will also be numerical.  No
attempt is made to determine if two eigenvalues are equal, or if
eigenvalues might actually be zero.  So the algebraic multiplicity
of each eigenvalue is reported as 1.  Decisions about equal
eigenvalues or zero eigenvalues should be addressed in the
calling routine.</p>
<p>The SciPy routines used for these computations produce eigenvectors
normalized to have length 1, but on different hardware they may vary
by a complex sign. So for doctests we have normalized output by forcing
their eigenvectors to have their first non-zero entry equal to one.</p>
<p>ALGORITHM:</p>
<p>Values are computed with the SciPy library using
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy:scipy.linalg.eig()</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">17</span><span class="p">],[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">13</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">m</span>
<span class="go">[ -5.0   3.0   2.0   8.0]</span>
<span class="go">[ 10.0   2.0   4.0  -2.0]</span>
<span class="go">[ -1.0 -10.0 -10.0 -17.0]</span>
<span class="go">[ -2.0   7.0   6.0  13.0]</span>
<span class="gp">sage: </span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">left_eigenvectors</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)):</span>
<span class="gp">....: </span>    <span class="n">spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">echelon_form</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(2.0, [(1.0, 1.0, 1.0, 1.0)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(1.0, [(1.0, 0.8, 0.8, 0.6)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(-2.0, [(1.0, 0.4, 0.6, 0.2)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(-1.0, [(1.0, 1.0, 2.0, 2.0)], 1)</span>
</pre></div>
</div>
<p>A generalized eigenvalue problem:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="o">+</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="o">-</span><span class="n">I</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">eigenvectors_left</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">((</span><span class="n">v</span> <span class="o">*</span> <span class="n">A</span> <span class="o">-</span> <span class="n">e</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-14</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">E</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In a generalized eigenvalue problem with a singular matrix <span class="math notranslate nohighlight">\(B\)</span>, we can
check the eigenvector property using homogeneous coordinates, even
though the quotient <span class="math notranslate nohighlight">\(\alpha/\beta\)</span> is not always defined:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="n">I</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">eigenvectors_left</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">homogeneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">((</span><span class="n">beta</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">A</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-14</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">),</span> <span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">E</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvalues" title="sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvalues"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eigenvalues()</span></code></a>,
<a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_right" title="sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_right"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eigenvectors_right()</span></code></a>,
<a class="reference internal" href="matrix2.html#sage.matrix.matrix2.Matrix.eigenmatrix_left" title="sage.matrix.matrix2.Matrix.eigenmatrix_left"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Matrix.eigenmatrix_left()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_right">
<span class="sig-name descname"><span class="pre">eigenvectors_right</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">homogeneous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_right" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the ordinary or generalized right eigenvectors of a matrix of
double precision real or complex numbers (i.e. <code class="docutils literal notranslate"><span class="pre">RDF</span></code> or <code class="docutils literal notranslate"><span class="pre">CDF</span></code>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> – a square matrix <span class="math notranslate nohighlight">\(B\)</span> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) in a generalized
eigenvalue problem; if <code class="docutils literal notranslate"><span class="pre">None</span></code>, an ordinary eigenvalue problem is
solved</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">homogeneous</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, use
homogeneous coordinates for the eigenvalues in the output</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of triples, each of the form <code class="docutils literal notranslate"><span class="pre">(e,[v],1)</span></code>,
where <code class="docutils literal notranslate"><span class="pre">e</span></code> is the eigenvalue, and <code class="docutils literal notranslate"><span class="pre">v</span></code> is an associated
right eigenvector such that</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[A v = e v.\]</div>
</div>
<p>If the matrix <span class="math notranslate nohighlight">\(A\)</span> is of size <span class="math notranslate nohighlight">\(n\)</span>, then there are <span class="math notranslate nohighlight">\(n\)</span> triples.</p>
<p>If a matrix <span class="math notranslate nohighlight">\(B\)</span> is passed as optional argument, the output is a
solution to the generalized eigenvalue problem such that</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[A v = e B v.\]</div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">homogeneous</span></code> is set, each eigenvalue is returned as a tuple
<span class="math notranslate nohighlight">\((\alpha, \beta)\)</span> of homogeneous coordinates such that</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\beta A v = \alpha B v.\]</div>
</div>
<p>The format of the output is designed to match the format
for exact results.  However, since matrices here have numerical
entries, the resulting eigenvalues will also be numerical.  No
attempt is made to determine if two eigenvalues are equal, or if
eigenvalues might actually be zero.  So the algebraic multiplicity
of each eigenvalue is reported as 1.  Decisions about equal
eigenvalues or zero eigenvalues should be addressed in the
calling routine.</p>
<p>The SciPy routines used for these computations produce eigenvectors
normalized to have length 1, but on different hardware they may vary
by a complex sign. So for doctests we have normalized output by forcing
their eigenvectors to have their first non-zero entry equal to one.</p>
<p>ALGORITHM:</p>
<p>Values are computed with the SciPy library using
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy:scipy.linalg.eig()</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">14</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="o">-</span><span class="mi">74</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">11</span><span class="p">],[</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">32</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">m</span>
<span class="go">[ -9.0 -14.0  19.0 -74.0]</span>
<span class="go">[ -1.0   2.0   4.0 -11.0]</span>
<span class="go">[ -4.0 -12.0   6.0 -32.0]</span>
<span class="go">[  0.0  -2.0  -1.0   1.0]</span>
<span class="gp">sage: </span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">right_eigenvectors</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)):</span>
<span class="gp">....: </span>  <span class="n">spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">echelon_form</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(2.0, [(1.0, -2.0, 3.0, 1.0)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(1.0, [(1.0, -0.666666666666633, 1.333333333333286, 0.33333333333331555)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(-2.0, [(1.0, -0.2, 1.0, 0.2)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(-1.0, [(1.0, -0.5, 2.0, 0.5)], 1)</span>
</pre></div>
</div>
<p>A generalized eigenvalue problem:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="o">+</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="o">-</span><span class="n">I</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">eigenvectors_right</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">((</span><span class="n">A</span> <span class="o">*</span> <span class="n">v</span> <span class="o">-</span> <span class="n">e</span> <span class="o">*</span> <span class="n">B</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-14</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">E</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In a generalized eigenvalue problem with a singular matrix <span class="math notranslate nohighlight">\(B\)</span>, we can
check the eigenvector property using homogeneous coordinates, even
though the quotient <span class="math notranslate nohighlight">\(\alpha/\beta\)</span> is not always defined:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">eigenvectors_right</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">homogeneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">((</span><span class="n">beta</span> <span class="o">*</span> <span class="n">A</span> <span class="o">*</span> <span class="n">v</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">B</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-14</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">),</span> <span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">E</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvalues" title="sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvalues"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eigenvalues()</span></code></a>,
<a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_left" title="sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_left"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eigenvectors_left()</span></code></a>,
<a class="reference internal" href="matrix2.html#sage.matrix.matrix2.Matrix.eigenmatrix_right" title="sage.matrix.matrix2.Matrix.eigenmatrix_right"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Matrix.eigenmatrix_right()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.exp" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the exponential of this matrix X, which is the matrix</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[e^X = \sum_{k=0}^{\infty} \frac{X^k}{k!}.\]</div>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]);</span> <span class="n">A</span>
<span class="go">[1.0 2.0]</span>
<span class="go">[3.0 4.0]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>  <span class="c1"># tol 1e-14</span>
<span class="go">[51.968956198705044  74.73656456700327]</span>
<span class="go">[112.10484685050491 164.07380304920997]</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">+</span><span class="n">I</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">,</span><span class="mi">4</span><span class="p">]);</span> <span class="n">A</span>
<span class="go">[        1.0 2.0 + 1.0*I]</span>
<span class="go">[      3.0*I         4.0]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>  <span class="c1"># tol 1.1e-14</span>
<span class="go">[-19.614602953804912 + 12.517743846762578*I   3.7949636449582176 + 28.88379930658099*I]</span>
<span class="go">[ -32.383580980922254 + 21.88423595789845*I   2.269633004093535 + 44.901324827684824*I]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.is_hermitian">
<span class="sig-name descname"><span class="pre">is_hermitian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'naive'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_hermitian" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the matrix is equal to its conjugate-transpose.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tol</span></code> - default: <code class="docutils literal notranslate"><span class="pre">1e-12</span></code> - the largest value of the
absolute value of the difference between two matrix entries
for which they will still be considered equal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: “naive”); either “naive”
or “orthonormal”</p></li>
</ul>
<p>OUTPUT:</p>
<p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the matrix is square and equal to the transpose with
every entry conjugated, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>Note that if conjugation has no effect on elements of the base
ring (such as for integers), then the <code class="xref py py-meth docutils literal notranslate"><span class="pre">is_symmetric()</span></code>
method is equivalent and faster.</p>
<p>The tolerance parameter is used to allow for numerical values
to be equal if there is a slight difference due to round-off
and other imprecisions.</p>
<p>The result is cached, on a per-tolerance and per-algorithm basis.</p>
<p>ALGORITHMS:</p>
<p>The naive algorithm simply compares corresponding entries on either
side of the diagonal (and on the diagonal itself) to see if they are
conjugates, with equality controlled by the tolerance parameter.</p>
<p>The orthonormal algorithm first computes a Schur decomposition
(via the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.schur" title="sage.matrix.matrix_double_dense.Matrix_double_dense.schur"><code class="xref py py-meth docutils literal notranslate"><span class="pre">schur()</span></code></a> method) and checks that the result is a
diagonal matrix with real entries.</p>
<p>So the naive algorithm can finish quickly for a matrix that is not
Hermitian, while the orthonormal algorithm will always compute a
Schur decomposition before going through a similar check of the matrix
entry-by-entry.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span>  <span class="mi">1</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">I</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">3</span> <span class="o">-</span> <span class="n">I</span><span class="p">,</span>     <span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>     <span class="o">-</span><span class="mi">2</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">8</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>  <span class="mi">2</span> <span class="o">+</span> <span class="n">I</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">conjugate_transpose</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A matrix that is nearly Hermitian, but for one non-real
diagonal entry.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span>    <span class="mi">2</span><span class="p">,</span>   <span class="mi">2</span><span class="o">-</span><span class="n">I</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">I</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span>  <span class="mi">2</span><span class="o">+</span><span class="n">I</span><span class="p">,</span>   <span class="mi">3</span><span class="o">+</span><span class="n">I</span><span class="p">,</span> <span class="mi">2</span><span class="o">-</span><span class="mi">6</span><span class="o">*</span><span class="n">I</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">6</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>     <span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">132</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We get a unitary matrix from the SVD routine and use this
numerical matrix to create a matrix that should be Hermitian
(indeed it should be the identity matrix), but with some
imprecision.  We use this to illustrate that if the tolerance
is set too small, then we can be too strict about the equality
of entries and may achieve the wrong result (depending on
the system):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span>  <span class="mi">1</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">I</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">3</span> <span class="o">-</span> <span class="n">I</span><span class="p">,</span>     <span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>     <span class="o">-</span><span class="mi">2</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">8</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>  <span class="mi">2</span> <span class="o">+</span> <span class="n">I</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">U</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">SVD</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">=</span><span class="n">U</span><span class="o">*</span><span class="n">U</span><span class="o">.</span><span class="n">conjugate_transpose</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-17</span><span class="p">)</span>  <span class="c1"># random</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-15</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A square, empty matrix is trivially Hermitian.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Rectangular matrices are never Hermitian, no matter which
algorithm is requested.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li><p>Rob Beezer (2011-03-30)</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.is_normal">
<span class="sig-name descname"><span class="pre">is_normal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'orthonormal'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_normal" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the matrix commutes with its conjugate-transpose.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tol</span></code> - default: <code class="docutils literal notranslate"><span class="pre">1e-12</span></code> - the largest value of the
absolute value of the difference between two matrix entries
for which they will still be considered equal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> - default: ‘orthonormal’ - set to ‘orthonormal’
for a stable procedure and set to ‘naive’ for a fast
procedure.</p></li>
</ul>
<p>OUTPUT:</p>
<p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the matrix is square and commutes with its
conjugate-transpose, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>Normal matrices are precisely those that can be diagonalized
by a unitary matrix.</p>
<p>The tolerance parameter is used to allow for numerical values
to be equal if there is a slight difference due to round-off
and other imprecisions.</p>
<p>The result is cached, on a per-tolerance and per-algorithm basis.</p>
<p>ALGORITHMS:</p>
<p>The naive algorithm simply compares entries of the two possible
products of the matrix with its conjugate-transpose, with equality
controlled by the tolerance parameter.</p>
<p>The orthonormal algorithm first computes a Schur decomposition
(via the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.schur" title="sage.matrix.matrix_double_dense.Matrix_double_dense.schur"><code class="xref py py-meth docutils literal notranslate"><span class="pre">schur()</span></code></a> method) and checks that the result is a
diagonal matrix.  An orthonormal diagonalization
is equivalent to being normal.</p>
<p>So the naive algorithm can finish fairly quickly for a matrix
that is not normal, once the products have been computed.
However, the orthonormal algorithm will compute a Schur
decomposition before going through a similar check of a
matrix entry-by-entry.</p>
<p>EXAMPLES:</p>
<p>First over the complexes.  <code class="docutils literal notranslate"><span class="pre">B</span></code> is Hermitian, hence normal.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span>  <span class="mi">1</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">I</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">3</span> <span class="o">-</span> <span class="n">I</span><span class="p">,</span>     <span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>     <span class="o">-</span><span class="mi">2</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">8</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>  <span class="mi">2</span> <span class="o">+</span> <span class="n">I</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">conjugate_transpose</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_normal</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_normal</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_normal</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_normal</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Now over the reals.  Circulant matrices are normal.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CirculantGraph</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">D</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">RDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_normal</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_normal</span><span class="p">(</span><span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">[</span><span class="mi">19</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.0</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_normal</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_normal</span><span class="p">(</span><span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Skew-Hermitian matrices are normal.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span>  <span class="mi">1</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">I</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">3</span> <span class="o">-</span> <span class="n">I</span><span class="p">,</span>     <span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>     <span class="o">-</span><span class="mi">2</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">8</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>  <span class="mi">2</span> <span class="o">+</span> <span class="n">I</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">conjugate_transpose</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_normal</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_normal</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A small matrix that does not fit into any of the usual categories
of normal matrices.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_normal</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="ow">not</span> <span class="n">A</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">A</span><span class="o">.</span><span class="n">is_skew_symmetric</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Sage has several fields besides the entire complex numbers
where conjugation is non-trivial.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span><span class="o">.&lt;</span><span class="n">b</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="p">[[</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">7</span><span class="o">*</span><span class="n">b</span> <span class="o">-</span> <span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>               <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>   <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="p">],</span>
<span class="gp">....: </span>               <span class="p">[</span>   <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>        <span class="mi">0</span><span class="p">,</span>     <span class="o">-</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">C</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">conjugate_transpose</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_normal</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A square, empty matrix is trivially normal.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_normal</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Rectangular matrices are never normal, no matter which
algorithm is requested.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_normal</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<blockquote>
<div><ul class="simple">
<li><p>Rob Beezer (2011-03-31)</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.is_positive_definite">
<span class="sig-name descname"><span class="pre">is_positive_definite</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_positive_definite" title="Permalink to this definition">#</a></dt>
<dd><p>Determines if a matrix is positive definite.</p>
<p>A matrix <span class="math notranslate nohighlight">\(A\)</span> is positive definite if it is square,
is Hermitian (which reduces to symmetric in the real case),
and for every nonzero vector <span class="math notranslate nohighlight">\(\vec{x}\)</span>,</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\vec{x}^\ast A \vec{x} &gt; 0\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\vec{x}^\ast\)</span> is the conjugate-transpose in the
complex case and just the transpose in the real case.
Equivalently, a positive definite matrix has only positive
eigenvalues and only positive determinants of leading
principal submatrices.</p>
<p>INPUT:</p>
<p>Any matrix over <code class="docutils literal notranslate"><span class="pre">RDF</span></code> or <code class="docutils literal notranslate"><span class="pre">CDF</span></code>.</p>
<p>OUTPUT:</p>
<p><code class="docutils literal notranslate"><span class="pre">True</span></code> if and only if the matrix is square, Hermitian,
and meets the condition above on the quadratic form.
The result is cached.</p>
<p>IMPLEMENTATION:</p>
<p>The existence of a Cholesky decomposition and the
positive definite property are equivalent.  So this
method and the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.cholesky" title="sage.matrix.matrix_double_dense.Matrix_double_dense.cholesky"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cholesky()</span></code></a> method compute and
cache both the Cholesky decomposition and the
positive-definiteness.  So the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_positive_definite" title="sage.matrix.matrix_double_dense.Matrix_double_dense.is_positive_definite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_positive_definite()</span></code></a>
method or catching a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> from the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.cholesky" title="sage.matrix.matrix_double_dense.Matrix_double_dense.cholesky"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cholesky()</span></code></a>
method are equally expensive computationally and if the
decomposition exists, it is cached as a side-effect of either
routine.</p>
<p>EXAMPLES:</p>
<p>A matrix over <code class="docutils literal notranslate"><span class="pre">RDF</span></code> that is positive definite.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,[[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>    <span class="mi">1</span><span class="p">,</span>     <span class="mi">1</span><span class="p">,</span>     <span class="mi">1</span><span class="p">],</span>
<span class="gp">....: </span>                <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>   <span class="mi">31</span><span class="p">,</span>   <span class="mi">121</span><span class="p">,</span>   <span class="mi">341</span><span class="p">],</span>
<span class="gp">....: </span>                <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span>  <span class="mi">341</span><span class="p">,</span>  <span class="mi">1555</span><span class="p">,</span>  <span class="mi">4681</span><span class="p">],</span>
<span class="gp">....: </span>                <span class="p">[</span> <span class="mi">1</span><span class="p">,</span><span class="mi">121</span><span class="p">,</span> <span class="mi">1555</span><span class="p">,</span>  <span class="mi">7381</span><span class="p">,</span> <span class="mi">22621</span><span class="p">],</span>
<span class="gp">....: </span>                <span class="p">[</span> <span class="mi">1</span><span class="p">,</span><span class="mi">341</span><span class="p">,</span> <span class="mi">4681</span><span class="p">,</span> <span class="mi">22621</span><span class="p">,</span> <span class="mi">69905</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()</span>
<span class="go">[77547.66..., 82.44..., 2.41..., 0.46..., 0.011...]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">M</span><span class="p">[:</span><span class="n">i</span><span class="p">,:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">determinant</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">nrows</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="go">[1, 4, 460, 27936, 82944]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">is_positive_definite</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A matrix over <code class="docutils literal notranslate"><span class="pre">CDF</span></code> that is positive definite.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span>        <span class="mi">23</span><span class="p">,</span>  <span class="mi">17</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">24</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">25</span><span class="p">,</span>     <span class="mi">21</span><span class="o">*</span><span class="n">I</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span> <span class="o">-</span><span class="mi">17</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span>        <span class="mi">38</span><span class="p">,</span> <span class="o">-</span><span class="mi">69</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">7</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">15</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">24</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">69</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">89</span><span class="p">,</span>        <span class="mi">976</span><span class="p">,</span> <span class="mi">24</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span>     <span class="o">-</span><span class="mi">21</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span>  <span class="o">-</span><span class="mi">24</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">6</span><span class="p">,</span>       <span class="mi">28</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">C</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()]</span>
<span class="go">[991.46..., 55.96..., 3.69..., 13.87...]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">C</span><span class="p">[:</span><span class="n">i</span><span class="p">,:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">determinant</span><span class="p">()</span><span class="o">.</span><span class="n">real</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">nrows</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="go">[23, 576, 359540, 2842600]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_positive_definite</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A matrix over <code class="docutils literal notranslate"><span class="pre">RDF</span></code> that is not positive definite.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span> <span class="mi">3</span><span class="p">,</span>  <span class="o">-</span><span class="mi">6</span><span class="p">,</span>   <span class="mi">9</span><span class="p">,</span>   <span class="mi">6</span><span class="p">,</span>  <span class="o">-</span><span class="mi">9</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span>  <span class="mi">11</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="o">-</span><span class="mi">11</span><span class="p">,</span>  <span class="mi">17</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span> <span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span><span class="p">,</span>  <span class="mi">28</span><span class="p">,</span>  <span class="mi">16</span><span class="p">,</span> <span class="o">-</span><span class="mi">40</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span> <span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">11</span><span class="p">,</span>  <span class="mi">16</span><span class="p">,</span>   <span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">19</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span>  <span class="mi">17</span><span class="p">,</span> <span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="o">-</span><span class="mi">19</span><span class="p">,</span>  <span class="mi">68</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()</span>
<span class="go">[108.07..., 13.02..., -0.02..., -0.70..., -1.37...]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="n">i</span><span class="p">,:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">determinant</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">nrows</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="go">[3, -3, -15, 30, -30]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_positive_definite</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A matrix over <code class="docutils literal notranslate"><span class="pre">CDF</span></code> that is not positive definite.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span>      <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>       <span class="mi">8</span><span class="p">,</span>    <span class="mi">10</span><span class="o">*</span><span class="n">I</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>   <span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>      <span class="o">-</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">ev</span><span class="o">.</span><span class="n">real</span><span class="p">()</span> <span class="k">for</span> <span class="n">ev</span> <span class="ow">in</span> <span class="n">B</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()]</span>
<span class="go">[15.88..., 0.08..., -8.97...]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">B</span><span class="p">[:</span><span class="n">i</span><span class="p">,:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">determinant</span><span class="p">()</span><span class="o">.</span><span class="n">real</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">nrows</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="go">[2, -4, -12]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_positive_definite</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A large random matrix that is guaranteed by theory to be
positive definite.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">random_matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">conjugate_transpose</span><span class="p">()</span><span class="o">*</span><span class="n">R</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_positive_definite</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li><p>Rob Beezer (2012-05-28)</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.is_skew_hermitian">
<span class="sig-name descname"><span class="pre">is_skew_hermitian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'orthonormal'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_skew_hermitian" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the matrix is equal to the negative of its
conjugate transpose.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tol</span></code> - default: <code class="docutils literal notranslate"><span class="pre">1e-12</span></code> - the largest value of the
absolute value of the difference between two matrix entries
for which they will still be considered equal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> - default: ‘orthonormal’ - set to ‘orthonormal’
for a stable procedure and set to ‘naive’ for a fast
procedure.</p></li>
</ul>
<p>OUTPUT:</p>
<p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the matrix is square and equal to the negative of
its conjugate transpose, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>Note that if conjugation has no effect on elements of the base
ring (such as for integers), then the <code class="xref py py-meth docutils literal notranslate"><span class="pre">is_skew_symmetric()</span></code>
method is equivalent and faster.</p>
<p>The tolerance parameter is used to allow for numerical values
to be equal if there is a slight difference due to round-off
and other imprecisions.</p>
<p>The result is cached, on a per-tolerance and per-algorithm basis.</p>
<p>ALGORITHMS:</p>
<p>The naive algorithm simply compares corresponding entries on either
side of the diagonal (and on the diagonal itself) to see if they are
conjugates, with equality controlled by the tolerance parameter.</p>
<p>The orthonormal algorithm first computes a Schur decomposition
(via the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.schur" title="sage.matrix.matrix_double_dense.Matrix_double_dense.schur"><code class="xref py py-meth docutils literal notranslate"><span class="pre">schur()</span></code></a> method) and checks that the result is a
diagonal matrix with real entries.</p>
<p>So the naive algorithm can finish quickly for a matrix that is not
Hermitian, while the orthonormal algorithm will always compute a
Schur decomposition before going through a similar check of the matrix
entry-by-entry.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_skew_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_skew_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A matrix that is nearly skew-Hermitian, but for a non-real
diagonal entry.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span>  <span class="o">-</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">I</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span>   <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">I</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="o">-</span><span class="n">I</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_skew_hermitian</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">I</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_skew_hermitian</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We get a unitary matrix from the SVD routine and use this
numerical matrix to create a matrix that should be
skew-Hermitian (indeed it should be the identity matrix
multiplied by <span class="math notranslate nohighlight">\(I\)</span>), but with some imprecision.  We use this to
illustrate that if the tolerance is set too small, then we can
be too strict about the equality of entries and may achieve
the wrong result (depending on the system):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span>  <span class="mi">1</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">I</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">3</span> <span class="o">-</span> <span class="n">I</span><span class="p">,</span>     <span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>     <span class="o">-</span><span class="mi">2</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">8</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>  <span class="mi">2</span> <span class="o">+</span> <span class="n">I</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">U</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">SVD</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">=</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">U</span><span class="o">*</span><span class="n">U</span><span class="o">.</span><span class="n">conjugate_transpose</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_skew_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_skew_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-17</span><span class="p">)</span>  <span class="c1"># random</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_skew_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-15</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A square, empty matrix is trivially Hermitian.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_skew_hermitian</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Rectangular matrices are never Hermitian, no matter which
algorithm is requested.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_skew_hermitian</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li><p>Rob Beezer (2011-03-30)</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.is_unitary">
<span class="sig-name descname"><span class="pre">is_unitary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'orthonormal'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_unitary" title="Permalink to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the columns of the matrix are an orthonormal basis.</p>
<p>For a matrix with real entries this determines if a matrix is
“orthogonal” and for a matrix with complex entries this determines
if the matrix is “unitary.”</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tol</span></code> - default: <code class="docutils literal notranslate"><span class="pre">1e-12</span></code> - the largest value of the
absolute value of the difference between two matrix entries
for which they will still be considered equal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> - default: ‘orthonormal’ - set to ‘orthonormal’
for a stable procedure and set to ‘naive’ for a fast
procedure.</p></li>
</ul>
<p>OUTPUT:</p>
<p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the matrix is square and its conjugate-transpose is
its inverse, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.  In other words, a matrix
is orthogonal or unitary if the product of its conjugate-transpose
times the matrix is the identity matrix.</p>
<p>The tolerance parameter is used to allow for numerical values
to be equal if there is a slight difference due to round-off
and other imprecisions.</p>
<p>The result is cached, on a per-tolerance and per-algorithm basis.</p>
<p>ALGORITHMS:</p>
<p>The naive algorithm simply computes the product of the
conjugate-transpose with the matrix and compares the entries
to the identity matrix, with equality controlled by the
tolerance parameter.</p>
<p>The orthonormal algorithm first computes a Schur decomposition
(via the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.schur" title="sage.matrix.matrix_double_dense.Matrix_double_dense.schur"><code class="xref py py-meth docutils literal notranslate"><span class="pre">schur()</span></code></a> method) and checks that the result is a
diagonal matrix with entries of modulus 1, which is equivalent to
being unitary.</p>
<p>So the naive algorithm might finish fairly quickly for a matrix
that is not unitary, once the product has been computed.
However, the orthonormal algorithm will compute a Schur
decomposition before going through a similar check of a
matrix entry-by-entry.</p>
<p>EXAMPLES:</p>
<p>A matrix that is far from unitary.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">*</span><span class="n">A</span>
<span class="go">[224.0 248.0 272.0 296.0]</span>
<span class="go">[248.0 276.0 304.0 332.0]</span>
<span class="go">[272.0 304.0 336.0 368.0]</span>
<span class="go">[296.0 332.0 368.0 404.0]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The QR decomposition will produce a unitary matrix as Q and the
SVD decomposition will create two unitary matrices, U and V.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span>   <span class="mi">1</span> <span class="o">-</span> <span class="n">I</span><span class="p">,</span>   <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>  <span class="o">-</span><span class="mi">2</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span>        <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span>   <span class="mi">1</span> <span class="o">-</span> <span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>        <span class="mi">0</span><span class="p">,</span>    <span class="mi">2</span> <span class="o">+</span> <span class="n">I</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span>      <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span>  <span class="o">-</span><span class="mi">2</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span>    <span class="mi">1</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">I</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>  <span class="mi">2</span> <span class="o">-</span> <span class="n">I</span><span class="p">,</span> <span class="mi">8</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>  <span class="mi">1</span> <span class="o">-</span> <span class="mi">8</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>  <span class="mi">3</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">QR</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">SVD</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">U</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">U</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If we make the tolerance too strict we can get misleading results.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">QR</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-16</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-17</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Rectangular matrices are not unitary/orthogonal, even if their
columns form an orthonormal set.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The smallest cases:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li><p>Rob Beezer (2011-05-04)</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.left_eigenvectors">
<span class="sig-name descname"><span class="pre">left_eigenvectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">homogeneous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.left_eigenvectors" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the ordinary or generalized left eigenvectors of a matrix of
double precision real or complex numbers (i.e. <code class="docutils literal notranslate"><span class="pre">RDF</span></code> or <code class="docutils literal notranslate"><span class="pre">CDF</span></code>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> – a square matrix <span class="math notranslate nohighlight">\(B\)</span> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) in a generalized
eigenvalue problem; if <code class="docutils literal notranslate"><span class="pre">None</span></code>, an ordinary eigenvalue problem is
solved</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">homogeneous</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, use
homogeneous coordinates for the eigenvalues in the output</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of triples, each of the form <code class="docutils literal notranslate"><span class="pre">(e,[v],1)</span></code>,
where <code class="docutils literal notranslate"><span class="pre">e</span></code> is the eigenvalue, and <code class="docutils literal notranslate"><span class="pre">v</span></code> is an associated
left eigenvector such that</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[v A = e v.\]</div>
</div>
<p>If the matrix <span class="math notranslate nohighlight">\(A\)</span> is of size <span class="math notranslate nohighlight">\(n\)</span>, then there are <span class="math notranslate nohighlight">\(n\)</span> triples.</p>
<p>If a matrix <span class="math notranslate nohighlight">\(B\)</span> is passed as optional argument, the output is a
solution to the generalized eigenvalue problem such that</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[v A = e v B.\]</div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">homogeneous</span></code> is set, each eigenvalue is returned as a tuple
<span class="math notranslate nohighlight">\((\alpha, \beta)\)</span> of homogeneous coordinates such that</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\beta v A = \alpha v B.\]</div>
</div>
<p>The format of the output is designed to match the format
for exact results.  However, since matrices here have numerical
entries, the resulting eigenvalues will also be numerical.  No
attempt is made to determine if two eigenvalues are equal, or if
eigenvalues might actually be zero.  So the algebraic multiplicity
of each eigenvalue is reported as 1.  Decisions about equal
eigenvalues or zero eigenvalues should be addressed in the
calling routine.</p>
<p>The SciPy routines used for these computations produce eigenvectors
normalized to have length 1, but on different hardware they may vary
by a complex sign. So for doctests we have normalized output by forcing
their eigenvectors to have their first non-zero entry equal to one.</p>
<p>ALGORITHM:</p>
<p>Values are computed with the SciPy library using
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy:scipy.linalg.eig()</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">17</span><span class="p">],[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">13</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">m</span>
<span class="go">[ -5.0   3.0   2.0   8.0]</span>
<span class="go">[ 10.0   2.0   4.0  -2.0]</span>
<span class="go">[ -1.0 -10.0 -10.0 -17.0]</span>
<span class="go">[ -2.0   7.0   6.0  13.0]</span>
<span class="gp">sage: </span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">left_eigenvectors</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)):</span>
<span class="gp">....: </span>    <span class="n">spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">echelon_form</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(2.0, [(1.0, 1.0, 1.0, 1.0)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(1.0, [(1.0, 0.8, 0.8, 0.6)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(-2.0, [(1.0, 0.4, 0.6, 0.2)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(-1.0, [(1.0, 1.0, 2.0, 2.0)], 1)</span>
</pre></div>
</div>
<p>A generalized eigenvalue problem:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="o">+</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="o">-</span><span class="n">I</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">eigenvectors_left</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">((</span><span class="n">v</span> <span class="o">*</span> <span class="n">A</span> <span class="o">-</span> <span class="n">e</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-14</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">E</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In a generalized eigenvalue problem with a singular matrix <span class="math notranslate nohighlight">\(B\)</span>, we can
check the eigenvector property using homogeneous coordinates, even
though the quotient <span class="math notranslate nohighlight">\(\alpha/\beta\)</span> is not always defined:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="n">I</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">eigenvectors_left</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">homogeneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">((</span><span class="n">beta</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">A</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-14</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">),</span> <span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">E</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvalues" title="sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvalues"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eigenvalues()</span></code></a>,
<a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_right" title="sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_right"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eigenvectors_right()</span></code></a>,
<a class="reference internal" href="matrix2.html#sage.matrix.matrix2.Matrix.eigenmatrix_left" title="sage.matrix.matrix2.Matrix.eigenmatrix_left"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Matrix.eigenmatrix_left()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.log_determinant">
<span class="sig-name descname"><span class="pre">log_determinant</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.log_determinant" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the log of the absolute value of the determinant
using LU decomposition.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is useful if the usual determinant overflows.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span> <span class="n">m</span>
<span class="go">[0.0 1.0]</span>
<span class="go">[2.0 3.0]</span>
<span class="gp">sage: </span><span class="n">RDF</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">determinant</span><span class="p">())))</span>
<span class="go">0.6931471805599453</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">log_determinant</span><span class="p">()</span>
<span class="go">0.6931471805599453</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,[]);</span> <span class="n">m</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">log_determinant</span><span class="p">()</span>
<span class="go">0.0</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span> <span class="n">m</span>
<span class="go">[0.0 1.0]</span>
<span class="go">[2.0 3.0]</span>
<span class="gp">sage: </span><span class="n">RDF</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">determinant</span><span class="p">())))</span>
<span class="go">0.6931471805599453</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">log_determinant</span><span class="p">()</span>
<span class="go">0.6931471805599453</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,[]);</span> <span class="n">m</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">log_determinant</span><span class="p">()</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.norm" title="Permalink to this definition">#</a></dt>
<dd><p>Return the norm of the matrix.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code> - default: 2 - controls which norm is computed,
allowable values are ‘frob’ (for the Frobenius norm),
integers -2, -1, 1, 2, positive and negative infinity.  See
output discussion for specifics.</p></li>
</ul>
<p>OUTPUT:</p>
<p>Returned value is a double precision floating point value
in <code class="docutils literal notranslate"><span class="pre">RDF</span></code>.  Row and column sums described below are
sums of the absolute values of the entries, where the
absolute value of the complex number <span class="math notranslate nohighlight">\(a+bi\)</span> is <span class="math notranslate nohighlight">\(\sqrt{a^2+b^2}\)</span>.
Singular values are the “diagonal” entries of the “S” matrix in
the singular value decomposition.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">'frob'</span></code>: the Frobenius norm, which for
a matrix <span class="math notranslate nohighlight">\(A=(a_{ij})\)</span> computes</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\left(\sum_{i,j}\left\lvert{a_{i,j}}\right\rvert^2\right)^{1/2}\]</div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">Infinity</span></code> or <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">oo</span></code>: the maximum row sum.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">-Infinity</span></code> or <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">-oo</span></code>: the minimum column sum.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">1</span></code>: the maximum column sum.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">-1</span></code>: the minimum column sum.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">2</span></code>: the induced 2-norm, equal to the maximum singular value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">-2</span></code>: the minimum singular value.</p></li>
</ul>
<p>ALGORITHM:</p>
<p>Computation is performed by the <code class="docutils literal notranslate"><span class="pre">norm()</span></code> function of
the SciPy/NumPy library.</p>
<p>EXAMPLES:</p>
<p>First over the reals.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">));</span> <span class="n">A</span>
<span class="go">[-3.0 -2.0 -1.0]</span>
<span class="go">[ 0.0  1.0  2.0]</span>
<span class="go">[ 3.0  4.0  5.0]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="go">7.99575670...</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="s1">&#39;frob&#39;</span><span class="p">)</span>
<span class="go">8.30662386...</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">Infinity</span><span class="p">)</span>
<span class="go">12.0</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="n">Infinity</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">8.0</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">6.0</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">7.99575670...</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">^-</span><span class="mi">15</span>
<span class="go">True</span>
</pre></div>
</div>
<p>And over the complex numbers.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="o">+</span><span class="n">I</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">],[</span><span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">I</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">]]);</span> <span class="n">B</span>
<span class="go">[1.0 + 1.0*I 2.0 + 3.0*I]</span>
<span class="go">[3.0 + 4.0*I       3.0*I]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="go">6.66189877...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="s1">&#39;frob&#39;</span><span class="p">)</span>
<span class="go">7.0</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">Infinity</span><span class="p">)</span>
<span class="go">8.0</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="n">Infinity</span><span class="p">)</span>
<span class="go">5.01976483...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">6.60555127...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">6.41421356...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">6.66189877...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2.14921023...</span>
</pre></div>
</div>
<p>Since it is invariant under unitary multiplication, the
Frobenius norm is equal to the square root of the sum of
squares of the singular values.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">26</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="s1">&#39;frob&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">SVD</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]))</span>
<span class="gp">sage: </span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="o">-</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.0e-12</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Return values are in <span class="math notranslate nohighlight">\(RDF\)</span>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="ow">in</span> <span class="n">RDF</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Improper values of <code class="docutils literal notranslate"><span class="pre">p</span></code> are caught.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="s1">&#39;bogus&#39;</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: matrix norm &#39;p&#39; must be +/- infinity, &#39;frob&#39; or an integer, not bogus</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">632</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: matrix norm integer values of &#39;p&#39; must be -2, -1, 1 or 2, not 632</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.right_eigenvectors">
<span class="sig-name descname"><span class="pre">right_eigenvectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">homogeneous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.right_eigenvectors" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the ordinary or generalized right eigenvectors of a matrix of
double precision real or complex numbers (i.e. <code class="docutils literal notranslate"><span class="pre">RDF</span></code> or <code class="docutils literal notranslate"><span class="pre">CDF</span></code>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> – a square matrix <span class="math notranslate nohighlight">\(B\)</span> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) in a generalized
eigenvalue problem; if <code class="docutils literal notranslate"><span class="pre">None</span></code>, an ordinary eigenvalue problem is
solved</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">homogeneous</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, use
homogeneous coordinates for the eigenvalues in the output</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of triples, each of the form <code class="docutils literal notranslate"><span class="pre">(e,[v],1)</span></code>,
where <code class="docutils literal notranslate"><span class="pre">e</span></code> is the eigenvalue, and <code class="docutils literal notranslate"><span class="pre">v</span></code> is an associated
right eigenvector such that</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[A v = e v.\]</div>
</div>
<p>If the matrix <span class="math notranslate nohighlight">\(A\)</span> is of size <span class="math notranslate nohighlight">\(n\)</span>, then there are <span class="math notranslate nohighlight">\(n\)</span> triples.</p>
<p>If a matrix <span class="math notranslate nohighlight">\(B\)</span> is passed as optional argument, the output is a
solution to the generalized eigenvalue problem such that</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[A v = e B v.\]</div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">homogeneous</span></code> is set, each eigenvalue is returned as a tuple
<span class="math notranslate nohighlight">\((\alpha, \beta)\)</span> of homogeneous coordinates such that</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\beta A v = \alpha B v.\]</div>
</div>
<p>The format of the output is designed to match the format
for exact results.  However, since matrices here have numerical
entries, the resulting eigenvalues will also be numerical.  No
attempt is made to determine if two eigenvalues are equal, or if
eigenvalues might actually be zero.  So the algebraic multiplicity
of each eigenvalue is reported as 1.  Decisions about equal
eigenvalues or zero eigenvalues should be addressed in the
calling routine.</p>
<p>The SciPy routines used for these computations produce eigenvectors
normalized to have length 1, but on different hardware they may vary
by a complex sign. So for doctests we have normalized output by forcing
their eigenvectors to have their first non-zero entry equal to one.</p>
<p>ALGORITHM:</p>
<p>Values are computed with the SciPy library using
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy:scipy.linalg.eig()</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">14</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="o">-</span><span class="mi">74</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">11</span><span class="p">],[</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">32</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">m</span>
<span class="go">[ -9.0 -14.0  19.0 -74.0]</span>
<span class="go">[ -1.0   2.0   4.0 -11.0]</span>
<span class="go">[ -4.0 -12.0   6.0 -32.0]</span>
<span class="go">[  0.0  -2.0  -1.0   1.0]</span>
<span class="gp">sage: </span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">right_eigenvectors</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)):</span>
<span class="gp">....: </span>  <span class="n">spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">echelon_form</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(2.0, [(1.0, -2.0, 3.0, 1.0)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(1.0, [(1.0, -0.666666666666633, 1.333333333333286, 0.33333333333331555)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(-2.0, [(1.0, -0.2, 1.0, 0.2)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(-1.0, [(1.0, -0.5, 2.0, 0.5)], 1)</span>
</pre></div>
</div>
<p>A generalized eigenvalue problem:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="o">+</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="o">-</span><span class="n">I</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">eigenvectors_right</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">((</span><span class="n">A</span> <span class="o">*</span> <span class="n">v</span> <span class="o">-</span> <span class="n">e</span> <span class="o">*</span> <span class="n">B</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-14</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">E</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In a generalized eigenvalue problem with a singular matrix <span class="math notranslate nohighlight">\(B\)</span>, we can
check the eigenvector property using homogeneous coordinates, even
though the quotient <span class="math notranslate nohighlight">\(\alpha/\beta\)</span> is not always defined:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">eigenvectors_right</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">homogeneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">((</span><span class="n">beta</span> <span class="o">*</span> <span class="n">A</span> <span class="o">*</span> <span class="n">v</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">B</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-14</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">),</span> <span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">E</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvalues" title="sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvalues"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eigenvalues()</span></code></a>,
<a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_left" title="sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_left"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eigenvectors_left()</span></code></a>,
<a class="reference internal" href="matrix2.html#sage.matrix.matrix2.Matrix.eigenmatrix_right" title="sage.matrix.matrix2.Matrix.eigenmatrix_right"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Matrix.eigenmatrix_right()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.round">
<span class="sig-name descname"><span class="pre">round</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ndigits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.round" title="Permalink to this definition">#</a></dt>
<dd><p>Return a copy of the matrix where all entries have been rounded
to a given precision in decimal digits (default 0 digits).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ndigits</span></code> - The precision in number of decimal digits</p></li>
</ul>
<p>OUTPUT:</p>
<p>A modified copy of the matrix</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mf">10.234</span><span class="n">r</span> <span class="o">+</span> <span class="mf">34.2343</span><span class="n">jr</span><span class="p">,</span> <span class="mf">34e10</span><span class="n">r</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">M</span>
<span class="go">[10.234 + 34.2343*I     340000000000.0]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[10.23 + 34.23*I  340000000000.0]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">[ 10.0 + 34.0*I 340000000000.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.schur">
<span class="sig-name descname"><span class="pre">schur</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_ring</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.schur" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Schur decomposition of the matrix.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">base_ring</span></code> - optional, defaults to the base ring of <code class="docutils literal notranslate"><span class="pre">self</span></code>.
Use this to request the base ring of the returned matrices, which
will affect the format of the results.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A pair of immutable matrices.  The first is a unitary matrix <span class="math notranslate nohighlight">\(Q\)</span>.
The second, <span class="math notranslate nohighlight">\(T\)</span>, is upper-triangular when returned over the complex
numbers, while it is almost upper-triangular over the reals.  In the
latter case, there can be some <span class="math notranslate nohighlight">\(2\times 2\)</span> blocks on the diagonal
which represent a pair of conjugate complex eigenvalues of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">self</span></code> is the matrix <span class="math notranslate nohighlight">\(A\)</span>, then</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[A = QT({\overline Q})^t\]</div>
</div>
<p>where the latter matrix is the conjugate-transpose of <code class="docutils literal notranslate"><span class="pre">Q</span></code>, which
is also the inverse of <code class="docutils literal notranslate"><span class="pre">Q</span></code>, since <code class="docutils literal notranslate"><span class="pre">Q</span></code> is unitary.</p>
<p>Note that in the case of a normal matrix (Hermitian, symmetric, and
others), the upper-triangular matrix is  a diagonal matrix with
eigenvalues of <code class="docutils literal notranslate"><span class="pre">self</span></code> on the diagonal, and the unitary matrix
has columns that form an orthonormal basis composed of eigenvectors
of <code class="docutils literal notranslate"><span class="pre">self</span></code>.  This is known as “orthonormal diagonalization”.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The Schur decomposition is not unique, as there may be numerous
choices for the vectors of the orthonormal basis, and consequently
different possibilities for the upper-triangular matrix.  However,
the diagonal of the upper-triangular matrix will always contain the
eigenvalues of the matrix (in the complex version), or <span class="math notranslate nohighlight">\(2\times 2\)</span>
block matrices in the real version representing pairs of conjugate
complex eigenvalues.</p>
<p>In particular, results may vary across systems and processors.</p>
</div>
<p>EXAMPLES:</p>
<p>First over the complexes.  The similar matrix is always
upper-triangular in this case.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span> <span class="o">+</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1e-12</span><span class="p">)</span>  <span class="c1"># tol 1e-12</span>
<span class="go">[ 0.999999999999999                0.0                0.0                0.0]</span>
<span class="go">[               0.0 0.9999999999999996                0.0                0.0]</span>
<span class="go">[               0.0                0.0 0.9999999999999992                0.0]</span>
<span class="go">[               0.0                0.0                0.0 0.9999999999999999]</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-12</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">-</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-11</span><span class="p">)</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="gp">sage: </span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)];</span> <span class="n">eigenvalues</span>
<span class="go">[30.733... + 4648.541...*I, -0.184... - 159.057...*I, -0.523... + 11.158...*I, -0.025... - 0.642...*I]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()</span>
<span class="go">[30.733... + 4648.541...*I, -0.184... - 159.057...*I, -0.523... + 11.158...*I, -0.025... - 0.642...*I]</span>
<span class="gp">sage: </span><span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span><span class="o">-</span><span class="n">T</span><span class="o">.</span><span class="n">norm</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We begin with a real matrix but ask for a decomposition over the
complexes.  The result will yield an upper-triangular matrix over
the complex numbers for <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">schur</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">CDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1e-12</span><span class="p">)</span>  <span class="c1"># tol 1e-12</span>
<span class="go">[0.9999999999999987                0.0                0.0                0.0]</span>
<span class="go">[               0.0 0.9999999999999999                0.0                0.0]</span>
<span class="go">[               0.0                0.0 1.0000000000000013                0.0]</span>
<span class="go">[               0.0                0.0                0.0 1.0000000000000007]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 4 by 4 dense matrices over Complex Double Field</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-12</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">-</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-11</span><span class="p">)</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
</pre></div>
</div>
<p>Now totally over the reals.  But with complex eigenvalues, the
similar matrix may not be upper-triangular. But “at worst” there
may be some <span class="math notranslate nohighlight">\(2\times 2\)</span> blocks on the diagonal which represent
a pair of conjugate complex eigenvalues. These blocks will then
just interrupt the zeros below the main diagonal.  This example
has a pair of these of the blocks.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">....: </span>                       <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">....: </span>                       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span>
<span class="gp">....: </span>                       <span class="p">[</span><span class="mi">26</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>  <span class="c1"># tol 1e-12</span>
<span class="go">[0.9999999999999994                0.0                0.0                0.0]</span>
<span class="go">[               0.0 1.0000000000000013                0.0                0.0]</span>
<span class="go">[               0.0                0.0 1.0000000000000004                0.0]</span>
<span class="go">[               0.0                0.0                0.0 1.0000000000000016]</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-12</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-12</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">-</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-11</span><span class="p">)</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()</span> <span class="o">+</span> <span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">())</span>
<span class="go">[-5.710... - 8.382...*I, -5.710... + 8.382...*I, -0.789... - 2.336...*I, -0.789... + 2.336...*I]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">())</span>
<span class="go">[-5.710... - 8.382...*I, -5.710... + 8.382...*I, -0.789... - 2.336...*I, -0.789... + 2.336...*I]</span>
<span class="gp">sage: </span><span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span><span class="o">-</span><span class="n">T</span><span class="o">.</span><span class="n">norm</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mf">1e-12</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Starting with complex numbers and requesting a result over the reals
will never happen.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="o">+</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mi">2</span><span class="o">-</span><span class="mi">7</span><span class="o">*</span><span class="n">I</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">schur</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">RDF</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: unable to convert input matrix over CDF to a matrix over RDF</span>
</pre></div>
</div>
<p>If theory predicts your matrix is real, but it contains some
very small imaginary parts, you can specify the cutoff for “small”
imaginary parts, then request the output as real matrices, and let
the routine do the rest.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0e-14</span><span class="o">*</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 2 by 2 dense matrices over Complex Double Field</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">schur</span><span class="p">(</span><span class="n">RDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 2 by 2 dense matrices over Real Double Field</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 2 by 2 dense matrices over Real Double Field</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[ 0.707107  0.707107]</span>
<span class="go">[-0.707107  0.707107]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[ 0.5  1.5]</span>
<span class="go">[-0.5  0.5]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">-</span><span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-11</span><span class="p">)</span>
<span class="go">[0.0 0.0]</span>
<span class="go">[0.0 0.0]</span>
</pre></div>
</div>
<p>A Hermitian matrix has real eigenvalues, so the similar matrix
will be upper-triangular.  Furthermore, a Hermitian matrix is
diagonalizable with respect to an orthonormal basis, composed
of eigenvectors of the matrix.  Here that basis is the set of
columns of the unitary matrix.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span>        <span class="mi">52</span><span class="p">,</span>   <span class="o">-</span><span class="mi">9</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">8</span><span class="p">,</span>    <span class="mi">6</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">187</span><span class="p">,</span>  <span class="o">-</span><span class="mi">188</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span>   <span class="mi">9</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">8</span><span class="p">,</span>         <span class="mi">12</span><span class="p">,</span>   <span class="o">-</span><span class="mi">58</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">59</span><span class="p">,</span>   <span class="mi">30</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">42</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">187</span><span class="p">,</span>  <span class="mi">58</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">59</span><span class="p">,</span>         <span class="mi">2677</span><span class="p">,</span> <span class="mi">2264</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">65</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span> <span class="mi">188</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">30</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">42</span><span class="p">,</span> <span class="o">-</span><span class="mi">2264</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">65</span><span class="p">,</span>       <span class="mi">2080</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-12</span><span class="p">)</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">RDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[4680.13301        0.0        0.0        0.0]</span>
<span class="go">[       0.0 102.715967        0.0        0.0]</span>
<span class="go">[       0.0        0.0  35.039344        0.0]</span>
<span class="go">[       0.0        0.0        0.0    3.11168]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1e-12</span><span class="p">)</span>  <span class="c1"># tol 1e-12</span>
<span class="go">[1.0000000000000004                0.0                0.0                0.0]</span>
<span class="go">[               0.0 0.9999999999999989                0.0                0.0]</span>
<span class="go">[               0.0                0.0 1.0000000000000002                0.0]</span>
<span class="go">[               0.0                0.0                0.0 0.9999999999999992]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">-</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-11</span><span class="p">)</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
</pre></div>
</div>
<p>Similarly, a real symmetric matrix has only real eigenvalues,
and there is an orthonormal basis composed of eigenvectors of
the matrix.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">5</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span> <span class="mi">5</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">[-0.3027  -0.751   0.576 -0.1121]</span>
<span class="go">[  0.139 -0.3892 -0.2648  0.8713]</span>
<span class="go">[ 0.4361   0.359  0.7599  0.3217]</span>
<span class="go">[ -0.836  0.3945  0.1438  0.3533]</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">10</span><span class="o">^-</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">^-</span><span class="mi">4</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="p">(</span><span class="n">T</span> <span class="o">-</span> <span class="n">diagonal_matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">13.5698</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8508</span><span class="p">,</span> <span class="mf">7.7664</span><span class="p">,</span> <span class="mf">11.6542</span><span class="p">]))</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>  <span class="c1"># tol 1e-12</span>
<span class="go">[0.9999999999999998                0.0                0.0                0.0]</span>
<span class="go">[               0.0                1.0                0.0                0.0]</span>
<span class="go">[               0.0                0.0 0.9999999999999998                0.0]</span>
<span class="go">[               0.0                0.0                0.0 0.9999999999999996]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">-</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-11</span><span class="p">)</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
</pre></div>
</div>
<p>The results are cached, both as a real factorization and also as a
complex factorization.  This means the returned matrices are
immutable.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Qr</span><span class="p">,</span> <span class="n">Tr</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">schur</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">RDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Qc</span><span class="p">,</span> <span class="n">Tc</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">schur</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">CDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">is_immutable</span><span class="p">()</span> <span class="k">for</span> <span class="n">M</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Qr</span><span class="p">,</span> <span class="n">Tr</span><span class="p">,</span> <span class="n">Qc</span><span class="p">,</span> <span class="n">Tc</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Tr</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Tc</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li><p>Rob Beezer (2011-03-31)</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.singular_values">
<span class="sig-name descname"><span class="pre">singular_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.singular_values" title="Permalink to this definition">#</a></dt>
<dd><p>Return a sorted list of the singular values of the matrix.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eps</span></code> - default: <code class="docutils literal notranslate"><span class="pre">None</span></code> - the largest number which
will be considered to be zero.  May also be set to the
string ‘auto’.  See the discussion below.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A sorted list of the singular values of the matrix, which are the
diagonal entries of the “S” matrix in the SVD decomposition.  As such,
the values are real and are returned as elements of <code class="docutils literal notranslate"><span class="pre">RDF</span></code>.  The
list is sorted with larger values first, and since theory predicts
these values are always positive, for a rank-deficient matrix the
list should end in zeros (but in practice may not).  The length of
the list is the minimum of the row count and column count for the
matrix.</p>
<p>The number of non-zero singular values will be the rank of the
matrix.  However, as a numerical matrix, it is impossible to
control the difference between zero entries and very small
non-zero entries.  As an informed consumer it is up to you
to use the output responsibly.  We will do our best, and give
you the tools to work with the output, but we cannot
give you a guarantee.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">eps</span></code> set to <code class="docutils literal notranslate"><span class="pre">None</span></code> you will get the raw singular
values and can manage them as you see fit.  You may also set
<code class="docutils literal notranslate"><span class="pre">eps</span></code> to any positive floating point value you wish.  If you
set <code class="docutils literal notranslate"><span class="pre">eps</span></code> to ‘auto’ this routine will compute a reasonable
cutoff value, based on the size of the matrix, the largest
singular value and the smallest nonzero value representable
by the 53-bit precision values used.  See the discussion
at page 268 of <a class="reference internal" href="../../../references/index.html#wat2010" id="id1"><span>[Wat2010]</span></a>.</p>
<p>See the examples for a way to use the “verbose” facility
to easily watch the zero cutoffs in action.</p>
<p>ALGORITHM:</p>
<p>The singular values come from the SVD decomposition
computed by SciPy/NumPy.</p>
<p>EXAMPLES:</p>
<p>Singular values close to zero have trailing digits that may vary
on different hardware.  For exact matrices, the number of non-zero
singular values will equal the rank of the matrix.  So for some of
the doctests we round the small singular values that ideally would
be zero, to control the variability across hardware.</p>
<p>This matrix has a determinant of one.  A chain of two or
three theorems implies the product of the singular values
must also be one.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>                <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
<span class="gp">....: </span>                <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>  <span class="mi">7</span><span class="p">],</span>
<span class="gp">....: </span>                <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">....: </span>                <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">],</span>
<span class="gp">....: </span>                <span class="p">[</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">8</span><span class="p">],</span>
<span class="gp">....: </span>                <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">determinant</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">RDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sv</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">singular_values</span><span class="p">();</span> <span class="n">sv</span>  <span class="c1"># tol 1e-12</span>
<span class="go">[20.523980658874265, 8.486837028536643, 5.86168134845073, 2.4429165899286978, 0.5831970144724045, 0.26933287286576313, 0.0025524488076110402]</span>
<span class="gp">sage: </span><span class="n">prod</span><span class="p">(</span><span class="n">sv</span><span class="p">)</span>  <span class="c1"># tol 1e-12</span>
<span class="go">0.9999999999999525</span>
</pre></div>
</div>
<p>An exact matrix that is obviously not of full rank, and then
a computation of the singular values after conversion
to an approximate matrix.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="o">/</span><span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>                <span class="p">[</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span>  <span class="mi">7</span><span class="o">/</span><span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>                <span class="p">[</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">27</span><span class="o">/</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">CDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sv</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">singular_values</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">sv</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[10.1973039..., 0.487045871...]</span>
<span class="gp">sage: </span><span class="n">sv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">1e-14</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A matrix of rank 3 over the complex numbers.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">46</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">28</span><span class="p">,</span> <span class="o">-</span><span class="mi">47</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">21</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">51</span><span class="p">,</span> <span class="o">-</span><span class="mi">62</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">782</span><span class="p">,</span> <span class="mi">13</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">22</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="mi">35</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">32</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">46</span><span class="p">,</span> <span class="mi">18</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">43</span><span class="p">,</span> <span class="o">-</span><span class="mi">57</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">670</span><span class="p">,</span> <span class="mi">7</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="mi">22</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">13</span><span class="p">,</span> <span class="o">-</span><span class="mi">23</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">9</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">24</span><span class="p">,</span> <span class="o">-</span><span class="mi">26</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">347</span><span class="p">,</span> <span class="mi">7</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">13</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="o">-</span><span class="mi">44</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">41</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">57</span><span class="p">,</span> <span class="o">-</span><span class="mi">19</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">60</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">757</span><span class="p">,</span> <span class="o">-</span><span class="mi">11</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">9</span><span class="p">],</span>
<span class="gp">....: </span>                 <span class="p">[</span><span class="mi">30</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">18</span><span class="p">,</span> <span class="o">-</span><span class="mi">30</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">14</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">34</span><span class="p">,</span> <span class="o">-</span><span class="mi">42</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">522</span><span class="p">,</span> <span class="mi">8</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">12</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">sv</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">singular_values</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">sv</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># tol 1e-14</span>
<span class="go">[1440.7336659952966, 18.404403413369227, 6.839707797136151]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">sv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">^-</span><span class="mi">13</span><span class="p">)</span> <span class="ow">or</span> <span class="n">sv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">sv</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">^-</span><span class="mi">14</span><span class="p">)</span> <span class="ow">or</span> <span class="n">sv</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A full-rank matrix that is ill-conditioned.  We use this to
illustrate ways of using the various possibilities for <code class="docutils literal notranslate"><span class="pre">eps</span></code>,
including one that is ill-advised. Notice that the automatically
computed cutoff gets this (difficult) example slightly wrong.
This illustrates the impossibility of any automated process always
getting this right.  Use with caution and judgement.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">entries</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="n">entries</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">12</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">RDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">1.59e16</span> <span class="ow">or</span> <span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">singular_values</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># abs tol 7e-16</span>
<span class="go">[1.7953720595619975, 0.38027524595503703, 0.04473854875218107, 0.0037223122378911614, 0.0002330890890217751, 1.116335748323284e-05, 4.082376110397296e-07, 1.1228610675717613e-08, 2.2519645713496478e-10, 3.1113486853814003e-12, 2.6500422260778388e-14, 9.87312834948426e-17]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">singular_values</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>  <span class="c1"># abs tol 7e-16</span>
<span class="go">[1.7953720595619975, 0.38027524595503703, 0.04473854875218107, 0.0037223122378911614, 0.0002330890890217751, 1.116335748323284e-05, 4.082376110397296e-07, 1.1228610675717613e-08, 2.2519645713496478e-10, 3.1113486853814003e-12, 2.6500422260778388e-14, 0.0]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">singular_values</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>  <span class="c1"># abs tol 7e-16</span>
<span class="go">[1.7953720595619975, 0.38027524595503703, 0.04473854875218107, 0.0037223122378911614, 0.0002330890890217751, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]</span>
</pre></div>
</div>
<p>With Sage’s “verbose” facility, you can compactly see the cutoff
at work.  In any application of this routine, or those that build upon
it, it would be a good idea to conduct this exercise on samples.
We also test here that all the  values are returned in <span class="math notranslate nohighlight">\(RDF\)</span> since
singular values are always real.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.misc.verbose</span> <span class="kn">import</span> <span class="n">set_verbose</span>
<span class="gp">sage: </span><span class="n">set_verbose</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sv</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">singular_values</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">);</span> <span class="n">sv</span>
<span class="go">verbose 1 (&lt;module&gt;) singular values,</span>
<span class="go">smallest-non-zero:cutoff:largest-zero,</span>
<span class="go">2.2766...:6.2421...e-14:...</span>
<span class="go">[35.13996365902..., 2.27661020871472..., 0.0, 0.0]</span>
<span class="gp">sage: </span><span class="n">set_verbose</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">s</span> <span class="ow">in</span> <span class="n">RDF</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sv</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li><p>Rob Beezer - (2011-02-18)</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.matrix.matrix_double_dense.Matrix_double_dense.zero_at">
<span class="sig-name descname"><span class="pre">zero_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.zero_at" title="Permalink to this definition">#</a></dt>
<dd><p>Return a copy of the matrix where elements smaller than or
equal to <code class="docutils literal notranslate"><span class="pre">eps</span></code> are replaced with zeroes. For complex matrices,
the real and imaginary parts are considered individually.</p>
<p>This is useful for modifying output from algorithms which have large
relative errors when producing zero elements, e.g. to create reliable
doctests.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eps</span></code> - Cutoff value</p></li>
</ul>
<p>OUTPUT:</p>
<p>A modified copy of the matrix.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1e-4</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mf">1e-100j</span><span class="n">r</span><span class="p">],</span> <span class="p">[</span><span class="mf">1e-8</span><span class="o">+</span><span class="mi">3</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1e-58</span><span class="n">r</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">a</span>
<span class="go">[           1.0         0.0001 1.0 + 1e-100*I]</span>
<span class="go">[ 1e-08 + 3.0*I            0.0          1e-58]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1e-50</span><span class="p">)</span>
<span class="go">[          1.0        0.0001           1.0]</span>
<span class="go">[1e-08 + 3.0*I           0.0           0.0]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1e-4</span><span class="p">)</span>
<span class="go">[  1.0   0.0   1.0]</span>
<span class="go">[3.0*I   0.0   0.0]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="matrix_real_double_dense.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Dense matrices over the Real Double Field using NumPy</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="matrix_rational_sparse.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Sparse rational matrices</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2005--2023, The Sage Development Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Dense matrices using a NumPy backend</a><ul>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense"><code class="docutils literal notranslate"><span class="pre">Matrix_double_dense</span></code></a><ul>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.LU"><code class="docutils literal notranslate"><span class="pre">LU()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.LU_valid"><code class="docutils literal notranslate"><span class="pre">LU_valid()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.QR"><code class="docutils literal notranslate"><span class="pre">QR()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.SVD"><code class="docutils literal notranslate"><span class="pre">SVD()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.cholesky"><code class="docutils literal notranslate"><span class="pre">cholesky()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.condition"><code class="docutils literal notranslate"><span class="pre">condition()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.conjugate"><code class="docutils literal notranslate"><span class="pre">conjugate()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.determinant"><code class="docutils literal notranslate"><span class="pre">determinant()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvalues"><code class="docutils literal notranslate"><span class="pre">eigenvalues()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_left"><code class="docutils literal notranslate"><span class="pre">eigenvectors_left()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_right"><code class="docutils literal notranslate"><span class="pre">eigenvectors_right()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.exp"><code class="docutils literal notranslate"><span class="pre">exp()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_hermitian"><code class="docutils literal notranslate"><span class="pre">is_hermitian()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_normal"><code class="docutils literal notranslate"><span class="pre">is_normal()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_positive_definite"><code class="docutils literal notranslate"><span class="pre">is_positive_definite()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_skew_hermitian"><code class="docutils literal notranslate"><span class="pre">is_skew_hermitian()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_unitary"><code class="docutils literal notranslate"><span class="pre">is_unitary()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.left_eigenvectors"><code class="docutils literal notranslate"><span class="pre">left_eigenvectors()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.log_determinant"><code class="docutils literal notranslate"><span class="pre">log_determinant()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.norm"><code class="docutils literal notranslate"><span class="pre">norm()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.right_eigenvectors"><code class="docutils literal notranslate"><span class="pre">right_eigenvectors()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.round"><code class="docutils literal notranslate"><span class="pre">round()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.schur"><code class="docutils literal notranslate"><span class="pre">schur()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.singular_values"><code class="docutils literal notranslate"><span class="pre">singular_values()</span></code></a></li>
<li><a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.zero_at"><code class="docutils literal notranslate"><span class="pre">zero_at()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    <script src="../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"ZZ": "\\Bold{Z}", "NN": "\\Bold{N}", "RR": "\\Bold{R}", "CC": "\\Bold{C}", "QQ": "\\Bold{Q}", "QQbar": "\\overline{\\QQ}", "GF": ["\\Bold{F}_{#1}", 1], "Zp": ["\\Bold{Z}_{#1}", 1], "Qp": ["\\Bold{Q}_{#1}", 1], "Zmod": ["\\ZZ/#1\\ZZ", 1], "CDF": "\\Bold{C}", "CIF": "\\Bold{C}", "CLF": "\\Bold{C}", "RDF": "\\Bold{R}", "RIF": "\\Bold{I} \\Bold{R}", "RLF": "\\Bold{R}", "SL": "\\mathrm{SL}", "PSL": "\\mathrm{PSL}", "Bold": ["\\mathbf{#1}", 1]}, "inlineMath": [["$", "$"], ["\\(", "\\)"]], "maxBuffer": 51200, "autoload": {"color": [], "colorv2": ["color"]}}}</script>
    <script defer="defer" src="../../../_static/mathjax/tex-chtml.js"></script>
    </body>
</html>