
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Riemann matrices and endomorphism rings of algebraic Riemann surfaces &#8212; Sage 9.5 Reference Manual: Curves</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sage.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script async="async" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="prev" title="Plane quartic curves over a general ring" href="../plane_quartics/quartic_generic.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../plane_quartics/quartic_generic.html" title="Plane quartic curves over a general ring"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Sage 9.5 Reference Manual: Curves</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Riemann matrices and endomorphism rings of algebraic Riemann surfaces</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="riemann-matrices-and-endomorphism-rings-of-algebraic-riemann-surfaces">
<span id="sage-schemes-riemann-surfaces-riemann-surface"></span><h1>Riemann matrices and endomorphism rings of algebraic Riemann surfaces<a class="headerlink" href="#riemann-matrices-and-endomorphism-rings-of-algebraic-riemann-surfaces" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.schemes.riemann_surfaces.riemann_surface"></span><p>This module provides a class, <a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface"><code class="xref py py-class docutils literal notranslate"><span class="pre">RiemannSurface</span></code></a>, to model the
Riemann surface determined by a plane algebraic curve over a subfield
of the complex numbers.</p>
<p>A homology basis is derived from the edges of a Voronoi cell decomposition based
on the branch locus. The pull-back of these edges to the Riemann surface
provides a graph on it that contains a homology basis.</p>
<p>The class provides methods for computing the Riemann period matrix of the
surface numerically, using a certified homotopy continuation method due to
<a class="reference internal" href="../../../../references/index.html#kr2016" id="id1"><span>[Kr2016]</span></a>.</p>
<p>The class also provides facilities for computing the endomorphism ring of the
period lattice numerically, by determining integer (near) solutions to the
relevant approximate linear equations.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li><p>Alexandre Zotine, Nils Bruin (2017-06-10): initial version</p></li>
<li><p>Nils Bruin, Jeroen Sijsling (2018-01-05): algebraization, isomorphisms</p></li>
<li><p>Linden Disney-Hogg, Nils Bruin (2021-06-23): efficient integration</p></li>
</ul>
<p>EXAMPLES:</p>
<p>We compute the Riemann matrix of a genus 3 curve:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">4</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">-</span><span class="n">y</span><span class="o">^</span><span class="mi">3</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">prec</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>
</pre></div>
</div>
<p>We test the usual properties, i.e., that the period matrix is symmetric and that
the imaginary part is positive definite:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-20</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="n">M</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">iM</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,[</span><span class="n">a</span><span class="o">.</span><span class="n">imag_part</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">list</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="n">iM</span><span class="o">.</span><span class="n">is_positive_definite</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We compute the endomorphism ring and check it has <span class="math notranslate nohighlight">\(\ZZ\)</span>-rank 6:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">endomorphism_basis</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In fact it is an order in a number field:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span><span class="o">.&lt;</span><span class="n">t</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">t</span><span class="o">^</span><span class="mi">6</span> <span class="o">-</span> <span class="n">t</span><span class="o">^</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">t</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="n">t</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">minpoly</span><span class="p">()</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">K</span><span class="p">))</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">minpoly</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<p>The initial version of this code was developed alongside <a class="reference internal" href="../../../../references/index.html#bsz2019" id="id2"><span>[BSZ2019]</span></a>.</p>
<dl class="py exception">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.ConvergenceError">
<em class="property"><span class="pre">exception</span> </em><span class="sig-prename descclassname"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.</span></span><span class="sig-name descname"><span class="pre">ConvergenceError</span></span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.ConvergenceError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/library/exceptions.html#ValueError" title="(in Python v3.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></a></p>
<p>Error object suitable for raising and catching when Newton iteration fails.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">ConvergenceError</span>
<span class="gp">sage: </span><span class="k">raise</span> <span class="n">ConvergenceError</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ConvergenceError: test</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ConvergenceError</span><span class="p">(),</span><span class="ne">ValueError</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.</span></span><span class="sig-name descname"><span class="pre">RiemannSurface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">53</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certification</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">differentials</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integration_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'heuristic'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Construct a Riemann Surface. This is specified by the zeroes of a bivariate
polynomial with rational coefficients <span class="math notranslate nohighlight">\(f(z,w) = 0\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code> – a bivariate polynomial with rational coefficients. The surface is
interpreted as the covering space of the coordinate plane in the first
variable.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prec</span></code> – the desired precision of computations on the surface in bits
(default: 53)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">certification</span></code> – a boolean (default: True) value indicating whether
homotopy continuation is certified or not. Uncertified homotopy
continuation can be faster.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">differentials</span></code> – (default: None). If specified, provides a list of
polynomials <span class="math notranslate nohighlight">\(h\)</span> such that <span class="math notranslate nohighlight">\(h/(df/dw) dz\)</span> is a regular differential on the
Riemann surface. This is taken as a basis of the regular differentials, so
the genus is assumed to be equal to the length of this list. The results
from the homology basis computation are checked against this value.
Providing this parameter makes the computation independent from Singular.
For a nonsingular plane curve of degree <span class="math notranslate nohighlight">\(d\)</span>, an appropriate set is given
by the monomials of degree up to <span class="math notranslate nohighlight">\(d-3\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integration_method</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'heuristic'</span></code>). String specifying the 
integration method to use when calculating the integrals of differentials. 
The options are <code class="docutils literal notranslate"><span class="pre">'heuristic'</span></code> and <code class="docutils literal notranslate"><span class="pre">'rigorous'</span></code>, the latter of
which is often the most efficient.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">Riemann surface defined by polynomial f = -z^3 + w^2 + 1 = 0, with 53 bits of precision</span>
</pre></div>
</div>
<p>Another Riemann surface with 100 bits of precision:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">100</span><span class="p">);</span> <span class="n">S</span>
<span class="go">Riemann surface defined by polynomial f = -z^3 + w^2 + 1 = 0, with 100 bits of precision</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span><span class="o">^</span><span class="mi">6</span> <span class="c1">#abs tol 0.00000001</span>
<span class="go">[1.0000000000000000000000000000 - 1.1832913578315177081175928479e-30*I]</span>
</pre></div>
</div>
<p>We can also work with Riemann surfaces that are defined over fields with a
complex embedding, but since the current interface for computing genus and
regular differentials in Singular presently does not support extensions of
QQ, we need to specify a description of the differentials ourselves. We give
an example of a CM elliptic curve:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Qt</span><span class="o">.&lt;</span><span class="n">t</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">t</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">t</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span><span class="n">embedding</span><span class="o">=</span><span class="n">CC</span><span class="p">(</span><span class="mf">0.5</span><span class="o">+</span><span class="mf">1.6</span><span class="o">*</span><span class="n">I</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">K</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="n">y</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">prec</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">differentials</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">endomorphism_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">minpoly</span><span class="p">()</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">K</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">A</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">'heuristic'</span></code> integration method uses the method <code class="docutils literal notranslate"><span class="pre">integrate_vector</span></code> 
defined in <code class="docutils literal notranslate"><span class="pre">sage.numerical.gauss_legendre</span></code> to compute integrals of differentials. 
As mentioned there, this works by iteratively doubling the number of nodes 
used in the quadrature, and uses a heuristic based on the rate at which the
result is seemingly converging to estimate the error. The <code class="docutils literal notranslate"><span class="pre">'rigorous'</span></code>
method uses results from <a class="reference internal" href="../../../../references/index.html#neu2018" id="id3"><span>[Neu2018]</span></a>, and bounds the algebraic integrands on 
circular domains using Cauchy’s form of the remainder in Taylor approximation
coupled to Fujiwara’s bound on polynomial roots (see Bruin-DisneyHogg-Gao,
in preparation). Note this method of bounding on circular domains is also 
implemented in <code class="xref py py-meth docutils literal notranslate"><span class="pre">_compute_delta()</span></code>. The net result of this bounding is 
that one can know (an upper bound on) the number of nodes required to achieve
a certain error. This means that for any given integral, assuming that the 
same number of nodes is required by both methods in order to achieve the 
desired error (not necessarily true in practice), approximately half
the number of integrand evaluations are required. When the required number
of nodes is high, e.g. when the precision required is high, this can make
the <code class="docutils literal notranslate"><span class="pre">'rigorous'</span></code> method much faster. However, the <code class="docutils literal notranslate"><span class="pre">'rigorous'</span></code> method does
not benefit as much from the caching of the <code class="docutils literal notranslate"><span class="pre">nodes</span></code> method over multiple
integrals. The result of this is that, for calls of <a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.matrix_of_integral_values" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.matrix_of_integral_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">matrix_of_integral_values()</span></code></a>
if the computation is ‘fast’, the heuristic method may outperform the
rigorous method, but for slower computations the rigorous method can be much
faster:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">z</span><span class="o">*</span><span class="n">w</span><span class="o">^</span><span class="mi">3</span><span class="o">+</span><span class="n">z</span><span class="o">^</span><span class="mi">3</span><span class="o">+</span><span class="n">w</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="mi">53</span>
<span class="gp">sage: </span><span class="n">Sh</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">integration_method</span><span class="o">=</span><span class="s1">&#39;heuristic&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Sr</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">integration_method</span><span class="o">=</span><span class="s1">&#39;rigorous&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.numerical.gauss_legendre</span> <span class="kn">import</span> <span class="n">nodes</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">time</span>
<span class="gp">sage: </span><span class="n">nodes</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ct</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Rh</span> <span class="o">=</span> <span class="n">Sh</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>  
<span class="gp">sage: </span><span class="n">ct1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">ct</span>
<span class="gp">sage: </span><span class="n">nodes</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ct</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Rr</span> <span class="o">=</span> <span class="n">Sr</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>  
<span class="gp">sage: </span><span class="n">ct2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">ct</span>
<span class="gp">sage: </span><span class="n">ct2</span><span class="o">/</span><span class="n">ct1</span>  <span class="c1"># random</span>
<span class="go">1.2429363969691192</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="mi">500</span>
<span class="gp">sage: </span><span class="n">Sh</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">integration_method</span><span class="o">=</span><span class="s1">&#39;heuristic&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Sr</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">integration_method</span><span class="o">=</span><span class="s1">&#39;rigorous&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">nodes</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ct</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Rh</span> <span class="o">=</span> <span class="n">Sh</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>  <span class="c1"># long time (6 seconds)</span>
<span class="gp">sage: </span><span class="n">ct1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">ct</span>
<span class="gp">sage: </span><span class="n">nodes</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ct</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Rr</span> <span class="o">=</span> <span class="n">Sr</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>  <span class="c1"># long time (4 seconds)</span>
<span class="gp">sage: </span><span class="n">ct2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">ct</span>
<span class="gp">sage: </span><span class="n">ct2</span><span class="o">/</span><span class="n">ct1</span>  <span class="c1"># random</span>
<span class="go">0.6627716056083879</span>
</pre></div>
</div>
<p>This disparity in timings can get increasingly worse, and testing has shown
that even for random quadrics the heuristic method can be as bad as 30 times
slower.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.cohomology_basis">
<span class="sig-name descname"><span class="pre">cohomology_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">option</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.cohomology_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the cohomology basis of this surface.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">option</span></code> – Presently, this routine uses Singular’s <code class="docutils literal notranslate"><span class="pre">adjointIdeal</span></code>
and passes the <code class="docutils literal notranslate"><span class="pre">option</span></code> parameter on. Legal values are 1, 2, 3 ,4,
where 1 is the default. See the Singular documentation for the
meaning. The backend for this function may change, and support for
this parameter may disappear.</p></li>
</ul>
<p>OUTPUT:</p>
<p>This returns a list of polynomials <span class="math notranslate nohighlight">\(g\)</span> representing the holomorphic
differentials <span class="math notranslate nohighlight">\(g/(df/dw) dz\)</span>, where <span class="math notranslate nohighlight">\(f(z,w)=0\)</span> is the equation
specifying the Riemann surface.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="n">w</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">cohomology_basis</span><span class="p">()</span>
<span class="go">[1, w, z]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.downstairs_edges">
<span class="sig-name descname"><span class="pre">downstairs_edges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.downstairs_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the edgeset of the Voronoi diagram.</p>
<p>OUTPUT:</p>
<p>A list of integer tuples corresponding to edges between vertices in the
Voronoi diagram.</p>
<p>EXAMPLES:</p>
<p>Form a Riemann surface, one with a particularly simple branch locus:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute the edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">downstairs_edges</span><span class="p">()</span>
<span class="go">[(0, 1), (0, 5), (1, 4), (2, 3), (2, 4), (3, 5), (4, 5)]</span>
</pre></div>
</div>
<p>This now gives an edgeset which one could use to form a graph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The numbering of the vertices is given by the Voronoi package.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.downstairs_graph">
<span class="sig-name descname"><span class="pre">downstairs_graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.downstairs_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Voronoi decomposition as a planar graph.</p>
<p>The result of this routine can be useful to interpret the labelling of
the vertices.</p>
<p>OUTPUT:</p>
<p>The Voronoi decomposition as a graph, with appropriate planar embedding.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">downstairs_graph</span><span class="p">()</span>
<span class="go">Graph on 11 vertices</span>
</pre></div>
</div>
<p>Similarly one can form the graph of the upstairs edges, which is
visually rather less attractive but can be instructive to verify that a
homology basis is likely correctly computed.:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">upstairs_edges</span><span class="p">());</span> <span class="n">G</span>
<span class="go">Graph on 22 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_planar</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.edge_permutations">
<span class="sig-name descname"><span class="pre">edge_permutations</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.edge_permutations" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the permutations of branches associated to each edge.</p>
<p>Over the vertices of the Voronoi decomposition around the branch locus,
we label the fibres. By following along an edge, the lifts of the edge
induce a permutation of that labelling.</p>
<p>OUTPUT:</p>
<p>A dictionary with as keys the edges of the Voronoi decomposition and as
values the corresponding permutations.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">edge_permutations</span><span class="p">()</span>
<span class="go">{(0, 2): (),</span>
<span class="go"> (0, 4): (),</span>
<span class="go"> (1, 2): (),</span>
<span class="go"> (1, 3): (0,1),</span>
<span class="go"> (1, 6): (),</span>
<span class="go"> (2, 0): (),</span>
<span class="go"> (2, 1): (),</span>
<span class="go"> (2, 5): (0,1),</span>
<span class="go"> (3, 1): (0,1),</span>
<span class="go"> (3, 4): (),</span>
<span class="go"> (4, 0): (),</span>
<span class="go"> (4, 3): (),</span>
<span class="go"> (5, 2): (0,1),</span>
<span class="go"> (5, 7): (),</span>
<span class="go"> (6, 1): (),</span>
<span class="go"> (6, 7): (),</span>
<span class="go"> (7, 5): (),</span>
<span class="go"> (7, 6): ()}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis">
<span class="sig-name descname"><span class="pre">endomorphism_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerically compute a <span class="math notranslate nohighlight">\(\ZZ\)</span>-basis for the endomorphism ring.</p>
<p>Let <span class="math notranslate nohighlight">\(\left(I | M \right)\)</span> be the normalized period matrix (<span class="math notranslate nohighlight">\(M\)</span> is the
<span class="math notranslate nohighlight">\(g\times g\)</span> <a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.riemann_matrix" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.riemann_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">riemann_matrix()</span></code></a>). We consider the system of matrix
equations <span class="math notranslate nohighlight">\(MA + C = (MB + D)M\)</span> where <span class="math notranslate nohighlight">\(A, B, C, D\)</span> are <span class="math notranslate nohighlight">\(g\times g\)</span>
integer matrices.  We determine small integer (near) solutions using LLL
reductions.  These solutions are returned as <span class="math notranslate nohighlight">\(2g \times 2g\)</span> integer
matrices obtained by stacking <span class="math notranslate nohighlight">\(\left(D | B\right)\)</span> on top of <span class="math notranslate nohighlight">\(\left(C |
A\right)\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> – integer (default provided). The equation coefficients are
scaled by <span class="math notranslate nohighlight">\(2^b\)</span> before rounding to integers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">b/4</span></code>). Solutions that have all
coefficients smaller than <span class="math notranslate nohighlight">\(2^r\)</span> in absolute value are reported as
actual solutions.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of <span class="math notranslate nohighlight">\(2g \times 2g\)</span> integer matrices that, for large enough <code class="docutils literal notranslate"><span class="pre">r</span></code>
and <code class="docutils literal notranslate"><span class="pre">b-r</span></code>, generate the endomorphism ring.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">y</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">endomorphism_basis</span><span class="p">();</span> <span class="n">B</span> <span class="c1">#random</span>
<span class="go">[</span>
<span class="go">[1 0]  [ 0 -1]</span>
<span class="go">[0 1], [ 1  1]</span>
<span class="go">]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">minpoly</span><span class="p">()</span><span class="o">.</span><span class="n">disc</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">B</span><span class="p">])</span>
<span class="go">[-3, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homology_basis">
<span class="sig-name descname"><span class="pre">homology_basis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homology_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the homology basis of the Riemann surface.</p>
<p>OUTPUT:</p>
<p>A list of paths <span class="math notranslate nohighlight">\(L = [P_1, \dots, P_n]\)</span>. Each path <span class="math notranslate nohighlight">\(P_i\)</span> is of the form
<span class="math notranslate nohighlight">\((k, [p_1 ... p_m, p_1])\)</span>, where <span class="math notranslate nohighlight">\(k\)</span> is the number of times to traverse
the path (if negative, to traverse it backwards), and the <span class="math notranslate nohighlight">\(p_i\)</span> are
vertices of the upstairs graph.</p>
<p>EXAMPLES:</p>
<p>In this example, there are two paths that form the homology basis:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">homology_basis</span><span class="p">()</span>  <span class="c1"># random</span>
<span class="go">[[(1, [(3, 1), (5, 0), (9, 0), (10, 0), (2, 0), (4, 0),</span>
<span class="go">    (7, 1), (10, 1), (3, 1)])],</span>
<span class="go"> [(1, [(8, 0), (6, 0), (7, 0), (10, 0), (2, 0), (4, 0),</span>
<span class="go">    (7, 1), (10, 1), (9, 1), (8, 0)])]]</span>
</pre></div>
</div>
<p>In order to check that the answer returned above is reasonable, we
test some basic properties. We express the faces of the downstairs graph
as ZZ-linear combinations of the edges and check that the projection
of the homology basis upstairs projects down to independent linear
combinations of an even number of faces:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dg</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">downstairs_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">edges</span> <span class="o">=</span> <span class="n">dg</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">^</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edge_to_E</span> <span class="o">=</span> <span class="p">{</span> <span class="n">e</span><span class="p">[:</span><span class="mi">2</span><span class="p">]:</span> <span class="n">E</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">)}</span>
<span class="gp">sage: </span><span class="n">edge_to_E</span><span class="o">.</span><span class="n">update</span><span class="p">({</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span> <span class="o">-</span><span class="n">E</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">face_span</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">submodule</span><span class="p">([</span><span class="nb">sum</span><span class="p">(</span><span class="n">edge_to_E</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">dg</span><span class="o">.</span><span class="n">faces</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">path_to_E</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">k</span><span class="p">,</span><span class="n">P</span> <span class="o">=</span> <span class="n">path</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">k</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">edge_to_E</span><span class="p">[(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">hom_basis</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">path_to_E</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">loop</span><span class="p">)</span> <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">homology_basis</span><span class="p">()]</span>
<span class="gp">sage: </span><span class="n">face_span</span><span class="o">.</span><span class="n">submodule</span><span class="p">(</span><span class="n">hom_basis</span><span class="p">)</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">face_span</span><span class="o">.</span><span class="n">coordinate_vector</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">%</span><span class="k">2</span> for b in hom_basis]
<span class="go">[0, 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis">
<span class="sig-name descname"><span class="pre">homomorphism_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerically compute a <span class="math notranslate nohighlight">\(\ZZ\)</span>-basis for module of homomorphisms to a given
complex torus.</p>
<p>Given another complex torus (given as the analytic Jacobian of a Riemann
surface), numerically compute a basis for the homomorphism module. The
answer is returned as a list of 2g x 2g integer matrices T=(D, B; C, A)
such that if the columns of (I|M1) generate the lattice defining the
Jacobian of the Riemann surface and the columns of (I|M2) do this for
the codomain, then approximately we have (I|M2)T=(D+M2C)(I|M1), i.e., up
to a choice of basis for <span class="math notranslate nohighlight">\(\CC^g\)</span> as a complex vector space, we we
realize (I|M1) as a sublattice of (I|M2).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> – integer (default provided). The equation coefficients are
scaled by <span class="math notranslate nohighlight">\(2^b\)</span> before rounding to integers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">b/4</span></code>). Solutions that have all
coefficients smaller than <span class="math notranslate nohighlight">\(2^r\)</span> in absolute value are reported as
actual solutions.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of <span class="math notranslate nohighlight">\(2g \times 2g\)</span> integer matrices that, for large enough <code class="docutils literal notranslate"><span class="pre">r</span></code>
and <code class="docutils literal notranslate"><span class="pre">b-r</span></code>, generate the homomorphism module.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;11a1&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">riemann_surface</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;11a3&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">riemann_surface</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">det</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">S1</span><span class="o">.</span><span class="n">homomorphism_basis</span><span class="p">(</span><span class="n">S2</span><span class="p">)]</span>
<span class="go">[5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homotopy_continuation">
<span class="sig-name descname"><span class="pre">homotopy_continuation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homotopy_continuation" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform homotopy continuation along an edge of the Voronoi diagram using
Newton iteration.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">edge</span></code> – a tuple of integers indicating an edge of the Voronoi
diagram</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of complex numbers corresponding to the points which are reached
when traversing along the direction of the edge. The ordering of these
points indicates how they have been permuted due to the weaving of the
curve.</p>
<p>EXAMPLES:</p>
<p>We check that continued values along an edge correspond (up to the
appropriate permutation) to what is stored. Note that the permutation
was originally computed from this data:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="n">w</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edge1</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">edge_permutations</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">edge_permutations</span><span class="p">()[</span><span class="n">edge1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">continued_values</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">homotopy_continuation</span><span class="p">(</span><span class="n">edge1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">stored_values</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">w_values</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">edge1</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">continued_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">stored_values</span><span class="p">[</span><span class="n">sigma</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span> <span class="o">&lt;</span> <span class="mf">1e-8</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.make_zw_interpolator">
<span class="sig-name descname"><span class="pre">make_zw_interpolator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">upstairs_edge</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.make_zw_interpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an upstairs edge for which continuation data has been stored,
return a function that computes <span class="math notranslate nohighlight">\(z(t),w(t)\)</span> , where <span class="math notranslate nohighlight">\(t\)</span> in <span class="math notranslate nohighlight">\([0,1]\)</span> is a
parametrization of the edge.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">upstairs_edge</span></code> – a pair of integer tuples indicating an edge on
the upstairs graph of the surface</p></li>
</ul>
<p>OUTPUT:</p>
<p>A tuple (g, d), where g is the function that computes the interpolation
along the edge and d is the difference of the z-values of the end and
start point.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">_</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">homology_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">,</span><span class="n">d</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">make_zw_interpolator</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)]);</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mf">0.1</span><span class="p">))</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-13</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">abs</span><span class="p">((</span><span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">g</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-13</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.matrix_of_integral_values">
<span class="sig-name descname"><span class="pre">matrix_of_integral_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">differentials</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integration_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'heuristic'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.matrix_of_integral_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the path integrals of the given differentials along the homology
basis.</p>
<p>The returned answer has a row for each differential. If the Riemann
surface is given by the equation <span class="math notranslate nohighlight">\(f(z,w)=0\)</span>, then the differentials are
encoded by polynomials g, signifying the differential <span class="math notranslate nohighlight">\(g(z,w)/(df/dw)
dz\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">differentials</span></code> – a list of polynomials.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integration_method</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'heuristic'</span></code>). String specifying
the integration method to use. The options are <code class="docutils literal notranslate"><span class="pre">'heuristic'</span></code> and 
<code class="docutils literal notranslate"><span class="pre">'rigorous'</span></code>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A matrix, one row per differential, containing the values of the path
integrals along the homology basis of the Riemann surface.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">y</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">cohomology_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">matrix_of_integral_values</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">Full MatrixSpace of 1 by 2 dense matrices over Complex Field with 53 bits of precision</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">algdep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="c1"># curve is CM, so the period is quadratic</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.monodromy_group">
<span class="sig-name descname"><span class="pre">monodromy_group</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.monodromy_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute local monodromy generators of the Riemann surface.</p>
<p>For each branch point, the local monodromy is encoded by a permutation.
The permutations returned correspond to positively oriented loops around
each branch point, with a fixed base point. This means the generators
are properly conjugated to ensure that together they generate the global
monodromy. The list has an entry for every finite point stored in
<code class="docutils literal notranslate"><span class="pre">self.branch_locus</span></code>, plus an entry for the ramification above infinity.</p>
<p>OUTPUT:</p>
<p>A list of permutations, encoding the local monodromy at each branch
point.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span> <span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="n">w</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">monodromy_group</span><span class="p">();</span> <span class="n">G</span>
<span class="go">[(0,1,2), (0,1), (0,2), (1,2), (1,2), (1,2), (0,1), (0,2), (0,2)]</span>
</pre></div>
</div>
<p>The permutations give the local monodromy generators for the branch
points:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">branch_locus</span> <span class="o">+</span> <span class="p">[</span><span class="n">unsigned_infinity</span><span class="p">],</span> <span class="n">G</span><span class="p">))</span> <span class="c1">#abs tol 0.0000001</span>
<span class="go">[(0.000000000000000, (0,1,2)),</span>
<span class="go"> (-1.31362670141929, (0,1)),</span>
<span class="go"> (-0.819032851784253 - 1.02703471138023*I, (0,2)),</span>
<span class="go"> (-0.819032851784253 + 1.02703471138023*I, (1,2)),</span>
<span class="go"> (0.292309440469772 - 1.28069133740100*I, (1,2)),</span>
<span class="go"> (0.292309440469772 + 1.28069133740100*I, (1,2)),</span>
<span class="go"> (1.18353676202412 - 0.569961265016465*I, (0,1)),</span>
<span class="go"> (1.18353676202412 + 0.569961265016465*I, (0,2)),</span>
<span class="go"> (Infinity, (0,2))]</span>
</pre></div>
</div>
<p>We can check the ramification by looking at the cycle lengths and verify
it agrees with the Riemann-Hurwitz formula:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">genus</span><span class="o">-</span><span class="mi">2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">degree</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">G</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">cycle_type</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.period_matrix">
<span class="sig-name descname"><span class="pre">period_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.period_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the period matrix of the surface.</p>
<p>OUTPUT:</p>
<p>A matrix of complex values.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="n">w</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span>
</pre></div>
</div>
<p>The results are highly arbitrary, so it is hard to check if the result
produced is correct. The closely related <code class="docutils literal notranslate"><span class="pre">riemann_matrix</span></code> is somewhat
easier to test.:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="go">Full MatrixSpace of 3 by 6 dense matrices over Complex Field with 30 bits of precision</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>One can check that the two methods give similar answers:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">integration_method</span><span class="o">=</span><span class="s2">&quot;rigorous&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">integration_method</span><span class="o">=</span><span class="s2">&quot;heuristic&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RM_S</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">RM_T</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">RM_S</span><span class="o">-</span><span class="n">RM_T</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.plot_paths">
<span class="sig-name descname"><span class="pre">plot_paths</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.plot_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a graphical representation of the integration paths.</p>
<p>This returns a two dimensional plot containing the branch points (in red) and
the integration paths (obtained from the Voronoi cells of the branch
points). The integration paths are plotted by plotting the points that
have been computed for homotopy continuation, so the density gives an
indication of where numerically sensitive features occur.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">plot_paths</span><span class="p">()</span>
<span class="go">Graphics object consisting of 2 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.plot_paths3d">
<span class="sig-name descname"><span class="pre">plot_paths3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thickness</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.plot_paths3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the homology basis as a graph in 3-space.</p>
<p>The homology basis of the surface is constructed by taking the Voronoi
cells around the branch points and taking the inverse image of the edges
on the Riemann surface. If the surface is given by the equation
<span class="math notranslate nohighlight">\(f(z,w)\)</span>, the returned object gives the image of this graph in 3-space
with coordinates <span class="math notranslate nohighlight">\(\left(\operatorname{Re}(z), \operatorname{Im}(z),
\operatorname{Im}(w)\right)\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">plot_paths3d</span><span class="p">()</span>
<span class="go">Graphics3d Object</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.riemann_matrix">
<span class="sig-name descname"><span class="pre">riemann_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.riemann_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Riemann matrix.</p>
<p>OUTPUT:</p>
<p>A matrix of complex values.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="n">w</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>
</pre></div>
</div>
<p>The Klein quartic has a Riemann matrix with values is a quadratic
field:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">algdep</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">K</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.rigorous_line_integral">
<span class="sig-name descname"><span class="pre">rigorous_line_integral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">upstairs_edge</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">differentials</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounding_data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.rigorous_line_integral" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform vectorized integration along a straight path.</p>
<p>Using the error bounds for Gauss-Legendre integration found in <a class="reference internal" href="../../../../references/index.html#neu2018" id="id4"><span>[Neu2018]</span></a>
and a method for bounding an algebraic integrand on a circular domains 
using Cauchy’s form of the remainder in Taylor approximation coupled to 
Fujiwara’s bound on polynomial roots (see Bruin-DisneyHogg-Gao, in 
preparation), this method calculates (semi-)rigorously the integral of a 
list of differentials along an edge of the upstairs graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">upstairs_edge</span></code> – a pair of integer tuples corresponding to an edge
of the upstairs graph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">differentials</span></code> – a list of polynomials; a polynomial <span class="math notranslate nohighlight">\(g\)</span>
represents the differential <span class="math notranslate nohighlight">\(g(z,w)/(df/dw) dz\)</span> where <span class="math notranslate nohighlight">\(f(z,w)=0\)</span> is
the equation defining the Riemann surface.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bounding_data</span></code> – tuple containing the data required for bounding
the integrands. This should be in the form of the output from 
<code class="xref py py-meth docutils literal notranslate"><span class="pre">_bounding_data()</span></code>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A complex number, the value of the line integral.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">);</span> <span class="n">S</span>
<span class="go">Riemann surface defined by polynomial f = -z^4 + w^2 + 1 = 0, with 53 bits of precision</span>
</pre></div>
</div>
<p>Since we make use of data from homotopy continuation, we need to compute
the necessary data:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">_</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">homology_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">differentials</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">cohomology_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bounding_data</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">_bounding_data</span><span class="p">(</span><span class="n">differentials</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">rigorous_line_integral</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="n">differentials</span><span class="p">,</span> <span class="n">bounding_data</span><span class="p">)</span>  <span class="c1"># abs tol 1e-10</span>
<span class="go">(1.80277751848459e-16 - 0.352971844594760*I)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Uses data that <code class="docutils literal notranslate"><span class="pre">homology_basis</span></code> initializes.</p>
<p>Note also that the  data of the differentials is contained within
<code class="docutils literal notranslate"><span class="pre">bounding_data</span></code>. It is, however, still advantageous to have this 
be a separate argument, as it lets the user supply a fast-callable
version of the differentials, to significantly speed up execution 
of the integrand calls, and not have to re-calculate these 
fast-callables for every run of the function. This is also the benefit
of representing the  differentials as a polynomial over a known 
common denominator.</p>
</div>
<div class="admonition-todo admonition" id="id6">
<p class="admonition-title">Todo</p>
<p>Note that bounding_data contains the information of the integrands,
so one may want to check for consistency between <code class="docutils literal notranslate"><span class="pre">bounding_data</span></code>
and <code class="docutils literal notranslate"><span class="pre">differentials</span></code>. If so one would not want to do so at the 
expense of speed.</p>
<p>Moreover, the current implementation bounds along a line by 
splitting it up into segments, each of which can be covered entirely
by a single circle, and then placing inside that the ellipse 
required to bound as per <a class="reference internal" href="../../../../references/index.html#neu2018" id="id5"><span>[Neu2018]</span></a>. This is reliably more efficient
than the heuristic method, especially in poorly-conditioned cases 
where discriminant points are close together around the edges, but
in the case where the branch locus is well separated, it can require
slightly more nodes than necessary. One may want to include a method
here to transition in this regime to an algorithm that covers the 
entire line with one ellipse, then bounds along that ellipse with 
multiple circles.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.rosati_involution">
<span class="sig-name descname"><span class="pre">rosati_involution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.rosati_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Rosati involution of an endomorphism.</p>
<p>The endomorphism in question should be given by its homology
representation with respect to the symplectic basis of the Jacobian.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">R</span></code> – integral matrix.</p></li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the Rosati involution to <code class="docutils literal notranslate"><span class="pre">R</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span> <span class="n">prec</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Rs</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">endomorphism_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">rosati_involution</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">rosati_involution</span><span class="p">(</span><span class="n">Rs</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">==</span> <span class="n">Rs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.simple_vector_line_integral">
<span class="sig-name descname"><span class="pre">simple_vector_line_integral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">upstairs_edge</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">differentials</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.simple_vector_line_integral" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform vectorized integration along a straight path.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">upstairs_edge</span></code> – a pair of integer tuples corresponding to an edge
of the upstairs graph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">differentials</span></code> – a list of polynomials; a polynomial <span class="math notranslate nohighlight">\(g\)</span>
represents the differential <span class="math notranslate nohighlight">\(g(z,w)/(df/dw) dz\)</span> where <span class="math notranslate nohighlight">\(f(z,w)=0\)</span> is
the equation defining the Riemann surface.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A complex number, the value of the line integral.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">);</span> <span class="n">S</span>
<span class="go">Riemann surface defined by polynomial f = -z^4 + w^2 + 1 = 0, with 53 bits of precision</span>
</pre></div>
</div>
<p>Since we make use of data from homotopy continuation, we need to compute
the necessary data:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">differentials</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">cohomology_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">simple_vector_line_integral</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="n">differentials</span><span class="p">)</span>  <span class="c1"># abs tol 0.00000001</span>
<span class="go">(1.14590610929717e-16 - 0.352971844594760*I)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Uses data that <code class="docutils literal notranslate"><span class="pre">homology_basis</span></code> initializes.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.symplectic_automorphism_group">
<span class="sig-name descname"><span class="pre">symplectic_automorphism_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">endo_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.symplectic_automorphism_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerically compute the symplectic automorphism group as a permutation
group.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">endo_basis</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) – a <span class="math notranslate nohighlight">\(\ZZ\)</span>-basis of the
endomorphisms of <code class="docutils literal notranslate"><span class="pre">self</span></code>, as obtained from
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">endomorphism_basis()</span></code></a>. If you have already calculated this
basis, it saves time to pass it via this keyword argument. Otherwise
the method will calculate it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> – integer (default provided): as for
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a>, and used in its invocation if
(re)calculating said basis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">b/4</span></code>).  as for
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a>, and used in its invocation if
(re)calculating said basis.</p></li>
</ul>
<p>OUTPUT:</p>
<p>The symplectic automorphism group of the Jacobian of the Riemann
surface. The automorphism group of the Riemann surface itself can be
recovered from this; if the curve is hyperelliptic, then it is
identical, and if not, then one divides out by the central element
corresponding to multiplication by -1.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span> <span class="n">prec</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">symplectic_automorphism_group</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">as_permutation_group</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">DihedralGroup</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.symplectic_isomorphisms">
<span class="sig-name descname"><span class="pre">symplectic_isomorphisms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hom_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.symplectic_isomorphisms" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerically compute symplectic isomorphisms.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> (default: <code class="docutils literal notranslate"><span class="pre">self</span></code>) – the codomain, another Riemann
surface.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hom_basis</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) – a <span class="math notranslate nohighlight">\(\ZZ\)</span>-basis of the
homomorphisms from <code class="docutils literal notranslate"><span class="pre">self</span></code> to <code class="docutils literal notranslate"><span class="pre">other</span></code>, as obtained from
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a>. If you have already calculated this
basis, it saves time to pass it via this keyword argument. Otherwise
the method will calculate it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> – integer (default provided): as for
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a>, and used in its invocation if
(re)calculating said basis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">b/4</span></code>).  as for
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a>, and used in its invocation if
(re)calculating said basis.</p></li>
</ul>
<p>OUTPUT:</p>
<p>This returns the combinations of the elements of
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a> that correspond to symplectic
isomorphisms between the Jacobians of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Rs</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">symplectic_isomorphisms</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Ts</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tangent_representation_numerical</span><span class="p">(</span><span class="n">Rs</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">test1</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(((</span><span class="n">T</span><span class="o">*</span><span class="n">P</span> <span class="o">-</span> <span class="n">Q</span><span class="o">*</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">80</span><span class="p">))</span> <span class="k">for</span> <span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">R</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Ts</span><span class="p">,</span> <span class="n">Rs</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">test2</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">det</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">Rs</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">test1</span> <span class="ow">and</span> <span class="n">test2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.tangent_representation_algebraic">
<span class="sig-name descname"><span class="pre">tangent_representation_algebraic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Rs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epscomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.tangent_representation_algebraic" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the algebraic tangent representations corresponding to the
homology representations in <code class="docutils literal notranslate"><span class="pre">Rs</span></code>.</p>
<p>The representations on homology <code class="docutils literal notranslate"><span class="pre">Rs</span></code> have to be given with respect to
the symplectic homology basis of the Jacobian of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.
Such matrices can for example be obtained via
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">endomorphism_basis()</span></code></a>.</p>
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be the period matrices of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>. Then
for a homology representation <span class="math notranslate nohighlight">\(R\)</span>, the corresponding tangential
representation <span class="math notranslate nohighlight">\(T\)</span> satisfies <span class="math notranslate nohighlight">\(T P = Q R\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Rs</span></code> – a set of matrices on homology to be converted to their
tangent representations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> (default: <code class="docutils literal notranslate"><span class="pre">self</span></code>) – the codomain, another Riemann
surface.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">epscomp</span></code> – real number (default: <code class="docutils literal notranslate"><span class="pre">2^(-prec</span> <span class="pre">+</span> <span class="pre">30)</span></code>). Used to
determine whether a complex number is close enough to a root of a
polynomial.</p></li>
</ul>
<p>OUTPUT:</p>
<p>The algebraic tangent representations of the matrices in <code class="docutils literal notranslate"><span class="pre">Rs</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span> <span class="n">prec</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Rs</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">endomorphism_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Ts</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">tangent_representation_algebraic</span><span class="p">(</span><span class="n">Rs</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">maximal_order</span><span class="p">()</span><span class="o">.</span><span class="n">discriminant</span><span class="p">()</span> <span class="o">==</span> <span class="mi">8</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.tangent_representation_numerical">
<span class="sig-name descname"><span class="pre">tangent_representation_numerical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Rs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.tangent_representation_numerical" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the numerical tangent representations corresponding to the
homology representations in <code class="docutils literal notranslate"><span class="pre">Rs</span></code>.</p>
<p>The representations on homology <code class="docutils literal notranslate"><span class="pre">Rs</span></code> have to be given with respect to
the symplectic homology basis of the Jacobian of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.
Such matrices can for example be obtained via
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">endomorphism_basis()</span></code></a>.</p>
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be the period matrices of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>. Then
for a homology representation <span class="math notranslate nohighlight">\(R\)</span>, the corresponding tangential
representation <span class="math notranslate nohighlight">\(T\)</span> satisfies <span class="math notranslate nohighlight">\(T P = Q R\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Rs</span></code> – a set of matrices on homology to be converted to their
tangent representations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> (default: <code class="docutils literal notranslate"><span class="pre">self</span></code>) – the codomain, another Riemann
surface.</p></li>
</ul>
<p>OUTPUT:</p>
<p>The numerical tangent representations of the matrices in <code class="docutils literal notranslate"><span class="pre">Rs</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span> <span class="n">prec</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Rs</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">endomorphism_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Ts</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">tangent_representation_numerical</span><span class="p">(</span><span class="n">Rs</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(((</span><span class="n">T</span><span class="o">*</span><span class="n">P</span> <span class="o">-</span> <span class="n">P</span><span class="o">*</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">80</span><span class="p">))</span> <span class="k">for</span> <span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">R</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Ts</span><span class="p">,</span> <span class="n">Rs</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.upstairs_edges">
<span class="sig-name descname"><span class="pre">upstairs_edges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.upstairs_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the edgeset of the lift of the downstairs graph onto the Riemann
surface.</p>
<p>OUTPUT:</p>
<p>An edgeset between vertices (i, j), where i corresponds to the i-th
point in the Voronoi diagram vertices, and j is the j-th w-value
associated with that point.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edgeset</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">upstairs_edges</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">edgeset</span><span class="p">)</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">degree</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">downstairs_edges</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">{(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">w</span> <span class="ow">in</span> <span class="n">edgeset</span><span class="p">}</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">downstairs_edges</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.w_values">
<span class="sig-name descname"><span class="pre">w_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.w_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the points lying on the surface above <code class="docutils literal notranslate"><span class="pre">z0</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">z0</span></code> – (complex) a point in the complex z-plane.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A set of complex numbers corresponding to solutions of <span class="math notranslate nohighlight">\(f(z_0,w) = 0\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Find the w-values above the origin, i.e. the solutions of <span class="math notranslate nohighlight">\(w^2 + 1 = 0\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">w_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># abs tol 1e-14</span>
<span class="go">[-1.00000000000000*I, 1.00000000000000*I]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.</span></span><span class="sig-name descname"><span class="pre">RiemannSurfaceSum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface</span></code></a></p>
<p>Represent the disjoint union of finitely many Riemann surfaces.</p>
<p>Rudimentary class to represent disjoint unions of Riemann surfaces. Exists
mainly (and this is the only functionality actually implemented) to
represents direct products of the complex tori that arise as analytic
Jacobians of Riemann surfaces.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p>L – list of RiemannSurface objects</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">_</span><span class="o">.&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">SC</span> <span class="o">=</span> <span class="n">HyperellipticCurve</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">riemann_surface</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">HyperellipticCurve</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">riemann_surface</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">HyperellipticCurve</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">riemann_surface</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">SC</span><span class="o">.</span><span class="n">homomorphism_basis</span><span class="p">(</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">))</span>
<span class="go">2</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum.period_matrix">
<span class="sig-name descname"><span class="pre">period_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum.period_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the period matrix of the surface.</p>
<p>This is just the diagonal block matrix constructed from the period
matrices of the constituents.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span><span class="p">,</span> <span class="n">RiemannSurfaceSum</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurfaceSum</span><span class="p">([</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">S1S2</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">block_sum</span><span class="p">(</span><span class="n">S2</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span> <span class="o">==</span> <span class="n">S1S2</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum.riemann_matrix">
<span class="sig-name descname"><span class="pre">riemann_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum.riemann_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normalized period matrix of the surface.</p>
<p>This is just the diagonal block matrix constructed from the Riemann
matrices of the constituents.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span><span class="p">,</span> <span class="n">RiemannSurfaceSum</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurfaceSum</span><span class="p">([</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span> <span class="o">==</span> <span class="n">S1</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">block_sum</span><span class="p">(</span><span class="n">S2</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.bisect">
<span class="sig-prename descclassname"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.</span></span><span class="sig-name descname"><span class="pre">bisect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.bisect" title="Permalink to this definition">¶</a></dt>
<dd><p>Find position in a sorted list using bisection.</p>
<p>Given a list <span class="math notranslate nohighlight">\(L = [(t_0,...),(t_1,...),...(t_n,...)]\)</span> with increasing <span class="math notranslate nohighlight">\(t_i\)</span>,
find the index i such that <span class="math notranslate nohighlight">\(t_i &lt;= t &lt; t_{i+1}\)</span> using bisection. The rest of
the tuple is available for whatever use required.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">L</span></code> – A list of tuples such that the first term of each tuple is a real
number between 0 and 1. These real numbers must be increasing.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – A real number between <span class="math notranslate nohighlight">\(t_0\)</span> and <span class="math notranslate nohighlight">\(t_n\)</span>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>An integer i, giving the position in L where t would be in</p>
<p>EXAMPLES:</p>
<p>Form a list of the desired form, and pick a real number between 0 and 1:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">bisect</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">sage: </span><span class="n">bisect</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Another example which demonstrates that if t is equal to one of the t_i, it
returns that index:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.45</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.65</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">sage: </span><span class="n">bisect</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.differential_basis_baker">
<span class="sig-prename descclassname"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.</span></span><span class="sig-name descname"><span class="pre">differential_basis_baker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.differential_basis_baker" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a differential bases for a curve that is nonsingular outside (1:0:0),(0:1:0),(0:0:1)</p>
<p>Baker’s theorem tells us that if a curve has its singularities at the coordinate vertices and meets
some further easily tested genericity criteria,
then we can read off a basis for the regular differentials from the interior of the
Newton polygon spanned by the monomials. While this theorem only applies to special plane curves
it is worth implementing because the analysis is relatively cheap and it applies to a lot of
commonly encountered curves (e.g., curves given by a hyperelliptic model). Other advantages include
that we can do the computation over any exact base ring (the alternative Singular based method for
computing the adjoint ideal requires the rationals), and that we can avoid being affected by subtle bugs
in the Singular code.</p>
<p><code class="docutils literal notranslate"><span class="pre">None</span></code> is returned when <code class="docutils literal notranslate"><span class="pre">f</span></code> does not describe a curve of the relevant type. If <code class="docutils literal notranslate"><span class="pre">f</span></code> is of the relevant
type, but is of genus <span class="math notranslate nohighlight">\(0\)</span> then <code class="docutils literal notranslate"><span class="pre">[]</span></code> is returned (which are both False values, but they are not equal).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(f\)</span> – a bivariate polynomial</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">differential_basis_baker</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">+</span><span class="n">y</span><span class="o">^</span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="o">^</span><span class="mi">5</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">5</span>
<span class="gp">sage: </span><span class="n">differential_basis_baker</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">[y^2, x*y, x*y^2, x^2, x^2*y, x^2*y^2, x^2*y^3, x^3*y^2, x^3*y^3]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">sage: </span><span class="n">differential_basis_baker</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">differential_basis_baker</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.integer_matrix_relations">
<span class="sig-prename descclassname"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.</span></span><span class="sig-name descname"><span class="pre">integer_matrix_relations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.integer_matrix_relations" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine integer relations between complex matrices.</p>
<p>Given two square matrices with complex entries of size g, h respectively,
numerically determine an (approximate) ZZ-basis for the 2g x 2h matrices
with integer entries of the shape (D, B; C, A) such that B+M1*A=(D+M1*C)*M2.
By considering real and imaginary parts separately we obtain <span class="math notranslate nohighlight">\(2gh\)</span> equations
with real coefficients in <span class="math notranslate nohighlight">\(4gh\)</span> variables. We scale the coefficients by a
constant <span class="math notranslate nohighlight">\(2^b\)</span> and round them to integers, in order to obtain an integer
system of equations. Standard application of LLL allows us to determine near
solutions.</p>
<p>The user can specify the parameter <span class="math notranslate nohighlight">\(b\)</span>, but by default the system will
choose a <span class="math notranslate nohighlight">\(b\)</span> based on the size of the coefficients and the precision with
which they are given.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">M1</span></code> – square complex valued matrix</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">M2</span></code> – square complex valued matrix of same size as M1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> – integer (default provided). The equation coefficients are scaled
by <span class="math notranslate nohighlight">\(2^b\)</span> before rounding to integers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">b/4</span></code>). The vectors found by LLL that satisfy
the scaled equations to within <span class="math notranslate nohighlight">\(2^r\)</span> are reported as solutions.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of 2g x 2h integer matrices that, for large enough <span class="math notranslate nohighlight">\(r\)</span>, <span class="math notranslate nohighlight">\(b-r\)</span>,
generate the ZZ-module of relevant transformations.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">integer_matrix_relations</span>
<span class="gp">sage: </span><span class="n">M1</span><span class="o">=</span><span class="n">M2</span><span class="o">=</span><span class="n">matrix</span><span class="p">(</span><span class="n">CC</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">=</span><span class="n">integer_matrix_relations</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span><span class="n">M2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">id</span><span class="o">=</span><span class="n">parent</span><span class="p">(</span><span class="n">M1</span><span class="p">)(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M1t</span><span class="o">=</span><span class="p">[</span><span class="nb">id</span><span class="o">.</span><span class="n">augment</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">T</span><span class="p">]</span>
<span class="gp">sage: </span><span class="p">[((</span><span class="n">m</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">m</span><span class="p">)[:,</span><span class="mi">2</span><span class="p">:]</span><span class="o">-</span><span class="n">M2</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-13</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">M1t</span><span class="p">]</span>
<span class="go">[True, True]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.numerical_inverse">
<span class="sig-prename descclassname"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.</span></span><span class="sig-name descname"><span class="pre">numerical_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.numerical_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute numerical inverse of a matrix via LU decomposition</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">C</span></code> – A real or complex invertible square matrix</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CC</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,[</span><span class="o">-</span><span class="mf">4.5606e-31</span> <span class="o">+</span> <span class="mf">1.2326e-31</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>
<span class="gp">....: </span><span class="o">-</span><span class="mf">0.21313</span> <span class="o">+</span> <span class="mf">0.24166</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>
<span class="gp">....: </span><span class="o">-</span><span class="mf">3.4513e-31</span> <span class="o">+</span> <span class="mf">0.16111</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>
<span class="gp">....: </span><span class="o">-</span><span class="mf">1.0175</span> <span class="o">+</span> <span class="mf">9.8608e-32</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>
<span class="gp">....: </span><span class="mf">0.30912</span> <span class="o">+</span> <span class="mf">0.19962</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>
<span class="gp">....: </span><span class="o">-</span><span class="mf">4.9304e-32</span> <span class="o">+</span> <span class="mf">0.39923</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>
<span class="gp">....: </span><span class="mf">0.96793</span> <span class="o">-</span> <span class="mf">3.4513e-31</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>
<span class="gp">....: </span><span class="o">-</span><span class="mf">0.091587</span> <span class="o">+</span> <span class="mf">0.19276</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>
<span class="gp">....: </span><span class="mf">3.9443e-31</span> <span class="o">+</span> <span class="mf">0.38552</span><span class="o">*</span><span class="n">I</span><span class="p">])</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">numerical_inverse</span>
<span class="gp">sage: </span><span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="n">C</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">C</span><span class="o">-</span><span class="n">C</span><span class="o">^</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="n">numerical_inverse</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">*</span><span class="n">C</span><span class="o">-</span><span class="n">C</span><span class="o">^</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.voronoi_ghost">
<span class="sig-prename descclassname"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.</span></span><span class="sig-name descname"><span class="pre">voronoi_ghost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">cpoints</span></em>, <em class="sig-param"><span class="pre">n=6</span></em>, <em class="sig-param"><span class="pre">CC=Complex</span> <span class="pre">Double</span> <span class="pre">Field</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.voronoi_ghost" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a set of complex points to a list of real tuples <span class="math notranslate nohighlight">\((x,y)\)</span>, and
appends n points in a big circle around them.</p>
<p>The effect is that, with n &gt;= 3, a Voronoi decomposition will have only
finite cells around the original points. Furthermore, because the extra
points are placed on a circle centered on the average of the given points,
with a radius 3/2 times the largest distance between the center and the
given points, these finite cells form a simply connected region.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cpoints</span></code> – a list of complex numbers</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of real tuples <span class="math notranslate nohighlight">\((x,y)\)</span> consisting of the original points and a set of
points which surround them.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">voronoi_ghost</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">*</span><span class="n">I</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">voronoi_ghost</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>  <span class="c1"># abs tol 1e-6</span>
<span class="go">[(1.0, 1.0),</span>
<span class="go"> (1.0, -1.0),</span>
<span class="go"> (-1.0, 1.0),</span>
<span class="go"> (-1.0, -1.0),</span>
<span class="go"> (2.121320343559643, 0.0),</span>
<span class="go"> (1.0606601717798216, 1.8371173070873836),</span>
<span class="go"> (-1.060660171779821, 1.8371173070873839),</span>
<span class="go"> (-2.121320343559643, 2.59786816870648e-16),</span>
<span class="go"> (-1.0606601717798223, -1.8371173070873832),</span>
<span class="go"> (1.06066017177982, -1.8371173070873845)]</span>
</pre></div>
</div>
</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="../plane_quartics/quartic_generic.html"
                        title="previous chapter">Plane quartic curves over a general ring</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/sage/schemes/riemann_surfaces/riemann_surface.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../plane_quartics/quartic_generic.html" title="Plane quartic curves over a general ring"
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Sage 9.5 Reference Manual: Curves</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Riemann matrices and endomorphism rings of algebraic Riemann surfaces</a></li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2022, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>