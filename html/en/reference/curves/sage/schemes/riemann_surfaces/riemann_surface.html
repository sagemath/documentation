
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Riemann matrices and endomorphism rings of algebraic Riemann surfaces &#8212; Sage Reference Manual v8.7: Plane curves</title>
    <link rel="stylesheet" href="../../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Elliptic curve constructor" href="../elliptic_curves/constructor.html" />
    <link rel="prev" title="Plane quartic curves over a general ring" href="../plane_quartics/quartic_generic.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../elliptic_curves/constructor.html" title="Elliptic curve constructor"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../plane_quartics/quartic_generic.html" title="Plane quartic curves over a general ring"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Plane curves</a> &#187;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="riemann-matrices-and-endomorphism-rings-of-algebraic-riemann-surfaces">
<span id="sage-schemes-riemann-surfaces-riemann-surface"></span><h1>Riemann matrices and endomorphism rings of algebraic Riemann surfaces<a class="headerlink" href="#riemann-matrices-and-endomorphism-rings-of-algebraic-riemann-surfaces" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.schemes.riemann_surfaces.riemann_surface"></span><p>This module provides a class, RiemannSurface, to model the Riemann surface
determined by a plane algebraic curve over a subfield of the complex numbers.</p>
<p>A homology basis is derived from the edges of a Voronoi cell decomposition based
on the branch locus. The pull-back of these edges to the Riemann surface
provides a graph on it that contains a homology basis.</p>
<p>The class provides methods for computing the Riemann period matrix of the
surface numerically, using a certified homotopy continuation method due to
[Kr2016].</p>
<p>The class also provides facilities for computing the endomorphism ring of the
period lattice numerically, by determining integer (near) solutions to the
relevant approximate linear equations.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li>Alexandre Zotine, Nils Bruin (2017-06-10): initial version</li>
<li>Nils Bruin, Jeroen Sijsling (2018-01-05): algebraization, isomorphisms</li>
</ul>
<p>EXAMPLES:</p>
<p>We compute the Riemann matrix of a genus 3 curve:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;=</span><span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">=</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">-</span><span class="n">y</span><span class="o">^</span><span class="mi">3</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">=</span><span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">prec</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>
</pre></div>
</div>
<p>We test the usual properties, i.e., that the period matrix is symmetric and that
the imaginary part is positive definite:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-20</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="n">M</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">iM</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,[</span><span class="n">a</span><span class="o">.</span><span class="n">imag_part</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">list</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="n">iM</span><span class="o">.</span><span class="n">is_positive_definite</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We compute the endomorphism ring and check it has <span class="math notranslate nohighlight">\(\ZZ\)</span>-rank 6:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">endomorphism_basis</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In fact it is an order in a number field:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span><span class="o">.&lt;</span><span class="n">t</span><span class="o">&gt;=</span><span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;=</span><span class="n">NumberField</span><span class="p">(</span><span class="n">t</span><span class="o">^</span><span class="mi">6</span> <span class="o">-</span> <span class="n">t</span><span class="o">^</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">t</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="n">t</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">minpoly</span><span class="p">()</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">K</span><span class="p">))</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">minpoly</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="exception">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.ConvergenceError">
<em class="property">exception </em><code class="descclassname">sage.schemes.riemann_surfaces.riemann_surface.</code><code class="descname">ConvergenceError</code><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.ConvergenceError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/library/exceptions.html#exceptions.ValueError" title="(in Python v2.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">exceptions.ValueError</span></code></a></p>
<p>Error object suitable for raising and catching when Newton iteration fails.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">ConvergenceError</span>
<span class="gp">sage: </span><span class="k">raise</span> <span class="n">ConvergenceError</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ConvergenceError</span>: <span class="n">test</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ConvergenceError</span><span class="p">(),</span><span class="ne">ValueError</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface">
<em class="property">class </em><code class="descclassname">sage.schemes.riemann_surfaces.riemann_surface.</code><code class="descname">RiemannSurface</code><span class="sig-paren">(</span><em>f</em>, <em>prec=53</em>, <em>certification=True</em>, <em>differentials=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Construct a Riemann Surface. This is specified by the zeroes of a bivariate
polynomial with rational coefficients <span class="math notranslate nohighlight">\(f(z,w) = 0\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code> – a bivariate polynomial with rational coefficients. The surface is
interpreted as the covering space of the coordinate plane in the first
variable.</li>
<li><code class="docutils literal notranslate"><span class="pre">prec</span></code> – the desired precision of computations on the surface in bits
(default: 53)</li>
<li><code class="docutils literal notranslate"><span class="pre">certification</span></code> – a boolean (default: True) value indicating whether
homotopy continuation is certified or not. Uncertified homotopy
continuation can be faster.</li>
<li><code class="docutils literal notranslate"><span class="pre">differentials</span></code> – (default: None). If specified, provides a list of
polynomials <span class="math notranslate nohighlight">\(h\)</span> such that <span class="math notranslate nohighlight">\(h/(df/dw) dz\)</span> is a regular differential on the
Riemann surface. This is taken as a basis of the regular differentials, so
the genus is assumed to be equal to the length of this list. The results
from the homology basis computation are checked against this value.
Providing this parameter makes the computation independent from Singular.
For a nonsingular plane curve of degree <span class="math notranslate nohighlight">\(d\)</span>, an appropriate set is given
by the monomials of degree up to <span class="math notranslate nohighlight">\(d-3\)</span>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">Riemann surface defined by polynomial f = -z^3 + w^2 + 1 = 0, with 53 bits of precision</span>
</pre></div>
</div>
<p>Another Riemann surface with 100 bits of precision:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">100</span><span class="p">);</span> <span class="n">S</span>
<span class="go">Riemann surface defined by polynomial f = -z^3 + w^2 + 1 = 0, with 100 bits of precision</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span> <span class="c1">#abs tol 0.00000001</span>
<span class="go">[0.500000000000000000000000... + 0.866025403784438646763723...*I]</span>
</pre></div>
</div>
<p>We can also work with Riemann surfaces that are defined over fields with a
complex embedding, but since the current interface for computing genus and
regular differentials in Singular presently does not support extensions of
QQ, we need to specify a description of the differentials ourselves. We give
an example of a CM elliptic curve:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Qt</span><span class="o">.&lt;</span><span class="n">t</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">t</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">t</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span><span class="n">embedding</span><span class="o">=</span><span class="n">CC</span><span class="p">(</span><span class="mf">0.5</span><span class="o">+</span><span class="mf">1.6</span><span class="o">*</span><span class="n">I</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">K</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="n">y</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">prec</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">differentials</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">endomorphism_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">minpoly</span><span class="p">()</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">K</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">A</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.cohomology_basis">
<code class="descname">cohomology_basis</code><span class="sig-paren">(</span><em>option=1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.cohomology_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the cohomology basis of this surface.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">option</span></code> – Presently, this routine uses Singular’s <code class="docutils literal notranslate"><span class="pre">adjointIdeal</span></code>
and passes the <code class="docutils literal notranslate"><span class="pre">option</span></code> parameter on. Legal values are 1, 2, 3 ,4,
where 1 is the default. See the Singular documentation for the
meaning. The backend for this function may change, and support for
this parameter may disappear.</li>
</ul>
<p>OUTPUT:</p>
<p>Returns a list of polynomials <span class="math notranslate nohighlight">\(g\)</span> representing the holomorphic
differentials <span class="math notranslate nohighlight">\(g/(df/dw) dz\)</span>, where <span class="math notranslate nohighlight">\(f(z,w)=0\)</span> is the equation
specifying the Riemann surface.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="n">w</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">cohomology_basis</span><span class="p">()</span>
<span class="go">[1, w, z]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.downstairs_edges">
<code class="descname">downstairs_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.downstairs_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the edgeset of the Voronoi diagram.</p>
<p>OUTPUT:</p>
<p>A list of integer tuples corresponding to edges between vertices in the
Voronoi diagram.</p>
<p>EXAMPLES:</p>
<p>Form a Riemann surface, one with a particularly simple branch locus:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute the edges:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">downstairs_edges</span><span class="p">()</span>
<span class="go">[(0, 1), (0, 5), (1, 4), (2, 3), (2, 4), (3, 5), (4, 5)]</span>
</pre></div>
</div>
<p>This now gives an edgeset which one could use to form a graph.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The numbering of the vertices is given by the Voronoi package.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.downstairs_graph">
<code class="descname">downstairs_graph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.downstairs_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Retun the Voronoi decomposition as a planar graph.</p>
<p>The result of this routine can be useful to interpret the labelling of
the vertices.</p>
<p>OUTPUT:</p>
<p>The Voronoi decomposition as a graph, with appropriate planar embedding.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">downstairs_graph</span><span class="p">()</span>
<span class="go">Graph on 11 vertices</span>
</pre></div>
</div>
<p>Similarly one can form the graph of the upstairs edges, which is
visually rather less attractive but can be instructive to verify that a
homology basis is likely correctly computed.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span><span class="o">=</span><span class="n">Graph</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">upstairs_edges</span><span class="p">());</span> <span class="n">G</span>
<span class="go">Graph on 22 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_planar</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.edge_permutations">
<code class="descname">edge_permutations</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.edge_permutations" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the permutations of branches associated to each edge.</p>
<p>Over the vertices of the Voronoi decomposition around the branch locus,
we label the fibres. By following along an edge, the lifts of the edge
induce a permutation of that labelling.</p>
<p>OUTPUT:</p>
<p>A dictionary with as keys the edges of the Voronoi decomposition and as
values the corresponding permutations.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">edge_permutations</span><span class="p">()</span>
<span class="go">{(0, 2): (),</span>
<span class="go"> (0, 4): (),</span>
<span class="go"> (1, 2): (),</span>
<span class="go"> (1, 3): (0,1),</span>
<span class="go"> (1, 6): (),</span>
<span class="go"> (2, 0): (),</span>
<span class="go"> (2, 1): (),</span>
<span class="go"> (2, 5): (0,1),</span>
<span class="go"> (3, 1): (0,1),</span>
<span class="go"> (3, 4): (),</span>
<span class="go"> (4, 0): (),</span>
<span class="go"> (4, 3): (),</span>
<span class="go"> (5, 2): (0,1),</span>
<span class="go"> (5, 7): (),</span>
<span class="go"> (6, 1): (),</span>
<span class="go"> (6, 7): (),</span>
<span class="go"> (7, 5): (),</span>
<span class="go"> (7, 6): ()}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis">
<code class="descname">endomorphism_basis</code><span class="sig-paren">(</span><em>b=None</em>, <em>r=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerically compute a <span class="math notranslate nohighlight">\(\ZZ\)</span>-basis for the endomorphism ring.</p>
<p>Let <span class="math notranslate nohighlight">\(\left(I | M \right)\)</span> be the normalized period matrix (<span class="math notranslate nohighlight">\(M\)</span> is the
<span class="math notranslate nohighlight">\(g\times g\)</span> <a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.riemann_matrix" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.riemann_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">riemann_matrix()</span></code></a>). We consider the system of matrix
equations <span class="math notranslate nohighlight">\(MA + C = (MB + D)M\)</span> where <span class="math notranslate nohighlight">\(A, B, C, D\)</span> are <span class="math notranslate nohighlight">\(g\times g\)</span>
integer matrices.  We determine small integer (near) solutions using LLL
reductions.  These solutions are returned as <span class="math notranslate nohighlight">\(2g \times 2g\)</span> integer
matrices obtained by stacking <span class="math notranslate nohighlight">\(\left(D | B\right)\)</span> on top of <span class="math notranslate nohighlight">\(\left(C |
A\right)\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">b</span></code> – integer (default provided). The equation coefficients are
scaled by <span class="math notranslate nohighlight">\(2^b\)</span> before rounding to integers.</li>
<li><code class="docutils literal notranslate"><span class="pre">r</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">b/4</span></code>). Solutions that have all
coefficients smaller than <span class="math notranslate nohighlight">\(2^r\)</span> in absolute value are reported as
actual solutions.</li>
</ul>
<p>OUTPUT:</p>
<p>A list of <span class="math notranslate nohighlight">\(2g \times 2g\)</span> integer matrices that, for large enough <code class="docutils literal notranslate"><span class="pre">r</span></code>
and <code class="docutils literal notranslate"><span class="pre">b-r</span></code>, generate the endomorphism ring.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">y</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">endomorphism_basis</span><span class="p">();</span> <span class="n">B</span> <span class="c1">#random</span>
<span class="go">[</span>
<span class="go">[1 0]  [ 0 -1]</span>
<span class="go">[0 1], [ 1  1]</span>
<span class="go">]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">minpoly</span><span class="p">()</span><span class="o">.</span><span class="n">disc</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">B</span><span class="p">])</span>
<span class="go">[-3, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homology_basis">
<code class="descname">homology_basis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homology_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the homology basis of the Riemann surface.</p>
<p>OUTPUT:</p>
<p>A list of paths <span class="math notranslate nohighlight">\(L = [P_1, \dots, P_n]\)</span>. Each path <span class="math notranslate nohighlight">\(P_i\)</span> is of the form
<span class="math notranslate nohighlight">\((k, [p_1 ... p_m, p_1])\)</span>, where <span class="math notranslate nohighlight">\(k\)</span> is the number of times to traverse
the path (if negative, to traverse it backwards), and the <span class="math notranslate nohighlight">\(p_i\)</span> are
vertices of the upstairs graph.</p>
<p>EXAMPLES:</p>
<p>In this example, there are two paths that form the homology basis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">homology_basis</span><span class="p">()</span> <span class="c1">#random</span>
<span class="go">[[(1, [(3, 1), (5, 0), (9, 0), (10, 0), (2, 0), (4, 0),</span>
<span class="go">    (7, 1), (10, 1), (3, 1)])],</span>
<span class="go"> [(1, [(8, 0), (6, 0), (7, 0), (10, 0), (2, 0), (4, 0),</span>
<span class="go">    (7, 1), (10, 1), (9, 1), (8, 0)])]]</span>
</pre></div>
</div>
<p>In order to check that the answer returned above is reasonable, we
test some basic properties. We express the faces of the downstairs graph
as ZZ-linear combinations of the edges and check that the projection
of the homology basis upstairs projects down to independent linear
combinations of an even number of faces:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dg</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">downstairs_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">edges</span> <span class="o">=</span> <span class="n">dg</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">^</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edge_to_E</span> <span class="o">=</span> <span class="p">{</span> <span class="n">e</span><span class="p">[:</span><span class="mi">2</span><span class="p">]:</span> <span class="n">E</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">)}</span>
<span class="gp">sage: </span><span class="n">edge_to_E</span><span class="o">.</span><span class="n">update</span><span class="p">({</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span> <span class="o">-</span><span class="n">E</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">face_span</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">submodule</span><span class="p">([</span><span class="nb">sum</span><span class="p">(</span><span class="n">edge_to_E</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">dg</span><span class="o">.</span><span class="n">faces</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">path_to_E</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="go">....:     k,P = path</span>
<span class="go">....:     return k*sum(edge_to_E[(P[i][0],P[i+1][0])] for i in range(len(P)-1))</span>
<span class="gp">sage: </span><span class="n">hom_basis</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">path_to_E</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">loop</span><span class="p">)</span> <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">homology_basis</span><span class="p">()]</span>
<span class="gp">sage: </span><span class="n">face_span</span><span class="o">.</span><span class="n">submodule</span><span class="p">(</span><span class="n">hom_basis</span><span class="p">)</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">face_span</span><span class="o">.</span><span class="n">coordinate_vector</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">%</span><span class="mi">2</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">hom_basis</span><span class="p">]</span>
<span class="go">[0, 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis">
<code class="descname">homomorphism_basis</code><span class="sig-paren">(</span><em>other</em>, <em>b=None</em>, <em>r=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerically compute a <span class="math notranslate nohighlight">\(\ZZ\)</span>-basis for module of homomorphisms to a given
complex torus.</p>
<p>Given another complex torus (given as the analytic Jacobian of a Riemann
surface), numerically compute a basis for the homomorphism module. The
answer is returned as a list of 2g x 2g integer matrices T=(D, B; C, A)
such that if the columns of (I|M1) generate the lattice defining the
Jacobian of the Riemann surface and the columns of (I|M2) do this for
the codomain, then approximately we have (I|M2)T=(D+M2C)(I|M1), i.e., up
to a choice of basis for <span class="math notranslate nohighlight">\(\CC^g\)</span> as a complex vector space, we we
realize (I|M1) as a sublattice of (I|M2).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">b</span></code> – integer (default provided). The equation coefficients are
scaled by <span class="math notranslate nohighlight">\(2^b\)</span> before rounding to integers.</li>
<li><code class="docutils literal notranslate"><span class="pre">r</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">b/4</span></code>). Solutions that have all
coefficients smaller than <span class="math notranslate nohighlight">\(2^r\)</span> in absolute value are reported as
actual solutions.</li>
</ul>
<p>OUTPUT:</p>
<p>A list of <span class="math notranslate nohighlight">\(2g \times 2g\)</span> integer matrices that, for large enough <code class="docutils literal notranslate"><span class="pre">r</span></code>
and <code class="docutils literal notranslate"><span class="pre">b-r</span></code>, generate the homomorphism module.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;11a1&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">riemann_surface</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;11a3&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">riemann_surface</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">det</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">S1</span><span class="o">.</span><span class="n">homomorphism_basis</span><span class="p">(</span><span class="n">S2</span><span class="p">)]</span>
<span class="go">[5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homotopy_continuation">
<code class="descname">homotopy_continuation</code><span class="sig-paren">(</span><em>edge</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homotopy_continuation" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform homotopy continuation along an edge of the Voronoi diagram using
Newton iteration.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">edge</span></code> – a tuple of integers indicating an edge of the Voronoi
diagram</li>
</ul>
<p>OUTPUT:</p>
<p>A list of complex numbers corresponding to the points which are reached
when traversing along the direction of the edge. The ordering of these
points indicates how they have been permuted due to the weaving of the
curve.</p>
<p>EXAMPLES:</p>
<p>We check that continued values along an edge correspond (up to the
appropriate permutation) to what is stored. Note that the permutation
was originally computed from this data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="n">w</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edge1</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">edge_permutations</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">edge_permutations</span><span class="p">()[</span><span class="n">edge1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">continued_values</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">homotopy_continuation</span><span class="p">(</span><span class="n">edge1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">stored_values</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">w_values</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">edge1</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">continued_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">stored_values</span><span class="p">[</span><span class="n">sigma</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span> <span class="o">&lt;</span> <span class="mf">1e-8</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.make_zw_interpolator">
<code class="descname">make_zw_interpolator</code><span class="sig-paren">(</span><em>upstairs_edge</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.make_zw_interpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an upstairs edge for which continuation data has been stored,
return a function that computes <span class="math notranslate nohighlight">\(z(t),w(t)\)</span> , where <span class="math notranslate nohighlight">\(t\)</span> in <span class="math notranslate nohighlight">\([0,1]\)</span> is a
parametrization of the edge.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">upstairs_edge</span></code> – a pair of integer tuples indicating an edge on
the upstairs graph of the surface</li>
</ul>
<p>OUTPUT:</p>
<p>A tuple (g, d), where g is the function that computes the interpolation
along the edge and d is the difference of the z-values of the end and
start point.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">_</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">homology_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">,</span><span class="n">d</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">make_zw_interpolator</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)]);</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mf">0.1</span><span class="p">))</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-13</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">abs</span><span class="p">((</span><span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">g</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-13</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.matrix_of_integral_values">
<code class="descname">matrix_of_integral_values</code><span class="sig-paren">(</span><em>differentials</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.matrix_of_integral_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the path integrals of the given differentials along the homology
basis.</p>
<p>The returned answer has a row for each differential. If the Riemann
surface is given by the equation <span class="math notranslate nohighlight">\(f(z,w)=0\)</span>, then the differentials are
encoded by polynomials g, signifying the differential <span class="math notranslate nohighlight">\(g(z,w)/(df/dw)
dz\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">differentials</span></code> – a list of polynomials.</li>
</ul>
<p>OUTPUT:</p>
<p>A matrix, one row per differential, containing the values of the path
integrals along the homology basis of the Riemann surface.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">y</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">cohomology_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">matrix_of_integral_values</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">Full MatrixSpace of 1 by 2 dense matrices over Complex Field with 53 bits of precision</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">algdep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="c1">#curve is CM, so the period is quadratic</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.monodromy_group">
<code class="descname">monodromy_group</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.monodromy_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute local monodromy generators of the Riemann surface.</p>
<p>For each branch point, the local monodromy is encoded by a permutation.
The permutations returned correspond to positively oriented loops around
each branch point, with a fixed base point. This means the generators
are properly conjugated to ensure that together they generate the global
monodromy. The list has an entry for every finite point stored in
<code class="docutils literal notranslate"><span class="pre">self.branch_locus</span></code>, plus an entry for the ramification above infinity.</p>
<p>OUTPUT:</p>
<p>A list of permutations, encoding the local monodromy at each branch
point.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span> <span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="n">w</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">monodromy_group</span><span class="p">();</span> <span class="n">G</span>
<span class="go">[(0,1,2), (0,1), (0,2), (1,2), (1,2), (1,2), (0,1), (0,2), (0,2)]</span>
</pre></div>
</div>
<p>The permutations give the local monodromy generators for the branch
points:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">branch_locus</span> <span class="o">+</span> <span class="p">[</span><span class="n">unsigned_infinity</span><span class="p">],</span> <span class="n">G</span><span class="p">))</span> <span class="c1">#abs tol 0.0000001</span>
<span class="go">[(0.000000000000000, (0,1,2)),</span>
<span class="go"> (-1.31362670141929, (0,1)),</span>
<span class="go"> (-0.819032851784253 - 1.02703471138023*I, (0,2)),</span>
<span class="go"> (-0.819032851784253 + 1.02703471138023*I, (1,2)),</span>
<span class="go"> (0.292309440469772 - 1.28069133740100*I, (1,2)),</span>
<span class="go"> (0.292309440469772 + 1.28069133740100*I, (1,2)),</span>
<span class="go"> (1.18353676202412 - 0.569961265016465*I, (0,1)),</span>
<span class="go"> (1.18353676202412 + 0.569961265016465*I, (0,2)),</span>
<span class="go"> (Infinity, (0,2))]</span>
</pre></div>
</div>
<p>We can check the ramification by looking at the cycle lengths and verify
it agrees with the Riemann-Hurwitz formula:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">genus</span><span class="o">-</span><span class="mi">2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">degree</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">G</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">cycle_type</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.period_matrix">
<code class="descname">period_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.period_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the period matrix of the surface.</p>
<p>OUTPUT:</p>
<p>A matrix of complex values.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="n">w</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span>
</pre></div>
</div>
<p>The results are highly arbitrary, so it is hard to check if the result
produced is correct. The closely related <code class="docutils literal notranslate"><span class="pre">riemann_matrix</span></code> is somewhat
easier to test.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="go">Full MatrixSpace of 3 by 6 dense matrices over Complex Field with 30 bits of precision</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.plot_paths">
<code class="descname">plot_paths</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.plot_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a graphical representation of the integration paths.</p>
<p>Returns a two dimensional plot containing the branch points (in red) and
the integration paths (obtained from the Voronoi cells of the branch
points). The integration paths are plotted by plotting the points that
have been computed for homotopy continuation, so the density gives an
indication of where numerically sensitive features occur.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">plot_paths</span><span class="p">()</span>
<span class="go">Graphics object consisting of 2 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.plot_paths3d">
<code class="descname">plot_paths3d</code><span class="sig-paren">(</span><em>thickness=0.01</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.plot_paths3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the homology basis as a graph in 3-space.</p>
<p>The homology basis of the surface is constructed by taking the Voronoi
cells around the branch points and taking the inverse image of the edges
on the Riemann surface. If the surface is given by the equation
<span class="math notranslate nohighlight">\(f(z,w)\)</span>, the returned object gives the image of this graph in 3-space
with coordinates <span class="math notranslate nohighlight">\(\left(\operatorname{Re}(z), \operatorname{Im}(z),
\operatorname{Im}(w)\right)\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">plot_paths3d</span><span class="p">()</span>
<span class="go">Graphics3d Object</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.riemann_matrix">
<code class="descname">riemann_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.riemann_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Riemann matrix.</p>
<p>OUTPUT:</p>
<p>A matrix of complex values.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="n">w</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>
</pre></div>
</div>
<p>The Klein quartic has a Riemann matrix with values is a quadratic
field:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">algdep</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">K</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.rosati_involution">
<code class="descname">rosati_involution</code><span class="sig-paren">(</span><em>R</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.rosati_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Rosati involution of an endomorphism.</p>
<p>The endomorphism in question should be given by its homology
representation with respect to the symplectic basis of the Jacobian.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">R</span></code> – integral matrix.</li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the Rosati involution to <code class="docutils literal notranslate"><span class="pre">R</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span> <span class="n">prec</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Rs</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">endomorphism_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">rosati_involution</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">rosati_involution</span><span class="p">(</span><span class="n">Rs</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">==</span> <span class="n">Rs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.simple_vector_line_integral">
<code class="descname">simple_vector_line_integral</code><span class="sig-paren">(</span><em>upstairs_edge</em>, <em>differentials</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.simple_vector_line_integral" title="Permalink to this definition">¶</a></dt>
<dd><p>Perfom vectorized integration along a straight path.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">upstairs_edge</span></code> – a pair of integer tuples corresponding to an edge
of the upstairs graph.</li>
<li><code class="docutils literal notranslate"><span class="pre">differentials</span></code> – a list of polynomials; a polynomial <span class="math notranslate nohighlight">\(g\)</span>
represents the differential <span class="math notranslate nohighlight">\(g(z,w)/(df/dw) dz\)</span> where <span class="math notranslate nohighlight">\(f(z,w)=0\)</span> is
the equation defining the Riemann surface.</li>
</ul>
<p>OUTPUT:</p>
<p>A complex number, the value of the line integral.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">);</span> <span class="n">S</span>
<span class="go">Riemann surface defined by polynomial f = -z^4 + w^2 + 1 = 0, with 53 bits of precision</span>
</pre></div>
</div>
<p>Since we make use of data from homotopy continuation, we need to compute
the necessary data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">differentials</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">cohomology_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">simple_vector_line_integral</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="n">differentials</span><span class="p">)</span> <span class="c1">#abs tol 0.00000001</span>
<span class="go">(1.14590610929717e-16 - 0.352971844594760*I)</span>
</pre></div>
</div>
<p>..NOTE:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Uses</span> <span class="n">data</span> <span class="n">that</span> <span class="s2">&quot;homology_basis&quot;</span> <span class="n">initializes</span><span class="o">.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.symplectic_automorphism_group">
<code class="descname">symplectic_automorphism_group</code><span class="sig-paren">(</span><em>endo_basis=None</em>, <em>b=None</em>, <em>r=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.symplectic_automorphism_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerically compute the symplectic automorphism group as a permutation
group.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">endo_basis</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) – a <span class="math notranslate nohighlight">\(\ZZ\)</span>-basis of the
endomorphisms of <code class="docutils literal notranslate"><span class="pre">self</span></code>, as obtained from
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">endomorphism_basis()</span></code></a>. If you have already calculated this
basis, it saves time to pass it via this keyword argument. Otherwise
the method will calculate it.</li>
<li><code class="docutils literal notranslate"><span class="pre">b</span></code> – integer (default provided): as for
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a>, and used in its invocation if
(re)calculating said basis.</li>
<li><code class="docutils literal notranslate"><span class="pre">r</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">b/4</span></code>).  as for
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a>, and used in its invocation if
(re)calculating said basis.</li>
</ul>
<p>OUTPUT:</p>
<p>The symplectic automorphism group of the Jacobian of the Riemann
surface. The automorphism group of the Riemann surface itself can be
recovered from this; if the curve is hyperelliptic, then it is
identical, and if not, then one divides out by the central element
corresponding to multiplication by -1.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span> <span class="n">prec</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">symplectic_automorphism_group</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">as_permutation_group</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">DihedralGroup</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.symplectic_isomorphisms">
<code class="descname">symplectic_isomorphisms</code><span class="sig-paren">(</span><em>other=None</em>, <em>hom_basis=None</em>, <em>b=None</em>, <em>r=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.symplectic_isomorphisms" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerically compute symplectic isomorphisms.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">other</span></code> (default: <code class="docutils literal notranslate"><span class="pre">self</span></code>) – the codomain, another Riemann
surface.</li>
<li><code class="docutils literal notranslate"><span class="pre">hom_basis</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) – a <span class="math notranslate nohighlight">\(\ZZ\)</span>-basis of the
homomorphisms from <code class="docutils literal notranslate"><span class="pre">self</span></code> to <code class="docutils literal notranslate"><span class="pre">other</span></code>, as obtained from
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a>. If you have already calculated this
basis, it saves time to pass it via this keyword argument. Otherwise
the method will calculate it.</li>
<li><code class="docutils literal notranslate"><span class="pre">b</span></code> – integer (default provided): as for
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a>, and used in its invocation if
(re)calculating said basis.</li>
<li><code class="docutils literal notranslate"><span class="pre">r</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">b/4</span></code>).  as for
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a>, and used in its invocation if
(re)calculating said basis.</li>
</ul>
<p>OUTPUT:</p>
<p>Returns the combinations of the elements of <a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a>
that correspond to symplectic isomorphisms between the Jacobians of
<code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">prec</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Rs</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">symplectic_isomorphisms</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Ts</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tangent_representation_numerical</span><span class="p">(</span><span class="n">Rs</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">test1</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(((</span><span class="n">T</span><span class="o">*</span><span class="n">P</span> <span class="o">-</span> <span class="n">Q</span><span class="o">*</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">80</span><span class="p">))</span> <span class="k">for</span> <span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">R</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Ts</span><span class="p">,</span> <span class="n">Rs</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">test2</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">det</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">Rs</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">test1</span> <span class="ow">and</span> <span class="n">test2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.tangent_representation_algebraic">
<code class="descname">tangent_representation_algebraic</code><span class="sig-paren">(</span><em>Rs</em>, <em>other=None</em>, <em>epscomp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.tangent_representation_algebraic" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the algebraic tangent representations corresponding to the
homology representations in <code class="docutils literal notranslate"><span class="pre">Rs</span></code>.</p>
<p>The representations on homology <code class="docutils literal notranslate"><span class="pre">Rs</span></code> have to be given with respect to
the symplectic homology basis of the Jacobian of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.
Such matrices can for example be obtained via
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">endomorphism_basis()</span></code></a>.</p>
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be the period matrices of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>. Then
for a homology representation <span class="math notranslate nohighlight">\(R\)</span>, the corresponding tangential
representation <span class="math notranslate nohighlight">\(T\)</span> satisfies <span class="math notranslate nohighlight">\(T P = Q R\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Rs</span></code> – a set of matrices on homology to be converted to their
tangent representations.</li>
<li><code class="docutils literal notranslate"><span class="pre">other</span></code> (default: <code class="docutils literal notranslate"><span class="pre">self</span></code>) – the codomain, another Riemann
surface.</li>
<li><code class="docutils literal notranslate"><span class="pre">epscomp</span></code> – real number (default: <code class="docutils literal notranslate"><span class="pre">2^(-prec</span> <span class="pre">+</span> <span class="pre">30)</span></code>). Used to
determine whether a complex number is close enough to a root of a
polynomial.</li>
</ul>
<p>OUTPUT:</p>
<p>The algebraic tangent representations of the matrices in <code class="docutils literal notranslate"><span class="pre">Rs</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span> <span class="n">prec</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Rs</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">endomorphism_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Ts</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">tangent_representation_algebraic</span><span class="p">(</span><span class="n">Rs</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">maximal_order</span><span class="p">()</span><span class="o">.</span><span class="n">discriminant</span><span class="p">()</span> <span class="o">==</span> <span class="mi">8</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.tangent_representation_numerical">
<code class="descname">tangent_representation_numerical</code><span class="sig-paren">(</span><em>Rs</em>, <em>other=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.tangent_representation_numerical" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the numerical tangent representations corresponding to the
homology representations in <code class="docutils literal notranslate"><span class="pre">Rs</span></code>.</p>
<p>The representations on homology <code class="docutils literal notranslate"><span class="pre">Rs</span></code> have to be given with respect to
the symplectic homology basis of the Jacobian of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.
Such matrices can for example be obtained via
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">endomorphism_basis()</span></code></a>.</p>
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be the period matrices of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>. Then
for a homology representation <span class="math notranslate nohighlight">\(R\)</span>, the corresponding tangential
representation <span class="math notranslate nohighlight">\(T\)</span> satisfies <span class="math notranslate nohighlight">\(T P = Q R\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Rs</span></code> – a set of matrices on homology to be converted to their
tangent representations.</li>
<li><code class="docutils literal notranslate"><span class="pre">other</span></code> (default: <code class="docutils literal notranslate"><span class="pre">self</span></code>) – the codomain, another Riemann
surface.</li>
</ul>
<p>OUTPUT:</p>
<p>The numerical tangent representations of the matrices in <code class="docutils literal notranslate"><span class="pre">Rs</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span> <span class="n">prec</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Rs</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">endomorphism_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Ts</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">tangent_representation_numerical</span><span class="p">(</span><span class="n">Rs</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(((</span><span class="n">T</span><span class="o">*</span><span class="n">P</span> <span class="o">-</span> <span class="n">P</span><span class="o">*</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">80</span><span class="p">))</span> <span class="k">for</span> <span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">R</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Ts</span><span class="p">,</span> <span class="n">Rs</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.upstairs_edges">
<code class="descname">upstairs_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.upstairs_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the edgeset of the lift of the downstairs graph onto the Riemann
surface.</p>
<p>OUTPUT:</p>
<p>An edgeset between vertices (i, j), where i corresponds to the i-th
point in the Voronoi diagram vertices, and j is the j-th w-value
associated with that point.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edgeset</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">upstairs_edges</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">edgeset</span><span class="p">)</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">degree</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">downstairs_edges</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">{(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">w</span> <span class="ow">in</span> <span class="n">edgeset</span><span class="p">}</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">downstairs_edges</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.w_values">
<code class="descname">w_values</code><span class="sig-paren">(</span><em>z0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.w_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the points lying on the surface above <code class="docutils literal notranslate"><span class="pre">z0</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">z0</span></code> – (complex) a point in the complex z-plane.</li>
</ul>
<p>OUTPUT:</p>
<p>A set of complex numbers corresponding to solutions of <span class="math notranslate nohighlight">\(f(z_0,w) = 0\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Find the w-values above the origin, i.e. the solutions of <span class="math notranslate nohighlight">\(w^2 + 1 = 0\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">w_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># abs tol 1e-14</span>
<span class="go">[-1.00000000000000*I, 1.00000000000000*I]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum">
<em class="property">class </em><code class="descclassname">sage.schemes.riemann_surfaces.riemann_surface.</code><code class="descname">RiemannSurfaceSum</code><span class="sig-paren">(</span><em>L</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface</span></code></a></p>
<p>Represent the disjoint union of finitely many Riemann surfaces.</p>
<p>Rudimentary class to represent disjoint unions of Riemann surfaces. Exists
mainly (and this is the only functionality actually implemented) to
represents direct products of the complex tori that arise as analytic
Jacobians of Riemann surfaces.</p>
<p>INPUT:</p>
<ul class="simple">
<li>L – list of RiemannSurface objects</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">_</span><span class="o">.&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">SC</span> <span class="o">=</span> <span class="n">HyperellipticCurve</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">riemann_surface</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">HyperellipticCurve</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">riemann_surface</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">HyperellipticCurve</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">riemann_surface</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">SC</span><span class="o">.</span><span class="n">homomorphism_basis</span><span class="p">(</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">))</span>
<span class="go">2</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum.period_matrix">
<code class="descname">period_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum.period_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the period matrix of the surface.</p>
<p>This is just the diagonal block matrix constructed from the period
matrices of the constituents.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span><span class="p">,</span> <span class="n">RiemannSurfaceSum</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;=</span><span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurfaceSum</span><span class="p">([</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">S1S2</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">block_sum</span><span class="p">(</span><span class="n">S2</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span> <span class="o">==</span> <span class="n">S1S2</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum.riemann_matrix">
<code class="descname">riemann_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum.riemann_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normalized period matrix of the surface.</p>
<p>This is just the diagonal block matrix constructed from the Riemann
matrices of the constituents.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span><span class="p">,</span> <span class="n">RiemannSurfaceSum</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;=</span><span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurfaceSum</span><span class="p">([</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span> <span class="o">==</span> <span class="n">S1</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">block_sum</span><span class="p">(</span><span class="n">S2</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.bisect">
<code class="descclassname">sage.schemes.riemann_surfaces.riemann_surface.</code><code class="descname">bisect</code><span class="sig-paren">(</span><em>L</em>, <em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.bisect" title="Permalink to this definition">¶</a></dt>
<dd><p>Find position in a sorted list using bisection.</p>
<p>Given a list <span class="math notranslate nohighlight">\(L = [(t_0,...),(t_1,...),...(t_n,...)]\)</span> with increasing <span class="math notranslate nohighlight">\(t_i\)</span>,
find the index i such that <span class="math notranslate nohighlight">\(t_i &lt;= t &lt; t_{i+1}\)</span> using bisection. The rest of
the tuple is available for whatever use required.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">L</span></code> – A list of tuples such that the first term of each tuple is a real
number between 0 and 1. These real numbers must be increasing.</li>
<li><code class="docutils literal notranslate"><span class="pre">t</span></code> – A real number between <span class="math notranslate nohighlight">\(t_0\)</span> and <span class="math notranslate nohighlight">\(t_n\)</span>.</li>
</ul>
<p>OUTPUT:</p>
<p>An integer i, giving the position in L where t would be in</p>
<p>EXAMPLES:</p>
<p>Form a list of the desired form, and pick a real number between 0 and 1:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">bisect</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">sage: </span><span class="n">bisect</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Another example which demonstrates that if t is equal to one of the t_i, it
returns that index:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.45</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.65</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">sage: </span><span class="n">bisect</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.differential_basis_baker">
<code class="descclassname">sage.schemes.riemann_surfaces.riemann_surface.</code><code class="descname">differential_basis_baker</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.differential_basis_baker" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a differential bases for a curve that is nonsingular outside (1:0:0),(0:1:0),(0:0:1)</p>
<p>Baker’s theorem tells us that if a curve has its singularities at the coordinate vertices and meets
some further easily tested genericity criteria,
then we can read off a basis for the regular differentials from the interior of the
Newton polygon spanned by the monomials. While this theorem only applies to special plane curves
it is worth implementing because the analysis is relatively cheap and it applies to a lot of
commonly encountered curves (e.g., curves given by a hyperelliptic model). Other advantages include
that we can do the computation over any exact base ring (the alternative Singular based method for
computing the adjoint ideal requires the rationals), and that we can avoid being affected by subtle bugs
in the Singular code.</p>
<p><code class="docutils literal notranslate"><span class="pre">None</span></code> is returned when <code class="docutils literal notranslate"><span class="pre">f</span></code> does not describe a curve of the relevant type. If <code class="docutils literal notranslate"><span class="pre">f</span></code> is of the relevant
type, but is of genus <span class="math notranslate nohighlight">\(0\)</span> then <code class="docutils literal notranslate"><span class="pre">[]</span></code> is returned (which are both False values, but they are not equal).</p>
<p>INPUT:</p>
<ul class="simple">
<li><span class="math notranslate nohighlight">\(f\)</span> – a bivariate polynomial</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">differential_basis_baker</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;=</span><span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">=</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">+</span><span class="n">y</span><span class="o">^</span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="o">^</span><span class="mi">5</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">5</span>
<span class="gp">sage: </span><span class="n">differential_basis_baker</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">[y^2, x*y, x*y^2, x^2, x^2*y, x^2*y^2, x^2*y^3, x^3*y^2, x^3*y^3]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">=</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">sage: </span><span class="n">differential_basis_baker</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">differential_basis_baker</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.integer_matrix_relations">
<code class="descclassname">sage.schemes.riemann_surfaces.riemann_surface.</code><code class="descname">integer_matrix_relations</code><span class="sig-paren">(</span><em>M1</em>, <em>M2</em>, <em>b=None</em>, <em>r=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.integer_matrix_relations" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine integer relations between complex matrices.</p>
<p>Given two square matrices with complex entries of size g, h respectively,
numerically determine an (approximate) ZZ-basis for the 2g x 2h matrices
with integer entries of the shape (D, B; C, A) such that B+M1*A=(D+M1*C)*M2.
By considering real and imaginary parts separately we obtain <span class="math notranslate nohighlight">\(2gh\)</span> equations
with real coefficients in <span class="math notranslate nohighlight">\(4gh\)</span> variables. We scale the coefficients by a
constant <span class="math notranslate nohighlight">\(2^b\)</span> and round them to integers, in order to obtain an integer
system of equations. Standard application of LLL allows us to determine near
solutions.</p>
<p>The user can specify the parameter <span class="math notranslate nohighlight">\(b\)</span>, but by default the system will
choose a <span class="math notranslate nohighlight">\(b\)</span> based on the size of the coefficients and the precision with
which they are given.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">M1</span></code> – square complex valued matrix</li>
<li><code class="docutils literal notranslate"><span class="pre">M2</span></code> – square complex valued matrix of same size as M1</li>
<li><code class="docutils literal notranslate"><span class="pre">b</span></code> – integer (default provided). The equation coefficients are scaled
by <span class="math notranslate nohighlight">\(2^b\)</span> before rounding to integers.</li>
<li><code class="docutils literal notranslate"><span class="pre">r</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">b/4</span></code>). The vectors found by LLL that satisfy
the scaled equations to withing <span class="math notranslate nohighlight">\(2^r\)</span> are reported as solutions.</li>
</ul>
<p>OUTPUT:</p>
<p>A list of 2g x 2h integer matrices that, for large enough <span class="math notranslate nohighlight">\(r\)</span>, <span class="math notranslate nohighlight">\(b-r\)</span>,
generate the ZZ-module of relevant transformations.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">integer_matrix_relations</span>
<span class="gp">sage: </span><span class="n">M1</span><span class="o">=</span><span class="n">M2</span><span class="o">=</span><span class="n">matrix</span><span class="p">(</span><span class="n">CC</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">=</span><span class="n">integer_matrix_relations</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span><span class="n">M2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">id</span><span class="o">=</span><span class="n">parent</span><span class="p">(</span><span class="n">M1</span><span class="p">)(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M1t</span><span class="o">=</span><span class="p">[</span><span class="nb">id</span><span class="o">.</span><span class="n">augment</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">T</span><span class="p">]</span>
<span class="gp">sage: </span><span class="p">[((</span><span class="n">m</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">m</span><span class="p">)[:,</span><span class="mi">2</span><span class="p">:]</span><span class="o">-</span><span class="n">M2</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-13</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">M1t</span><span class="p">]</span>
<span class="go">[True, True]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.numerical_inverse">
<code class="descclassname">sage.schemes.riemann_surfaces.riemann_surface.</code><code class="descname">numerical_inverse</code><span class="sig-paren">(</span><em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.numerical_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute numerical inverse of a matrix via LU decomposition</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">C</span></code> – A real or complex invertible square matrix</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">=</span><span class="n">matrix</span><span class="p">(</span><span class="n">CC</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,[</span><span class="o">-</span><span class="mf">4.5606e-31</span> <span class="o">+</span> <span class="mf">1.2326e-31</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>
<span class="go">....: -0.21313 + 0.24166*I,</span>
<span class="go">....: -3.4513e-31 + 0.16111*I,</span>
<span class="go">....: -1.0175 + 9.8608e-32*I,</span>
<span class="go">....: 0.30912 + 0.19962*I,</span>
<span class="go">....: -4.9304e-32 + 0.39923*I,</span>
<span class="go">....: 0.96793 - 3.4513e-31*I,</span>
<span class="go">....: -0.091587 + 0.19276*I,</span>
<span class="go">....: 3.9443e-31 + 0.38552*I])</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">numerical_inverse</span>
<span class="gp">sage: </span><span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="n">C</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">C</span><span class="o">-</span><span class="n">C</span><span class="o">^</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="n">numerical_inverse</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">*</span><span class="n">C</span><span class="o">-</span><span class="n">C</span><span class="o">^</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.schemes.riemann_surfaces.riemann_surface.voronoi_ghost">
<code class="descclassname">sage.schemes.riemann_surfaces.riemann_surface.</code><code class="descname">voronoi_ghost</code><span class="sig-paren">(</span><em>cpoints</em>, <em>n=6</em>, <em>CC=Complex Double Field</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.voronoi_ghost" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a set of complex points to a list of real tuples <span class="math notranslate nohighlight">\((x,y)\)</span>, and
appends n points in a big circle around them.</p>
<p>The effect is that, with n &gt;= 3, a Voronoi decomposition will have only
finite cells around the original points. Furthermore, because the extra
points are placed on a circle centered on the average of the given points,
with a radius 3/2 times the largest distance between the center and the
given points, these finite cells form a simply connected region.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">cpoints</span></code> – a list of complex numbers</li>
</ul>
<p>OUTPUT:</p>
<p>A list of real tuples <span class="math notranslate nohighlight">\((x,y)\)</span> consisting of the original points and a set of
points which surround them.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">voronoi_ghost</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">*</span><span class="n">I</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">voronoi_ghost</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="c1"># abs tol 1e-6</span>
<span class="go">[(1.0, 1.0),</span>
<span class="go"> (1.0, -1.0),</span>
<span class="go"> (-1.0, 1.0),</span>
<span class="go"> (-1.0, -1.0),</span>
<span class="go"> (2.121320343559643, 0.0),</span>
<span class="go"> (1.0606601717798216, 1.8371173070873836),</span>
<span class="go"> (-1.060660171779821, 1.8371173070873839),</span>
<span class="go"> (-2.121320343559643, 2.59786816870648e-16),</span>
<span class="go"> (-1.0606601717798223, -1.8371173070873832),</span>
<span class="go"> (1.06066017177982, -1.8371173070873845)]</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="../plane_quartics/quartic_generic.html"
                        title="previous chapter">Plane quartic curves over a general ring</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../elliptic_curves/constructor.html"
                        title="next chapter">Elliptic curve constructor</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/sage/schemes/riemann_surfaces/riemann_surface.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../elliptic_curves/constructor.html" title="Elliptic curve constructor"
             >next</a> |</li>
        <li class="right" >
          <a href="../plane_quartics/quartic_generic.html" title="Plane quartic curves over a general ring"
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Plane curves</a> &#187;</li>
 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2019, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.6.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>