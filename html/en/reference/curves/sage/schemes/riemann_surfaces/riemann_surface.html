<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="../../../../genindex.html" /><link rel="search" title="Search" href="../../../../search.html" /><link rel="prev" title="Plane quartic curves over a general ring" href="../plane_quartics/quartic_generic.html" />

    <meta name="generator" content="sphinx-5.2.3, furo 2022.09.29"/>
        <title>Riemann matrices and endomorphism rings of algebraic Riemann surfaces - Curves</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo.css?digest=d81277517bee4d6b0349d71bb2661d4890b5617c" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/custom-furo.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">Curves</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../../_static/logo_sagemath_black.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../../_static/logo_sagemath_white.svg" alt="Dark Logo"/>
  </div>
  
      <span class="sidebar-brand-text">Sage 10.1 Reference Manual</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-home">
  <div class="sidebar-tree">
    <ul><li class="toctree-l1">
      <a class="reference internal" href="../../../index.html">Home - Curves</a>
    </li></ul>
  </div>
</div><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../curves/constructor.html">Curve constructor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../curves/curve.html">Base class of curves</a></li>
<li class="toctree-l1"><a class="reference internal" href="../curves/affine_curve.html">Affine curves</a></li>
<li class="toctree-l1"><a class="reference internal" href="../curves/projective_curve.html">Projective curves</a></li>
<li class="toctree-l1"><a class="reference internal" href="../curves/point.html">Rational points of curves</a></li>
<li class="toctree-l1"><a class="reference internal" href="../curves/closed_point.html">Closed points of integral curves</a></li>
<li class="toctree-l1"><a class="reference internal" href="../jacobians/abstract_jacobian.html">Jacobians of curves</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../plane_conics/constructor.html">Plane conic constructor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plane_conics/con_field.html">Projective plane conics over a field</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plane_conics/con_number_field.html">Projective plane conics over a number field</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plane_conics/con_rational_field.html">Projective plane conics over <span class="math notranslate nohighlight">\(\QQ\)</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="../plane_conics/con_finite_field.html">Projective plane conics over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plane_conics/con_rational_function_field.html">Projective plane conics over a rational function field</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../plane_quartics/quartic_constructor.html">Quartic curve constructor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plane_quartics/quartic_generic.html">Plane quartic curves over a general ring</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Riemann matrices and endomorphism rings of algebraic Riemann surfaces</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="riemann-matrices-and-endomorphism-rings-of-algebraic-riemann-surfaces">
<span id="sage-schemes-riemann-surfaces-riemann-surface"></span><h1>Riemann matrices and endomorphism rings of algebraic Riemann surfaces<a class="headerlink" href="#riemann-matrices-and-endomorphism-rings-of-algebraic-riemann-surfaces" title="Permalink to this heading">#</a></h1>
<span class="target" id="module-sage.schemes.riemann_surfaces.riemann_surface"></span><p>This module provides a class, <a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface"><code class="xref py py-class docutils literal notranslate"><span class="pre">RiemannSurface</span></code></a>, to model the
Riemann surface determined by a plane algebraic curve over a subfield
of the complex numbers.</p>
<p>A homology basis is derived from the edges of a Voronoi cell decomposition based
on the branch locus. The pull-back of these edges to the Riemann surface
provides a graph on it that contains a homology basis.</p>
<p>The class provides methods for computing the Riemann period matrix of the
surface numerically, using a certified homotopy continuation method due to
<a class="reference internal" href="../../../../references/index.html#kr2016" id="id1"><span>[Kr2016]</span></a>.</p>
<p>The class also provides facilities for computing the endomorphism ring of the
period lattice numerically, by determining integer (near) solutions to the
relevant approximate linear equations.</p>
<p>One can also calculate the Abel-Jacobi map on the Riemann surface, and there
is basic functionality to interface with divisors of curves to facilitate this.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li><p>Alexandre Zotine, Nils Bruin (2017-06-10): initial version</p></li>
<li><p>Nils Bruin, Jeroen Sijsling (2018-01-05): algebraization, isomorphisms</p></li>
<li><p>Linden Disney-Hogg, Nils Bruin (2021-06-23): efficient integration</p></li>
<li><p>Linden Disney-Hogg, Nils Bruin (2022-09-07): Abel-Jacobi map</p></li>
</ul>
<p>EXAMPLES:</p>
<p>We compute the Riemann matrix of a genus 3 curve:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">4</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">-</span><span class="n">y</span><span class="o">^</span><span class="mi">3</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>
</pre></div>
</div>
<p>We test the usual properties, i.e., that the period matrix is symmetric and that
the imaginary part is positive definite:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-20</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="n">M</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">iM</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,[</span><span class="n">a</span><span class="o">.</span><span class="n">imag_part</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">list</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="n">iM</span><span class="o">.</span><span class="n">is_positive_definite</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We compute the endomorphism ring and check it has <span class="math notranslate nohighlight">\(\ZZ\)</span>-rank 6:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">endomorphism_basis</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In fact it is an order in a number field:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span><span class="o">.&lt;</span><span class="n">t</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">t</span><span class="o">^</span><span class="mi">6</span> <span class="o">-</span> <span class="n">t</span><span class="o">^</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">t</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="n">t</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">minpoly</span><span class="p">()</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">K</span><span class="p">))</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">minpoly</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can look at an extended example of the Abel-Jacobi functionality. We will
demonstrate a particular half-canonical divisor on Klein’s Curve, known in
the literature:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">y</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">integration_method</span><span class="o">=</span><span class="s1">&#39;rigorous&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BL</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">places_at_branch_locus</span><span class="p">();</span> <span class="n">BL</span>
<span class="go">[Place (x, y, y^2),</span>
<span class="go"> Place (x^7 + 27/4, y + 4/9*x^5, y^2 + 4/3*x^3),</span>
<span class="go"> Place (x^7 + 27/4, y - 2/9*x^5, y^2 + 1/3*x^3)]</span>
</pre></div>
</div>
<p>We can read off out the output of <code class="docutils literal notranslate"><span class="pre">places_at_branch_locus</span></code> to choose our
divisor, and we can calculate the canonical divisor using curve functionality:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P0</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="n">BL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.curves.constructor</span> <span class="kn">import</span> <span class="n">Curve</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Curve</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">function_field</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">differential</span><span class="p">())</span><span class="o">.</span><span class="n">divisor</span><span class="p">()</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">divisor</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Pinf</span><span class="p">,</span> <span class="n">Pinf_prime</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">places_at_infinity</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">if</span> <span class="n">K</span><span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">Pinf</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">Pinf_prime</span><span class="p">:</span> <span class="n">Pinf</span><span class="p">,</span> <span class="n">Pinf_prime</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pinf_prime</span><span class="p">,</span> <span class="n">Pinf</span><span class="p">);</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">P0</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">Pinf</span> <span class="o">-</span> <span class="n">Pinf_prime</span>
</pre></div>
</div>
<p>Note we could check using exact techniques that <span class="math notranslate nohighlight">\(2D = K\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">K</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">D</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">basis_differential_space</span><span class="p">())</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">genus</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">basis_function_space</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(True, True, True)</span>
</pre></div>
</div>
<p>We can also check this using our Abel-Jacobi functions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">avoid</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">places_at_infinity</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Zeq</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">strong_approximation</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">avoid</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Zlist</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">divisor_to_divisor_list</span><span class="p">(</span><span class="n">Zeq</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">AJ</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">abel_jacobi</span><span class="p">(</span><span class="n">Zlist</span><span class="p">)</span>  <span class="c1"># long time (1 second)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">reduce_over_period_lattice</span><span class="p">(</span><span class="n">AJ</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>  <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<p>The initial version of this code was developed alongside <a class="reference internal" href="../../../../references/index.html#bsz2019" id="id2"><span>[BSZ2019]</span></a>.</p>
<dl class="py exception">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.ConvergenceError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.</span></span><span class="sig-name descname"><span class="pre">ConvergenceError</span></span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.ConvergenceError" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/library/exceptions.html#ValueError" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></a></p>
<p>Error object suitable for raising and catching when Newton iteration fails.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">ConvergenceError</span>
<span class="gp">sage: </span><span class="k">raise</span> <span class="n">ConvergenceError</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ConvergenceError: test</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ConvergenceError</span><span class="p">(),</span><span class="ne">ValueError</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.</span></span><span class="sig-name descname"><span class="pre">RiemannSurface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">53</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">certification</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">differentials</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integration_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rigorous'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Construct a Riemann Surface. This is specified by the zeroes of a bivariate
polynomial with rational coefficients <span class="math notranslate nohighlight">\(f(z,w) = 0\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code> – a bivariate polynomial with rational coefficients. The surface is
interpreted as the covering space of the coordinate plane in the first
variable.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prec</span></code> – the desired precision of computations on the surface in bits
(default: 53)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">certification</span></code> – a boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) value indicating
whether homotopy continuation is certified or not. Uncertified
homotopy continuation can be faster.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">differentials</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>). If specified, provides a list
of polynomials <span class="math notranslate nohighlight">\(h\)</span> such that <span class="math notranslate nohighlight">\(h/(df/dw) dz\)</span> is a regular
differential on the Riemann surface. This is taken as a basis of
the regular differentials, so the genus is assumed to be equal
to the length of this list. The results from the homology basis
computation are checked against this value.  Providing this
parameter makes the computation independent from Singular.  For
a nonsingular plane curve of degree <span class="math notranslate nohighlight">\(d\)</span>, an appropriate set is
given by the monomials of degree up to <span class="math notranslate nohighlight">\(d-3\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integration_method</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'rigorous'</span></code>). String specifying the
integration method to use when calculating the integrals of differentials.
The options are <code class="docutils literal notranslate"><span class="pre">'heuristic'</span></code> and <code class="docutils literal notranslate"><span class="pre">'rigorous'</span></code>, the latter of
which is often the most efficient.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">Riemann surface defined by polynomial f = -z^3 + w^2 + 1 = 0, with 53 bits of precision</span>
</pre></div>
</div>
<p>Another Riemann surface with 100 bits of precision:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">100</span><span class="p">);</span> <span class="n">S</span>
<span class="go">Riemann surface defined by polynomial f = -z^3 + w^2 + 1 = 0, with 100 bits of precision</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span><span class="o">^</span><span class="mi">6</span> <span class="c1">#abs tol 0.00000001</span>
<span class="go">[1.0000000000000000000000000000 - 1.1832913578315177081175928479e-30*I]</span>
</pre></div>
</div>
<p>We can also work with Riemann surfaces that are defined over fields with a
complex embedding, but since the current interface for computing genus and
regular differentials in Singular presently does not support extensions of
<span class="math notranslate nohighlight">\(\QQ\)</span>, we need to specify a description of the differentials ourselves. We give
an example of a CM elliptic curve:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Qt</span><span class="o">.&lt;</span><span class="n">t</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">t</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">t</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span><span class="n">embedding</span><span class="o">=</span><span class="n">CC</span><span class="p">(</span><span class="mf">0.5</span><span class="o">+</span><span class="mf">1.6</span><span class="o">*</span><span class="n">I</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">K</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">endomorphism_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">minpoly</span><span class="p">()</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">K</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">A</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">'heuristic'</span></code> integration method uses the method <code class="docutils literal notranslate"><span class="pre">integrate_vector</span></code>
defined in <code class="docutils literal notranslate"><span class="pre">sage.numerical.gauss_legendre</span></code> to compute integrals of differentials.
As mentioned there, this works by iteratively doubling the number of nodes
used in the quadrature, and uses a heuristic based on the rate at which the
result is seemingly converging to estimate the error. The <code class="docutils literal notranslate"><span class="pre">'rigorous'</span></code>
method uses results from <a class="reference internal" href="../../../../references/index.html#neu2018" id="id3"><span>[Neu2018]</span></a>, and bounds the algebraic integrands on
circular domains using Cauchy’s form of the remainder in Taylor approximation
coupled to Fujiwara’s bound on polynomial roots (see Bruin-DisneyHogg-Gao,
in preparation). Note this method of bounding on circular domains is also
implemented in <code class="xref py py-meth docutils literal notranslate"><span class="pre">_compute_delta()</span></code>. The net result of this bounding is
that one can know (an upper bound on) the number of nodes required to achieve
a certain error. This means that for any given integral, assuming that the
same number of nodes is required by both methods in order to achieve the
desired error (not necessarily true in practice), approximately half
the number of integrand evaluations are required. When the required number
of nodes is high, e.g. when the precision required is high, this can make
the <code class="docutils literal notranslate"><span class="pre">'rigorous'</span></code> method much faster. However, the <code class="docutils literal notranslate"><span class="pre">'rigorous'</span></code> method does
not benefit as much from the caching of the <code class="docutils literal notranslate"><span class="pre">nodes</span></code> method over multiple
integrals. The result of this is that, for calls of <a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.matrix_of_integral_values" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.matrix_of_integral_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">matrix_of_integral_values()</span></code></a>
if the computation is ‘fast’, the heuristic method may outperform the
rigorous method, but for slower computations the rigorous method can be much
faster:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">z</span><span class="o">*</span><span class="n">w</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">w</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="mi">53</span>
<span class="gp">sage: </span><span class="n">Sh</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">integration_method</span><span class="o">=</span><span class="s1">&#39;heuristic&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Sr</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">integration_method</span><span class="o">=</span><span class="s1">&#39;rigorous&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.numerical.gauss_legendre</span> <span class="kn">import</span> <span class="n">nodes</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">time</span>
<span class="gp">sage: </span><span class="n">nodes</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ct</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Rh</span> <span class="o">=</span> <span class="n">Sh</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ct1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">ct</span>
<span class="gp">sage: </span><span class="n">nodes</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ct</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Rr</span> <span class="o">=</span> <span class="n">Sr</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ct2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">ct</span>
<span class="gp">sage: </span><span class="n">ct2</span><span class="o">/</span><span class="n">ct1</span>  <span class="c1"># random</span>
<span class="go">1.2429363969691192</span>
</pre></div>
</div>
<p>Note that for the above curve, the branch points are evenly distributed, and
hence the implicit assumptions in the heuristic method are more sensible,
meaning that a higher precision is required to see the heuristic method
being significantly slower than the rigorous method. For a worse conditioned
curve, this effect is more pronounced:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">10</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">q</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">q</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="mi">500</span>
<span class="gp">sage: </span><span class="n">Sh</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">integration_method</span><span class="o">=</span><span class="s1">&#39;heuristic&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Sr</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">integration_method</span><span class="o">=</span><span class="s1">&#39;rigorous&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">nodes</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Rh</span> <span class="o">=</span> <span class="n">Sh</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>  <span class="c1"># long time (8 seconds)</span>
<span class="gp">sage: </span><span class="n">nodes</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Rr</span> <span class="o">=</span> <span class="n">Sr</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>  <span class="c1"># long time (1 seconds)</span>
</pre></div>
</div>
<p>This disparity in timings can get increasingly worse, and testing has shown
that even for random quadrics the heuristic method can be as bad as 30 times
slower.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.abel_jacobi">
<span class="sig-name descname"><span class="pre">abel_jacobi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">divisor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.abel_jacobi" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Abel-Jacobi map of <code class="docutils literal notranslate"><span class="pre">divisor</span></code>.</p>
<p>Return a representative of the Abel-Jacobi map of a divisor with basepoint
<code class="docutils literal notranslate"><span class="pre">self._basepoint</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">divisor</span></code> – list. A list with each entry a tuple of the form <code class="docutils literal notranslate"><span class="pre">(v,</span> <span class="pre">P)</span></code>,
where <code class="docutils literal notranslate"><span class="pre">v</span></code> is the valuation of the divisor at point <code class="docutils literal notranslate"><span class="pre">P</span></code>, <code class="docutils literal notranslate"><span class="pre">P</span></code> as per
the input to <code class="xref py py-meth docutils literal notranslate"><span class="pre">_aj_based()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – logical (default: False). Whether to report the progress
of the computation, in terms of how many elements of the list <code class="docutils literal notranslate"><span class="pre">divisor</span></code>
have been completed.</p></li>
</ul>
<p>OUTPUT: A vector of length <code class="docutils literal notranslate"><span class="pre">self.genus</span></code>.</p>
<p>EXAMPLES:</p>
<p>We can test that the Abel-Jacobi map between two branchpoints of a
superelliptic curve of degree <span class="math notranslate nohighlight">\(p\)</span> is a <span class="math notranslate nohighlight">\(p\)</span>-torsion point in the Jacobian:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="n">p</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">divisor</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))]</span>
<span class="gp">sage: </span><span class="n">AJ</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">abel_jacobi</span><span class="p">(</span><span class="n">divisor</span><span class="p">)</span>  <span class="c1"># long time (15 seconds)</span>
<span class="gp">sage: </span><span class="n">AJxp</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">z</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">AJ</span><span class="p">]</span>  <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="nb">bool</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">reduce_over_period_lattice</span><span class="p">(</span><span class="n">AJxp</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span><span class="o">&lt;</span><span class="mf">1e-7</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.cohomology_basis">
<span class="sig-name descname"><span class="pre">cohomology_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">option</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.cohomology_basis" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the cohomology basis of this surface.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">option</span></code> – Presently, this routine uses Singular’s <code class="docutils literal notranslate"><span class="pre">adjointIdeal</span></code>
and passes the <code class="docutils literal notranslate"><span class="pre">option</span></code> parameter on. Legal values are 1, 2, 3 ,4,
where 1 is the default. See the Singular documentation for the
meaning. The backend for this function may change, and support for
this parameter may disappear.</p></li>
</ul>
<p>OUTPUT:</p>
<p>This returns a list of polynomials <span class="math notranslate nohighlight">\(g\)</span> representing the holomorphic
differentials <span class="math notranslate nohighlight">\(g/(df/dw) dz\)</span>, where <span class="math notranslate nohighlight">\(f(z,w)=0\)</span> is the equation
specifying the Riemann surface.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="n">w</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">cohomology_basis</span><span class="p">()</span>
<span class="go">[1, w, z]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.curve">
<span class="sig-name descname"><span class="pre">curve</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.curve" title="Permalink to this definition">#</a></dt>
<dd><p>Return the curve from which this Riemann surface is obtained.</p>
<p>Riemann surfaces explicitly obtained from a curve return that same object.
For others, the curve is constructed and cached, so that an identical curve is
returned upon subsequent calls.</p>
<p>OUTPUT: Curve from which Riemann surface is obtained.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Curve</span><span class="p">(</span> <span class="n">y</span><span class="o">^</span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">riemann_surface</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">curve</span><span class="p">()</span> <span class="ow">is</span> <span class="n">C</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.divisor_to_divisor_list">
<span class="sig-name descname"><span class="pre">divisor_to_divisor_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">divisor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.divisor_to_divisor_list" title="Permalink to this definition">#</a></dt>
<dd><p>Turn a divisor into a list for <a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.abel_jacobi" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.abel_jacobi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">abel_jacobi()</span></code></a>.</p>
<p>Given <code class="docutils literal notranslate"><span class="pre">divisor</span></code> in <code class="docutils literal notranslate"><span class="pre">Curve(self.f).function_field().divisor_group()</span></code>,
consisting of places above finite points in the base, return an equivalent
divisor list suitable for input into <code class="xref py py-meth docutils literal notranslate"><span class="pre">abel_jacboi()</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">divisor</span></code> – an element of <code class="docutils literal notranslate"><span class="pre">Curve(self.f).function_field().divisor_group()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eps</span></code> – real number (optional); tolerance used to determine whether a complex
number is close enough to a root of a polynomial</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list with elements of the form <code class="docutils literal notranslate"><span class="pre">(v,</span> <span class="pre">(z,</span> <span class="pre">w))</span></code> representing the finite places.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">places_at_branch_locus</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">divisor_to_divisor_list</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">[(1, (1.00000000000000, 0.000000000000000)),</span>
<span class="go"> (1, (-0.500000000000000 - 0.866025403784439*I, 0.000000000000000)),</span>
<span class="go"> (1, (-0.500000000000000 + 0.866025403784439*I, 0.000000000000000))]</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="id4">
<p class="admonition-title">Todo</p>
<p>Currently this method can only handle places above finite points in
the base. It would be useful to extend this to allow for places at
infinity.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.downstairs_edges">
<span class="sig-name descname"><span class="pre">downstairs_edges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.downstairs_edges" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the edgeset of the Voronoi diagram.</p>
<p>OUTPUT:</p>
<p>A list of integer tuples corresponding to edges between vertices in the
Voronoi diagram.</p>
<p>EXAMPLES:</p>
<p>Form a Riemann surface, one with a particularly simple branch locus:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute the edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">downstairs_edges</span><span class="p">()</span>
<span class="go">[(0, 1), (0, 5), (1, 4), (2, 3), (2, 4), (3, 5), (4, 5)]</span>
</pre></div>
</div>
<p>This now gives an edgeset which one could use to form a graph.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The numbering of the vertices is given by the Voronoi package.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.downstairs_graph">
<span class="sig-name descname"><span class="pre">downstairs_graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.downstairs_graph" title="Permalink to this definition">#</a></dt>
<dd><p>Return the Voronoi decomposition as a planar graph.</p>
<p>The result of this routine can be useful to interpret the labelling of
the vertices. See also <a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.upstairs_graph" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.upstairs_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">upstairs_graph()</span></code></a>.</p>
<p>OUTPUT:</p>
<p>The Voronoi decomposition as a graph, with appropriate planar embedding.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">downstairs_graph</span><span class="p">()</span>
<span class="go">Graph on 11 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.edge_permutations">
<span class="sig-name descname"><span class="pre">edge_permutations</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.edge_permutations" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the permutations of branches associated to each edge.</p>
<p>Over the vertices of the Voronoi decomposition around the branch locus,
we label the fibres. By following along an edge, the lifts of the edge
induce a permutation of that labelling.</p>
<p>OUTPUT:</p>
<p>A dictionary with as keys the edges of the Voronoi decomposition and as
values the corresponding permutations.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">edge_permutations</span><span class="p">()</span>
<span class="go">{(0, 2): (),</span>
<span class="go"> (0, 4): (),</span>
<span class="go"> (1, 2): (),</span>
<span class="go"> (1, 3): (0,1),</span>
<span class="go"> (1, 6): (),</span>
<span class="go"> (2, 0): (),</span>
<span class="go"> (2, 1): (),</span>
<span class="go"> (2, 5): (0,1),</span>
<span class="go"> (3, 1): (0,1),</span>
<span class="go"> (3, 4): (),</span>
<span class="go"> (4, 0): (),</span>
<span class="go"> (4, 3): (),</span>
<span class="go"> (5, 2): (0,1),</span>
<span class="go"> (5, 7): (),</span>
<span class="go"> (6, 1): (),</span>
<span class="go"> (6, 7): (),</span>
<span class="go"> (7, 5): (),</span>
<span class="go"> (7, 6): ()}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis">
<span class="sig-name descname"><span class="pre">endomorphism_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis" title="Permalink to this definition">#</a></dt>
<dd><p>Numerically compute a <span class="math notranslate nohighlight">\(\ZZ\)</span>-basis for the endomorphism ring.</p>
<p>Let <span class="math notranslate nohighlight">\(\left(I | M \right)\)</span> be the normalized period matrix (<span class="math notranslate nohighlight">\(M\)</span> is the
<span class="math notranslate nohighlight">\(g\times g\)</span> <a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.riemann_matrix" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.riemann_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">riemann_matrix()</span></code></a>). We consider the system of matrix
equations <span class="math notranslate nohighlight">\(MA + C = (MB + D)M\)</span> where <span class="math notranslate nohighlight">\(A, B, C, D\)</span> are <span class="math notranslate nohighlight">\(g\times g\)</span>
integer matrices.  We determine small integer (near) solutions using LLL
reductions.  These solutions are returned as <span class="math notranslate nohighlight">\(2g \times 2g\)</span> integer
matrices obtained by stacking <span class="math notranslate nohighlight">\(\left(D | B\right)\)</span> on top of <span class="math notranslate nohighlight">\(\left(C |
A\right)\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> – integer (default provided). The equation coefficients are
scaled by <span class="math notranslate nohighlight">\(2^b\)</span> before rounding to integers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">b/4</span></code>). Solutions that have all
coefficients smaller than <span class="math notranslate nohighlight">\(2^r\)</span> in absolute value are reported as
actual solutions.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of <span class="math notranslate nohighlight">\(2g \times 2g\)</span> integer matrices that, for large enough <code class="docutils literal notranslate"><span class="pre">r</span></code>
and <code class="docutils literal notranslate"><span class="pre">b-r</span></code>, generate the endomorphism ring.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">y</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">endomorphism_basis</span><span class="p">();</span> <span class="n">B</span> <span class="c1">#random</span>
<span class="go">[</span>
<span class="go">[1 0]  [ 0 -1]</span>
<span class="go">[0 1], [ 1  1]</span>
<span class="go">]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">minpoly</span><span class="p">()</span><span class="o">.</span><span class="n">disc</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">B</span><span class="p">])</span>
<span class="go">[-3, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homology_basis">
<span class="sig-name descname"><span class="pre">homology_basis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homology_basis" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the homology basis of the Riemann surface.</p>
<p>OUTPUT:</p>
<p>A list of paths <span class="math notranslate nohighlight">\(L = [P_1, \dots, P_n]\)</span>. Each path <span class="math notranslate nohighlight">\(P_i\)</span> is of the form
<span class="math notranslate nohighlight">\((k, [p_1 ... p_m, p_1])\)</span>, where <span class="math notranslate nohighlight">\(k\)</span> is the number of times to traverse
the path (if negative, to traverse it backwards), and the <span class="math notranslate nohighlight">\(p_i\)</span> are
vertices of the upstairs graph.</p>
<p>EXAMPLES:</p>
<p>In this example, there are two paths that form the homology basis:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">homology_basis</span><span class="p">()</span>  <span class="c1"># random</span>
<span class="go">[[(1, [(3, 1), (5, 0), (9, 0), (10, 0), (2, 0), (4, 0),</span>
<span class="go">    (7, 1), (10, 1), (3, 1)])],</span>
<span class="go"> [(1, [(8, 0), (6, 0), (7, 0), (10, 0), (2, 0), (4, 0),</span>
<span class="go">    (7, 1), (10, 1), (9, 1), (8, 0)])]]</span>
</pre></div>
</div>
<p>In order to check that the answer returned above is reasonable, we
test some basic properties. We express the faces of the downstairs graph
as ZZ-linear combinations of the edges and check that the projection
of the homology basis upstairs projects down to independent linear
combinations of an even number of faces:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dg</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">downstairs_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">edges</span> <span class="o">=</span> <span class="n">dg</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">^</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edge_to_E</span> <span class="o">=</span> <span class="p">{</span> <span class="n">e</span><span class="p">[:</span><span class="mi">2</span><span class="p">]:</span> <span class="n">E</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">)}</span>
<span class="gp">sage: </span><span class="n">edge_to_E</span><span class="o">.</span><span class="n">update</span><span class="p">({</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span> <span class="o">-</span><span class="n">E</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">face_span</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">submodule</span><span class="p">([</span><span class="nb">sum</span><span class="p">(</span><span class="n">edge_to_E</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">dg</span><span class="o">.</span><span class="n">faces</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">path_to_E</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">k</span><span class="p">,</span><span class="n">P</span> <span class="o">=</span> <span class="n">path</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">k</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">edge_to_E</span><span class="p">[(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">hom_basis</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">path_to_E</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">loop</span><span class="p">)</span> <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">homology_basis</span><span class="p">()]</span>
<span class="gp">sage: </span><span class="n">face_span</span><span class="o">.</span><span class="n">submodule</span><span class="p">(</span><span class="n">hom_basis</span><span class="p">)</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">face_span</span><span class="o">.</span><span class="n">coordinate_vector</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">%</span><span class="k">2</span> for b in hom_basis]
<span class="go">[0, 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis">
<span class="sig-name descname"><span class="pre">homomorphism_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="Permalink to this definition">#</a></dt>
<dd><p>Numerically compute a <span class="math notranslate nohighlight">\(\ZZ\)</span>-basis for module of homomorphisms to a given
complex torus.</p>
<p>Given another complex torus (given as the analytic Jacobian of a Riemann
surface), numerically compute a basis for the homomorphism module. The
answer is returned as a list of <span class="math notranslate nohighlight">\(2g \times 2g\)</span> integer matrices <span class="math notranslate nohighlight">\(T=(D, B; C, A)\)</span>
such that if the columns of <span class="math notranslate nohighlight">\((I|M_1)\)</span> generate the lattice defining the
Jacobian of the Riemann surface and the columns of <span class="math notranslate nohighlight">\((I|M_2)\)</span> do this for
the codomain, then approximately we have <span class="math notranslate nohighlight">\((I|M_2)T=(D+M_2C)(I|M_1)\)</span>, i.e., up
to a choice of basis for <span class="math notranslate nohighlight">\(\CC^g\)</span> as a complex vector space, we we
realize <span class="math notranslate nohighlight">\((I|M_1)\)</span> as a sublattice of <span class="math notranslate nohighlight">\((I|M_2)\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> – integer (default provided). The equation coefficients are
scaled by <span class="math notranslate nohighlight">\(2^b\)</span> before rounding to integers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">b/4</span></code>). Solutions that have all
coefficients smaller than <span class="math notranslate nohighlight">\(2^r\)</span> in absolute value are reported as
actual solutions.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of <span class="math notranslate nohighlight">\(2g \times 2g\)</span> integer matrices that, for large enough <code class="docutils literal notranslate"><span class="pre">r</span></code>
and <code class="docutils literal notranslate"><span class="pre">b-r</span></code>, generate the homomorphism module.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;11a1&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">riemann_surface</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;11a3&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">riemann_surface</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">det</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">S1</span><span class="o">.</span><span class="n">homomorphism_basis</span><span class="p">(</span><span class="n">S2</span><span class="p">)]</span>
<span class="go">[5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homotopy_continuation">
<span class="sig-name descname"><span class="pre">homotopy_continuation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homotopy_continuation" title="Permalink to this definition">#</a></dt>
<dd><p>Perform homotopy continuation along an edge of the Voronoi diagram using
Newton iteration.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">edge</span></code> – a tuple <code class="docutils literal notranslate"><span class="pre">(z_start,</span> <span class="pre">z_end)</span></code> indicating the straight line
over which to perform the homotopy continutation</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list containing the initialised continuation data. Each entry in the
list contains: the <span class="math notranslate nohighlight">\(t\)</span> values that entry corresponds to, a list of
complex numbers corresponding to the points which are reached when
continued along the edge when traversing along the direction of the
edge, and a value <code class="docutils literal notranslate"><span class="pre">epsilon</span></code> giving the minimumdistance between the
fibre values divided by 3. The ordering of these points indicates how
they have been permuted due to the weaving of the curve.</p>
<p>EXAMPLES:</p>
<p>We check that continued values along an edge correspond (up to the
appropriate permutation) to what is stored. Note that the permutation
was originally computed from this data:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="n">w</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edge1</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">edge_permutations</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">edge_permutations</span><span class="p">()[</span><span class="n">edge1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">edge</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">edge1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">continued_values</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">homotopy_continuation</span><span class="p">(</span><span class="n">edge</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">stored_values</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">w_values</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">edge1</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">continued_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">stored_values</span><span class="p">[</span><span class="n">sigma</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span> <span class="o">&lt;</span> <span class="mf">1e-8</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.make_zw_interpolator">
<span class="sig-name descname"><span class="pre">make_zw_interpolator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">upstairs_edge</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_continuation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.make_zw_interpolator" title="Permalink to this definition">#</a></dt>
<dd><p>Given a downstairs edge for which continuation data has been initialised,
return a function that computes <span class="math notranslate nohighlight">\(z(t), w(t)\)</span> , where <span class="math notranslate nohighlight">\(t\)</span> in <span class="math notranslate nohighlight">\([0,1]\)</span> is a
parametrization of the edge.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">upstairs_edge</span></code> – tuple <code class="docutils literal notranslate"><span class="pre">((z_start,</span> <span class="pre">sb),</span> <span class="pre">(z_end,))</span></code> giving the
start and end values of the base coordinate along the straight-line
path and the starting branch</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_continuation</span></code> – list (optional);  output of
<code class="docutils literal notranslate"><span class="pre">homotopy_continuation</span></code> initialising the continuation data</p></li>
</ul>
<p>OUTPUT:</p>
<p>A tuple <code class="docutils literal notranslate"><span class="pre">(g,</span> <span class="pre">d)</span></code>, where <code class="docutils literal notranslate"><span class="pre">g</span></code> is the function that computes the interpolation
along the edge and <code class="docutils literal notranslate"><span class="pre">d</span></code> is the difference of the z-values of the end and
start point.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">_</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">homology_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">u_edge</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">d_edge</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">u_edge</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">u_edge</span> <span class="o">=</span> <span class="p">[(</span><span class="n">S</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">u_edge</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">initial_continuation</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">_L</span><span class="p">[</span><span class="n">d_edge</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">make_zw_interpolator</span><span class="p">(</span><span class="n">u_edge</span><span class="p">,</span> <span class="n">initial_continuation</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mf">0.1</span><span class="p">))</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-13</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">abs</span><span class="p">((</span><span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">g</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-13</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The interpolator returned by this method can effectively hang if
either <code class="docutils literal notranslate"><span class="pre">z_start</span></code> or <code class="docutils literal notranslate"><span class="pre">z_end</span></code> are branchpoints. In these situations
it is better to take a different approach rather than continue to use
the interpolator.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.matrix_of_integral_values">
<span class="sig-name descname"><span class="pre">matrix_of_integral_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">differentials</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integration_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'heuristic'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.matrix_of_integral_values" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the path integrals of the given differentials along the homology
basis.</p>
<p>The returned answer has a row for each differential. If the Riemann
surface is given by the equation <span class="math notranslate nohighlight">\(f(z,w)=0\)</span>, then the differentials are
encoded by polynomials g, signifying the differential <span class="math notranslate nohighlight">\(g(z,w)/(df/dw)
dz\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">differentials</span></code> – a list of polynomials.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">integration_method</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'heuristic'</span></code>). String specifying
the integration method to use. The options are <code class="docutils literal notranslate"><span class="pre">'heuristic'</span></code> and
<code class="docutils literal notranslate"><span class="pre">'rigorous'</span></code>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A matrix, one row per differential, containing the values of the path
integrals along the homology basis of the Riemann surface.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">y</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">cohomology_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">matrix_of_integral_values</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">Full MatrixSpace of 1 by 2 dense matrices over Complex Field with 53 bits of precision</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">algdep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="c1"># curve is CM, so the period is quadratic</span>
<span class="go">2</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">differentials</span> <span class="pre">is</span> <span class="pre">self.cohomology_basis()</span></code>, the calculations
of the integrals along the edges are written to <code class="docutils literal notranslate"><span class="pre">self._integral_dict</span></code>.
This is as this data will be required when computing the Abel-Jacobi
map, and so it is helpful to have is stored rather than recomputing.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.monodromy_group">
<span class="sig-name descname"><span class="pre">monodromy_group</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.monodromy_group" title="Permalink to this definition">#</a></dt>
<dd><p>Compute local monodromy generators of the Riemann surface.</p>
<p>For each branch point, the local monodromy is encoded by a permutation.
The permutations returned correspond to positively oriented loops around
each branch point, with a fixed base point. This means the generators
are properly conjugated to ensure that together they generate the global
monodromy. The list has an entry for every finite point stored in
<code class="docutils literal notranslate"><span class="pre">self.branch_locus</span></code>, plus an entry for the ramification above infinity.</p>
<p>OUTPUT:</p>
<p>A list of permutations, encoding the local monodromy at each branch
point.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span> <span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="n">w</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">monodromy_group</span><span class="p">();</span> <span class="n">G</span>
<span class="go">[(0,1,2), (0,1), (0,2), (1,2), (1,2), (1,2), (0,1), (0,2), (0,2)]</span>
</pre></div>
</div>
<p>The permutations give the local monodromy generators for the branch
points:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">branch_locus</span> <span class="o">+</span> <span class="p">[</span><span class="n">unsigned_infinity</span><span class="p">],</span> <span class="n">G</span><span class="p">))</span> <span class="c1">#abs tol 0.0000001</span>
<span class="go">[(0.000000000000000, (0,1,2)),</span>
<span class="go"> (-1.31362670141929, (0,1)),</span>
<span class="go"> (-0.819032851784253 - 1.02703471138023*I, (0,2)),</span>
<span class="go"> (-0.819032851784253 + 1.02703471138023*I, (1,2)),</span>
<span class="go"> (0.292309440469772 - 1.28069133740100*I, (1,2)),</span>
<span class="go"> (0.292309440469772 + 1.28069133740100*I, (1,2)),</span>
<span class="go"> (1.18353676202412 - 0.569961265016465*I, (0,1)),</span>
<span class="go"> (1.18353676202412 + 0.569961265016465*I, (0,2)),</span>
<span class="go"> (Infinity, (0,2))]</span>
</pre></div>
</div>
<p>We can check the ramification by looking at the cycle lengths and verify
it agrees with the Riemann-Hurwitz formula:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">genus</span><span class="o">-</span><span class="mi">2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">degree</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">G</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">cycle_type</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.period_matrix">
<span class="sig-name descname"><span class="pre">period_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.period_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the period matrix of the surface.</p>
<p>OUTPUT:</p>
<p>A matrix of complex values.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="n">w</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span>
</pre></div>
</div>
<p>The results are highly arbitrary, so it is hard to check if the result
produced is correct. The closely related <code class="docutils literal notranslate"><span class="pre">riemann_matrix</span></code> is somewhat
easier to test.:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="go">Full MatrixSpace of 3 by 6 dense matrices over Complex Field with 30 bits of precision</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>One can check that the two methods give similar answers:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">integration_method</span><span class="o">=</span><span class="s2">&quot;rigorous&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">integration_method</span><span class="o">=</span><span class="s2">&quot;heuristic&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RM_S</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">RM_T</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">RM_S</span><span class="o">-</span><span class="n">RM_T</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.places_at_branch_locus">
<span class="sig-name descname"><span class="pre">places_at_branch_locus</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.places_at_branch_locus" title="Permalink to this definition">#</a></dt>
<dd><p>Return the places above the branch locus.</p>
<p>Return a list of the of places above the branch locus. This must be
done over the base ring, and so the places are given in terms of the
factors of the discriminant. Currently, this method only works when
<code class="docutils literal notranslate"><span class="pre">self._R.base_ring()</span> <span class="pre">==</span> <span class="pre">QQ</span></code> as for other rings, the function field
for <code class="docutils literal notranslate"><span class="pre">Curve(self.f)</span></code> is not implemented. To go from these divisors to
a divisor list, see <a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.divisor_to_divisor_list" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.divisor_to_divisor_list"><code class="xref py py-meth docutils literal notranslate"><span class="pre">divisor_to_divisor_list()</span></code></a>.</p>
<p>OUTPUT:</p>
<p>List of places of the functions field <code class="docutils literal notranslate"><span class="pre">Curve(self.f).function_field()</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="mi">25</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span><span class="o">+</span><span class="n">y</span><span class="o">^</span><span class="mi">4</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">34</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">places_at_branch_locus</span><span class="p">()</span>
<span class="go">[Place (x - 2, (x - 2)*y, y^2 - 17/5, y^3 - 17/5*y),</span>
<span class="go"> Place (x + 2, (x + 2)*y, y^2 - 17/5, y^3 - 17/5*y),</span>
<span class="go"> Place (x - 1/2, (x - 1/2)*y, y^2 - 17/20, y^3 - 17/20*y),</span>
<span class="go"> Place (x + 1/2, (x + 1/2)*y, y^2 - 17/20, y^3 - 17/20*y),</span>
<span class="go"> Place (x^4 - 34/25*x^2 + 1, y, y^2, y^3),</span>
<span class="go"> Place (x^4 - 34/25*x^2 + 1, (x^4 - 34/25*x^2 + 1)*y, y^2 - 34/25*x^2 - 34/25, y^3 + (-34/25*x^2 - 34/25)*y)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.plot_paths">
<span class="sig-name descname"><span class="pre">plot_paths</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.plot_paths" title="Permalink to this definition">#</a></dt>
<dd><p>Make a graphical representation of the integration paths.</p>
<p>This returns a two dimensional plot containing the branch points (in red) and
the integration paths (obtained from the Voronoi cells of the branch
points). The integration paths are plotted by plotting the points that
have been computed for homotopy continuation, so the density gives an
indication of where numerically sensitive features occur.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">plot_paths</span><span class="p">()</span>
<span class="go">Graphics object consisting of 2 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.plot_paths3d">
<span class="sig-name descname"><span class="pre">plot_paths3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thickness</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.plot_paths3d" title="Permalink to this definition">#</a></dt>
<dd><p>Return the homology basis as a graph in 3-space.</p>
<p>The homology basis of the surface is constructed by taking the Voronoi
cells around the branch points and taking the inverse image of the edges
on the Riemann surface. If the surface is given by the equation
<span class="math notranslate nohighlight">\(f(z,w)\)</span>, the returned object gives the image of this graph in 3-space
with coordinates <span class="math notranslate nohighlight">\(\left(\operatorname{Re}(z), \operatorname{Im}(z),
\operatorname{Im}(w)\right)\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">plot_paths3d</span><span class="p">()</span>
<span class="go">Graphics3d Object</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.reduce_over_period_lattice">
<span class="sig-name descname"><span class="pre">reduce_over_period_lattice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ip'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalised</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.reduce_over_period_lattice" title="Permalink to this definition">#</a></dt>
<dd><p>Reduce a vector over the period lattice.</p>
<p>Given a vector of length <code class="docutils literal notranslate"><span class="pre">self.genus</span></code>, this method returns a vector
in the same orbit of the period lattice that is short. There are two
possible methods, <code class="docutils literal notranslate"><span class="pre">'svp'</span></code> which returns a certified shortest vector,
but can be much slower for higher genus curves, and <code class="docutils literal notranslate"><span class="pre">'ip'</span></code>, which is
faster but not guaranteed to return the shortest vector. In general the
latter will perform well when the lattice basis vectors are of similar
size.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vector</span></code> – vector. A vector of length <code class="docutils literal notranslate"><span class="pre">self.genus</span></code> to reduce over
the lattice.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">method</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'ip'</span></code>). String specifying the method
to use to reduce the vector. THe options are <code class="docutils literal notranslate"><span class="pre">'ip'</span></code> and <code class="docutils literal notranslate"><span class="pre">'svp'</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> – integer (default provided): as for
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a>, and used in its invocation if
(re)calculating said basis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">b/4</span></code>).  as for
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a>, and used in its invocation if
(re)calculating said basis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">normalised</span></code> – logical (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>). Whether to use the
period matrix with the differentials normalised s.t. the <span class="math notranslate nohighlight">\(A\)</span>-matrix
is the identity.</p></li>
</ul>
<p>OUTPUT:</p>
<p>Complex vector of length <code class="docutils literal notranslate"><span class="pre">self.genus</span></code> in the same orbit as <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the lattice.</p>
<p>EXAMPLES:</p>
<p>We can check that the lattice basis vectors themselves are reduced to
zero:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">5</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">epsilon</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">_RR</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">S</span><span class="o">.</span><span class="n">_prec</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">vector</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">columns</span><span class="p">():</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">reduce_over_period_lattice</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span><span class="o">&lt;</span><span class="n">epsilon</span><span class="p">))</span>
<span class="go">True</span>
<span class="go">True</span>
<span class="go">True</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can also check that the method <code class="docutils literal notranslate"><span class="pre">'svp'</span></code> always gives a smaller norm
than <code class="docutils literal notranslate"><span class="pre">'ip'</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">vector</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">columns</span><span class="p">():</span>
<span class="gp">....: </span>    <span class="n">n1</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">reduce_over_period_lattice</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="n">n2</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">reduce_over_period_lattice</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;svp&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">n2</span><span class="o">&lt;=</span><span class="n">n1</span><span class="p">))</span>
<span class="go">True</span>
<span class="go">True</span>
<span class="go">True</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.riemann_matrix">
<span class="sig-name descname"><span class="pre">riemann_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.riemann_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the Riemann matrix.</p>
<p>OUTPUT:</p>
<p>A matrix of complex values.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="n">w</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>
</pre></div>
</div>
<p>The Klein quartic has a Riemann matrix with values in a quadratic
field:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">algdep</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">K</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.rigorous_line_integral">
<span class="sig-name descname"><span class="pre">rigorous_line_integral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">upstairs_edge</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">differentials</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounding_data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.rigorous_line_integral" title="Permalink to this definition">#</a></dt>
<dd><p>Perform vectorized integration along a straight path.</p>
<p>Using the error bounds for Gauss-Legendre integration found in <a class="reference internal" href="../../../../references/index.html#neu2018" id="id5"><span>[Neu2018]</span></a>
and a method for bounding an algebraic integrand on a circular domains
using Cauchy’s form of the remainder in Taylor approximation coupled to
Fujiwara’s bound on polynomial roots (see Bruin-DisneyHogg-Gao, in
preparation), this method calculates (semi-)rigorously the integral of a
list of differentials along an edge of the upstairs graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">upstairs_edge</span></code> – tuple. Either a pair of integer tuples
corresponding to an edge of the upstairs graph, or a tuple
<code class="docutils literal notranslate"><span class="pre">((z_start,</span> <span class="pre">sb),</span> <span class="pre">(z_end,</span> <span class="pre">))</span></code> as in the input of
<code class="docutils literal notranslate"><span class="pre">make_zw_interpolator</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">differentials</span></code> – a list of polynomials; a polynomial <span class="math notranslate nohighlight">\(g\)</span>
represents the differential <span class="math notranslate nohighlight">\(g(z,w)/(df/dw) dz\)</span> where <span class="math notranslate nohighlight">\(f(z,w)=0\)</span> is
the equation defining the Riemann surface.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bounding_data</span></code> – tuple containing the data required for bounding
the integrands. This should be in the form of the output from
<code class="xref py py-meth docutils literal notranslate"><span class="pre">_bounding_data()</span></code>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A complex number, the value of the line integral.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">);</span> <span class="n">S</span>
<span class="go">Riemann surface defined by polynomial f = -z^4 + w^2 + 1 = 0, with 53 bits of precision</span>
</pre></div>
</div>
<p>Since we make use of data from homotopy continuation, we need to compute
the necessary data:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">_</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">homology_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">differentials</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">cohomology_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bounding_data</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">_bounding_data</span><span class="p">(</span><span class="n">differentials</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">rigorous_line_integral</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="n">differentials</span><span class="p">,</span> <span class="n">bounding_data</span><span class="p">)</span>  <span class="c1"># abs tol 1e-10</span>
<span class="go">(1.80277751848459e-16 - 0.352971844594760*I)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Uses data that <code class="docutils literal notranslate"><span class="pre">homology_basis</span></code> initializes, and may give incorrect
values if <a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homology_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homology_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology_basis()</span></code></a> has not initialized them.</p>
<p>Note also that the data of the differentials is contained within
<code class="docutils literal notranslate"><span class="pre">bounding_data</span></code>. It is, however, still advantageous to have this
be a separate argument, as it lets the user supply a fast-callable
version of the differentials, to significantly speed up execution
of the integrand calls, and not have to re-calculate these
fast-callables for every run of the function. This is also the benefit
of representing the  differentials as a polynomial over a known
common denominator.</p>
</div>
<div class="admonition-todo admonition" id="id7">
<p class="admonition-title">Todo</p>
<p>Note that bounding_data contains the information of the integrands,
so one may want to check for consistency between <code class="docutils literal notranslate"><span class="pre">bounding_data</span></code>
and <code class="docutils literal notranslate"><span class="pre">differentials</span></code>. If so one would not want to do so at the
expense of speed.</p>
<p>Moreover, the current implementation bounds along a line by
splitting it up into segments, each of which can be covered entirely
by a single circle, and then placing inside that the ellipse
required to bound as per <a class="reference internal" href="../../../../references/index.html#neu2018" id="id6"><span>[Neu2018]</span></a>. This is reliably more efficient
than the heuristic method, especially in poorly-conditioned cases
where discriminant points are close together around the edges, but
in the case where the branch locus is well separated, it can require
slightly more nodes than necessary. One may want to include a method
here to transition in this regime to an algorithm that covers the
entire line with one ellipse, then bounds along that ellipse with
multiple circles.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.rosati_involution">
<span class="sig-name descname"><span class="pre">rosati_involution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.rosati_involution" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the Rosati involution of an endomorphism.</p>
<p>The endomorphism in question should be given by its homology
representation with respect to the symplectic basis of the Jacobian.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">R</span></code> – integral matrix.</p></li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the Rosati involution to <code class="docutils literal notranslate"><span class="pre">R</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span> <span class="n">prec</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Rs</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">endomorphism_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">rosati_involution</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">rosati_involution</span><span class="p">(</span><span class="n">Rs</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">==</span> <span class="n">Rs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.simple_vector_line_integral">
<span class="sig-name descname"><span class="pre">simple_vector_line_integral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">upstairs_edge</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">differentials</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.simple_vector_line_integral" title="Permalink to this definition">#</a></dt>
<dd><p>Perform vectorized integration along a straight path.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">upstairs_edge</span></code> – tuple. Either a pair of integer tuples
corresponding to an edge of the upstairs graph, or a tuple
<code class="docutils literal notranslate"><span class="pre">((z_start,</span> <span class="pre">sb),</span> <span class="pre">(z_end,</span> <span class="pre">))</span></code> as in the input of
<code class="docutils literal notranslate"><span class="pre">make_zw_interpolator</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">differentials</span></code> – a list of polynomials; a polynomial <span class="math notranslate nohighlight">\(g\)</span>
represents the differential <span class="math notranslate nohighlight">\(g(z,w)/(df/dw) dz\)</span> where <span class="math notranslate nohighlight">\(f(z,w)=0\)</span> is
the equation defining the Riemann surface.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A complex number, the value of the line integral.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">);</span> <span class="n">S</span>
<span class="go">Riemann surface defined by polynomial f = -z^4 + w^2 + 1 = 0, with 53 bits of precision</span>
</pre></div>
</div>
<p>Since we make use of data from homotopy continuation, we need to compute
the necessary data:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">differentials</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">cohomology_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">simple_vector_line_integral</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">differentials</span><span class="p">)</span> <span class="c1">#abs tol 0.00000001</span>
<span class="go">(1.14590610929717e-16 - 0.352971844594760*I)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Uses data that <a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homology_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homology_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology_basis()</span></code></a> initializes, and may give incorrect
values if <a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homology_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homology_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology_basis()</span></code></a> has not initialized them. In practice
it is more efficient to set <code class="docutils literal notranslate"><span class="pre">differentials</span></code> to a fast-callable version
of differentials to speed up execution.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.strong_approximation">
<span class="sig-name descname"><span class="pre">strong_approximation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">divisor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.strong_approximation" title="Permalink to this definition">#</a></dt>
<dd><p>Apply the method of strong approximation to a divisor.</p>
<p>As described in <a class="reference internal" href="../../../../references/index.html#neu2018" id="id8"><span>[Neu2018]</span></a>, apply the method of strong approximation to
<code class="docutils literal notranslate"><span class="pre">divisor</span></code> with list of places to avoid <code class="docutils literal notranslate"><span class="pre">S</span></code>. Currently, this method
only works when <code class="docutils literal notranslate"><span class="pre">self._R.base_ring()</span> <span class="pre">==</span> <span class="pre">QQ</span></code> as for other rings, the function
field for <code class="docutils literal notranslate"><span class="pre">Curve(self.f)</span></code> is not implemented.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">divisor</span></code> – an element of <code class="docutils literal notranslate"><span class="pre">Curve(self.f).function_field().divisor_group()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">S</span></code> – list of places to avoid</p></li>
</ul>
<p>OUTPUT:</p>
<p>A tuple <code class="docutils literal notranslate"><span class="pre">(D,</span> <span class="pre">B)</span></code>, where <code class="docutils literal notranslate"><span class="pre">D</span></code> is a new divisor, linearly equivalent
to <code class="docutils literal notranslate"><span class="pre">divisor</span></code>, but not intersecting <code class="docutils literal notranslate"><span class="pre">S</span></code>, and <code class="docutils literal notranslate"><span class="pre">B</span></code> is a list of tuples
<code class="docutils literal notranslate"><span class="pre">(v,</span> <span class="pre">b)</span></code> where <code class="docutils literal notranslate"><span class="pre">b</span></code> are the functions giving the linear equivalence,
added with multiplicity <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">avoid</span> <span class="o">=</span> <span class="n">Curve</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">places_at_infinity</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="n">avoid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">strong_approximation</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">avoid</span><span class="p">)</span>
<span class="go">(- Place (x - 2, (x - 2)*y)</span>
<span class="go">  + Place (x - 1, y)</span>
<span class="go">  + Place (x^2 + x + 1, y),</span>
<span class="go"> [(1, (1/(x - 2))*y)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.symplectic_automorphism_group">
<span class="sig-name descname"><span class="pre">symplectic_automorphism_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">endo_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.symplectic_automorphism_group" title="Permalink to this definition">#</a></dt>
<dd><p>Numerically compute the symplectic automorphism group as a permutation
group.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">endo_basis</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) – a <span class="math notranslate nohighlight">\(\ZZ\)</span>-basis of the
endomorphisms of <code class="docutils literal notranslate"><span class="pre">self</span></code>, as obtained from
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">endomorphism_basis()</span></code></a>. If you have already calculated this
basis, it saves time to pass it via this keyword argument. Otherwise
the method will calculate it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> – integer (default provided): as for
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a>, and used in its invocation if
(re)calculating said basis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">b/4</span></code>).  as for
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a>, and used in its invocation if
(re)calculating said basis.</p></li>
</ul>
<p>OUTPUT:</p>
<p>The symplectic automorphism group of the Jacobian of the Riemann
surface. The automorphism group of the Riemann surface itself can be
recovered from this; if the curve is hyperelliptic, then it is
identical, and if not, then one divides out by the central element
corresponding to multiplication by -1.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span> <span class="n">prec</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">symplectic_automorphism_group</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">as_permutation_group</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">DihedralGroup</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.symplectic_isomorphisms">
<span class="sig-name descname"><span class="pre">symplectic_isomorphisms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hom_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.symplectic_isomorphisms" title="Permalink to this definition">#</a></dt>
<dd><p>Numerically compute symplectic isomorphisms.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> (default: <code class="docutils literal notranslate"><span class="pre">self</span></code>) – the codomain, another Riemann
surface.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hom_basis</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) – a <span class="math notranslate nohighlight">\(\ZZ\)</span>-basis of the
homomorphisms from <code class="docutils literal notranslate"><span class="pre">self</span></code> to <code class="docutils literal notranslate"><span class="pre">other</span></code>, as obtained from
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a>. If you have already calculated this
basis, it saves time to pass it via this keyword argument. Otherwise
the method will calculate it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> – integer (default provided): as for
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a>, and used in its invocation if
(re)calculating said basis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">b/4</span></code>).  as for
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a>, and used in its invocation if
(re)calculating said basis.</p></li>
</ul>
<p>OUTPUT:</p>
<p>This returns the combinations of the elements of
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a> that correspond to symplectic
isomorphisms between the Jacobians of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Rs</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">symplectic_isomorphisms</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Ts</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">tangent_representation_numerical</span><span class="p">(</span><span class="n">Rs</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">test1</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(((</span><span class="n">T</span><span class="o">*</span><span class="n">P</span> <span class="o">-</span> <span class="n">Q</span><span class="o">*</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">80</span><span class="p">))</span> <span class="k">for</span> <span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">R</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Ts</span><span class="p">,</span> <span class="n">Rs</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">test2</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">det</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">Rs</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">test1</span> <span class="ow">and</span> <span class="n">test2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.tangent_representation_algebraic">
<span class="sig-name descname"><span class="pre">tangent_representation_algebraic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Rs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epscomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.tangent_representation_algebraic" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the algebraic tangent representations corresponding to the
homology representations in <code class="docutils literal notranslate"><span class="pre">Rs</span></code>.</p>
<p>The representations on homology <code class="docutils literal notranslate"><span class="pre">Rs</span></code> have to be given with respect to
the symplectic homology basis of the Jacobian of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.
Such matrices can for example be obtained via
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">endomorphism_basis()</span></code></a>.</p>
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be the period matrices of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>. Then
for a homology representation <span class="math notranslate nohighlight">\(R\)</span>, the corresponding tangential
representation <span class="math notranslate nohighlight">\(T\)</span> satisfies <span class="math notranslate nohighlight">\(T P = Q R\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Rs</span></code> – a set of matrices on homology to be converted to their
tangent representations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> (default: <code class="docutils literal notranslate"><span class="pre">self</span></code>) – the codomain, another Riemann
surface.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">epscomp</span></code> – real number (default: <code class="docutils literal notranslate"><span class="pre">2^(-prec</span> <span class="pre">+</span> <span class="pre">30)</span></code>). Used to
determine whether a complex number is close enough to a root of a
polynomial.</p></li>
</ul>
<p>OUTPUT:</p>
<p>The algebraic tangent representations of the matrices in <code class="docutils literal notranslate"><span class="pre">Rs</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span> <span class="n">prec</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Rs</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">endomorphism_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Ts</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">tangent_representation_algebraic</span><span class="p">(</span><span class="n">Rs</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">maximal_order</span><span class="p">()</span><span class="o">.</span><span class="n">discriminant</span><span class="p">()</span> <span class="o">==</span> <span class="mi">8</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.tangent_representation_numerical">
<span class="sig-name descname"><span class="pre">tangent_representation_numerical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Rs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.tangent_representation_numerical" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the numerical tangent representations corresponding to the
homology representations in <code class="docutils literal notranslate"><span class="pre">Rs</span></code>.</p>
<p>The representations on homology <code class="docutils literal notranslate"><span class="pre">Rs</span></code> have to be given with respect to
the symplectic homology basis of the Jacobian of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.
Such matrices can for example be obtained via
<a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">endomorphism_basis()</span></code></a>.</p>
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be the period matrices of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>. Then
for a homology representation <span class="math notranslate nohighlight">\(R\)</span>, the corresponding tangential
representation <span class="math notranslate nohighlight">\(T\)</span> satisfies <span class="math notranslate nohighlight">\(T P = Q R\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Rs</span></code> – a set of matrices on homology to be converted to their
tangent representations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> (default: <code class="docutils literal notranslate"><span class="pre">self</span></code>) – the codomain, another Riemann
surface.</p></li>
</ul>
<p>OUTPUT:</p>
<p>The numerical tangent representations of the matrices in <code class="docutils literal notranslate"><span class="pre">Rs</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span> <span class="n">prec</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Rs</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">endomorphism_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Ts</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">tangent_representation_numerical</span><span class="p">(</span><span class="n">Rs</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(((</span><span class="n">T</span><span class="o">*</span><span class="n">P</span> <span class="o">-</span> <span class="n">P</span><span class="o">*</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">80</span><span class="p">))</span> <span class="k">for</span> <span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">R</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Ts</span><span class="p">,</span> <span class="n">Rs</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.upstairs_edges">
<span class="sig-name descname"><span class="pre">upstairs_edges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.upstairs_edges" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the edgeset of the lift of the downstairs graph onto the Riemann
surface.</p>
<p>OUTPUT:</p>
<p>An edgeset between vertices (i, j), where i corresponds to the i-th
point in the Voronoi diagram vertices, and j is the j-th w-value
associated with that point.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edgeset</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">upstairs_edges</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">edgeset</span><span class="p">)</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">degree</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">downstairs_edges</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">{(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">w</span> <span class="ow">in</span> <span class="n">edgeset</span><span class="p">}</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">downstairs_edges</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.upstairs_graph">
<span class="sig-name descname"><span class="pre">upstairs_graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.upstairs_graph" title="Permalink to this definition">#</a></dt>
<dd><p>Return the graph of the upstairs edges.</p>
<p>This method can be useful for generating paths in the surface between points labelled
by upstairs vertices, and verifying that a homology basis is likely computed correctly.
See also <a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.downstairs_graph" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.downstairs_graph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">downstairs_graph()</span></code></a>.</p>
<p>OUTPUT:</p>
<p>The homotopy-continued Voronoi decomposition as a graph, with appropriate 3D embedding.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Curve</span><span class="p">(</span><span class="n">w</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">z</span><span class="o">^</span><span class="mi">4</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">riemann_surface</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">upstairs_graph</span><span class="p">();</span> <span class="n">G</span>
<span class="go">Graph on 22 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.w_values">
<span class="sig-name descname"><span class="pre">w_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.w_values" title="Permalink to this definition">#</a></dt>
<dd><p>Return the points lying on the surface above <code class="docutils literal notranslate"><span class="pre">z0</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">z0</span></code> – (complex) a point in the complex z-plane.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A set of complex numbers corresponding to solutions of <span class="math notranslate nohighlight">\(f(z_0,w) = 0\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Find the w-values above the origin, i.e. the solutions of <span class="math notranslate nohighlight">\(w^2 + 1 = 0\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">w_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># abs tol 1e-14</span>
<span class="go">[-1.00000000000000*I, 1.00000000000000*I]</span>
</pre></div>
</div>
<p>Note that typically the method returns a list of length <code class="docutils literal notranslate"><span class="pre">self.degree</span></code>,
but that at ramification points, this may no longer be true:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">w_values</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># abs tol 1e-14</span>
<span class="go">[0.000000000000000]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.</span></span><span class="sig-name descname"><span class="pre">RiemannSurfaceSum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface" title="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface"><code class="xref py py-class docutils literal notranslate"><span class="pre">RiemannSurface</span></code></a></p>
<p>Represent the disjoint union of finitely many Riemann surfaces.</p>
<p>Rudimentary class to represent disjoint unions of Riemann surfaces. Exists
mainly (and this is the only functionality actually implemented) to
represents direct products of the complex tori that arise as analytic
Jacobians of Riemann surfaces.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p>L – list of RiemannSurface objects</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">_</span><span class="o">.&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">SC</span> <span class="o">=</span> <span class="n">HyperellipticCurve</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">riemann_surface</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">HyperellipticCurve</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">riemann_surface</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">HyperellipticCurve</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">riemann_surface</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">SC</span><span class="o">.</span><span class="n">homomorphism_basis</span><span class="p">(</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">))</span>
<span class="go">2</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum.period_matrix">
<span class="sig-name descname"><span class="pre">period_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum.period_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Return the period matrix of the surface.</p>
<p>This is just the diagonal block matrix constructed from the period
matrices of the constituents.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span><span class="p">,</span> <span class="n">RiemannSurfaceSum</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurfaceSum</span><span class="p">([</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">S1S2</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">block_sum</span><span class="p">(</span><span class="n">S2</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">period_matrix</span><span class="p">()</span> <span class="o">==</span> <span class="n">S1S2</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum.riemann_matrix">
<span class="sig-name descname"><span class="pre">riemann_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum.riemann_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Return the normalized period matrix of the surface.</p>
<p>This is just the diagonal block matrix constructed from the Riemann
matrices of the constituents.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span><span class="p">,</span> <span class="n">RiemannSurfaceSum</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurfaceSum</span><span class="p">([</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span> <span class="o">==</span> <span class="n">S1</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">block_sum</span><span class="p">(</span><span class="n">S2</span><span class="o">.</span><span class="n">riemann_matrix</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.bisect">
<span class="sig-prename descclassname"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.</span></span><span class="sig-name descname"><span class="pre">bisect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.bisect" title="Permalink to this definition">#</a></dt>
<dd><p>Find position in a sorted list using bisection.</p>
<p>Given a list <span class="math notranslate nohighlight">\(L = [(t_0,...),(t_1,...),...(t_n,...)]\)</span> with increasing <span class="math notranslate nohighlight">\(t_i\)</span>,
find the index i such that <span class="math notranslate nohighlight">\(t_i &lt;= t &lt; t_{i+1}\)</span> using bisection. The rest of
the tuple is available for whatever use required.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">L</span></code> – A list of tuples such that the first term of each tuple is a real
number between 0 and 1. These real numbers must be increasing.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – A real number between <span class="math notranslate nohighlight">\(t_0\)</span> and <span class="math notranslate nohighlight">\(t_n\)</span>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>An integer i, giving the position in L where t would be in</p>
<p>EXAMPLES:</p>
<p>Form a list of the desired form, and pick a real number between 0 and 1:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">bisect</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">sage: </span><span class="n">bisect</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Another example which demonstrates that if t is equal to one of the t_i, it
returns that index:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.45</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.65</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">sage: </span><span class="n">bisect</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.differential_basis_baker">
<span class="sig-prename descclassname"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.</span></span><span class="sig-name descname"><span class="pre">differential_basis_baker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.differential_basis_baker" title="Permalink to this definition">#</a></dt>
<dd><p>Compute a differential basis for a curve that is nonsingular outside (1:0:0),(0:1:0),(0:0:1)</p>
<p>Baker’s theorem tells us that if a curve has its singularities at the coordinate vertices and meets
some further easily tested genericity criteria,
then we can read off a basis for the regular differentials from the interior of the
Newton polygon spanned by the monomials. While this theorem only applies to special plane curves
it is worth implementing because the analysis is relatively cheap and it applies to a lot of
commonly encountered curves (e.g., curves given by a hyperelliptic model). Other advantages include
that we can do the computation over any exact base ring (the alternative Singular based method for
computing the adjoint ideal requires the rationals), and that we can avoid being affected by subtle bugs
in the Singular code.</p>
<p><code class="docutils literal notranslate"><span class="pre">None</span></code> is returned when <code class="docutils literal notranslate"><span class="pre">f</span></code> does not describe a curve of the relevant type. If <code class="docutils literal notranslate"><span class="pre">f</span></code> is of the relevant
type, but is of genus <span class="math notranslate nohighlight">\(0\)</span> then <code class="docutils literal notranslate"><span class="pre">[]</span></code> is returned (which are both False values, but they are not equal).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(f\)</span> – a bivariate polynomial</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">differential_basis_baker</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">y</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">5</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">5</span>
<span class="gp">sage: </span><span class="n">differential_basis_baker</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">[y^2, x*y, x*y^2, x^2, x^2*y, x^2*y^2, x^2*y^3, x^3*y^2, x^3*y^3]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">sage: </span><span class="n">differential_basis_baker</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">differential_basis_baker</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.find_closest_element">
<span class="sig-prename descclassname"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.</span></span><span class="sig-name descname"><span class="pre">find_closest_element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.find_closest_element" title="Permalink to this definition">#</a></dt>
<dd><p>Return the index of the closest element of a list.</p>
<p>Given <code class="docutils literal notranslate"><span class="pre">List</span></code> and <code class="docutils literal notranslate"><span class="pre">item</span></code>, return the index of the element <code class="docutils literal notranslate"><span class="pre">l</span></code> of <code class="docutils literal notranslate"><span class="pre">List</span></code>
which minimises <code class="docutils literal notranslate"><span class="pre">(item-l).abs()</span></code>. If there are multiple such elements, the
first is returned.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">item</span></code> – value to minimize the distance to over the list</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lst</span></code> – list to look for closest element in</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">find_closest_element</span>
<span class="gp">sage: </span><span class="n">i</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">i</span> <span class="o">==</span> <span class="n">find_closest_element</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note that this method does no checks on the input, but will fail for inputs
where the absolute value or subtraction do not make sense.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.integer_matrix_relations">
<span class="sig-prename descclassname"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.</span></span><span class="sig-name descname"><span class="pre">integer_matrix_relations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.integer_matrix_relations" title="Permalink to this definition">#</a></dt>
<dd><p>Determine integer relations between complex matrices.</p>
<p>Given two square matrices with complex entries of size g, h respectively,
numerically determine an (approximate) ZZ-basis for the 2g x 2h matrices
with integer entries of the shape (D, B; C, A) such that B+M1*A=(D+M1*C)*M2.
By considering real and imaginary parts separately we obtain <span class="math notranslate nohighlight">\(2gh\)</span> equations
with real coefficients in <span class="math notranslate nohighlight">\(4gh\)</span> variables. We scale the coefficients by a
constant <span class="math notranslate nohighlight">\(2^b\)</span> and round them to integers, in order to obtain an integer
system of equations. Standard application of LLL allows us to determine near
solutions.</p>
<p>The user can specify the parameter <span class="math notranslate nohighlight">\(b\)</span>, but by default the system will
choose a <span class="math notranslate nohighlight">\(b\)</span> based on the size of the coefficients and the precision with
which they are given.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">M1</span></code> – square complex valued matrix</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">M2</span></code> – square complex valued matrix of same size as M1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> – integer (default provided). The equation coefficients are scaled
by <span class="math notranslate nohighlight">\(2^b\)</span> before rounding to integers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">b/4</span></code>). The vectors found by LLL that satisfy
the scaled equations to within <span class="math notranslate nohighlight">\(2^r\)</span> are reported as solutions.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of 2g x 2h integer matrices that, for large enough <span class="math notranslate nohighlight">\(r\)</span>, <span class="math notranslate nohighlight">\(b-r\)</span>,
generate the ZZ-module of relevant transformations.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">integer_matrix_relations</span>
<span class="gp">sage: </span><span class="n">M1</span><span class="o">=</span><span class="n">M2</span><span class="o">=</span><span class="n">matrix</span><span class="p">(</span><span class="n">CC</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">=</span><span class="n">integer_matrix_relations</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span><span class="n">M2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">id</span><span class="o">=</span><span class="n">parent</span><span class="p">(</span><span class="n">M1</span><span class="p">)(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M1t</span><span class="o">=</span><span class="p">[</span><span class="nb">id</span><span class="o">.</span><span class="n">augment</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">T</span><span class="p">]</span>
<span class="gp">sage: </span><span class="p">[((</span><span class="n">m</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">m</span><span class="p">)[:,</span><span class="mi">2</span><span class="p">:]</span><span class="o">-</span><span class="n">M2</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-13</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">M1t</span><span class="p">]</span>
<span class="go">[True, True]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.numerical_inverse">
<span class="sig-prename descclassname"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.</span></span><span class="sig-name descname"><span class="pre">numerical_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.numerical_inverse" title="Permalink to this definition">#</a></dt>
<dd><p>Compute numerical inverse of a matrix via LU decomposition</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">C</span></code> – A real or complex invertible square matrix</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CC</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">4.5606e-31</span> <span class="o">+</span> <span class="mf">1.2326e-31</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>
<span class="gp">....: </span>                      <span class="o">-</span><span class="mf">0.21313</span> <span class="o">+</span> <span class="mf">0.24166</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>
<span class="gp">....: </span>                      <span class="o">-</span><span class="mf">3.4513e-31</span> <span class="o">+</span> <span class="mf">0.16111</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>
<span class="gp">....: </span>                      <span class="o">-</span><span class="mf">1.0175</span> <span class="o">+</span> <span class="mf">9.8608e-32</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>
<span class="gp">....: </span>                      <span class="mf">0.30912</span> <span class="o">+</span> <span class="mf">0.19962</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>
<span class="gp">....: </span>                      <span class="o">-</span><span class="mf">4.9304e-32</span> <span class="o">+</span> <span class="mf">0.39923</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>
<span class="gp">....: </span>                      <span class="mf">0.96793</span> <span class="o">-</span> <span class="mf">3.4513e-31</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>
<span class="gp">....: </span>                      <span class="o">-</span><span class="mf">0.091587</span> <span class="o">+</span> <span class="mf">0.19276</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>
<span class="gp">....: </span>                      <span class="mf">3.9443e-31</span> <span class="o">+</span> <span class="mf">0.38552</span><span class="o">*</span><span class="n">I</span><span class="p">])</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">numerical_inverse</span>
<span class="gp">sage: </span><span class="mf">3e-16</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">C</span><span class="o">^-</span><span class="mi">1</span><span class="o">*</span><span class="n">C</span><span class="o">-</span><span class="n">C</span><span class="o">^</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-15</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">numerical_inverse</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">*</span><span class="n">C</span><span class="o">-</span><span class="n">C</span><span class="o">^</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">3e-16</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.reparameterize_differential_minpoly">
<span class="sig-prename descclassname"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.</span></span><span class="sig-name descname"><span class="pre">reparameterize_differential_minpoly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">minpoly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.reparameterize_differential_minpoly" title="Permalink to this definition">#</a></dt>
<dd><p>Rewrites a minimal polynomial to write is around <span class="math notranslate nohighlight">\(z_0\)</span>.</p>
<p>Given a minimal polynomial <span class="math notranslate nohighlight">\(m(z,g)\)</span>, where <span class="math notranslate nohighlight">\(g\)</span> corresponds to a differential
on the surface (that is, it is represented as a rational function, and
implicitly carries a factor <span class="math notranslate nohighlight">\(dz\)</span>), we rewrite the minpoly in terms of
variables <span class="math notranslate nohighlight">\(\bar{z}, \bar{g}\)</span> s.t now <span class="math notranslate nohighlight">\(\bar{z}=0 \Leftrightarrow z=z_0\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">minpoly</span></code> – a polynomial in two variables, where the first variable
corresponds to the base coordinate on the Riemann surface</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">z0</span></code> – complex number or infinity; the point about which to
reparameterize</p></li>
</ul>
<p>OUTPUT:</p>
<p>A polynomial in two variables giving the reparameterize minimal polynomial.</p>
<p>EXAMPLES:</p>
<p>On the curve given by <span class="math notranslate nohighlight">\(w^2 - z^3 + 1 = 0\)</span>, we have differential
<span class="math notranslate nohighlight">\(\frac{dz}{2w} = \frac{dz}{2\sqrt{z^3-1}}\)</span>
with minimal polynomial <span class="math notranslate nohighlight">\(g^2(z^3-1) - 1/4=0\)</span>. We can make the substitution
<span class="math notranslate nohighlight">\(\bar{z}=z^{-1}\)</span> to parameterise the differential about <span class="math notranslate nohighlight">\(z=\infty\)</span> as</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{-\bar{z}^{-2} d\bar{z}}{2\sqrt{\bar{z}^{-3}-1}} = \frac{-d\bar{z}}{2\sqrt{\bar{z}(1-\bar{z}^3)}}.\]</div>
</div>
<p>Hence the transformed differential should have minimal polynomial
<span class="math notranslate nohighlight">\(\bar{g}^2 \bar{z} (1 - \bar{z}^3) - 1/4 = 0\)</span>, and we can check this:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">RiemannSurface</span><span class="p">,</span> <span class="n">reparameterize_differential_minpoly</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RiemannSurface</span><span class="p">(</span><span class="n">w</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">z</span><span class="o">^</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">minpoly</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">_cohomology_basis_bounding_data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">z0</span> <span class="o">=</span> <span class="n">Infinity</span>
<span class="gp">sage: </span><span class="n">reparameterize_differential_minpoly</span><span class="p">(</span><span class="n">minpoly</span><span class="p">,</span> <span class="n">z0</span><span class="p">)</span>
<span class="go">-zbar^4*gbar^2 + zbar*gbar^2 - 1/4</span>
</pre></div>
</div>
<p>We can further check that reparameterising about <span class="math notranslate nohighlight">\(0\)</span> is the identity
operation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">reparameterize_differential_minpoly</span><span class="p">(</span><span class="n">minpoly</span><span class="p">,</span> <span class="mi">0</span><span class="p">)(</span><span class="o">*</span><span class="n">minpoly</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">())</span> <span class="o">==</span> <span class="n">minpoly</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As part of the routine, when reparameterising about infinity, a
rational function is reduced and then the numerator is taken. Over
an inexact ring this is numerically unstable, and so it is advisable
to only reparameterize about infinity over an exact ring.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.schemes.riemann_surfaces.riemann_surface.voronoi_ghost">
<span class="sig-prename descclassname"><span class="pre">sage.schemes.riemann_surfaces.riemann_surface.</span></span><span class="sig-name descname"><span class="pre">voronoi_ghost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cpoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n=6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">CC=Complex</span> <span class="pre">Double</span> <span class="pre">Field</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.schemes.riemann_surfaces.riemann_surface.voronoi_ghost" title="Permalink to this definition">#</a></dt>
<dd><p>Convert a set of complex points to a list of real tuples <span class="math notranslate nohighlight">\((x,y)\)</span>, and
appends n points in a big circle around them.</p>
<p>The effect is that, with n &gt;= 3, a Voronoi decomposition will have only
finite cells around the original points. Furthermore, because the extra
points are placed on a circle centered on the average of the given points,
with a radius 3/2 times the largest distance between the center and the
given points, these finite cells form a simply connected region.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cpoints</span></code> – a list of complex numbers</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of real tuples <span class="math notranslate nohighlight">\((x,y)\)</span> consisting of the original points and a set of
points which surround them.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="kn">import</span> <span class="n">voronoi_ghost</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">*</span><span class="n">I</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">voronoi_ghost</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>  <span class="c1"># abs tol 1e-6</span>
<span class="go">[(1.0, 1.0),</span>
<span class="go"> (1.0, -1.0),</span>
<span class="go"> (-1.0, 1.0),</span>
<span class="go"> (-1.0, -1.0),</span>
<span class="go"> (2.121320343559643, 0.0),</span>
<span class="go"> (1.0606601717798216, 1.8371173070873836),</span>
<span class="go"> (-1.060660171779821, 1.8371173070873839),</span>
<span class="go"> (-2.121320343559643, 2.59786816870648e-16),</span>
<span class="go"> (-1.0606601717798223, -1.8371173070873832),</span>
<span class="go"> (1.06066017177982, -1.8371173070873845)]</span>
</pre></div>
</div>
</dd></dl>

</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          <a class="prev-page" href="../plane_quartics/quartic_generic.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Plane quartic curves over a general ring</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2005--2023, The Sage Development Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Riemann matrices and endomorphism rings of algebraic Riemann surfaces</a><ul>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.ConvergenceError"><code class="docutils literal notranslate"><span class="pre">ConvergenceError</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface"><code class="docutils literal notranslate"><span class="pre">RiemannSurface</span></code></a><ul>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.abel_jacobi"><code class="docutils literal notranslate"><span class="pre">abel_jacobi()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.cohomology_basis"><code class="docutils literal notranslate"><span class="pre">cohomology_basis()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.curve"><code class="docutils literal notranslate"><span class="pre">curve()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.divisor_to_divisor_list"><code class="docutils literal notranslate"><span class="pre">divisor_to_divisor_list()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.downstairs_edges"><code class="docutils literal notranslate"><span class="pre">downstairs_edges()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.downstairs_graph"><code class="docutils literal notranslate"><span class="pre">downstairs_graph()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.edge_permutations"><code class="docutils literal notranslate"><span class="pre">edge_permutations()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.endomorphism_basis"><code class="docutils literal notranslate"><span class="pre">endomorphism_basis()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homology_basis"><code class="docutils literal notranslate"><span class="pre">homology_basis()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homomorphism_basis"><code class="docutils literal notranslate"><span class="pre">homomorphism_basis()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.homotopy_continuation"><code class="docutils literal notranslate"><span class="pre">homotopy_continuation()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.make_zw_interpolator"><code class="docutils literal notranslate"><span class="pre">make_zw_interpolator()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.matrix_of_integral_values"><code class="docutils literal notranslate"><span class="pre">matrix_of_integral_values()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.monodromy_group"><code class="docutils literal notranslate"><span class="pre">monodromy_group()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.period_matrix"><code class="docutils literal notranslate"><span class="pre">period_matrix()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.places_at_branch_locus"><code class="docutils literal notranslate"><span class="pre">places_at_branch_locus()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.plot_paths"><code class="docutils literal notranslate"><span class="pre">plot_paths()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.plot_paths3d"><code class="docutils literal notranslate"><span class="pre">plot_paths3d()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.reduce_over_period_lattice"><code class="docutils literal notranslate"><span class="pre">reduce_over_period_lattice()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.riemann_matrix"><code class="docutils literal notranslate"><span class="pre">riemann_matrix()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.rigorous_line_integral"><code class="docutils literal notranslate"><span class="pre">rigorous_line_integral()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.rosati_involution"><code class="docutils literal notranslate"><span class="pre">rosati_involution()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.simple_vector_line_integral"><code class="docutils literal notranslate"><span class="pre">simple_vector_line_integral()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.strong_approximation"><code class="docutils literal notranslate"><span class="pre">strong_approximation()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.symplectic_automorphism_group"><code class="docutils literal notranslate"><span class="pre">symplectic_automorphism_group()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.symplectic_isomorphisms"><code class="docutils literal notranslate"><span class="pre">symplectic_isomorphisms()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.tangent_representation_algebraic"><code class="docutils literal notranslate"><span class="pre">tangent_representation_algebraic()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.tangent_representation_numerical"><code class="docutils literal notranslate"><span class="pre">tangent_representation_numerical()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.upstairs_edges"><code class="docutils literal notranslate"><span class="pre">upstairs_edges()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.upstairs_graph"><code class="docutils literal notranslate"><span class="pre">upstairs_graph()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface.w_values"><code class="docutils literal notranslate"><span class="pre">w_values()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum"><code class="docutils literal notranslate"><span class="pre">RiemannSurfaceSum</span></code></a><ul>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum.period_matrix"><code class="docutils literal notranslate"><span class="pre">period_matrix()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.RiemannSurfaceSum.riemann_matrix"><code class="docutils literal notranslate"><span class="pre">riemann_matrix()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.bisect"><code class="docutils literal notranslate"><span class="pre">bisect()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.differential_basis_baker"><code class="docutils literal notranslate"><span class="pre">differential_basis_baker()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.find_closest_element"><code class="docutils literal notranslate"><span class="pre">find_closest_element()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.integer_matrix_relations"><code class="docutils literal notranslate"><span class="pre">integer_matrix_relations()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.numerical_inverse"><code class="docutils literal notranslate"><span class="pre">numerical_inverse()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.reparameterize_differential_minpoly"><code class="docutils literal notranslate"><span class="pre">reparameterize_differential_minpoly()</span></code></a></li>
<li><a class="reference internal" href="#sage.schemes.riemann_surfaces.riemann_surface.voronoi_ghost"><code class="docutils literal notranslate"><span class="pre">voronoi_ghost()</span></code></a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../_static/scripts/furo.js"></script>
    <script src="../../../../_static/clipboard.min.js"></script>
    <script src="../../../../_static/copybutton.js"></script>
    <script src="../../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"ZZ": "\\Bold{Z}", "NN": "\\Bold{N}", "RR": "\\Bold{R}", "CC": "\\Bold{C}", "QQ": "\\Bold{Q}", "QQbar": "\\overline{\\QQ}", "GF": ["\\Bold{F}_{#1}", 1], "Zp": ["\\Bold{Z}_{#1}", 1], "Qp": ["\\Bold{Q}_{#1}", 1], "Zmod": ["\\ZZ/#1\\ZZ", 1], "CDF": "\\Bold{C}", "CIF": "\\Bold{C}", "CLF": "\\Bold{C}", "RDF": "\\Bold{R}", "RIF": "\\Bold{I} \\Bold{R}", "RLF": "\\Bold{R}", "SL": "\\mathrm{SL}", "PSL": "\\mathrm{PSL}", "lcm": "\\mathop{\\operatorname{lcm}}", "Bold": ["\\mathbf{#1}", 1]}, "inlineMath": [["$", "$"], ["\\(", "\\)"]], "maxBuffer": 51200, "autoload": {"color": [], "colorv2": ["color"]}}}</script>
    <script defer="defer" src="../../../../_static/mathjax/tex-chtml.js"></script>
    </body>
</html>