<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../../../../genindex.html" /><link rel="search" title="Search" href="../../../../search.html" /><link rel="next" title="Isolate Complex Roots of Polynomials" href="complex_roots.html" /><link rel="prev" title="Univariate Polynomials over GF(p^e) via NTL’s ZZ_pEX" href="polynomial_zz_pex.html" />

    <!-- Generated with Sphinx 7.2.6 and Furo 2023.09.10 -->
        <title>Isolate Real Roots of Real Polynomials - Polynomials</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=a078f75a" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css?v=7f9a90b1" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/jupyter-sphinx.css?v=572af1d6" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo-extensions.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/custom-furo.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/custom-jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/custom-codemirror-monokai.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">Polynomials</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../../_static/logo_sagemath_black.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../../_static/logo_sagemath_white.svg" alt="Dark Logo"/>
  </div>
  
      <span class="sidebar-brand-text">Sage 10.3 Reference Manual</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-home">
  <div class="sidebar-tree">
    <ul><li class="toctree-l1">
      <a class="reference internal" href="../../../index.html">Home - Polynomials</a>
    </li></ul>
  </div>
</div><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="polynomial_ring_constructor.html">Constructors for polynomial rings</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="../../../polynomial_rings_univar.html">Univariate Polynomials and Polynomial Rings</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Univariate Polynomials and Polynomial Rings</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="polynomial_ring.html">Univariate Polynomial Rings</a></li>
<li class="toctree-l2"><a class="reference internal" href="polynomial_ring_homomorphism.html">Ring homomorphisms from a polynomial ring to another ring</a></li>
<li class="toctree-l2"><a class="reference internal" href="polynomial_element.html">Univariate polynomial base class</a></li>
<li class="toctree-l2"><a class="reference internal" href="polynomial_element_generic.html">Univariate Polynomials over domains and fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="polynomial_gf2x.html">Univariate Polynomials over GF(2) via NTL’s GF2X</a></li>
<li class="toctree-l2"><a class="reference internal" href="polynomial_number_field.html">Univariate polynomials over number fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="polynomial_integer_dense_flint.html">Dense univariate polynomials over <span class="math notranslate nohighlight">\(\ZZ\)</span>, implemented using FLINT</a></li>
<li class="toctree-l2"><a class="reference internal" href="polynomial_integer_dense_ntl.html">Dense univariate polynomials over <span class="math notranslate nohighlight">\(\ZZ\)</span>, implemented using NTL.</a></li>
<li class="toctree-l2"><a class="reference internal" href="polynomial_rational_flint.html">Univariate polynomials over <span class="math notranslate nohighlight">\(\QQ\)</span> implemented via FLINT</a></li>
<li class="toctree-l2"><a class="reference internal" href="polynomial_zmod_flint.html">Dense univariate polynomials over <span class="math notranslate nohighlight">\(\ZZ/n\ZZ\)</span>, implemented using FLINT</a></li>
<li class="toctree-l2"><a class="reference internal" href="polynomial_modn_dense_ntl.html">Dense univariate polynomials over  <span class="math notranslate nohighlight">\(\ZZ/n\ZZ\)</span>, implemented using NTL</a></li>
<li class="toctree-l2"><a class="reference internal" href="polynomial_real_mpfr_dense.html">Dense univariate polynomials over <span class="math notranslate nohighlight">\(\RR\)</span>, implemented using MPFR</a></li>
<li class="toctree-l2"><a class="reference internal" href="polynomial_singular_interface.html">Polynomial Interfaces to Singular</a></li>
<li class="toctree-l2"><a class="reference internal" href="padics/polynomial_padic.html">Base class for generic <span class="math notranslate nohighlight">\(p\)</span>-adic polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="padics/polynomial_padic_capped_relative_dense.html">p-adic Capped Relative Dense Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="padics/polynomial_padic_flat.html">p-adic Flat Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="polynomial_zz_pex.html">Univariate Polynomials over GF(p^e) via NTL’s ZZ_pEX</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Isolate Real Roots of Real Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="complex_roots.html">Isolate Complex Roots of Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="refine_root.html">Refine polynomial roots using Newton–Raphson</a></li>
<li class="toctree-l2"><a class="reference internal" href="ideal.html">Ideals in Univariate Polynomial Rings</a></li>
<li class="toctree-l2"><a class="reference internal" href="polynomial_quotient_ring.html">Quotients of Univariate Polynomial Rings</a></li>
<li class="toctree-l2"><a class="reference internal" href="polynomial_quotient_ring_element.html">Elements of Quotients of Univariate Polynomial Rings</a></li>
<li class="toctree-l2"><a class="reference internal" href="polynomial_compiled.html">Polynomial Compilers</a></li>
<li class="toctree-l2"><a class="reference internal" href="polynomial_fateman.html">Polynomial multiplication by Kronecker substitution</a></li>
<li class="toctree-l2"><a class="reference internal" href="integer_valued_polynomials.html">Integer-valued polynomial rings</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="convolution.html">Generic Convolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="cyclotomic.html">Fast calculation of cyclotomic polynomials</a></li>
</ul>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../polynomial_rings_multivar.html">Multivariate Polynomials and Polynomial Rings</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Multivariate Polynomials and Polynomial Rings</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="term_order.html">Term orders</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi_polynomial_ring_base.html">Base class for multivariate polynomial rings</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi_polynomial.html">Base class for elements of multivariate polynomial rings</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi_polynomial_ring.html">Multivariate Polynomial Rings over Generic Rings</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi_polynomial_element.html">Generic Multivariate Polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi_polynomial_ideal.html">Ideals in multivariate polynomial rings</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi_polynomial_sequence.html">Polynomial Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi_polynomial_libsingular.html">Multivariate Polynomials via libSINGULAR</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi_polynomial_ideal_libsingular.html">Direct low-level access to SINGULAR’s Groebner basis engine via libSINGULAR</a></li>
<li class="toctree-l2"><a class="reference internal" href="msolve.html">Solution of polynomial systems using msolve</a></li>
<li class="toctree-l2"><a class="reference internal" href="polydict.html">Generic data structures for multivariate polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="hilbert.html">Compute Hilbert series of monomial ideals</a></li>
<li class="toctree-l2"><a class="reference internal" href="flatten.html">Class to flatten polynomial rings over polynomial ring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../monomials.html">Monomials</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../invariant_theory.html">Classical Invariant Theory</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Classical Invariant Theory</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../invariants/invariant_theory.html">Classical Invariant Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../invariants/reconstruction.html">Reconstruction of Algebraic Forms</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../polynomial_rings_toy_implementations.html">Educational Versions of Groebner Basis Related Algorithms</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of Educational Versions of Groebner Basis Related Algorithms</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="toy_buchberger.html">Educational versions of Groebner basis algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="toy_variety.html">Educational versions of Groebner basis algorithms: triangular factorization</a></li>
<li class="toctree-l2"><a class="reference internal" href="toy_d_basis.html">Educational version of the <span class="math notranslate nohighlight">\(d\)</span>-Groebner basis algorithm over PIDs</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../fraction_field.html">Fraction Field of Integral Domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fraction_field_element.html">Fraction Field Elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fraction_field_FpT.html">Univariate rational functions over prime fields</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="laurent_polynomial_ring_base.html">Ring of Laurent Polynomials (base class)</a></li>
<li class="toctree-l1"><a class="reference internal" href="laurent_polynomial_ring.html">Ring of Laurent Polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="laurent_polynomial.html">Elements of Laurent polynomial rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="omega.html">MacMahon’s Partition Analysis Omega Operator</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="infinite_polynomial_ring.html">Infinite Polynomial Rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="infinite_polynomial_element.html">Elements of Infinite Polynomial Rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="symmetric_ideal.html">Symmetric Ideals of Infinite Polynomial Rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="symmetric_reduction.html">Symmetric Reduction of Infinite Polynomials</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="pbori/pbori.html">Boolean Polynomials</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="isolate-real-roots-of-real-polynomials">
<span id="sage-rings-polynomial-real-roots"></span><h1>Isolate Real Roots of Real Polynomials<a class="headerlink" href="#isolate-real-roots-of-real-polynomials" title="Link to this heading">#</a></h1>
<p id="module-sage.rings.polynomial.real_roots">AUTHOR:</p>
<ul class="simple">
<li><p>Carl Witty (2007-09-19): initial version</p></li>
</ul>
<p>This is an implementation of real root isolation.  That is, given a
polynomial with exact real coefficients, we compute isolating intervals
for the real roots of the polynomial. (Polynomials with
integer, rational, or algebraic real coefficients are supported.)</p>
<p>We convert the polynomials into the Bernstein basis, and then use
de Casteljau’s algorithm and Descartes’ rule of signs on the Bernstein
basis polynomial (using interval arithmetic) to locate the roots. The
algorithm is similar to that in “A Descartes Algorithm for Polynomials
with Bit-Stream Coefficients”, by Eigenwillig, Kettner, Krandick, Mehlhorn,
Schmitt, and Wolpert, but has three crucial optimizations over the
algorithm in that paper:</p>
<ul class="simple">
<li><p>Precision reduction: at certain points in the computation, we discard the
low-order bits of the coefficients, widening the intervals.</p></li>
<li><p>Degree reduction: at certain points in the computation, we find lower-degree
polynomials that are approximately equal to our high-degree polynomial over
the region of interest.</p></li>
<li><p>When the intervals are too wide to continue (either because of a too-low
initial precision, or because of precision or degree reduction), and we need
to restart with higher precision, we recall which regions have already been
proven not to have any roots and do not examine them again.</p></li>
</ul>
<p>The best description of the algorithms used (other than this source
code itself) is in the slides for my Sage Days 4 talk, currently available
from <a class="reference external" href="https://wiki.sagemath.org/days4schedule">https://wiki.sagemath.org/days4schedule</a> .</p>
<dl class="py exception">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.PrecisionError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">PrecisionError</span></span><a class="headerlink" href="#sage.rings.polynomial.real_roots.PrecisionError" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/library/exceptions.html#ValueError" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.bernstein_down">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">bernstein_down</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_down" title="Link to this definition">#</a></dt>
<dd><p>Given polynomial degrees d1 and d2 (where d1 &lt; d2), and a number
of samples s, computes a matrix bd.</p>
<p>If you have a Bernstein polynomial of formal degree d2, and select
s of its coefficients (according to subsample_vec), and multiply
the resulting vector by bd, then you get the coefficients
of a Bernstein polynomial of formal degree d1, where this second
polynomial is a good approximation to the first polynomial over the
region of the Bernstein basis.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bernstein_down</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">[ 612/245 -348/245   -37/49  338/245 -172/245]</span>
<span class="go">[-724/441   132/49  395/441 -290/147  452/441]</span>
<span class="go">[ 452/441 -290/147  395/441   132/49 -724/441]</span>
<span class="go">[-172/245  338/245   -37/49 -348/245  612/245]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.bernstein_expand">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">bernstein_expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_expand" title="Link to this definition">#</a></dt>
<dd><p>Given an integer vector representing a Bernstein polynomial p, and
a degree d2, compute the representation of p as a Bernstein
polynomial of formal degree d2.</p>
<p>This is similar to multiplying by the result of bernstein_up, but
should be faster for large d2 (this has about the same number of
multiplies, but in this version all the multiplies are by single
machine words).</p>
<p>This returns a pair consisting of the expanded polynomial, and the maximum
error E.  (So if an element of the returned polynomial is a, and the
true value of that coefficient is b, then a &lt;= b &lt; a + E.)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="o">-</span><span class="mi">3000</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">bernstein_expand</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">((1000, 1666, 333, -3000), 1)</span>
<span class="gp">sage: </span><span class="n">bernstein_expand</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">((1000, 1500, 1000, -500, -3000), 1)</span>
<span class="gp">sage: </span><span class="n">bernstein_expand</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">((1000, 1100, 1168, 1205, 1210, 1184, 1126, 1036, 915, 763, 578, 363, 115, -164, -474, -816, -1190, -1595, -2032, -2500, -3000), 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">bernstein_polynomial_factory</span></span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An abstract base class for bernstein_polynomial factories.  That
is, elements of subclasses represent Bernstein polynomials
(exactly), and are responsible for creating
interval_bernstein_polynomial_integer approximations at arbitrary
precision.</p>
<p>Supports four methods, coeffs_bitsize(), bernstein_polynomial(),
lsign(), and usign().  The coeffs_bitsize() method gives an
integer approximation to the log2 of the max of the absolute
values of the Bernstein coefficients.  The
bernstein_polynomial(scale_log2) method gives an approximation
where the maximum coefficient has approximately coeffs_bitsize() -
scale_log2 bits.  The lsign() and usign() methods give the (exact)
sign of the first and last coefficient, respectively.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory.lsign">
<span class="sig-name descname"><span class="pre">lsign</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory.lsign" title="Link to this definition">#</a></dt>
<dd><p>Return the sign of the first coefficient of this
Bernstein polynomial.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory.usign">
<span class="sig-name descname"><span class="pre">usign</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory.usign" title="Link to this definition">#</a></dt>
<dd><p>Return the sign of the last coefficient of this
Bernstein polynomial.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ar">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">bernstein_polynomial_factory_ar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ar" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory" title="sage.rings.polynomial.real_roots.bernstein_polynomial_factory"><code class="xref py py-class docutils literal notranslate"><span class="pre">bernstein_polynomial_factory</span></code></a></p>
<p>This class holds an exact Bernstein polynomial (represented as a
list of algebraic real coefficients), and returns
arbitrarily-precise interval approximations of this polynomial on
demand.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ar.bernstein_polynomial">
<span class="sig-name descname"><span class="pre">bernstein_polynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale_log2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ar.bernstein_polynomial" title="Link to this definition">#</a></dt>
<dd><p>Compute an interval_bernstein_polynomial_integer that approximates
this polynomial, using the given scale_log2.  (Smaller scale_log2
values give more accurate approximations.)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">AA</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">AA</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bpf</span> <span class="o">=</span> <span class="n">bernstein_polynomial_factory_ar</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">degree 3 IBP with 2-bit coefficients</span>
<span class="gp">sage: </span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">)</span>
<span class="go">&lt;IBP: ((-2965821, 2181961, -1542880, 1048576) + [0 .. 1)) * 2^-20&gt;</span>
<span class="gp">sage: </span><span class="n">bpf</span> <span class="o">=</span> <span class="n">bernstein_polynomial_factory_ar</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">)</span>
<span class="go">&lt;IBP: ((-2965821, -2181962, -1542880, -1048576) + [0 .. 1)) * 2^-20&gt;</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">bpf</span> <span class="o">=</span> <span class="n">bernstein_polynomial_factory_ar</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>
<span class="go">&lt;IBP: ((-1024, 0, 1024) + [0 .. 1)) * 2^-10&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ar.coeffs_bitsize">
<span class="sig-name descname"><span class="pre">coeffs_bitsize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ar.coeffs_bitsize" title="Link to this definition">#</a></dt>
<dd><p>Computes the approximate log2 of the maximum of the absolute
values of the coefficients.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">AA</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">AA</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bernstein_polynomial_factory_ar</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">coeffs_bitsize</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory_intlist">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">bernstein_polynomial_factory_intlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeffs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_intlist" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory" title="sage.rings.polynomial.real_roots.bernstein_polynomial_factory"><code class="xref py py-class docutils literal notranslate"><span class="pre">bernstein_polynomial_factory</span></code></a></p>
<p>This class holds an exact Bernstein polynomial (represented
as a list of integer coefficients), and returns arbitrarily-precise
interval approximations of this polynomial on demand.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory_intlist.bernstein_polynomial">
<span class="sig-name descname"><span class="pre">bernstein_polynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale_log2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_intlist.bernstein_polynomial" title="Link to this definition">#</a></dt>
<dd><p>Compute an interval_bernstein_polynomial_integer that approximates
this polynomial, using the given scale_log2.  (Smaller scale_log2
values give more accurate approximations.)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bpf</span> <span class="o">=</span> <span class="n">bernstein_polynomial_factory_intlist</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="o">-</span><span class="mi">40</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">degree 3 IBP with 6-bit coefficients</span>
<span class="gp">sage: </span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">&lt;IBP: ((0, -1, 0, -1) + [0 .. 1)) * 2^20; lsign 1&gt;</span>
<span class="gp">sage: </span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&lt;IBP: (10, -20, 30, -40) + [0 .. 1)&gt;</span>
<span class="gp">sage: </span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">)</span>
<span class="go">&lt;IBP: ((10485760, -20971520, 31457280, -41943040) + [0 .. 1)) * 2^-20&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory_intlist.coeffs_bitsize">
<span class="sig-name descname"><span class="pre">coeffs_bitsize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_intlist.coeffs_bitsize" title="Link to this definition">#</a></dt>
<dd><p>Computes the approximate log2 of the maximum of the absolute
values of the coefficients.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bernstein_polynomial_factory_intlist</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">60000</span><span class="p">])</span><span class="o">.</span><span class="n">coeffs_bitsize</span><span class="p">()</span>
<span class="go">16</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ratlist">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">bernstein_polynomial_factory_ratlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeffs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ratlist" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory" title="sage.rings.polynomial.real_roots.bernstein_polynomial_factory"><code class="xref py py-class docutils literal notranslate"><span class="pre">bernstein_polynomial_factory</span></code></a></p>
<p>This class holds an exact Bernstein polynomial (represented
as a list of rational coefficients), and returns arbitrarily-precise
interval approximations of this polynomial on demand.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ratlist.bernstein_polynomial">
<span class="sig-name descname"><span class="pre">bernstein_polynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale_log2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ratlist.bernstein_polynomial" title="Link to this definition">#</a></dt>
<dd><p>Compute an interval_bernstein_polynomial_integer that approximates
this polynomial, using the given scale_log2.  (Smaller scale_log2
values give more accurate approximations.)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bpf</span> <span class="o">=</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">193</span><span class="o">/</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">140</span><span class="o">/</span><span class="mi">99</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">degree 3 IBP with 3-bit coefficients</span>
<span class="gp">sage: </span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">&lt;IBP: ((0, -1, 0, -1) + [0 .. 1)) * 2^20; lsign 1&gt;</span>
<span class="gp">sage: </span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&lt;IBP: (0, -4, 2, -2) + [0 .. 1); lsign 1&gt;</span>
<span class="gp">sage: </span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">)</span>
<span class="go">&lt;IBP: ((349525, -3295525, 2850354, -1482835) + [0 .. 1)) * 2^-20&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ratlist.coeffs_bitsize">
<span class="sig-name descname"><span class="pre">coeffs_bitsize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ratlist.coeffs_bitsize" title="Link to this definition">#</a></dt>
<dd><p>Computes the approximate log2 of the maximum of the absolute
values of the coefficients.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">60000</span><span class="p">])</span><span class="o">.</span><span class="n">coeffs_bitsize</span><span class="p">()</span>
<span class="go">15</span>
<span class="gp">sage: </span><span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">65535</span><span class="o">/</span><span class="mi">65536</span><span class="p">])</span><span class="o">.</span><span class="n">coeffs_bitsize</span><span class="p">()</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">65536</span><span class="o">/</span><span class="mi">65535</span><span class="p">])</span><span class="o">.</span><span class="n">coeffs_bitsize</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.bernstein_up">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">bernstein_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_up" title="Link to this definition">#</a></dt>
<dd><p>Given polynomial degrees d1 and d2, where d1 &lt; d2, compute a matrix bu.</p>
<p>If you have a Bernstein polynomial of formal degree d1, and
multiply its coefficient vector by bu, then the result is the
coefficient vector of the same polynomial represented as a
Bernstein polynomial of formal degree d2.</p>
<p>If s is not None, then it represents a number of samples; then the
product only gives s of the coefficients of the new Bernstein polynomial,
selected according to subsample_vec.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bernstein_down</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">[  12/5     -4      3   -2/5]</span>
<span class="go">[-13/15   16/3     -4   8/15]</span>
<span class="go">[  8/15     -4   16/3 -13/15]</span>
<span class="go">[  -2/5      3     -4   12/5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.bitsize_doctest">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">bitsize_doctest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bitsize_doctest" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.cl_maximum_root">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">cl_maximum_root</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cl</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.cl_maximum_root" title="Link to this definition">#</a></dt>
<dd><p>Given a polynomial represented by a list of its coefficients
(as RealIntervalFieldElements), compute an upper bound on its
largest real root.</p>
<p>Uses two algorithms of Akritas, Strzebo'nski, and Vigklas, and
picks the better result.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">cl_maximum_root</span><span class="p">([</span><span class="n">RIF</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">RIF</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">RIF</span><span class="p">(</span><span class="mi">1</span><span class="p">)])</span>
<span class="go">1.00000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.cl_maximum_root_first_lambda">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">cl_maximum_root_first_lambda</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cl</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.cl_maximum_root_first_lambda" title="Link to this definition">#</a></dt>
<dd><p>Given a polynomial represented by a list of its coefficients
(as RealIntervalFieldElements), compute an upper bound on its
largest real root.</p>
<p>Uses the first-lambda algorithm from “Implementations of a New Theorem
for Computing Bounds for Positive Roots of Polynomials”,
by Akritas, Strzebo'nski, and Vigklas.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">cl_maximum_root_first_lambda</span><span class="p">([</span><span class="n">RIF</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">RIF</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">RIF</span><span class="p">(</span><span class="mi">1</span><span class="p">)])</span>
<span class="go">1.00000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.cl_maximum_root_local_max">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">cl_maximum_root_local_max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cl</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.cl_maximum_root_local_max" title="Link to this definition">#</a></dt>
<dd><p>Given a polynomial represented by a list of its coefficients
(as RealIntervalFieldElements), compute an upper bound on its
largest real root.</p>
<p>Uses the local-max algorithm from “Implementations of a New Theorem
for Computing Bounds for Positive Roots of Polynomials”,
by Akritas, Strzebo'nski, and Vigklas.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">cl_maximum_root_local_max</span><span class="p">([</span><span class="n">RIF</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">RIF</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">RIF</span><span class="p">(</span><span class="mi">1</span><span class="p">)])</span>
<span class="go">1.41421356237310</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.context">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">context</span></span><a class="headerlink" href="#sage.rings.polynomial.real_roots.context" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A simple context class, which is passed through parts of the
real root isolation algorithm to avoid global variables.</p>
<p>Holds logging information, a random number generator, and
the target machine wordsize.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.context.get_be_log">
<span class="sig-name descname"><span class="pre">get_be_log</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.context.get_be_log" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.context.get_dc_log">
<span class="sig-name descname"><span class="pre">get_dc_log</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.context.get_dc_log" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.de_casteljau_doublevec">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">de_casteljau_doublevec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.de_casteljau_doublevec" title="Link to this definition">#</a></dt>
<dd><p>Given a polynomial in Bernstein form with floating-point coefficients
over the region [0 .. 1], and a split point x, use de Casteljau’s
algorithm to give polynomials in Bernstein form over [0 .. x] and
[x .. 1].</p>
<p>This function will work for an arbitrary rational split point x, as
long as 0 &lt; x &lt; 1; but it has a specialized code path for x==1/2.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">c</span></code> – vector of coefficients of polynomial in Bernstein form</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – rational splitting point; 0 &lt; x &lt; 1</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">c1</span></code> – coefficients of polynomial over range [0 .. x]</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">c2</span></code> – coefficients of polynomial over range [x .. 1]</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">err_inc</span></code> – number of half-ulps by which error intervals widened</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">de_casteljau_doublevec</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="go">((0.7, 0.35, 0.175, 0.0875, 0.04375, 0.021875), (0.021875, 0.0, 0.0, 0.0, 0.0, 0.0), 5)</span>
<span class="gp">sage: </span><span class="n">de_casteljau_doublevec</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># rel tol</span>
<span class="go">((0.7, 0.4666666666666667, 0.31111111111111117, 0.20740740740740746, 0.13827160493827165, 0.09218106995884777), (0.09218106995884777, 0.0, 0.0, 0.0, 0.0, 0.0), 15)</span>
<span class="gp">sage: </span><span class="n">de_casteljau_doublevec</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">7</span><span class="o">/</span><span class="mi">22</span><span class="p">)</span>  <span class="c1"># rel tol</span>
<span class="go">((0.7, 0.4772727272727273, 0.3254132231404959, 0.22187265214124724, 0.15127680827812312, 0.10314327837144759), (0.10314327837144759, 0.0, 0.0, 0.0, 0.0, 0.0), 15)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.de_casteljau_intvec">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">de_casteljau_intvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_bitsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_ints</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.de_casteljau_intvec" title="Link to this definition">#</a></dt>
<dd><p>Given a polynomial in Bernstein form with integer coefficients
over the region [0 .. 1], and a split point x, use de Casteljau’s
algorithm to give polynomials in Bernstein form over [0 .. x] and
[x .. 1].</p>
<p>This function will work for an arbitrary rational split point x, as
long as 0 &lt; x &lt; 1; but it has specialized code paths that make
some values of x faster than others.  If x == a/(a + b),
there are special efficient cases for a==1, b==1, a+b fits in a machine
word, a+b is a power of 2, a fits in a machine word, b fits in
a machine word.  The most efficient case is x==1/2.</p>
<p>Given split points x == a/(a + b) and y == c/(c + d), where
min(a, b) and min(c, d) fit in the same number of machine words
and a+b and c+d are both powers of two, then x and y should be
equally fast split points.</p>
<p>If use_ints is nonzero, then instead of checking whether numerators
and denominators fit in machine words, we check whether they fit in
ints (32 bits, even on 64-bit machines).  This slows things down, but
allows for identical results across machines.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">c</span></code> – vector of coefficients of polynomial in Bernstein form</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">c_bitsize</span></code> – approximate size of coefficients in c (in bits)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – rational splitting point; 0 &lt; x &lt; 1</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">c1</span></code> – coefficients of polynomial over range [0 .. x]</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">c2</span></code> – coefficients of polynomial over range [x .. 1]</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">err_inc</span></code> – amount by which error intervals widened</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1048576</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">de_casteljau_intvec</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">((1048576, 524288, 262144, 131072, 65536, 32768), (32768, 0, 0, 0, 0, 0), 1)</span>
<span class="gp">sage: </span><span class="n">de_casteljau_intvec</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">((1048576, 699050, 466033, 310689, 207126, 138084), (138084, 0, 0, 0, 0, 0), 1)</span>
<span class="gp">sage: </span><span class="n">de_casteljau_intvec</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">7</span><span class="o">/</span><span class="mi">22</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">((1048576, 714938, 487457, 332357, 226607, 154505), (154505, 0, 0, 0, 0, 0), 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.degree_reduction_next_size">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">degree_reduction_next_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.degree_reduction_next_size" title="Link to this definition">#</a></dt>
<dd><p>Given n (a polynomial degree), returns either a smaller integer or None.
This defines the sequence of degrees followed by our degree reduction
implementation.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">degree_reduction_next_size</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="go">30</span>
<span class="gp">sage: </span><span class="n">degree_reduction_next_size</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">15</span>
<span class="gp">sage: </span><span class="n">degree_reduction_next_size</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">degree_reduction_next_size</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.dprod_imatrow_vec">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">dprod_imatrow_vec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.dprod_imatrow_vec" title="Link to this definition">#</a></dt>
<dd><p>Computes the dot product of row k of the matrix m with the vector v
(that is, compute one element of the product m*v).</p>
<p>If v has more elements than m has columns, then elements of v are
selected using subsample_vec.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">dprod_imatrow_vec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">dprod_imatrow_vec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">dprod_imatrow_vec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">dprod_imatrow_vec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">dprod_imatrow_vec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">dprod_imatrow_vec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">dprod_imatrow_vec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">dprod_imatrow_vec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">26</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.get_realfield_rndu">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">get_realfield_rndu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.get_realfield_rndu" title="Link to this definition">#</a></dt>
<dd><p>A simple cache for RealField fields (with rounding set to
round-to-positive-infinity).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">get_realfield_rndu</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">Real Field with 20 bits of precision and rounding RNDU</span>
<span class="gp">sage: </span><span class="n">get_realfield_rndu</span><span class="p">(</span><span class="mi">53</span><span class="p">)</span>
<span class="go">Real Field with 53 bits of precision and rounding RNDU</span>
<span class="gp">sage: </span><span class="n">get_realfield_rndu</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">Real Field with 20 bits of precision and rounding RNDU</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">interval_bernstein_polynomial</span></span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An interval_bernstein_polynomial is an approximation to an exact
polynomial.  This approximation is in the form of a Bernstein
polynomial (a polynomial given as coefficients over a Bernstein
basis) with interval coefficients.</p>
<p>The Bernstein basis of degree n over the region [a .. b] is the
set of polynomials</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\binom{n}{k} (x-a)^k (b-x)^{n-k} / (b-a)^n\]</div>
</div>
<p>for <span class="math notranslate nohighlight">\(0 \le k \le n\)</span>.</p>
<p>A degree-n interval Bernstein polynomial P with its region [a .. b] can
represent an exact polynomial p in two different ways: it can
“contain” the polynomial or it can “bound” the polynomial.</p>
<p>We say that P contains p if, when p is represented as a degree-n
Bernstein polynomial over [a .. b], its coefficients are contained
in the corresponding interval coefficients of P.  For instance,
[0.9 .. 1.1]*x^2 (which is a degree-2 interval Bernstein polynomial
over [0 .. 1]) contains x^2.</p>
<p>We say that P bounds p if, for all a &lt;= x &lt;= b, there exists a
polynomial p’ contained in P such that p(x) == p’(x).  For instance,
[0 .. 1]*x is a degree-1 interval Bernstein polynomial which bounds
x^2 over [0 .. 1].</p>
<p>If P contains p, then P bounds p; but the converse is not necessarily
true.  In particular, if n &lt; m, it is possible for a degree-n interval
Bernstein polynomial to bound a degree-m polynomial; but it cannot
contain the polynomial.</p>
<p>In the case where P bounds p, we maintain extra information, the
“slope error”.  We say that P (over [a .. b]) bounds p with a
slope error of E (where E is an interval) if there is a polynomial
p’ contained in P such that the derivative of (p - p’) is bounded
by E in the range [a .. b].  If P bounds p with a slope error of 0
then P contains p.</p>
<p>(Note that “contains” and “bounds” are not standard terminology;
I just made them up.)</p>
<p>Interval Bernstein polynomials are useful in finding real roots
because of the following properties:</p>
<ul class="simple">
<li><p>Given an exact real polynomial p, we can compute an interval Bernstein
polynomial over an arbitrary region containing p.</p></li>
<li><p>Given an interval Bernstein polynomial P over [a .. c], where a &lt; b &lt; c,
we can compute interval Bernstein polynomials P1 over [a .. b] and P2
over [b .. c], where P1 and P2 contain (or bound) all polynomials that P
contains (or bounds).</p></li>
<li><p>Given a degree-n interval Bernstein polynomial P over [a .. b], and m &lt;
n, we can compute a degree-m interval Bernstein polynomial P’ over [a ..
b] that bounds all polynomials that P bounds.</p></li>
<li><p>It is sometimes possible to prove that no polynomial bounded by P over [a
.. b] has any roots in [a .. b].  (Roughly, this is possible when no
polynomial contained by P has any complex roots near the line segment [a
.. b], where “near” is defined relative to the length b-a.)</p></li>
<li><p>It is sometimes possible to prove that every polynomial bounded by P over
[a .. b] with slope error E has exactly one root in [a .. b].  (Roughly,
this is possible when every polynomial contained by P over [a .. b] has
exactly one root in [a .. b], there are no other complex roots near the
line segment [a .. b], and every polynomial contained in P has a
derivative which is bounded away from zero over [a .. b] by an amount
which is large relative to E.)</p></li>
<li><p>Starting from a sufficiently precise interval Bernstein polynomial, it is
always possible to split it into polynomials which provably have 0 or 1
roots (as long as your original polynomial has no multiple real roots).</p></li>
</ul>
<p>So a rough outline of a family of algorithms would be:</p>
<ul class="simple">
<li><p>Given a polynomial p, compute a region [a .. b] in which any real roots
must lie.</p></li>
<li><p>Compute an interval Bernstein polynomial P containing p over [a .. b].</p></li>
<li><p>Keep splitting P until you have isolated all the roots.  Optionally,
reduce the degree or the precision of the interval Bernstein polynomials
at intermediate stages (to reduce computation time).  If this seems not
to be working, go back and try again with higher precision.</p></li>
</ul>
<p>Obviously, there are many details to be worked out to turn this
into a full algorithm, like:</p>
<ul class="simple">
<li><p>What initial precision is selected for computing P?</p></li>
<li><p>How do you decide when to reduce the degree of intermediate polynomials?</p></li>
<li><p>How do you decide when to reduce the precision of intermediate
polynomials?</p></li>
<li><p>How do you decide where to split the interval Bernstein polynomial
regions?</p></li>
<li><p>How do you decide when to give up and start over with higher precision?</p></li>
</ul>
<p>Each set of answers to these questions gives a different algorithm
(potentially with very different performance characteristics), but all of
them can use this <code class="docutils literal notranslate"><span class="pre">interval_bernstein_polynomial</span></code> class as their basic
building block.</p>
<p>To save computation time, all coefficients in an
<code class="docutils literal notranslate"><span class="pre">interval_bernstein_polynomial</span></code> share the same interval width.
(There is one exception: when creating an <code class="docutils literal notranslate"><span class="pre">interval_bernstein_polynomial</span></code>,
the first and last coefficients can be marked as “known positive”
or “known negative”.  This has some of the same effect as having
a (potentially) smaller interval width for these two coefficients,
although it does not affect de Casteljau splitting.)
To allow for widely varying coefficient magnitudes, all
coefficients in an interval_bernstein_polynomial are scaled
by <span class="math notranslate nohighlight">\(2^n\)</span> (where <span class="math notranslate nohighlight">\(n\)</span> may be positive, negative, or zero).</p>
<p>There are two representations for interval_bernstein_polynomials,
integer and floating-point. These are the two subclasses of
this class; <code class="docutils literal notranslate"><span class="pre">interval_bernstein_polynomial</span></code> itself is an abstract
class.</p>
<p><code class="docutils literal notranslate"><span class="pre">interval_bernstein_polynomial</span></code> and its subclasses are not expected
to be used outside this file.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial.region">
<span class="sig-name descname"><span class="pre">region</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial.region" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial.region_width">
<span class="sig-name descname"><span class="pre">region_width</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial.region_width" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial.try_rand_split">
<span class="sig-name descname"><span class="pre">try_rand_split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logging_note</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial.try_rand_split" title="Link to this definition">#</a></dt>
<dd><p>Compute a random split point r (using the random number generator
embedded in ctx).  We require 1/4 &lt;= r &lt; 3/4 (to ensure that
recursive algorithms make progress).</p>
<p>Then, try doing a de Casteljau split of this polynomial at r, resulting
in polynomials p1 and p2.  If we see that the sign of this polynomial
is determined at r, then return (p1, p2, r); otherwise,
return None.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">50</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">70</span><span class="p">,</span> <span class="mi">200</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">try_rand_split</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>
<span class="go">&lt;IBP: (50, 29, -27, -56, -11) + [0 .. 6) over [0 .. 43/64]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>
<span class="go">&lt;IBP: (-11, 10, 49, 111, 200) + [0 .. 6) over [43/64 .. 1]&gt;</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">try_rand_split</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>
<span class="go">&lt;IBP: (50, 32, -11, -41, -29) + [0 .. 6) over [0 .. 583/1024]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>
<span class="go">&lt;IBP: (-29, -20, 13, 83, 200) + [0 .. 6) over [583/1024 .. 1]&gt;</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpf</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.9</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">],</span> <span class="n">neg_err</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">pos_err</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">try_rand_split</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>  <span class="c1"># rel tol</span>
<span class="go">&lt;IBP: (0.5, 0.2984375, -0.2642578125, -0.5511661529541015, -0.3145806974172592) + [-0.10000000000000069 .. 0.010000000000000677] over [0 .. 43/64]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>  <span class="c1"># rel tol</span>
<span class="go">&lt;IBP: (-0.3145806974172592, -0.19903896331787108, 0.04135986328125002, 0.43546875, 0.99) + [-0.10000000000000069 .. 0.010000000000000677] over [43/64 .. 1]&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial.try_split">
<span class="sig-name descname"><span class="pre">try_split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logging_note</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial.try_split" title="Link to this definition">#</a></dt>
<dd><p>Try doing a de Casteljau split of this polynomial at 1/2, resulting
in polynomials p1 and p2.  If we see that the sign of this polynomial
is determined at 1/2, then return (p1, p2, 1/2); otherwise,
return None.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">50</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">70</span><span class="p">,</span> <span class="mi">200</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">try_split</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>
<span class="go">&lt;IBP: (50, 35, 0, -29, -31) + [0 .. 6) over [0 .. 1/2]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>
<span class="go">&lt;IBP: (-31, -33, -8, 65, 200) + [0 .. 6) over [1/2 .. 1]&gt;</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpf</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.9</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">],</span> <span class="n">neg_err</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">pos_err</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">try_split</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>
<span class="go">&lt;IBP: (0.5, 0.35, 0.0, -0.2875, -0.369375) + [-0.10000000000000023 .. 0.010000000000000226] over [0 .. 1/2]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>
<span class="go">&lt;IBP: (-0.369375, -0.45125, -0.3275, 0.14500000000000002, 0.99) + [-0.10000000000000023 .. 0.010000000000000226] over [1/2 .. 1]&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial.variations">
<span class="sig-name descname"><span class="pre">variations</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial.variations" title="Link to this definition">#</a></dt>
<dd><p>Consider a polynomial (written in either the normal power basis
or the Bernstein basis).  Take its list of coefficients, omitting
zeroes.  Count the number of positions in the list where the
sign of one coefficient is opposite the sign of the next coefficient.</p>
<p>This count is the number of sign variations of the polynomial.
According to Descartes’ rule of signs, the number of real
roots of the polynomial (counted with multiplicity) in a
certain interval is always less than or equal to the number of
sign variations, and the difference is always even.  (If the
polynomial is written in the power basis, the region is the
positive reals; if the polynomial is written in the Bernstein
basis over a particular region, then we count roots in that region.)</p>
<p>In particular, a polynomial with no sign variations has no real
roots in the region, and a polynomial with one sign variation
has one real root in the region.</p>
<p>In an interval Bernstein polynomial, we do not necessarily
know the signs of the coefficients (if some of the coefficient
intervals contain zero), so the polynomials contained by
this interval polynomial may not all have the same number
of sign variations.  However, we can compute a range of
possible numbers of sign variations.</p>
<p>This function returns the range, as a 2-tuple of integers.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">interval_bernstein_polynomial_float</span></span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial" title="sage.rings.polynomial.real_roots.interval_bernstein_polynomial"><code class="xref py py-class docutils literal notranslate"><span class="pre">interval_bernstein_polynomial</span></code></a></p>
<p>This is the subclass of <a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial" title="sage.rings.polynomial.real_roots.interval_bernstein_polynomial"><code class="xref py py-class docutils literal notranslate"><span class="pre">interval_bernstein_polynomial</span></code></a> where
polynomial coefficients are represented using floating-point numbers.</p>
<p>In the floating-point representation, each coefficient is represented
as an IEEE double-precision float A, and the (shared) lower and
upper interval widths E1 and E2.  These represent the coefficients
(A+E1)*2^n &lt;= c &lt;= (A+E2)*2^n.</p>
<p>Note that we always have E1 &lt;= 0 &lt;= E2.  Also, each floating-point
coefficient has absolute value less than one.</p>
<p>(Note that <a class="reference internal" href="#sage.rings.polynomial.real_roots.mk_ibpf" title="sage.rings.polynomial.real_roots.mk_ibpf"><code class="xref py py-func docutils literal notranslate"><span class="pre">mk_ibpf()</span></code></a> is a simple helper function for creating
elements of <a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float" title="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float"><code class="xref py py-class docutils literal notranslate"><span class="pre">interval_bernstein_polynomial_float</span></code></a> in doctests.)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpf</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">pos_err</span><span class="o">=</span><span class="mf">0.5</span><span class="p">);</span> <span class="nb">print</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span>
<span class="go">degree 2 IBP with floating-point coefficients</span>
<span class="gp">sage: </span><span class="n">bp</span>
<span class="go">&lt;IBP: (0.1, 0.2, 0.3) + [0.0 .. 0.5]&gt;</span>
<span class="gp">sage: </span><span class="n">bp</span><span class="o">.</span><span class="n">variations</span><span class="p">()</span>
<span class="go">(0, 0)</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpf</span><span class="p">([</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">],</span>                         <span class="c1"># needs sage.symbolic</span>
<span class="gp">....: </span>             <span class="n">lower</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mi">5</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="n">usign</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pos_err</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
<span class="gp">....: </span>             <span class="n">scale_log2</span><span class="o">=-</span><span class="mi">3</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">slope_err</span><span class="o">=</span><span class="n">RIF</span><span class="p">(</span><span class="n">pi</span><span class="p">));</span> <span class="nb">print</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span>
<span class="go">degree 5 IBP with floating-point coefficients</span>
<span class="gp">sage: </span><span class="n">bp</span>                                                                        <span class="c1"># needs sage.symbolic</span>
<span class="go">&lt;IBP: ((-0.3, -0.1, 0.1, -0.1, -0.3, -0.1) + [0.0 .. 0.2]) * 2^-3</span>
<span class="go">      over [1 .. 5/4]; usign 1; level 2; slope_err 3.141592653589794?&gt;</span>
<span class="gp">sage: </span><span class="n">bp</span><span class="o">.</span><span class="n">variations</span><span class="p">()</span>                                                           <span class="c1"># needs sage.symbolic</span>
<span class="go">(3, 3)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.as_float">
<span class="sig-name descname"><span class="pre">as_float</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.as_float" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.de_casteljau">
<span class="sig-name descname"><span class="pre">de_casteljau</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msign</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.de_casteljau" title="Link to this definition">#</a></dt>
<dd><p>Uses de Casteljau’s algorithm to compute the representation
of this polynomial in a Bernstein basis over new regions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mid</span></code> – where to split the Bernstein basis region; <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">mid</span> <span class="pre">&lt;</span> <span class="pre">1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">msign</span></code> – default 0 (unknown); the sign of this polynomial at <code class="docutils literal notranslate"><span class="pre">mid</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bp1</span></code>, <code class="docutils literal notranslate"><span class="pre">bp2</span></code> – the new interval Bernstein polynomials</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ok</span></code> – a boolean; <code class="docutils literal notranslate"><span class="pre">True</span></code> if the sign of the original polynomial at <code class="docutils literal notranslate"><span class="pre">mid</span></code> is known</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">mk_context</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpf</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.9</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">],</span> <span class="n">neg_err</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">pos_err</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">de_casteljau</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>
<span class="go">&lt;IBP: (0.5, 0.35, 0.0, -0.2875, -0.369375) + [-0.10000000000000023 .. 0.010000000000000226] over [0 .. 1/2]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>
<span class="go">&lt;IBP: (-0.369375, -0.45125, -0.3275, 0.14500000000000002, 0.99) + [-0.10000000000000023 .. 0.010000000000000226] over [1/2 .. 1]&gt;</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">de_casteljau</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span> <span class="c1"># rel tol 2e-16</span>
<span class="go">&lt;IBP: (0.5, 0.30000000000000004, -0.2555555555555555, -0.5444444444444444, -0.32172839506172846) + [-0.10000000000000069 .. 0.010000000000000677] over [0 .. 2/3]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>  <span class="c1"># rel tol 3e-15</span>
<span class="go">&lt;IBP: (-0.32172839506172846, -0.21037037037037046, 0.028888888888888797, 0.4266666666666666, 0.99) + [-0.10000000000000069 .. 0.010000000000000677] over [2/3 .. 1]&gt;</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">de_casteljau</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">7</span><span class="o">/</span><span class="mi">39</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>  <span class="c1"># rel tol</span>
<span class="go">&lt;IBP: (0.5, 0.4461538461538461, 0.36653517422748183, 0.27328680523946786, 0.1765692706232836) + [-0.10000000000000069 .. 0.010000000000000677] over [0 .. 7/39]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>  <span class="c1"># rel tol</span>
<span class="go">&lt;IBP: (0.1765692706232836, -0.26556803047927313, -0.7802038132807364, -0.3966666666666666, 0.99) + [-0.10000000000000069 .. 0.010000000000000677] over [7/39 .. 1]&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.get_msb_bit">
<span class="sig-name descname"><span class="pre">get_msb_bit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.get_msb_bit" title="Link to this definition">#</a></dt>
<dd><p>Return an approximation of the log2 of the maximum of the
absolute values of the coefficients, as an integer.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.slope_range">
<span class="sig-name descname"><span class="pre">slope_range</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.slope_range" title="Link to this definition">#</a></dt>
<dd><p>Compute a bound on the derivative of this polynomial, over its region.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpf</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.9</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">],</span> <span class="n">neg_err</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">pos_err</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp</span><span class="o">.</span><span class="n">slope_range</span><span class="p">()</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;brackets&#39;</span><span class="p">)</span>
<span class="go">&#39;[-4.8400000000000017 .. 7.2000000000000011]&#39;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">interval_bernstein_polynomial_integer</span></span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial" title="sage.rings.polynomial.real_roots.interval_bernstein_polynomial"><code class="xref py py-class docutils literal notranslate"><span class="pre">interval_bernstein_polynomial</span></code></a></p>
<p>This is the subclass of <a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial" title="sage.rings.polynomial.real_roots.interval_bernstein_polynomial"><code class="xref py py-class docutils literal notranslate"><span class="pre">interval_bernstein_polynomial</span></code></a> where
polynomial coefficients are represented using integers.</p>
<p>In this integer representation, each coefficient is represented by
a GMP arbitrary-precision integer A, and a (shared) interval width
E (which is a machine integer).  These represent the coefficients
A*2^n &lt;= c &lt; (A+E)*2^n.</p>
<p>(Note that <code class="xref py py-func docutils literal notranslate"><span class="pre">mk_ibpi</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">simple</span> <span class="pre">helper()</span></code> function for creating
elements of <a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer" title="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">interval_bernstein_polynomial_integer</span></code></a> in doctests.)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">5</span><span class="p">);</span> <span class="nb">print</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span>
<span class="go">degree 2 IBP with 2-bit coefficients</span>
<span class="gp">sage: </span><span class="n">bp</span>
<span class="go">&lt;IBP: (1, 2, 3) + [0 .. 5)&gt;</span>
<span class="gp">sage: </span><span class="n">bp</span><span class="o">.</span><span class="n">variations</span><span class="p">()</span>
<span class="go">(0, 0)</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">lower</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mi">5</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="n">usign</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>        <span class="c1"># needs sage.symbolic</span>
<span class="gp">....: </span>             <span class="n">error</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">scale_log2</span><span class="o">=-</span><span class="mi">3</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">slope_err</span><span class="o">=</span><span class="n">RIF</span><span class="p">(</span><span class="n">pi</span><span class="p">));</span> <span class="nb">print</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span>
<span class="go">degree 5 IBP with 2-bit coefficients</span>
<span class="gp">sage: </span><span class="n">bp</span>                                                                        <span class="c1"># needs sage.symbolic</span>
<span class="go">&lt;IBP: ((-3, -1, 1, -1, -3, -1) + [0 .. 2)) * 2^-3 over [1 .. 5/4]; usign 1;</span>
<span class="go">      level 2; slope_err 3.141592653589794?&gt;</span>
<span class="gp">sage: </span><span class="n">bp</span><span class="o">.</span><span class="n">variations</span><span class="p">()</span>                                                           <span class="c1"># needs sage.symbolic</span>
<span class="go">(3, 3)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.as_float">
<span class="sig-name descname"><span class="pre">as_float</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.as_float" title="Link to this definition">#</a></dt>
<dd><p>Compute an interval_bernstein_polynomial_float which contains
(or bounds) all the polynomials this interval polynomial
contains (or bounds).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">50</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">70</span><span class="p">,</span> <span class="mi">200</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">bp</span><span class="o">.</span><span class="n">as_float</span><span class="p">())</span>
<span class="go">degree 4 IBP with floating-point coefficients</span>
<span class="gp">sage: </span><span class="n">bp</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span>
<span class="go">&lt;IBP: ((0.1953125, 0.078125, -0.3515625, -0.2734375, 0.78125) + [-1.1275702593849246e-16 .. 0.01953125000000017]) * 2^8&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.de_casteljau">
<span class="sig-name descname"><span class="pre">de_casteljau</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msign</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.de_casteljau" title="Link to this definition">#</a></dt>
<dd><p>Uses de Casteljau’s algorithm to compute the representation
of this polynomial in a Bernstein basis over new regions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mid</span></code> – where to split the Bernstein basis region; 0 &lt; mid &lt; 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">msign</span></code> – default 0 (unknown); the sign of this polynomial at mid</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bp1</span></code>, <code class="docutils literal notranslate"><span class="pre">bp2</span></code> – the new interval Bernstein polynomials</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ok</span></code> – a boolean; True if the sign of the original polynomial at mid is known</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">50</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">70</span><span class="p">,</span> <span class="mi">200</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">mk_context</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">de_casteljau</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>
<span class="go">&lt;IBP: (50, 35, 0, -29, -31) + [0 .. 6) over [0 .. 1/2]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>
<span class="go">&lt;IBP: (-31, -33, -8, 65, 200) + [0 .. 6) over [1/2 .. 1]&gt;</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">de_casteljau</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>
<span class="go">&lt;IBP: (50, 30, -26, -55, -13) + [0 .. 6) over [0 .. 2/3]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>
<span class="go">&lt;IBP: (-13, 8, 47, 110, 200) + [0 .. 6) over [2/3 .. 1]&gt;</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">de_casteljau</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">7</span><span class="o">/</span><span class="mi">39</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>
<span class="go">&lt;IBP: (50, 44, 36, 27, 17) + [0 .. 6) over [0 .. 7/39]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>
<span class="go">&lt;IBP: (17, -26, -75, -22, 200) + [0 .. 6) over [7/39 .. 1]&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.down_degree">
<span class="sig-name descname"><span class="pre">down_degree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_err</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exp_err_shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.down_degree" title="Link to this definition">#</a></dt>
<dd><p>Compute an interval_bernstein_polynomial_integer which bounds
all the polynomials this interval polynomial bounds, but is
of lesser degree.</p>
<p>During the computation, we find an “expected error”
expected_err, which is the error inherent in our approach
(this depends on the degrees involved, and is proportional
to the error of the current polynomial).</p>
<p>We require that the error of the new interval polynomial
be bounded both by max_err, and by expected_err &lt;&lt; exp_err_shift.
If we find such a polynomial p, then we return a pair of p and some
debugging/logging information.  Otherwise, we return the pair
(None, None).</p>
<p>If the resulting polynomial would have error more than 2^17,
then it is downscaled before returning.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">903</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">mk_context</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bp</span>
<span class="go">&lt;IBP: (0, 100, 400, 903) + [0 .. 2)&gt;</span>
<span class="gp">sage: </span><span class="n">dbp</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">down_degree</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dbp</span>
<span class="go">&lt;IBP: (-1, 148, 901) + [0 .. 4); level 1; slope_err 0.?e2&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.down_degree_iter">
<span class="sig-name descname"><span class="pre">down_degree_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_scale</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.down_degree_iter" title="Link to this definition">#</a></dt>
<dd><p>Compute a degree-reduced version of this interval polynomial, by
iterating down_degree.</p>
<p>We stop when degree reduction would give a polynomial which is
too inaccurate, meaning that either we think the current polynomial
may have more roots in its region than the degree of the
reduced polynomial, or that the least significant accurate bit
in the result (on the absolute scale) would be larger than
1 &lt;&lt; max_scale.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">903</span><span class="p">,</span> <span class="mi">1600</span><span class="p">,</span> <span class="mi">2500</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">mk_context</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bp</span>
<span class="go">&lt;IBP: (0, 100, 400, 903, 1600, 2500) + [0 .. 2)&gt;</span>
<span class="gp">sage: </span><span class="n">rbp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">down_degree_iter</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rbp</span>
<span class="go">&lt;IBP: (-4, 249, 2497) + [0 .. 9); level 2; slope_err 0.?e3&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.downscale">
<span class="sig-name descname"><span class="pre">downscale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bits</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.downscale" title="Link to this definition">#</a></dt>
<dd><p>Compute an interval_bernstein_polynomial_integer which
contains (or bounds) all the polynomials this interval
polynomial contains (or bounds), but uses
“bits” fewer bits.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">903</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp</span><span class="o">.</span><span class="n">downscale</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&lt;IBP: ((0, 3, 12, 28) + [0 .. 1)) * 2^5&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.get_msb_bit">
<span class="sig-name descname"><span class="pre">get_msb_bit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.get_msb_bit" title="Link to this definition">#</a></dt>
<dd><p>Return an approximation of the log2 of the maximum of the
absolute values of the coefficients, as an integer.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.slope_range">
<span class="sig-name descname"><span class="pre">slope_range</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.slope_range" title="Link to this definition">#</a></dt>
<dd><p>Compute a bound on the derivative of this polynomial, over its region.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">903</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp</span><span class="o">.</span><span class="n">slope_range</span><span class="p">()</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;brackets&#39;</span><span class="p">)</span>
<span class="go">&#39;[294.00000000000000 .. 1515.0000000000000]&#39;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.intvec_to_doublevec">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">intvec_to_doublevec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.intvec_to_doublevec" title="Link to this definition">#</a></dt>
<dd><p>Given a vector of integers A = [a1, …, an], and an integer
error bound E, returns a vector of floating-point numbers
B = [b1, …, bn], lower and upper error bounds F1 and F2, and
a scaling factor d, such that</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[(bk + F1) * 2^d \le ak\]</div>
</div>
<p>and</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[ak + E \le (bk + F2) * 2^d\]</div>
</div>
<p>If bj is the element of B with largest absolute value, then
0.5 &lt;= abs(bj) &lt; 1.0 .</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">intvec_to_doublevec</span><span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]),</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">((0.125, 0.25, 0.375, 0.5, 0.625), -1.1275702593849246e-16, 0.37500000000000017, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.island">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">island</span></span><a class="headerlink" href="#sage.rings.polynomial.real_roots.island" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This implements the island portion of my ocean-island root isolation
algorithm.  See the documentation for class ocean, for more
information on the overall algorithm.</p>
<p>Island root refinement starts with a Bernstein polynomial whose
region is the whole island (or perhaps slightly more than the
island in certain cases).  There are two subalgorithms; one when
looking at a Bernstein polynomial covering a whole island (so we
know that there are gaps on the left and right), and one when
looking at a Bernstein polynomial covering the left segment of an
island (so we know that there is a gap on the left, but the right
is in the middle of an island).  An important invariant of the
left-segment subalgorithm over the region [l .. r] is that it
always finds a gap [r0 .. r] ending at its right endpoint.</p>
<p>Ignoring degree reduction, downscaling (precision reduction), and
failures to split, the algorithm is roughly:</p>
<p>Whole island:</p>
<ol class="arabic simple">
<li><p>If the island definitely has exactly one root, then return.</p></li>
<li><p>Split the island in (approximately) half.</p></li>
<li><p>If both halves definitely have no roots, then remove this island from
its doubly-linked list (merging its left and right gaps) and return.</p></li>
<li><p>If either half definitely has no roots, then discard that half
and call the whole-island algorithm with the other half, then return.</p></li>
<li><p>If both halves may have roots, then call the left-segment algorithm
on the left half.</p></li>
<li><p>We now know that there is a gap immediately to the left of the
right half, so call the whole-island algorithm on the right half,
then return.</p></li>
</ol>
<p>Left segment:</p>
<ol class="arabic simple">
<li><p>Split the left segment in (approximately) half.</p></li>
<li><p>If both halves definitely have no roots, then extend the left gap
over the segment and return.</p></li>
<li><p>If the left half definitely has no roots, then extend the left gap
over this half and call the left-segment algorithm on the right half,
then return.</p></li>
<li><p>If the right half definitely has no roots, then split the island
in two, creating a new gap.  Call the whole-island algorithm on the
left half, then return.</p></li>
<li><p>Both halves may have roots.  Call the left-segment algorithm on
the left half.</p></li>
<li><p>We now know that there is a gap immediately to the left of the
right half, so call the left-segment algorithm on the right half,
then return.</p></li>
</ol>
<p>Degree reduction complicates this picture only slightly.  Basically,
we use heuristics to decide when degree reduction might be likely
to succeed and be helpful; whenever this is the case, we attempt
degree reduction.</p>
<p>Precision reduction and split failure add more complications.
The algorithm maintains a stack of different-precision representations
of the interval Bernstein polynomial.  The base of the stack
is at the highest (currently known) precision; each stack entry has
approximately half the precision of the entry below it.  When we
do a split, we pop off the top of the stack, split it, then push
whichever half we’re interested in back on the stack (so the
different Bernstein polynomials may be over different regions).
When we push a polynomial onto the stack, we may heuristically decide to
push further lower-precision versions of the same polynomial onto the
stack.</p>
<p>In the algorithm above, whenever we say “split in (approximately) half”,
we attempt to split the top-of-stack polynomial using try_split()
and try_rand_split().  However, these will fail if the sign of the
polynomial at the chosen split point is unknown (if the polynomial is
not known to high enough precision, or if the chosen split point
actually happens to be a root of the polynomial).  If this fails, then
we discard the top-of-stack polynomial, and try again with the
next polynomial down (which has approximately twice the precision).
This next polynomial may not be over the same region; if not, we
split it using de Casteljau’s algorithm to get a polynomial over
(approximately) the same region first.</p>
<p>If we run out of higher-precision polynomials (if we empty out the
entire stack), then we give up on root refinement for this island.
The ocean class will notice this, provide the island with a
higher-precision polynomial, and restart root refinement.  Basically
the only information kept in that case is the lower and upper bounds
on the island.  Since these are updated whenever we discover a “half”
(of an island or a segment) that definitely contains no roots, we
never need to re-examine these gaps.  (We could keep more information.
For example, we could keep a record of split points that succeeded
and failed.  However, a split point that failed at lower precision
is likely to succeed at higher precision, so it’s not worth avoiding.
It could be useful to select split points that are known to succeed,
but starting from a new Bernstein polynomial over a slightly different
region, hitting such split points would require de Casteljau splits
with non-power-of-two denominators, which are much much slower.)</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.island.bp_done">
<span class="sig-name descname"><span class="pre">bp_done</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.island.bp_done" title="Link to this definition">#</a></dt>
<dd><p>Examine the given Bernstein polynomial to see if it is known
to have exactly one root in its region.  (In addition, we require
that the polynomial region not include 0 or 1.  This makes things
work if the user gives explicit bounds to real_roots(),
where the lower or upper bound is a root of the polynomial.
real_roots() deals with this by explicitly detecting it,
dividing out the appropriate linear polynomial, and adding the
root to the returned list of roots; but then if the island
considers itself “done” with a region including 0 or 1, the returned
root regions can overlap with each other.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.island.done">
<span class="sig-name descname"><span class="pre">done</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.island.done" title="Link to this definition">#</a></dt>
<dd><p>Check to see if the island is known to contain zero roots or
is known to contain one root.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.island.has_root">
<span class="sig-name descname"><span class="pre">has_root</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.island.has_root" title="Link to this definition">#</a></dt>
<dd><p>Assuming that the island is done (has either 0 or 1 roots),
reports whether the island has a root.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.island.less_bits">
<span class="sig-name descname"><span class="pre">less_bits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ancestors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.island.less_bits" title="Link to this definition">#</a></dt>
<dd><p>Heuristically pushes lower-precision polynomials on
the polynomial stack.  See the class documentation for class
island for more information.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.island.more_bits">
<span class="sig-name descname"><span class="pre">more_bits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ancestors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rightmost</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.island.more_bits" title="Link to this definition">#</a></dt>
<dd><p>Find a Bernstein polynomial on the “ancestors” stack with
more precision than bp; if it is over a different region,
then shrink its region to (approximately) match that of bp.
(If this is rightmost – if bp covers the whole island – then
we only require that the new region cover the whole island
fairly tightly; if this is not rightmost, then the new region
will have exactly the same right boundary as bp, although the
left boundary may vary slightly.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.island.refine">
<span class="sig-name descname"><span class="pre">refine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.island.refine" title="Link to this definition">#</a></dt>
<dd><p>Attempts to shrink and/or split this island into sub-island
that each definitely contain exactly one root.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.island.refine_recurse">
<span class="sig-name descname"><span class="pre">refine_recurse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ancestors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">history</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rightmost</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.island.refine_recurse" title="Link to this definition">#</a></dt>
<dd><p>This implements the root isolation algorithm described in the
class documentation for class island.  This is the implementation
of both the whole-island and the left-segment algorithms;
if the flag rightmost is True, then it is the whole-island algorithm,
otherwise the left-segment algorithm.</p>
<p>The precision-reduction stack is (ancestors + [bp]); that is, the
top-of-stack is maintained separately.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.island.reset_root_width">
<span class="sig-name descname"><span class="pre">reset_root_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.island.reset_root_width" title="Link to this definition">#</a></dt>
<dd><p>Modify the criteria for this island to require that it is not “done”
until its width is less than or equal to target_width.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.island.shrink_bp">
<span class="sig-name descname"><span class="pre">shrink_bp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.island.shrink_bp" title="Link to this definition">#</a></dt>
<dd><p>If the island’s Bernstein polynomial covers a region much larger
than the island itself (in particular, if either the island’s
left gap or right gap are totally contained in the polynomial’s
region) then shrink the polynomial down to cover the island more
tightly.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.linear_map">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">linear_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lower</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.linear_map" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A simple class to map linearly between original coordinates
(ranging from [lower .. upper]) and ocean coordinates (ranging
from [0 .. 1]).</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.linear_map.from_ocean">
<span class="sig-name descname"><span class="pre">from_ocean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">region</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.linear_map.from_ocean" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.linear_map.to_ocean">
<span class="sig-name descname"><span class="pre">to_ocean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">region</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.linear_map.to_ocean" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.max_abs_doublevec">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">max_abs_doublevec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.max_abs_doublevec" title="Link to this definition">#</a></dt>
<dd><p>Given a floating-point vector, return the maximum of the
absolute values of its elements.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">max_abs_doublevec</span><span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.767</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.693</span><span class="p">]))</span>
<span class="go">0.767</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.max_bitsize_intvec_doctest">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">max_bitsize_intvec_doctest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.max_bitsize_intvec_doctest" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.maximum_root_first_lambda">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">maximum_root_first_lambda</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.maximum_root_first_lambda" title="Link to this definition">#</a></dt>
<dd><p>Given a polynomial with real coefficients, computes an upper bound
on its largest real root.</p>
<p>This is using the first-lambda algorithm from
“Implementations of a New Theorem for Computing Bounds for Positive
Roots of Polynomials”, by Akritas, Strzebo'nski, and Vigklas.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">maximum_root_first_lambda</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="go">6.00000000000001</span>
<span class="gp">sage: </span><span class="n">maximum_root_first_lambda</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">))</span>
<span class="go">0.000000000000000</span>
<span class="gp">sage: </span><span class="n">maximum_root_first_lambda</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">1.00000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.maximum_root_local_max">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">maximum_root_local_max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.maximum_root_local_max" title="Link to this definition">#</a></dt>
<dd><p>Given a polynomial with real coefficients, computes an upper bound
on its largest real root, using the local-max algorithm from
“Implementations of a New Theorem for Computing Bounds for Positive
Roots of Polynomials”, by Akritas, Strzebo'nski, and Vigklas.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">maximum_root_local_max</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="go">12.0000000000001</span>
<span class="gp">sage: </span><span class="n">maximum_root_local_max</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">))</span>
<span class="go">0.000000000000000</span>
<span class="gp">sage: </span><span class="n">maximum_root_local_max</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">1.41421356237310</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.min_max_delta_intvec">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">min_max_delta_intvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.min_max_delta_intvec" title="Link to this definition">#</a></dt>
<dd><p>Given two integer vectors a and b (of equal, nonzero length), return
a pair of the minimum and maximum values taken on by a[i] - b[i].</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">30</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="o">-</span><span class="mi">60</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">min_max_delta_intvec</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">(30, -5)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.min_max_diff_doublevec">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">min_max_diff_doublevec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.min_max_diff_doublevec" title="Link to this definition">#</a></dt>
<dd><p>Given a floating-point vector b = (b0, …, bn), compute the
minimum and maximum values of b_{j+1} - b_j.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">min_max_diff_doublevec</span><span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">(-9.0, 6.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.min_max_diff_intvec">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">min_max_diff_intvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.min_max_diff_intvec" title="Link to this definition">#</a></dt>
<dd><p>Given an integer vector b = (b0, …, bn), compute the
minimum and maximum values of b_{j+1} - b_j.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">min_max_diff_intvec</span><span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">(-9, 6)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.mk_context">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">mk_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">do_logging</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wordsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.mk_context" title="Link to this definition">#</a></dt>
<dd><p>A simple wrapper for creating context objects with coercions,
defaults, etc.</p>
<p>For use in doctests.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">mk_context</span><span class="p">(</span><span class="n">do_logging</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">wordsize</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
<span class="go">root isolation context: seed=3; do_logging=True; wordsize=64</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.mk_ibpf">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">mk_ibpf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lsign</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usign</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg_err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_log2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope_err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.mk_ibpf" title="Link to this definition">#</a></dt>
<dd><p>A simple wrapper for creating <a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float" title="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float"><code class="xref py py-class docutils literal notranslate"><span class="pre">interval_bernstein_polynomial_float</span></code></a>
objects with coercions, defaults, etc.</p>
<p>For use in doctests.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">mk_ibpf</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.9</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">],</span> <span class="n">pos_err</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">neg_err</span><span class="o">=-</span><span class="mf">0.01</span><span class="p">))</span>
<span class="go">degree 4 IBP with floating-point coefficients</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.mk_ibpi">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">mk_ibpi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lsign</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usign</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_log2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope_err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.mk_ibpi" title="Link to this definition">#</a></dt>
<dd><p>A simple wrapper for creating interval_bernstein_polynomial_integer
objects with coercions, defaults, etc.</p>
<p>For use in doctests.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">50</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">70</span><span class="p">,</span> <span class="mi">200</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span>
<span class="go">degree 4 IBP with 8-bit coefficients</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.ocean">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">ocean</span></span><a class="headerlink" href="#sage.rings.polynomial.real_roots.ocean" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Given the tools we’ve defined so far, there are many possible root
isolation algorithms that differ on where to select split points,
what precision to work at when, and when to attempt degree
reduction.</p>
<p>Here we implement one particular algorithm, which I call the
ocean-island algorithm.  We start with an interval Bernstein
polynomial defined over the region [0 .. 1].  This region is
the “ocean”.  Using de Casteljau’s algorithm and Descartes’
rule of signs, we divide this region into subregions which may
contain roots, and subregions which are guaranteed not to contain
roots.  Subregions which may contain roots are “islands”; subregions
known not to contain roots are “gaps”.</p>
<p>All the real root isolation work happens in class island.  See the
documentation of that class for more information.</p>
<p>An island can be told to refine itself until it contains only a
single root.  This may not succeed, if the island’s interval
Bernstein polynomial does not have enough precision.  The ocean
basically loops, refining each of its islands, then increasing the
precision of islands which did not succeed in isolating a single
root; until all islands are done.</p>
<p>Increasing the precision of unsuccessful islands is done in a
single pass using split_for_target(); this means it is possible
to share work among multiple islands.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.ocean.all_done">
<span class="sig-name descname"><span class="pre">all_done</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.ocean.all_done" title="Link to this definition">#</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> iff all islands are known to contain exactly one root.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">oc</span> <span class="o">=</span> <span class="n">ocean</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">193</span><span class="o">/</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">140</span><span class="o">/</span><span class="mi">99</span><span class="p">]),</span> <span class="n">lmap</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">all_done</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">find_roots</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">all_done</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.ocean.approx_bp">
<span class="sig-name descname"><span class="pre">approx_bp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale_log2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.ocean.approx_bp" title="Link to this definition">#</a></dt>
<dd><p>Return an approximation to our Bernstein polynomial with the
given scale_log2.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">oc</span> <span class="o">=</span> <span class="n">ocean</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">193</span><span class="o">/</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">140</span><span class="o">/</span><span class="mi">99</span><span class="p">]),</span> <span class="n">lmap</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">approx_bp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&lt;IBP: (0, -4, 2, -2) + [0 .. 1); lsign 1&gt;</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">approx_bp</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">)</span>
<span class="go">&lt;IBP: ((349525, -3295525, 2850354, -1482835) + [0 .. 1)) * 2^-20&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.ocean.find_roots">
<span class="sig-name descname"><span class="pre">find_roots</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.ocean.find_roots" title="Link to this definition">#</a></dt>
<dd><p>Isolate all roots in this ocean.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">oc</span> <span class="o">=</span> <span class="n">ocean</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">193</span><span class="o">/</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">140</span><span class="o">/</span><span class="mi">99</span><span class="p">]),</span> <span class="n">lmap</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span>
<span class="go">ocean with precision 120 and 1 island(s)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">find_roots</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span>
<span class="go">ocean with precision 120 and 3 island(s)</span>
<span class="gp">sage: </span><span class="n">oc</span> <span class="o">=</span> <span class="n">ocean</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1111</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">11108889</span><span class="o">/</span><span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">lmap</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">find_roots</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span>
<span class="go">ocean with precision 240 and 3 island(s)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.ocean.increase_precision">
<span class="sig-name descname"><span class="pre">increase_precision</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.ocean.increase_precision" title="Link to this definition">#</a></dt>
<dd><p>Increase the precision of the interval Bernstein polynomial held
by any islands which are not done.  (In normal use, calls to this
function are separated by calls to self.refine_all().)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">oc</span> <span class="o">=</span> <span class="n">ocean</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">193</span><span class="o">/</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">140</span><span class="o">/</span><span class="mi">99</span><span class="p">]),</span> <span class="n">lmap</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span>
<span class="go">ocean with precision 120 and 1 island(s)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">increase_precision</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">increase_precision</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">increase_precision</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span>
<span class="go">ocean with precision 960 and 1 island(s)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.ocean.refine_all">
<span class="sig-name descname"><span class="pre">refine_all</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.ocean.refine_all" title="Link to this definition">#</a></dt>
<dd><p>Refine all islands which are not done (which are not known to
contain exactly one root).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">oc</span> <span class="o">=</span> <span class="n">ocean</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">193</span><span class="o">/</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">140</span><span class="o">/</span><span class="mi">99</span><span class="p">]),</span> <span class="n">lmap</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span>
<span class="go">ocean with precision 120 and 1 island(s)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">refine_all</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span>
<span class="go">ocean with precision 120 and 3 island(s)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.ocean.reset_root_width">
<span class="sig-name descname"><span class="pre">reset_root_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">isle_num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.ocean.reset_root_width" title="Link to this definition">#</a></dt>
<dd><p>Require that the isle_num island have a width at most target_width.</p>
<p>If this is followed by a call to find_roots(), then the
corresponding root will be refined to the specified width.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">oc</span> <span class="o">=</span> <span class="n">ocean</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">lmap</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">find_roots</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">roots</span><span class="p">()</span>
<span class="go">[(1/2, 3/4)]</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">reset_root_width</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">^</span><span class="mi">200</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">find_roots</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span>
<span class="go">ocean with precision 240 and 1 island(s)</span>
<span class="gp">sage: </span><span class="n">RR</span><span class="p">(</span><span class="n">RealIntervalField</span><span class="p">(</span><span class="mi">300</span><span class="p">)(</span><span class="n">oc</span><span class="o">.</span><span class="n">roots</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">absolute_diameter</span><span class="p">())</span><span class="o">.</span><span class="n">log2</span><span class="p">()</span>
<span class="go">-232.668979560890</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.ocean.roots">
<span class="sig-name descname"><span class="pre">roots</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.ocean.roots" title="Link to this definition">#</a></dt>
<dd><p>Return the locations of all islands in this ocean.  (If run
after find_roots(), this is the location of all roots in the ocean.)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">oc</span> <span class="o">=</span> <span class="n">ocean</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">193</span><span class="o">/</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">140</span><span class="o">/</span><span class="mi">99</span><span class="p">]),</span> <span class="n">lmap</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">find_roots</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">roots</span><span class="p">()</span>
<span class="go">[(1/32, 1/16), (1/2, 5/8), (3/4, 7/8)]</span>
<span class="gp">sage: </span><span class="n">oc</span> <span class="o">=</span> <span class="n">ocean</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1111</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">11108889</span><span class="o">/</span><span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">lmap</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">find_roots</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">roots</span><span class="p">()</span>
<span class="go">[(95761241267509487747625/9671406556917033397649408, 191522482605387719863145/19342813113834066795298816), (1496269395904347376805/151115727451828646838272, 374067366568272936175/37778931862957161709568), (31/32, 63/64)]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.precompute_degree_reduction_cache">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">precompute_degree_reduction_cache</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.precompute_degree_reduction_cache" title="Link to this definition">#</a></dt>
<dd><p>Compute and cache the matrices used for degree reduction, starting
from degree n.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">precompute_degree_reduction_cache</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dr_cache</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
<span class="go">(</span>
<span class="go">   [121/126    8/63    -1/9   -2/63  11/126   -2/63]</span>
<span class="go">   [   -3/7   37/42   16/21    1/21    -3/7     1/6]</span>
<span class="go">   [    1/6    -3/7    1/21   16/21   37/42    -3/7]</span>
<span class="go">3, [  -2/63  11/126   -2/63    -1/9    8/63 121/126], 2,</span>

<span class="go">([121  16 -14  -4  11  -4]</span>
<span class="go">[-54 111  96   6 -54  21]</span>
<span class="go">[ 21 -54   6  96 111 -54]</span>
<span class="go">[ -4  11  -4 -14  16 121], 126)</span>
<span class="go">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.pseudoinverse">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">pseudoinverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.pseudoinverse" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.rational_root_bounds">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">rational_root_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.rational_root_bounds" title="Link to this definition">#</a></dt>
<dd><p>Given a polynomial p with real coefficients, computes rationals
a and b, such that for every real root r of p, a &lt; r &lt; b.
We try to find rationals which bound the roots somewhat tightly,
yet are simple (have small numerators and denominators).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rational_root_bounds</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="go">(0, 7)</span>
<span class="gp">sage: </span><span class="n">rational_root_bounds</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(-1/2, 1/2)</span>
<span class="gp">sage: </span><span class="n">rational_root_bounds</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="go">(-3/2, 1/2)</span>
<span class="gp">sage: </span><span class="n">rational_root_bounds</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="go">(-3, 6)</span>
<span class="gp">sage: </span><span class="n">rational_root_bounds</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">995</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">9999</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(-100, 1000/7)</span>
<span class="gp">sage: </span><span class="n">rational_root_bounds</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">995</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">9999</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(-142, 213/2)</span>
</pre></div>
</div>
<dl class="simple">
<dt>If we can see that the polynomial has no real roots, return None.</dt><dd><p>sage: rational_root_bounds(x^2 + 7) is None
True</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.real_roots">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">real_roots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_squarefree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_logging</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wordsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">retval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rational'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_diameter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.real_roots" title="Link to this definition">#</a></dt>
<dd><p>Compute the real roots of a given polynomial with exact coefficients
(integer, rational, and algebraic real coefficients are supported).</p>
<p>This returns a list of pairs of a root and its multiplicity.</p>
<p>The root itself can be returned in one of three different ways.
If retval==’rational’, then it is returned as a pair of rationals
that define a region that includes exactly one root.  If
retval==’interval’, then it is returned as a RealIntervalFieldElement
that includes exactly one root.  If retval==’algebraic_real’, then
it is returned as an AlgebraicReal.  In the former two cases, all
the intervals are disjoint.</p>
<p>An alternate high-level algorithm can be used by selecting
strategy=’warp’.  This affects the conversion into Bernstein
polynomial form, but still uses the same ocean-island algorithm
as the default algorithm.  The ‘warp’ algorithm performs the conversion
into Bernstein polynomial form much more quickly, but performs
the rest of the computation slightly slower in some benchmarks.
The ‘warp’ algorithm is particularly likely to be helpful for
low-degree polynomials.</p>
<p>Part of the algorithm is randomized; the seed parameter gives a seed
for the random number generator.  (By default, the same
seed is used for every call, so that results are repeatable.)  The
random seed may affect the running time, or the exact intervals returned,
but the results are correct regardless of the seed used.</p>
<p>The bounds parameter lets you find roots in some proper subinterval of
the reals; it takes a pair of a rational lower and upper bound
and only roots within this bound will be found.  Currently, specifying
bounds does not work if you select strategy=’warp’, or if you
use a polynomial with algebraic real coefficients.</p>
<p>By default, the algorithm will do a squarefree decomposition
to get squarefree polynomials.  The skip_squarefree parameter
lets you skip this step.  (If this step is skipped, and the polynomial
has a repeated real root, then the algorithm will loop forever!
However, repeated non-real roots are not a problem.)</p>
<p>For integer and rational coefficients, the squarefree
decomposition is very fast, but it may be slow for algebraic
reals.  (It may trigger exact computation, so it might be
arbitrarily slow.  The only other way that this algorithm might
trigger exact computation on algebraic real coefficients is that
it checks the constant term of the input polynomial for equality with
zero.)</p>
<p>Part of the algorithm works (approximately) by splitting numbers into
word-size pieces (that is, pieces that fit into a machine word).
For portability, this defaults to always selecting pieces suitable
for a 32-bit machine; the wordsize parameter lets you make choices
suitable for a 64-bit machine instead.  (This affects the running
time, and the exact intervals returned, but the results are correct
on both 32- and 64-bit machines even if the wordsize is chosen “wrong”.)</p>
<p>The precision of the results can be improved (at the expense of time,
of course) by specifying the max_diameter parameter.  If specified,
this sets the maximum diameter() of the intervals returned.
(Sage defines diameter() to be the relative diameter for intervals
that do not contain 0, and the absolute diameter for intervals
containing 0.)  This directly affects the results in rational or
interval return mode; in algebraic_real mode, it increases the
precision of the intervals passed to the algebraic number package,
which may speed up some operations on that algebraic real.</p>
<p>Some logging can be enabled with do_logging=True.  If logging is enabled,
then the normal values are not returned; instead, a pair of
the internal context object and a list of all the roots in their
internal form is returned.</p>
<p>ALGORITHM: We convert the polynomial into the Bernstein basis, and
then use de Casteljau’s algorithm and Descartes’ rule of signs
(using interval arithmetic) to locate the roots.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[((7/4, 19/8), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">8</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">13</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">21</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">34</span><span class="p">))</span>
<span class="go">[((11/16, 33/32), 1), ((11/8, 33/16), 1), ((11/4, 55/16), 1), ((77/16, 165/32), 1), ((11/2, 33/4), 1), ((11, 55/4), 1), ((165/8, 341/16), 1), ((22, 44), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">9999</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[((-29274496381311/9007199254740992, 419601125186091/2251799813685248), 1), ((2126658450145849453951061654415153249597/21267647932558653966460912964485513216, 4253316902721330018853696359533061621799/42535295865117307932921825928971026432), 1), ((1063329226287740282451317352558954186101/10633823966279326983230456482242756608, 531664614358685696701445201630854654353/5316911983139663491615228241121378304), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">9999</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="go">[((-123196838480289/18014398509481984, 293964743458749/9007199254740992), 1), ((8307259573979551907841696381986376143/83076749736557242056487941267521536, 16614519150981033789137940378745325503/166153499473114484112975882535043072), 1), ((519203723562592617581015249797434335/5192296858534827628530496329220096, 60443268924081068060312183/604462909807314587353088), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">9999</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">wordsize</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
<span class="go">[((-62866503803202151050003/19342813113834066795298816, 901086554512564177624143/4835703278458516698824704), 1), ((544424563237337315214990987922809050101157/5444517870735015415413993718908291383296, 1088849127096660194637118845654929064385439/10889035741470030830827987437816582766592), 1), ((272212281929661439711063928866060007142141/2722258935367507707706996859454145691648, 136106141275823501959100399337685485662633/1361129467683753853853498429727072845824), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[((-47/256, 81/512), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[((-47/256, 81/512), 1), ((1/2, 1201/1024), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[((209/256, 593/512), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[((0, 0), 1), ((81/128, 337/256), 1), ((2, 2), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;algebraic_real&#39;</span><span class="p">)</span>
<span class="go">[(0, 1), (1, 1), (2, 1)]</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="mi">2</span><span class="o">^</span><span class="mi">40</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">((</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">v</span><span class="p">))</span>
<span class="go">[((-12855504354077768210885019021174120740504020581912910106032833/12855504354071922204335696738729300820177623950262342682411008, -6427752177038884105442509510587059395588605840418680645585479/6427752177035961102167848369364650410088811975131171341205504), 1), ((-1125899906842725/1125899906842624, -562949953421275/562949953421312), 2), ((62165404551223330269422781018352603934643403586760330761772204409982940218804935733653/62165404551223330269422781018352605012557018849668464680057997111644937126566671941632, 3885337784451458141838923813647037871787041539340705594199885610069035709862106085785/3885337784451458141838923813647037813284813678104279042503624819477808570410416996352), 2), ((509258994083853105745586001837045839749063767798922046787130823804169826426726965449697819/509258994083621521567111422102344540262867098416484062659035112338595324940834176545849344, 25711008708155536421770038042348240136257704305733983563630791/25711008708143844408671393477458601640355247900524685364822016), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[((-3/2, -1), 1), ((1, 3/2), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;interval&#39;</span><span class="p">)</span>
<span class="go">[(-2.?, 1), (2.?, 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_diameter</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">^</span><span class="mi">30</span><span class="p">)</span>
<span class="go">[((-22506280506048041472675379598886543645348790970912519198456805737131269246430553365310109/15914343565113172548972231940698266883214596825515126958094847260581103904401068017057792, -45012561012096082945350759197773086524448972309421182031053065599548946985601579935498343/31828687130226345097944463881396533766429193651030253916189694521162207808802136034115584), 1), ((45012561012096082945350759197773086524448972309421182031053065599548946985601579935498343/31828687130226345097944463881396533766429193651030253916189694521162207808802136034115584, 22506280506048041472675379598886543645348790970912519198456805737131269246430553365310109/15914343565113172548972231940698266883214596825515126958094847260581103904401068017057792), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;interval&#39;</span><span class="p">,</span> <span class="n">max_diameter</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">^</span><span class="mi">500</span><span class="p">)</span>
<span class="go">[(-1.414213562373095048801688724209698078569671875376948073176679737990732478462107038850387534327641572735013846230912297024924836055850737212644121497099935831413222665927505592755799950501152782060571470109559971605970274534596862014728517418640889198609552?, 1), (1.414213562373095048801688724209698078569671875376948073176679737990732478462107038850387534327641572735013846230912297024924836055850737212644121497099935831413222665927505592755799950501152782060571470109559971605970274534596862014728517418640889198609552?, 1)]</span>
<span class="gp">sage: </span><span class="n">ar_rts</span> <span class="o">=</span> <span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;algebraic_real&#39;</span><span class="p">);</span> <span class="n">ar_rts</span>
<span class="go">[(-1.414213562373095?, 1), (1.414213562373095?, 1)]</span>
<span class="gp">sage: </span><span class="n">ar_rts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="mi">2</span><span class="o">^</span><span class="mi">40</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">v</span><span class="p">),</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;interval&#39;</span><span class="p">)</span>
<span class="go">[(1.000000000000?, 1), (1.000000000001?, 1)]</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="mi">2</span><span class="o">^</span><span class="mi">60</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">v</span><span class="p">),</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;interval&#39;</span><span class="p">)</span>
<span class="go">[(1.000000000000000000?, 1), (1.000000000000000001?, 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;warp&#39;</span><span class="p">)</span>
<span class="go">[((499/525, 1173/875), 1), ((337/175, 849/175), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;warp&#39;</span><span class="p">)</span>
<span class="go">[((-1713/335, -689/335), 1), ((-2067/2029, -689/1359), 1), ((0, 0), 1), ((499/525, 1173/875), 1), ((337/175, 849/175), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;warp&#39;</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;algebraic_real&#39;</span><span class="p">)</span>
<span class="go">[(-3.000000000000000?, 1), (-1.000000000000000?, 1), (0, 1), (1.000000000000000?, 1), (2.000000000000000?, 1)]</span>
<span class="gp">sage: </span><span class="n">ar_rts</span> <span class="o">=</span> <span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;algebraic_real&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ar_rts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If the polynomial has no real roots, we get an empty list.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">real_root_intervals</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>We can compute Conway’s constant
(see <a class="reference external" href="http://mathworld.wolfram.com/ConwaysConstant.html">http://mathworld.wolfram.com/ConwaysConstant.html</a>) to arbitrary
precision.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">71</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">69</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">68</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">67</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">66</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">65</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">64</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">63</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">62</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">61</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">60</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">59</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">58</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">57</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">56</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">55</span> <span class="o">-</span> <span class="mi">10</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">54</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">53</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">52</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">51</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">50</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">49</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">48</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">47</span> <span class="o">-</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">46</span> <span class="o">-</span> <span class="mi">8</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">45</span> <span class="o">-</span> <span class="mi">8</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">44</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">43</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">42</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">41</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">40</span> <span class="o">-</span> <span class="mi">12</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">39</span> <span class="o">+</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">38</span> <span class="o">-</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">37</span> <span class="o">+</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">36</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">35</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">34</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">33</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">32</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">31</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">30</span> <span class="o">-</span> <span class="mi">10</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">29</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">28</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">27</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">26</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">25</span> <span class="o">+</span> <span class="mi">14</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">24</span> <span class="o">-</span> <span class="mi">8</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">23</span> <span class="o">-</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">21</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">20</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">19</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">18</span> <span class="o">-</span> <span class="mi">10</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">17</span> <span class="o">-</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">16</span> <span class="o">+</span> <span class="mi">12</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">15</span> <span class="o">+</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">14</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">13</span> <span class="o">-</span> <span class="mi">12</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">12</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">11</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">9</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">7</span> <span class="o">-</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">12</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">6</span>
<span class="gp">sage: </span><span class="n">cc</span> <span class="o">=</span> <span class="n">real_roots</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;algebraic_real&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="n">RealField</span><span class="p">(</span><span class="mi">180</span><span class="p">)(</span><span class="n">cc</span><span class="p">)</span>                                <span class="c1"># long time</span>
<span class="go">1.3035772690342963912570991121525518907307025046594049</span>
</pre></div>
</div>
<p>Now we play with algebraic real coefficients.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">AA</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">AA</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">[((499/525, 2171/1925), 1), ((1173/875, 2521/1575), 1), ((337/175, 849/175), 1)]</span>
<span class="gp">sage: </span><span class="n">ar_rts</span> <span class="o">=</span> <span class="n">real_roots</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;algebraic_real&#39;</span><span class="p">);</span> <span class="n">ar_rts</span>
<span class="go">[(1.000000000000000?, 1), (1.414213562373095?, 1), (2.000000000000000?, 1)]</span>
<span class="gp">sage: </span><span class="n">ar_rts</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">ar_rts</span> <span class="o">=</span> <span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;algebraic_real&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ar_rts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">p2</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">100</span><span class="p">);</span> <span class="n">p2</span>
<span class="go">x^6 - 8.82842712474619?*x^5 + 31.97056274847714?*x^4 - 60.77955262170047?*x^3 + 63.98526763257801?*x^2 - 35.37613490585595?*x + 8.028284271247462?</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;interval&#39;</span><span class="p">)</span>
<span class="go">[(1.00?, 1), (1.1?, 1), (1.38?, 1), (1.5?, 1), (2.00?, 1), (2.1?, 1)]</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">AA</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">3</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">AA</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;interval&#39;</span><span class="p">)</span>
<span class="go">[(1.000000000000000?, 1), (1.414213562373095?, 2), (2.000000000000000?, 3)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.relative_bounds">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">relative_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.relative_bounds" title="Link to this definition">#</a></dt>
<dd><p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(al,</span> <span class="pre">ah)</span></code> – pair of rationals</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(bl,</span> <span class="pre">bh)</span></code> – pair of rationals</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(cl,</span> <span class="pre">ch)</span></code> – pair of rationals</p></li>
</ul>
<p>Computes the linear transformation that maps (al, ah) to (0, 1);
then applies this transformation to (bl, bh) and returns the result.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">relative_bounds</span><span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">))</span>
<span class="go">(2/9, 8/15)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.reverse_intvec">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">reverse_intvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.reverse_intvec" title="Link to this definition">#</a></dt>
<dd><p>Given a vector of integers, reverse the vector (like the reverse()
method on lists).</p>
<p>Modifies the input vector; has no return value.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span> <span class="n">v</span>
<span class="go">(1, 2, 3, 4)</span>
<span class="gp">sage: </span><span class="n">reverse_intvec</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span>
<span class="go">(4, 3, 2, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.root_bounds">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">root_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.root_bounds" title="Link to this definition">#</a></dt>
<dd><p>Given a polynomial with real coefficients, computes a lower and
upper bound on its real roots.  Uses algorithms of
Akritas, Strzebo'nski, and Vigklas.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">root_bounds</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="go">(0.545454545454545, 6.00000000000001)</span>
<span class="gp">sage: </span><span class="n">root_bounds</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(0.000000000000000, 0.000000000000000)</span>
<span class="gp">sage: </span><span class="n">root_bounds</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="go">(-1.00000000000000, 0.000000000000000)</span>
<span class="gp">sage: </span><span class="n">root_bounds</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="go">(-2.44948974278317, 3.46410161513776)</span>
<span class="gp">sage: </span><span class="n">root_bounds</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">995</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">9999</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(-99.9949998749937, 141.414284992713)</span>
<span class="gp">sage: </span><span class="n">root_bounds</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">995</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">9999</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(-141.414284992712, 99.9949998749938)</span>
</pre></div>
</div>
<p>If we can see that the polynomial has no real roots, return None.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">root_bounds</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.rr_gap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">rr_gap</span></span><a class="headerlink" href="#sage.rings.polynomial.real_roots.rr_gap" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A simple class representing the gaps between islands, in my
ocean-island root isolation algorithm.  Named “rr_gap” for
“real roots gap”, because “gap” seemed too short and generic.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.rr_gap.region">
<span class="sig-name descname"><span class="pre">region</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.rr_gap.region" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.scale_intvec_var">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">scale_intvec_var</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.scale_intvec_var" title="Link to this definition">#</a></dt>
<dd><p>Given a vector of integers c of length n+1, and a rational
k == kn / kd, multiplies each element c[i] by (kd^i)*(kn^(n-i)).</p>
<p>Modifies the input vector; has no return value.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">scale_intvec_var</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span>
<span class="go">(64, 48, 36, 27)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.split_for_targets">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">split_for_targets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.split_for_targets" title="Link to this definition">#</a></dt>
<dd><p>Given an interval Bernstein polynomial over a particular region
(assumed to be a (not necessarily proper) subregion of [0 .. 1]),
and a list of targets, uses de Casteljau’s method to compute
representations of the Bernstein polynomial over each target.
Uses degree reduction as often as possible while maintaining the
requested precision.</p>
<p>Each target is of the form (lgap, ugap, b).  Suppose lgap.region()
is (l1, l2), and ugap.region() is (u1, u2).  Then we will compute
an interval Bernstein polynomial over a region [l .. u], where
l1 &lt;= l &lt;= l2 and u1 &lt;= u &lt;= u2.  (split_for_targets() is free to
select arbitrary region endpoints within these bounds; it picks
endpoints which make the computation easier.)  The third component
of the target, b, is the maximum allowed scale_log2 of the result;
this is used to decide when degree reduction is allowed.</p>
<p>The pair (l1, l2) can be replaced by None, meaning [-infinity .. 0];
or, (u1, u2) can be replaced by None, meaning [1 .. infinity].</p>
<p>There is another constraint on the region endpoints selected by
split_for_targets() for a target ((l1, l2), (u1, u2), b).
We set a size goal g, such that (u - l) &lt;= g * (u1 - l2).
Normally g is 256/255, but if precise is True, then g is 65536/65535.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">1000000</span><span class="p">,</span> <span class="o">-</span><span class="mi">2000000</span><span class="p">,</span> <span class="mi">3000000</span><span class="p">,</span> <span class="o">-</span><span class="mi">4000000</span><span class="p">,</span> <span class="o">-</span><span class="mi">5000000</span><span class="p">,</span> <span class="o">-</span><span class="mi">6000000</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">mk_context</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bps</span> <span class="o">=</span> <span class="n">split_for_targets</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="p">[(</span><span class="n">rr_gap</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1234567893</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1234567892</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">rr_gap</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1234567891</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1234567890</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">12</span><span class="p">),</span> <span class="p">(</span><span class="n">rr_gap</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">rr_gap</span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">bps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&lt;IBP: (999992, 999992, 999992) + [0 .. 15) over [8613397477114467984778830327/10633823966279326983230456482242756608 .. 591908168025934394813836527495938294787/730750818665451459101842416358141509827966271488]; level 2; slope_err 0.?e12&gt;</span>
<span class="gp">sage: </span><span class="n">bps</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&lt;IBP: (-1562500, -1875001, -2222223, -2592593, -2969137, -3337450) + [0 .. 4) over [1/2 .. 2863311531/4294967296]&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.subsample_vec_doctest">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">subsample_vec_doctest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slen</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">llen</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.subsample_vec_doctest" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.taylor_shift1_intvec">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">taylor_shift1_intvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.taylor_shift1_intvec" title="Link to this definition">#</a></dt>
<dd><p>Given a vector of integers c of length d+1, representing the
coefficients of a degree-d polynomial p, modify the vector
to perform a Taylor shift by 1 (that is, p becomes p(x+1)).</p>
<p>This is the straightforward algorithm, which is not asymptotically
optimal.</p>
<p>Modifies the input vector; has no return value.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span> <span class="n">v</span>
<span class="go">(x^3 - 6*x^2 + 11*x - 6, (-6, 11, -6, 1))</span>
<span class="gp">sage: </span><span class="n">taylor_shift1_intvec</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">v</span>
<span class="go">(x^3 - 3*x^2 + 2*x, (0, 2, -3, 1))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.to_bernstein">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">to_bernstein</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.to_bernstein" title="Link to this definition">#</a></dt>
<dd><p>Given a polynomial p with integer coefficients, and rational
bounds low and high, compute the exact rational Bernstein
coefficients of p over the region [low .. high].  The optional
parameter degree can be used to give a formal degree higher than
the actual degree.</p>
<p>The return value is a pair (c, scale); c represents the same
polynomial as p*scale.  (If you only care about the roots of
the polynomial, then of course scale can be ignored.)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">to_bernstein</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">([0, 1], 1)</span>
<span class="gp">sage: </span><span class="n">to_bernstein</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">([0, 1/5, 2/5, 3/5, 4/5, 1], 1)</span>
<span class="gp">sage: </span><span class="n">to_bernstein</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">low</span><span class="o">=-</span><span class="mi">3</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">([-16, 24, -32, 32], 1)</span>
<span class="gp">sage: </span><span class="n">to_bernstein</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="p">)</span>
<span class="go">([296352, 310464, 325206, 340605], 9261)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.to_bernstein_warp">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">to_bernstein_warp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.to_bernstein_warp" title="Link to this definition">#</a></dt>
<dd><p>Given a polynomial p with rational coefficients, compute the
exact rational Bernstein coefficients of p(x/(x+1)).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">to_bernstein_warp</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">5</span><span class="p">)</span>
<span class="go">[1, 1/5, 1/10, 1/10, 1/5, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.warp_map">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">warp_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">neg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.warp_map" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class to map between original coordinates and ocean coordinates.
If neg is False, then the original-&gt;ocean transform is
x -&gt; x/(x+1), and the ocean-&gt;original transform is x/(1-x);
this maps between [0 .. infinity] and [0 .. 1].
If neg is True, then the original-&gt;ocean transform is
x -&gt; -x/(1-x), and the ocean-&gt;original transform is the same thing:
-x/(1-x).  This maps between [0 .. -infinity] and [0 .. 1].</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.warp_map.from_ocean">
<span class="sig-name descname"><span class="pre">from_ocean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">region</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.warp_map.from_ocean" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.warp_map.to_ocean">
<span class="sig-name descname"><span class="pre">to_ocean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">region</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.warp_map.to_ocean" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.rings.polynomial.real_roots.wordsize_rational">
<span class="sig-prename descclassname"><span class="pre">sage.rings.polynomial.real_roots.</span></span><span class="sig-name descname"><span class="pre">wordsize_rational</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wordsize</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.wordsize_rational" title="Link to this definition">#</a></dt>
<dd><p>Given rationals a and b, select a de Casteljau split point r between
a and b.</p>
<p>An attempt is made to select an efficient split point
(according to the criteria mentioned in the documentation
for de_casteljau_intvec), with a bias towards split points near a.</p>
<p>In full detail:</p>
<p>This takes as input two rationals, a and b, such that 0&lt;=a&lt;=1, 0&lt;=b&lt;=1,
and a!=b. This returns rational r, such that a&lt;=r&lt;=b or b&lt;=r&lt;=a.
The denominator of r is a power of 2.  Let m be min(r, 1-r),
nm be numerator(m), and dml be log2(denominator(m)).  The return value
r is taken from the first of the following classes to have any
members between a and b (except that if a &lt;= 1/8, or 7/8 &lt;= a, then
class 2 is preferred to class 1).</p>
<ol class="arabic simple">
<li><p>dml &lt; wordsize</p></li>
<li><p>bitsize(nm) &lt;= wordsize</p></li>
<li><p>bitsize(nm) &lt;= 2*wordsize</p></li>
<li><p>bitsize(nm) &lt;= 3*wordsize</p></li>
</ol>
<p>…</p>
<ol class="loweralpha simple" start="11">
<li><p>bitsize(nm) &lt;= (k-1)*wordsize</p></li>
</ol>
<p>From the first class to have members between a and b, r is chosen
as the element of the class which is closest to a.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">wordsize_rational</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="go">429496729/2147483648</span>
<span class="gp">sage: </span><span class="n">wordsize_rational</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="go">306783379/2147483648</span>
<span class="gp">sage: </span><span class="n">wordsize_rational</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="go">1844674407370955161/9223372036854775808</span>
<span class="gp">sage: </span><span class="n">wordsize_rational</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="go">658812288346769701/4611686018427387904</span>
<span class="gp">sage: </span><span class="n">wordsize_rational</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">17</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">19</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="go">252645135/4294967296</span>
<span class="gp">sage: </span><span class="n">wordsize_rational</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">17</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">19</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="go">1085102592571150095/18446744073709551616</span>
<span class="gp">sage: </span><span class="n">wordsize_rational</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1234567890</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1234567891</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="go">933866427/1152921504606846976</span>
<span class="gp">sage: </span><span class="n">wordsize_rational</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1234567890</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1234567891</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="go">4010925763784056541/4951760157141521099596496896</span>
</pre></div>
</div>
</dd></dl>

</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="complex_roots.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Isolate Complex Roots of Polynomials</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="polynomial_zz_pex.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Univariate Polynomials over GF(p^e) via NTL’s ZZ_pEX</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2005--2024, The Sage Development Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Isolate Real Roots of Real Polynomials</a><ul>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.PrecisionError"><code class="docutils literal notranslate"><span class="pre">PrecisionError</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_down"><code class="docutils literal notranslate"><span class="pre">bernstein_down()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_expand"><code class="docutils literal notranslate"><span class="pre">bernstein_expand()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory"><code class="docutils literal notranslate"><span class="pre">bernstein_polynomial_factory</span></code></a><ul>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory.lsign"><code class="docutils literal notranslate"><span class="pre">lsign()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory.usign"><code class="docutils literal notranslate"><span class="pre">usign()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ar"><code class="docutils literal notranslate"><span class="pre">bernstein_polynomial_factory_ar</span></code></a><ul>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ar.bernstein_polynomial"><code class="docutils literal notranslate"><span class="pre">bernstein_polynomial()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ar.coeffs_bitsize"><code class="docutils literal notranslate"><span class="pre">coeffs_bitsize()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_intlist"><code class="docutils literal notranslate"><span class="pre">bernstein_polynomial_factory_intlist</span></code></a><ul>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_intlist.bernstein_polynomial"><code class="docutils literal notranslate"><span class="pre">bernstein_polynomial()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_intlist.coeffs_bitsize"><code class="docutils literal notranslate"><span class="pre">coeffs_bitsize()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ratlist"><code class="docutils literal notranslate"><span class="pre">bernstein_polynomial_factory_ratlist</span></code></a><ul>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ratlist.bernstein_polynomial"><code class="docutils literal notranslate"><span class="pre">bernstein_polynomial()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ratlist.coeffs_bitsize"><code class="docutils literal notranslate"><span class="pre">coeffs_bitsize()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_up"><code class="docutils literal notranslate"><span class="pre">bernstein_up()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.bitsize_doctest"><code class="docutils literal notranslate"><span class="pre">bitsize_doctest()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.cl_maximum_root"><code class="docutils literal notranslate"><span class="pre">cl_maximum_root()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.cl_maximum_root_first_lambda"><code class="docutils literal notranslate"><span class="pre">cl_maximum_root_first_lambda()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.cl_maximum_root_local_max"><code class="docutils literal notranslate"><span class="pre">cl_maximum_root_local_max()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.context"><code class="docutils literal notranslate"><span class="pre">context</span></code></a><ul>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.context.get_be_log"><code class="docutils literal notranslate"><span class="pre">get_be_log()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.context.get_dc_log"><code class="docutils literal notranslate"><span class="pre">get_dc_log()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.de_casteljau_doublevec"><code class="docutils literal notranslate"><span class="pre">de_casteljau_doublevec()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.de_casteljau_intvec"><code class="docutils literal notranslate"><span class="pre">de_casteljau_intvec()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.degree_reduction_next_size"><code class="docutils literal notranslate"><span class="pre">degree_reduction_next_size()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.dprod_imatrow_vec"><code class="docutils literal notranslate"><span class="pre">dprod_imatrow_vec()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.get_realfield_rndu"><code class="docutils literal notranslate"><span class="pre">get_realfield_rndu()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial"><code class="docutils literal notranslate"><span class="pre">interval_bernstein_polynomial</span></code></a><ul>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial.region"><code class="docutils literal notranslate"><span class="pre">region()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial.region_width"><code class="docutils literal notranslate"><span class="pre">region_width()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial.try_rand_split"><code class="docutils literal notranslate"><span class="pre">try_rand_split()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial.try_split"><code class="docutils literal notranslate"><span class="pre">try_split()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial.variations"><code class="docutils literal notranslate"><span class="pre">variations()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float"><code class="docutils literal notranslate"><span class="pre">interval_bernstein_polynomial_float</span></code></a><ul>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.as_float"><code class="docutils literal notranslate"><span class="pre">as_float()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.de_casteljau"><code class="docutils literal notranslate"><span class="pre">de_casteljau()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.get_msb_bit"><code class="docutils literal notranslate"><span class="pre">get_msb_bit()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.slope_range"><code class="docutils literal notranslate"><span class="pre">slope_range()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer"><code class="docutils literal notranslate"><span class="pre">interval_bernstein_polynomial_integer</span></code></a><ul>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.as_float"><code class="docutils literal notranslate"><span class="pre">as_float()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.de_casteljau"><code class="docutils literal notranslate"><span class="pre">de_casteljau()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.down_degree"><code class="docutils literal notranslate"><span class="pre">down_degree()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.down_degree_iter"><code class="docutils literal notranslate"><span class="pre">down_degree_iter()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.downscale"><code class="docutils literal notranslate"><span class="pre">downscale()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.get_msb_bit"><code class="docutils literal notranslate"><span class="pre">get_msb_bit()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.slope_range"><code class="docutils literal notranslate"><span class="pre">slope_range()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.intvec_to_doublevec"><code class="docutils literal notranslate"><span class="pre">intvec_to_doublevec()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.island"><code class="docutils literal notranslate"><span class="pre">island</span></code></a><ul>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.island.bp_done"><code class="docutils literal notranslate"><span class="pre">bp_done()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.island.done"><code class="docutils literal notranslate"><span class="pre">done()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.island.has_root"><code class="docutils literal notranslate"><span class="pre">has_root()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.island.less_bits"><code class="docutils literal notranslate"><span class="pre">less_bits()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.island.more_bits"><code class="docutils literal notranslate"><span class="pre">more_bits()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.island.refine"><code class="docutils literal notranslate"><span class="pre">refine()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.island.refine_recurse"><code class="docutils literal notranslate"><span class="pre">refine_recurse()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.island.reset_root_width"><code class="docutils literal notranslate"><span class="pre">reset_root_width()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.island.shrink_bp"><code class="docutils literal notranslate"><span class="pre">shrink_bp()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.linear_map"><code class="docutils literal notranslate"><span class="pre">linear_map</span></code></a><ul>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.linear_map.from_ocean"><code class="docutils literal notranslate"><span class="pre">from_ocean()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.linear_map.to_ocean"><code class="docutils literal notranslate"><span class="pre">to_ocean()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.max_abs_doublevec"><code class="docutils literal notranslate"><span class="pre">max_abs_doublevec()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.max_bitsize_intvec_doctest"><code class="docutils literal notranslate"><span class="pre">max_bitsize_intvec_doctest()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.maximum_root_first_lambda"><code class="docutils literal notranslate"><span class="pre">maximum_root_first_lambda()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.maximum_root_local_max"><code class="docutils literal notranslate"><span class="pre">maximum_root_local_max()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.min_max_delta_intvec"><code class="docutils literal notranslate"><span class="pre">min_max_delta_intvec()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.min_max_diff_doublevec"><code class="docutils literal notranslate"><span class="pre">min_max_diff_doublevec()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.min_max_diff_intvec"><code class="docutils literal notranslate"><span class="pre">min_max_diff_intvec()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.mk_context"><code class="docutils literal notranslate"><span class="pre">mk_context()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.mk_ibpf"><code class="docutils literal notranslate"><span class="pre">mk_ibpf()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.mk_ibpi"><code class="docutils literal notranslate"><span class="pre">mk_ibpi()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.ocean"><code class="docutils literal notranslate"><span class="pre">ocean</span></code></a><ul>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.ocean.all_done"><code class="docutils literal notranslate"><span class="pre">all_done()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.ocean.approx_bp"><code class="docutils literal notranslate"><span class="pre">approx_bp()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.ocean.find_roots"><code class="docutils literal notranslate"><span class="pre">find_roots()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.ocean.increase_precision"><code class="docutils literal notranslate"><span class="pre">increase_precision()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.ocean.refine_all"><code class="docutils literal notranslate"><span class="pre">refine_all()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.ocean.reset_root_width"><code class="docutils literal notranslate"><span class="pre">reset_root_width()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.ocean.roots"><code class="docutils literal notranslate"><span class="pre">roots()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.precompute_degree_reduction_cache"><code class="docutils literal notranslate"><span class="pre">precompute_degree_reduction_cache()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.pseudoinverse"><code class="docutils literal notranslate"><span class="pre">pseudoinverse()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.rational_root_bounds"><code class="docutils literal notranslate"><span class="pre">rational_root_bounds()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.real_roots"><code class="docutils literal notranslate"><span class="pre">real_roots()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.relative_bounds"><code class="docutils literal notranslate"><span class="pre">relative_bounds()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.reverse_intvec"><code class="docutils literal notranslate"><span class="pre">reverse_intvec()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.root_bounds"><code class="docutils literal notranslate"><span class="pre">root_bounds()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.rr_gap"><code class="docutils literal notranslate"><span class="pre">rr_gap</span></code></a><ul>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.rr_gap.region"><code class="docutils literal notranslate"><span class="pre">region()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.scale_intvec_var"><code class="docutils literal notranslate"><span class="pre">scale_intvec_var()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.split_for_targets"><code class="docutils literal notranslate"><span class="pre">split_for_targets()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.subsample_vec_doctest"><code class="docutils literal notranslate"><span class="pre">subsample_vec_doctest()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.taylor_shift1_intvec"><code class="docutils literal notranslate"><span class="pre">taylor_shift1_intvec()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.to_bernstein"><code class="docutils literal notranslate"><span class="pre">to_bernstein()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.to_bernstein_warp"><code class="docutils literal notranslate"><span class="pre">to_bernstein_warp()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.warp_map"><code class="docutils literal notranslate"><span class="pre">warp_map</span></code></a><ul>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.warp_map.from_ocean"><code class="docutils literal notranslate"><span class="pre">from_ocean()</span></code></a></li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.warp_map.to_ocean"><code class="docutils literal notranslate"><span class="pre">to_ocean()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#sage.rings.polynomial.real_roots.wordsize_rational"><code class="docutils literal notranslate"><span class="pre">wordsize_rational()</span></code></a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../_static/scripts/furo.js"></script>
    <script src="../../../../_static/clipboard.min.js"></script>
    <script src="../../../../_static/copybutton.js"></script>
    <script src="../../../../_static/tabs.js"></script>
    <script src="../../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"ZZ": "\\Bold{Z}", "NN": "\\Bold{N}", "RR": "\\Bold{R}", "CC": "\\Bold{C}", "QQ": "\\Bold{Q}", "QQbar": "\\overline{\\QQ}", "GF": ["\\Bold{F}_{#1}", 1], "Zp": ["\\Bold{Z}_{#1}", 1], "Qp": ["\\Bold{Q}_{#1}", 1], "Zmod": ["\\ZZ/#1\\ZZ", 1], "CDF": "\\Bold{C}", "CIF": "\\Bold{C}", "CLF": "\\Bold{C}", "RDF": "\\Bold{R}", "RIF": "\\Bold{I} \\Bold{R}", "RLF": "\\Bold{R}", "SL": "\\mathrm{SL}", "PSL": "\\mathrm{PSL}", "lcm": "\\mathop{\\operatorname{lcm}}", "dist": "\\mathrm{dist}", "Bold": ["\\mathbf{#1}", 1]}, "inlineMath": [["$", "$"], ["\\(", "\\)"]], "maxBuffer": 51200, "autoload": {"color": [], "colorv2": ["color"]}}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <script src="../../../../_static/jupyter-sphinx-furo.js"></script>
    </body>
</html>