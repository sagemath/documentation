
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Isolate Real Roots of Real Polynomials &#8212; Sage Reference Manual v9.0: Polynomials</title>
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Isolate Complex Roots of Polynomials" href="complex_roots.html" />
    <link rel="prev" title="Univariate Polynomials over GF(p^e) via NTL’s ZZ_pEX." href="polynomial_zz_pex.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="complex_roots.html" title="Isolate Complex Roots of Polynomials"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="polynomial_zz_pex.html" title="Univariate Polynomials over GF(p^e) via NTL’s ZZ_pEX."
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Polynomials</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../../polynomial_rings_univar.html" accesskey="U">Univariate Polynomials and Polynomial Rings</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="isolate-real-roots-of-real-polynomials">
<span id="sage-rings-polynomial-real-roots"></span><h1>Isolate Real Roots of Real Polynomials<a class="headerlink" href="#isolate-real-roots-of-real-polynomials" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.rings.polynomial.real_roots"></span><p>AUTHOR:</p>
<ul class="simple">
<li>Carl Witty (2007-09-19): initial version</li>
</ul>
<p>This is an implementation of real root isolation.  That is, given a
polynomial with exact real coefficients, we compute isolating intervals
for the real roots of the polynomial. (Polynomials with
integer, rational, or algebraic real coefficients are supported.)</p>
<p>We convert the polynomials into the Bernstein basis, and then use
de Casteljau’s algorithm and Descartes’ rule of signs on the Bernstein
basis polynomial (using interval arithmetic) to locate the roots. The
algorithm is similar to that in “A Descartes Algorithm for Polynomials
with Bit-Stream Coefficients”, by Eigenwillig, Kettner, Krandick, Mehlhorn,
Schmitt, and Wolpert, but has three crucial optimizations over the
algorithm in that paper:</p>
<ul class="simple">
<li>Precision reduction: at certain points in the computation, we discard the
low-order bits of the coefficients, widening the intervals.</li>
<li>Degree reduction: at certain points in the computation, we find lower-degree
polynomials that are approximately equal to our high-degree polynomial over
the region of interest.</li>
<li>When the intervals are too wide to continue (either because of a too-low
initial precision, or because of precision or degree reduction), and we need
to restart with higher precision, we recall which regions have already been
proven not to have any roots and do not examine them again.</li>
</ul>
<p>The best description of the algorithms used (other than this source
code itself) is in the slides for my Sage Days 4 talk, currently available
from <a class="reference external" href="https://wiki.sagemath.org/days4schedule">https://wiki.sagemath.org/days4schedule</a> .</p>
<dl class="exception">
<dt id="sage.rings.polynomial.real_roots.PrecisionError">
<em class="property">exception </em><code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">PrecisionError</code><a class="headerlink" href="#sage.rings.polynomial.real_roots.PrecisionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/library/exceptions.html#ValueError" title="(in Python v3.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></a></p>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.bernstein_down">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">bernstein_down</code><span class="sig-paren">(</span><em>d1</em>, <em>d2</em>, <em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_down" title="Permalink to this definition">¶</a></dt>
<dd><p>Given polynomial degrees d1 and d2 (where d1 &lt; d2), and a number
of samples s, computes a matrix bd.</p>
<p>If you have a Bernstein polynomial of formal degree d2, and select
s of its coefficients (according to subsample_vec), and multiply
the resulting vector by bd, then you get the coefficients
of a Bernstein polynomial of formal degree d1, where this second
polynomial is a good approximation to the first polynomial over the
region of the Bernstein basis.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bernstein_down</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">[ 612/245 -348/245   -37/49  338/245 -172/245]</span>
<span class="go">[-724/441   132/49  395/441 -290/147  452/441]</span>
<span class="go">[ 452/441 -290/147  395/441   132/49 -724/441]</span>
<span class="go">[-172/245  338/245   -37/49 -348/245  612/245]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.bernstein_expand">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">bernstein_expand</code><span class="sig-paren">(</span><em>c</em>, <em>d2</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an integer vector representing a Bernstein polynomial p, and
a degree d2, compute the representation of p as a Bernstein
polynomial of formal degree d2.</p>
<p>This is similar to multiplying by the result of bernstein_up, but
should be faster for large d2 (this has about the same number of
multiplies, but in this version all the multiplies are by single
machine words).</p>
<p>Returns a pair consisting of the expanded polynomial, and the maximum
error E.  (So if an element of the returned polynomial is a, and the
true value of that coefficient is b, then a &lt;= b &lt; a + E.)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="o">-</span><span class="mi">3000</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">bernstein_expand</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">((1000, 1666, 333, -3000), 1)</span>
<span class="gp">sage: </span><span class="n">bernstein_expand</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">((1000, 1500, 1000, -500, -3000), 1)</span>
<span class="gp">sage: </span><span class="n">bernstein_expand</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">((1000, 1100, 1168, 1205, 1210, 1184, 1126, 1036, 915, 763, 578, 363, 115, -164, -474, -816, -1190, -1595, -2032, -2500, -3000), 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory">
<em class="property">class </em><code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">bernstein_polynomial_factory</code><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An abstract base class for bernstein_polynomial factories.  That
is, elements of subclasses represent Bernstein polynomials
(exactly), and are responsible for creating
interval_bernstein_polynomial_integer approximations at arbitrary
precision.</p>
<p>Supports four methods, coeffs_bitsize(), bernstein_polynomial(),
lsign(), and usign().  The coeffs_bitsize() method gives an
integer approximation to the log2 of the max of the absolute
values of the Bernstein coefficients.  The
bernstein_polynomial(scale_log2) method gives an approximation
where the maximum coefficient has approximately coeffs_bitsize() -
scale_log2 bits.  The lsign() and usign() methods give the (exact)
sign of the first and last coefficient, respectively.</p>
<dl class="method">
<dt id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory.lsign">
<code class="descname">lsign</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory.lsign" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sign of the first coefficient of this
Bernstein polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory.usign">
<code class="descname">usign</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory.usign" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sign of the last coefficient of this
Bernstein polynomial.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ar">
<em class="property">class </em><code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">bernstein_polynomial_factory_ar</code><span class="sig-paren">(</span><em>poly</em>, <em>neg</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory" title="sage.rings.polynomial.real_roots.bernstein_polynomial_factory"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.rings.polynomial.real_roots.bernstein_polynomial_factory</span></code></a></p>
<p>This class holds an exact Bernstein polynomial (represented as a
list of algebraic real coefficients), and returns
arbitrarily-precise interval approximations of this polynomial on
demand.</p>
<dl class="method">
<dt id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ar.bernstein_polynomial">
<code class="descname">bernstein_polynomial</code><span class="sig-paren">(</span><em>scale_log2</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ar.bernstein_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an interval_bernstein_polynomial_integer that approximates
this polynomial, using the given scale_log2.  (Smaller scale_log2
values give more accurate approximations.)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">AA</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">AA</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bpf</span> <span class="o">=</span> <span class="n">bernstein_polynomial_factory_ar</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">degree 3 IBP with 2-bit coefficients</span>
<span class="gp">sage: </span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">)</span>
<span class="go">&lt;IBP: ((-2965821, 2181961, -1542880, 1048576) + [0 .. 1)) * 2^-20&gt;</span>
<span class="gp">sage: </span><span class="n">bpf</span> <span class="o">=</span> <span class="n">bernstein_polynomial_factory_ar</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">)</span>
<span class="go">&lt;IBP: ((-2965821, -2181962, -1542880, -1048576) + [0 .. 1)) * 2^-20&gt;</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">bpf</span> <span class="o">=</span> <span class="n">bernstein_polynomial_factory_ar</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>
<span class="go">&lt;IBP: ((-1024, 0, 1024) + [0 .. 1)) * 2^-10&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ar.coeffs_bitsize">
<code class="descname">coeffs_bitsize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ar.coeffs_bitsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the approximate log2 of the maximum of the absolute
values of the coefficients.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">AA</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">AA</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bernstein_polynomial_factory_ar</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">coeffs_bitsize</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory_intlist">
<em class="property">class </em><code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">bernstein_polynomial_factory_intlist</code><span class="sig-paren">(</span><em>coeffs</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_intlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory" title="sage.rings.polynomial.real_roots.bernstein_polynomial_factory"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.rings.polynomial.real_roots.bernstein_polynomial_factory</span></code></a></p>
<p>This class holds an exact Bernstein polynomial (represented
as a list of integer coefficients), and returns arbitrarily-precise
interval approximations of this polynomial on demand.</p>
<dl class="method">
<dt id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory_intlist.bernstein_polynomial">
<code class="descname">bernstein_polynomial</code><span class="sig-paren">(</span><em>scale_log2</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_intlist.bernstein_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an interval_bernstein_polynomial_integer that approximates
this polynomial, using the given scale_log2.  (Smaller scale_log2
values give more accurate approximations.)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bpf</span> <span class="o">=</span> <span class="n">bernstein_polynomial_factory_intlist</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="o">-</span><span class="mi">40</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">degree 3 IBP with 6-bit coefficients</span>
<span class="gp">sage: </span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">&lt;IBP: ((0, -1, 0, -1) + [0 .. 1)) * 2^20; lsign 1&gt;</span>
<span class="gp">sage: </span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&lt;IBP: (10, -20, 30, -40) + [0 .. 1)&gt;</span>
<span class="gp">sage: </span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">)</span>
<span class="go">&lt;IBP: ((10485760, -20971520, 31457280, -41943040) + [0 .. 1)) * 2^-20&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory_intlist.coeffs_bitsize">
<code class="descname">coeffs_bitsize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_intlist.coeffs_bitsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the approximate log2 of the maximum of the absolute
values of the coefficients.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bernstein_polynomial_factory_intlist</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">60000</span><span class="p">])</span><span class="o">.</span><span class="n">coeffs_bitsize</span><span class="p">()</span>
<span class="go">16</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ratlist">
<em class="property">class </em><code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">bernstein_polynomial_factory_ratlist</code><span class="sig-paren">(</span><em>coeffs</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ratlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory" title="sage.rings.polynomial.real_roots.bernstein_polynomial_factory"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.rings.polynomial.real_roots.bernstein_polynomial_factory</span></code></a></p>
<p>This class holds an exact Bernstein polynomial (represented
as a list of rational coefficients), and returns arbitrarily-precise
interval approximations of this polynomial on demand.</p>
<dl class="method">
<dt id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ratlist.bernstein_polynomial">
<code class="descname">bernstein_polynomial</code><span class="sig-paren">(</span><em>scale_log2</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ratlist.bernstein_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an interval_bernstein_polynomial_integer that approximates
this polynomial, using the given scale_log2.  (Smaller scale_log2
values give more accurate approximations.)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bpf</span> <span class="o">=</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">193</span><span class="o">/</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">140</span><span class="o">/</span><span class="mi">99</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">degree 3 IBP with 3-bit coefficients</span>
<span class="gp">sage: </span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">&lt;IBP: ((0, -1, 0, -1) + [0 .. 1)) * 2^20; lsign 1&gt;</span>
<span class="gp">sage: </span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&lt;IBP: (0, -4, 2, -2) + [0 .. 1); lsign 1&gt;</span>
<span class="gp">sage: </span><span class="n">bpf</span><span class="o">.</span><span class="n">bernstein_polynomial</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">)</span>
<span class="go">&lt;IBP: ((349525, -3295525, 2850354, -1482835) + [0 .. 1)) * 2^-20&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ratlist.coeffs_bitsize">
<code class="descname">coeffs_bitsize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_polynomial_factory_ratlist.coeffs_bitsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the approximate log2 of the maximum of the absolute
values of the coefficients.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">60000</span><span class="p">])</span><span class="o">.</span><span class="n">coeffs_bitsize</span><span class="p">()</span>
<span class="go">15</span>
<span class="gp">sage: </span><span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">65535</span><span class="o">/</span><span class="mi">65536</span><span class="p">])</span><span class="o">.</span><span class="n">coeffs_bitsize</span><span class="p">()</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">65536</span><span class="o">/</span><span class="mi">65535</span><span class="p">])</span><span class="o">.</span><span class="n">coeffs_bitsize</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.bernstein_up">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">bernstein_up</code><span class="sig-paren">(</span><em>d1</em>, <em>d2</em>, <em>s=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bernstein_up" title="Permalink to this definition">¶</a></dt>
<dd><p>Given polynomial degrees d1 and d2, where d1 &lt; d2, compute a matrix bu.</p>
<p>If you have a Bernstein polynomial of formal degree d1, and
multiply its coefficient vector by bu, then the result is the
coefficient vector of the same polynomial represented as a
Bernstein polynomial of formal degree d2.</p>
<p>If s is not None, then it represents a number of samples; then the
product only gives s of the coefficients of the new Bernstein polynomial,
selected according to subsample_vec.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bernstein_down</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">[  12/5     -4      3   -2/5]</span>
<span class="go">[-13/15   16/3     -4   8/15]</span>
<span class="go">[  8/15     -4   16/3 -13/15]</span>
<span class="go">[  -2/5      3     -4   12/5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.bitsize_doctest">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">bitsize_doctest</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.bitsize_doctest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.cl_maximum_root">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">cl_maximum_root</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.cl_maximum_root" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a polynomial represented by a list of its coefficients
(as RealIntervalFieldElements), compute an upper bound on its
largest real root.</p>
<p>Uses two algorithms of Akritas, Strzebo’nski, and Vigklas, and
picks the better result.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">cl_maximum_root</span><span class="p">([</span><span class="n">RIF</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">RIF</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">RIF</span><span class="p">(</span><span class="mi">1</span><span class="p">)])</span>
<span class="go">1.00000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.cl_maximum_root_first_lambda">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">cl_maximum_root_first_lambda</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.cl_maximum_root_first_lambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a polynomial represented by a list of its coefficients
(as RealIntervalFieldElements), compute an upper bound on its
largest real root.</p>
<p>Uses the first-lambda algorithm from “Implementations of a New Theorem
for Computing Bounds for Positive Roots of Polynomials”,
by Akritas, Strzebo’nski, and Vigklas.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">cl_maximum_root_first_lambda</span><span class="p">([</span><span class="n">RIF</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">RIF</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">RIF</span><span class="p">(</span><span class="mi">1</span><span class="p">)])</span>
<span class="go">1.00000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.cl_maximum_root_local_max">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">cl_maximum_root_local_max</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.cl_maximum_root_local_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a polynomial represented by a list of its coefficients
(as RealIntervalFieldElements), compute an upper bound on its
largest real root.</p>
<p>Uses the local-max algorithm from “Implementations of a New Theorem
for Computing Bounds for Positive Roots of Polynomials”,
by Akritas, Strzebo’nski, and Vigklas.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">cl_maximum_root_local_max</span><span class="p">([</span><span class="n">RIF</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">RIF</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">RIF</span><span class="p">(</span><span class="mi">1</span><span class="p">)])</span>
<span class="go">1.41421356237310</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.rings.polynomial.real_roots.context">
<em class="property">class </em><code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">context</code><a class="headerlink" href="#sage.rings.polynomial.real_roots.context" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A simple context class, which is passed through parts of the
real root isolation algorithm to avoid global variables.</p>
<p>Holds logging information, a random number generator, and
the target machine wordsize.</p>
<dl class="method">
<dt id="sage.rings.polynomial.real_roots.context.get_be_log">
<code class="descname">get_be_log</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.context.get_be_log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.context.get_dc_log">
<code class="descname">get_dc_log</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.context.get_dc_log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.de_casteljau_doublevec">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">de_casteljau_doublevec</code><span class="sig-paren">(</span><em>c</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.de_casteljau_doublevec" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a polynomial in Bernstein form with floating-point coefficients
over the region [0 .. 1], and a split point x, use de Casteljau’s
algorithm to give polynomials in Bernstein form over [0 .. x] and
[x .. 1].</p>
<p>This function will work for an arbitrary rational split point x, as
long as 0 &lt; x &lt; 1; but it has a specialized code path for x==1/2.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">c</span></code> – vector of coefficients of polynomial in Bernstein form</li>
<li><code class="docutils literal notranslate"><span class="pre">x</span></code> – rational splitting point; 0 &lt; x &lt; 1</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">c1</span></code> – coefficients of polynomial over range [0 .. x]</li>
<li><code class="docutils literal notranslate"><span class="pre">c2</span></code> – coefficients of polynomial over range [x .. 1]</li>
<li><code class="docutils literal notranslate"><span class="pre">err_inc</span></code> – number of half-ulps by which error intervals widened</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">de_casteljau_doublevec</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="go">((0.7, 0.35, 0.175, 0.0875, 0.04375, 0.021875), (0.021875, 0.0, 0.0, 0.0, 0.0, 0.0), 5)</span>
<span class="gp">sage: </span><span class="n">de_casteljau_doublevec</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># rel tol</span>
<span class="go">((0.7, 0.4666666666666667, 0.31111111111111117, 0.20740740740740746, 0.13827160493827165, 0.09218106995884777), (0.09218106995884777, 0.0, 0.0, 0.0, 0.0, 0.0), 15)</span>
<span class="gp">sage: </span><span class="n">de_casteljau_doublevec</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">7</span><span class="o">/</span><span class="mi">22</span><span class="p">)</span>  <span class="c1"># rel tol</span>
<span class="go">((0.7, 0.4772727272727273, 0.3254132231404959, 0.22187265214124724, 0.15127680827812312, 0.10314327837144759), (0.10314327837144759, 0.0, 0.0, 0.0, 0.0, 0.0), 15)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.de_casteljau_intvec">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">de_casteljau_intvec</code><span class="sig-paren">(</span><em>c</em>, <em>c_bitsize</em>, <em>x</em>, <em>use_ints</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.de_casteljau_intvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a polynomial in Bernstein form with integer coefficients
over the region [0 .. 1], and a split point x, use de Casteljau’s
algorithm to give polynomials in Bernstein form over [0 .. x] and
[x .. 1].</p>
<p>This function will work for an arbitrary rational split point x, as
long as 0 &lt; x &lt; 1; but it has specialized code paths that make
some values of x faster than others.  If x == a/(a + b),
there are special efficient cases for a==1, b==1, a+b fits in a machine
word, a+b is a power of 2, a fits in a machine word, b fits in
a machine word.  The most efficient case is x==1/2.</p>
<p>Given split points x == a/(a + b) and y == c/(c + d), where
min(a, b) and min(c, d) fit in the same number of machine words
and a+b and c+d are both powers of two, then x and y should be
equally fast split points.</p>
<p>If use_ints is nonzero, then instead of checking whether numerators
and denominators fit in machine words, we check whether they fit in
ints (32 bits, even on 64-bit machines).  This slows things down, but
allows for identical results across machines.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">c</span></code> – vector of coefficients of polynomial in Bernstein form</li>
<li><code class="docutils literal notranslate"><span class="pre">c_bitsize</span></code> – approximate size of coefficients in c (in bits)</li>
<li><code class="docutils literal notranslate"><span class="pre">x</span></code> – rational splitting point; 0 &lt; x &lt; 1</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">c1</span></code> – coefficients of polynomial over range [0 .. x]</li>
<li><code class="docutils literal notranslate"><span class="pre">c2</span></code> – coefficients of polynomial over range [x .. 1]</li>
<li><code class="docutils literal notranslate"><span class="pre">err_inc</span></code> – amount by which error intervals widened</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1048576</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">de_casteljau_intvec</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">((1048576, 524288, 262144, 131072, 65536, 32768), (32768, 0, 0, 0, 0, 0), 1)</span>
<span class="gp">sage: </span><span class="n">de_casteljau_intvec</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">((1048576, 699050, 466033, 310689, 207126, 138084), (138084, 0, 0, 0, 0, 0), 1)</span>
<span class="gp">sage: </span><span class="n">de_casteljau_intvec</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">7</span><span class="o">/</span><span class="mi">22</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">((1048576, 714938, 487457, 332357, 226607, 154505), (154505, 0, 0, 0, 0, 0), 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.degree_reduction_next_size">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">degree_reduction_next_size</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.degree_reduction_next_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Given n (a polynomial degree), returns either a smaller integer or None.
This defines the sequence of degrees followed by our degree reduction
implementation.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">degree_reduction_next_size</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="go">30</span>
<span class="gp">sage: </span><span class="n">degree_reduction_next_size</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">15</span>
<span class="gp">sage: </span><span class="n">degree_reduction_next_size</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">degree_reduction_next_size</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.dprod_imatrow_vec">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">dprod_imatrow_vec</code><span class="sig-paren">(</span><em>m</em>, <em>v</em>, <em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.dprod_imatrow_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the dot product of row k of the matrix m with the vector v
(that is, compute one element of the product m*v).</p>
<p>If v has more elements than m has columns, then elements of v are
selected using subsample_vec.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">dprod_imatrow_vec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">dprod_imatrow_vec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">dprod_imatrow_vec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">dprod_imatrow_vec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">dprod_imatrow_vec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">dprod_imatrow_vec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">dprod_imatrow_vec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">dprod_imatrow_vec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">26</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.get_realfield_rndu">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">get_realfield_rndu</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.get_realfield_rndu" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple cache for RealField fields (with rounding set to
round-to-positive-infinity).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">get_realfield_rndu</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">Real Field with 20 bits of precision and rounding RNDU</span>
<span class="gp">sage: </span><span class="n">get_realfield_rndu</span><span class="p">(</span><span class="mi">53</span><span class="p">)</span>
<span class="go">Real Field with 53 bits of precision and rounding RNDU</span>
<span class="gp">sage: </span><span class="n">get_realfield_rndu</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">Real Field with 20 bits of precision and rounding RNDU</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial">
<em class="property">class </em><code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">interval_bernstein_polynomial</code><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An interval_bernstein_polynomial is an approximation to an exact
polynomial.  This approximation is in the form of a Bernstein
polynomial (a polynomial given as coefficients over a Bernstein
basis) with interval coefficients.</p>
<p>The Bernstein basis of degree n over the region [a .. b] is the
set of polynomials</p>
<div class="math notranslate nohighlight">
\[\binom{n}{k} (x-a)^k (b-x)^{n-k} / (b-a)^n\]</div>
<p>for <span class="math notranslate nohighlight">\(0 \le k \le n\)</span>.</p>
<p>A degree-n interval Bernstein polynomial P with its region [a .. b] can
represent an exact polynomial p in two different ways: it can
“contain” the polynomial or it can “bound” the polynomial.</p>
<p>We say that P contains p if, when p is represented as a degree-n
Bernstein polynomial over [a .. b], its coefficients are contained
in the corresponding interval coefficients of P.  For instance,
[0.9 .. 1.1]*x^2 (which is a degree-2 interval Bernstein polynomial
over [0 .. 1]) contains x^2.</p>
<p>We say that P bounds p if, for all a &lt;= x &lt;= b, there exists a
polynomial p’ contained in P such that p(x) == p’(x).  For instance,
[0 .. 1]*x is a degree-1 interval Bernstein polynomial which bounds
x^2 over [0 .. 1].</p>
<p>If P contains p, then P bounds p; but the converse is not necessarily
true.  In particular, if n &lt; m, it is possible for a degree-n interval
Bernstein polynomial to bound a degree-m polynomial; but it cannot
contain the polynomial.</p>
<p>In the case where P bounds p, we maintain extra information, the
“slope error”.  We say that P (over [a .. b]) bounds p with a
slope error of E (where E is an interval) if there is a polynomial
p’ contained in P such that the derivative of (p - p’) is bounded
by E in the range [a .. b].  If P bounds p with a slope error of 0
then P contains p.</p>
<p>(Note that “contains” and “bounds” are not standard terminology;
I just made them up.)</p>
<p>Interval Bernstein polynomials are useful in finding real roots
because of the following properties:</p>
<ul class="simple">
<li>Given an exact real polynomial p, we can compute an interval Bernstein
polynomial over an arbitrary region containing p.</li>
<li>Given an interval Bernstein polynomial P over [a .. c], where a &lt; b &lt; c,
we can compute interval Bernstein polynomials P1 over [a .. b] and P2
over [b .. c], where P1 and P2 contain (or bound) all polynomials that P
contains (or bounds).</li>
<li>Given a degree-n interval Bernstein polynomial P over [a .. b], and m &lt;
n, we can compute a degree-m interval Bernstein polynomial P’ over [a ..
b] that bounds all polynomials that P bounds.</li>
<li>It is sometimes possible to prove that no polynomial bounded by P over [a
.. b] has any roots in [a .. b].  (Roughly, this is possible when no
polynomial contained by P has any complex roots near the line segment [a
.. b], where “near” is defined relative to the length b-a.)</li>
<li>It is sometimes possible to prove that every polynomial bounded by P over
[a .. b] with slope error E has exactly one root in [a .. b].  (Roughly,
this is possible when every polynomial contained by P over [a .. b] has
exactly one root in [a .. b], there are no other complex roots near the
line segment [a .. b], and every polynomial contained in P has a
derivative which is bounded away from zero over [a .. b] by an amount
which is large relative to E.)</li>
<li>Starting from a sufficiently precise interval Bernstein polynomial, it is
always possible to split it into polynomials which provably have 0 or 1
roots (as long as your original polynomial has no multiple real roots).</li>
</ul>
<p>So a rough outline of a family of algorithms would be:</p>
<ul class="simple">
<li>Given a polynomial p, compute a region [a .. b] in which any real roots
must lie.</li>
<li>Compute an interval Bernstein polynomial P containing p over [a .. b].</li>
<li>Keep splitting P until you have isolated all the roots.  Optionally,
reduce the degree or the precision of the interval Bernstein polynomials
at intermediate stages (to reduce computation time).  If this seems not
to be working, go back and try again with higher precision.</li>
</ul>
<p>Obviously, there are many details to be worked out to turn this
into a full algorithm, like:</p>
<ul class="simple">
<li>What initial precision is selected for computing P?</li>
<li>How do you decide when to reduce the degree of intermediate polynomials?</li>
<li>How do you decide when to reduce the precision of intermediate
polynomials?</li>
<li>How do you decide where to split the interval Bernstein polynomial
regions?</li>
<li>How do you decide when to give up and start over with higher precision?</li>
</ul>
<p>Each set of answers to these questions gives a different algorithm
(potentially with very different performance characteristics), but all of
them can use this <code class="docutils literal notranslate"><span class="pre">interval_bernstein_polynomial</span></code> class as their basic
building block.</p>
<p>To save computation time, all coefficients in an
<code class="docutils literal notranslate"><span class="pre">interval_bernstein_polynomial</span></code> share the same interval width.
(There is one exception: when creating an <code class="docutils literal notranslate"><span class="pre">interval_bernstein_polynomial</span></code>,
the first and last coefficients can be marked as “known positive”
or “known negative”.  This has some of the same effect as having
a (potentially) smaller interval width for these two coefficients,
although it does not affect de Casteljau splitting.)
To allow for widely varying coefficient magnitudes, all
coefficients in an interval_bernstein_polynomial are scaled
by <span class="math notranslate nohighlight">\(2^n\)</span> (where <span class="math notranslate nohighlight">\(n\)</span> may be positive, negative, or zero).</p>
<p>There are two representations for interval_bernstein_polynomials,
integer and floating-point. These are the two subclasses of
this class; <code class="docutils literal notranslate"><span class="pre">interval_bernstein_polynomial</span></code> itself is an abstract
class.</p>
<p><code class="docutils literal notranslate"><span class="pre">interval_bernstein_polynomial</span></code> and its subclasses are not expected
to be used outside this file.</p>
<dl class="method">
<dt id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial.region">
<code class="descname">region</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial.region" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial.region_width">
<code class="descname">region_width</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial.region_width" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial.try_rand_split">
<code class="descname">try_rand_split</code><span class="sig-paren">(</span><em>ctx</em>, <em>logging_note</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial.try_rand_split" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a random split point r (using the random number generator
embedded in ctx).  We require 1/4 &lt;= r &lt; 3/4 (to ensure that
recursive algorithms make progress).</p>
<p>Then, try doing a de Casteljau split of this polynomial at r, resulting
in polynomials p1 and p2.  If we see that the sign of this polynomial
is determined at r, then return (p1, p2, r); otherwise,
return None.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">50</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">70</span><span class="p">,</span> <span class="mi">200</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">try_rand_split</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>
<span class="go">&lt;IBP: (50, 29, -27, -56, -11) + [0 .. 6) over [0 .. 43/64]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>
<span class="go">&lt;IBP: (-11, 10, 49, 111, 200) + [0 .. 6) over [43/64 .. 1]&gt;</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">try_rand_split</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">),</span> <span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>
<span class="go">&lt;IBP: (50, 32, -11, -41, -29) + [0 .. 6) over [0 .. 583/1024]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>
<span class="go">&lt;IBP: (-29, -20, 13, 83, 200) + [0 .. 6) over [583/1024 .. 1]&gt;</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpf</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.9</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">],</span> <span class="n">neg_err</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">pos_err</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">try_rand_split</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>  <span class="c1"># rel tol</span>
<span class="go">&lt;IBP: (0.5, 0.2984375, -0.2642578125, -0.5511661529541015, -0.3145806974172592) + [-0.10000000000000069 .. 0.010000000000000677] over [0 .. 43/64]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>  <span class="c1"># rel tol</span>
<span class="go">&lt;IBP: (-0.3145806974172592, -0.19903896331787108, 0.04135986328125002, 0.43546875, 0.99) + [-0.10000000000000069 .. 0.010000000000000677] over [43/64 .. 1]&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial.try_split">
<code class="descname">try_split</code><span class="sig-paren">(</span><em>ctx</em>, <em>logging_note</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial.try_split" title="Permalink to this definition">¶</a></dt>
<dd><p>Try doing a de Casteljau split of this polynomial at 1/2, resulting
in polynomials p1 and p2.  If we see that the sign of this polynomial
is determined at 1/2, then return (p1, p2, 1/2); otherwise,
return None.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">50</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">70</span><span class="p">,</span> <span class="mi">200</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">try_split</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>
<span class="go">&lt;IBP: (50, 35, 0, -29, -31) + [0 .. 6) over [0 .. 1/2]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>
<span class="go">&lt;IBP: (-31, -33, -8, 65, 200) + [0 .. 6) over [1/2 .. 1]&gt;</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpf</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.9</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">],</span> <span class="n">neg_err</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">pos_err</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">try_split</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>
<span class="go">&lt;IBP: (0.5, 0.35, 0.0, -0.2875, -0.369375) + [-0.10000000000000023 .. 0.010000000000000226] over [0 .. 1/2]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>
<span class="go">&lt;IBP: (-0.369375, -0.45125, -0.3275, 0.14500000000000002, 0.99) + [-0.10000000000000023 .. 0.010000000000000226] over [1/2 .. 1]&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial.variations">
<code class="descname">variations</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial.variations" title="Permalink to this definition">¶</a></dt>
<dd><p>Consider a polynomial (written in either the normal power basis
or the Bernstein basis).  Take its list of coefficients, omitting
zeroes.  Count the number of positions in the list where the
sign of one coefficient is opposite the sign of the next coefficient.</p>
<p>This count is the number of sign variations of the polynomial.
According to Descartes’ rule of signs, the number of real
roots of the polynomial (counted with multiplicity) in a
certain interval is always less than or equal to the number of
sign variations, and the difference is always even.  (If the
polynomial is written in the power basis, the region is the
positive reals; if the polynomial is written in the Bernstein
basis over a particular region, then we count roots in that region.)</p>
<p>In particular, a polynomial with no sign variations has no real
roots in the region, and a polynomial with one sign variation
has one real root in the region.</p>
<p>In an interval Bernstein polynomial, we do not necessarily
know the signs of the coefficients (if some of the coefficient
intervals contain zero), so the polynomials contained by
this interval polynomial may not all have the same number
of sign variations.  However, we can compute a range of
possible numbers of sign variations.</p>
<p>This function returns the range, as a 2-tuple of integers.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float">
<em class="property">class </em><code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">interval_bernstein_polynomial_float</code><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial" title="sage.rings.polynomial.real_roots.interval_bernstein_polynomial"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.rings.polynomial.real_roots.interval_bernstein_polynomial</span></code></a></p>
<p>This is the subclass of interval_bernstein_polynomial where
polynomial coefficients are represented using floating-point numbers.</p>
<p>In the floating-point representation, each coefficient is represented
as an IEEE double-precision float A, and the (shared) lower and
upper interval widths E1 and E2.  These represent the coefficients
(A+E1)*2^n &lt;= c &lt;= (A+E2)*2^n.</p>
<p>Note that we always have E1 &lt;= 0 &lt;= E2.  Also, each floating-point
coefficient has absolute value less than one.</p>
<p>(Note that mk_ibpf is a simple helper function for creating
elements of interval_bernstein_polynomial_float in doctests.)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpf</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">pos_err</span><span class="o">=</span><span class="mf">0.5</span><span class="p">);</span> <span class="k">print</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span>
<span class="go">degree 2 IBP with floating-point coefficients</span>
<span class="gp">sage: </span><span class="n">bp</span>
<span class="go">&lt;IBP: (0.1, 0.2, 0.3) + [0.0 .. 0.5]&gt;</span>
<span class="gp">sage: </span><span class="n">bp</span><span class="o">.</span><span class="n">variations</span><span class="p">()</span>
<span class="go">(0, 0)</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpf</span><span class="p">([</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">],</span> <span class="n">lower</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mi">5</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="n">usign</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pos_err</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">scale_log2</span><span class="o">=-</span><span class="mi">3</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">slope_err</span><span class="o">=</span><span class="n">RIF</span><span class="p">(</span><span class="n">pi</span><span class="p">));</span> <span class="k">print</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span>
<span class="go">degree 5 IBP with floating-point coefficients</span>
<span class="gp">sage: </span><span class="n">bp</span>
<span class="go">&lt;IBP: ((-0.3, -0.1, 0.1, -0.1, -0.3, -0.1) + [0.0 .. 0.2]) * 2^-3 over [1 .. 5/4]; usign 1; level 2; slope_err 3.141592653589794?&gt;</span>
<span class="gp">sage: </span><span class="n">bp</span><span class="o">.</span><span class="n">variations</span><span class="p">()</span>
<span class="go">(3, 3)</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.as_float">
<code class="descname">as_float</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.as_float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.de_casteljau">
<code class="descname">de_casteljau</code><span class="sig-paren">(</span><em>ctx</em>, <em>mid</em>, <em>msign=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.de_casteljau" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses de Casteljau’s algorithm to compute the representation
of this polynomial in a Bernstein basis over new regions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">mid</span></code> – where to split the Bernstein basis region; 0 &lt; mid &lt; 1</li>
<li><code class="docutils literal notranslate"><span class="pre">msign</span></code> – default 0 (unknown); the sign of this polynomial at mid</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">bp1</span></code>, <code class="docutils literal notranslate"><span class="pre">bp2</span></code> – the new interval Bernstein polynomials</li>
<li><code class="docutils literal notranslate"><span class="pre">ok</span></code> – a boolean; True if the sign of the original polynomial at mid is known</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">mk_context</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpf</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.9</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">],</span> <span class="n">neg_err</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">pos_err</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">de_casteljau</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>
<span class="go">&lt;IBP: (0.5, 0.35, 0.0, -0.2875, -0.369375) + [-0.10000000000000023 .. 0.010000000000000226] over [0 .. 1/2]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>
<span class="go">&lt;IBP: (-0.369375, -0.45125, -0.3275, 0.14500000000000002, 0.99) + [-0.10000000000000023 .. 0.010000000000000226] over [1/2 .. 1]&gt;</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">de_casteljau</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span> <span class="c1"># rel tol 2e-16</span>
<span class="go">&lt;IBP: (0.5, 0.30000000000000004, -0.2555555555555555, -0.5444444444444444, -0.32172839506172846) + [-0.10000000000000069 .. 0.010000000000000677] over [0 .. 2/3]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>  <span class="c1"># rel tol 3e-15</span>
<span class="go">&lt;IBP: (-0.32172839506172846, -0.21037037037037046, 0.028888888888888797, 0.4266666666666666, 0.99) + [-0.10000000000000069 .. 0.010000000000000677] over [2/3 .. 1]&gt;</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">de_casteljau</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">7</span><span class="o">/</span><span class="mi">39</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>  <span class="c1"># rel tol</span>
<span class="go">&lt;IBP: (0.5, 0.4461538461538461, 0.36653517422748183, 0.27328680523946786, 0.1765692706232836) + [-0.10000000000000069 .. 0.010000000000000677] over [0 .. 7/39]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>  <span class="c1"># rel tol</span>
<span class="go">&lt;IBP: (0.1765692706232836, -0.26556803047927313, -0.7802038132807364, -0.3966666666666666, 0.99) + [-0.10000000000000069 .. 0.010000000000000677] over [7/39 .. 1]&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.get_msb_bit">
<code class="descname">get_msb_bit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.get_msb_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an approximation of the log2 of the maximum of the
absolute values of the coefficients, as an integer.</p>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.slope_range">
<code class="descname">slope_range</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_float.slope_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a bound on the derivative of this polynomial, over its region.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpf</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.9</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">],</span> <span class="n">neg_err</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">pos_err</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp</span><span class="o">.</span><span class="n">slope_range</span><span class="p">()</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;brackets&#39;</span><span class="p">)</span>
<span class="go">&#39;[-4.8400000000000017 .. 7.2000000000000011]&#39;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer">
<em class="property">class </em><code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">interval_bernstein_polynomial_integer</code><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial" title="sage.rings.polynomial.real_roots.interval_bernstein_polynomial"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.rings.polynomial.real_roots.interval_bernstein_polynomial</span></code></a></p>
<p>This is the subclass of interval_bernstein_polynomial where
polynomial coefficients are represented using integers.</p>
<p>In this integer representation, each coefficient is represented by
a GMP arbitrary-precision integer A, and a (shared) interval width
E (which is a machine integer).  These represent the coefficients
A*2^n &lt;= c &lt; (A+E)*2^n.</p>
<p>(Note that mk_ibpi is a simple helper function for creating
elements of interval_bernstein_polynomial_integer in doctests.)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">5</span><span class="p">);</span> <span class="k">print</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span>
<span class="go">degree 2 IBP with 2-bit coefficients</span>
<span class="gp">sage: </span><span class="n">bp</span>
<span class="go">&lt;IBP: (1, 2, 3) + [0 .. 5)&gt;</span>
<span class="gp">sage: </span><span class="n">bp</span><span class="o">.</span><span class="n">variations</span><span class="p">()</span>
<span class="go">(0, 0)</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">lower</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mi">5</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="n">usign</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">scale_log2</span><span class="o">=-</span><span class="mi">3</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">slope_err</span><span class="o">=</span><span class="n">RIF</span><span class="p">(</span><span class="n">pi</span><span class="p">));</span> <span class="k">print</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span>
<span class="go">degree 5 IBP with 2-bit coefficients</span>
<span class="gp">sage: </span><span class="n">bp</span>
<span class="go">&lt;IBP: ((-3, -1, 1, -1, -3, -1) + [0 .. 2)) * 2^-3 over [1 .. 5/4]; usign 1; level 2; slope_err 3.141592653589794?&gt;</span>
<span class="gp">sage: </span><span class="n">bp</span><span class="o">.</span><span class="n">variations</span><span class="p">()</span>
<span class="go">(3, 3)</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.as_float">
<code class="descname">as_float</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.as_float" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an interval_bernstein_polynomial_float which contains
(or bounds) all the polynomials this interval polynomial
contains (or bounds).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">50</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">70</span><span class="p">,</span> <span class="mi">200</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">bp</span><span class="o">.</span><span class="n">as_float</span><span class="p">())</span>
<span class="go">degree 4 IBP with floating-point coefficients</span>
<span class="gp">sage: </span><span class="n">bp</span><span class="o">.</span><span class="n">as_float</span><span class="p">()</span>
<span class="go">&lt;IBP: ((0.1953125, 0.078125, -0.3515625, -0.2734375, 0.78125) + [-1.1275702593849246e-16 .. 0.01953125000000017]) * 2^8&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.de_casteljau">
<code class="descname">de_casteljau</code><span class="sig-paren">(</span><em>ctx</em>, <em>mid</em>, <em>msign=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.de_casteljau" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses de Casteljau’s algorithm to compute the representation
of this polynomial in a Bernstein basis over new regions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">mid</span></code> – where to split the Bernstein basis region; 0 &lt; mid &lt; 1</li>
<li><code class="docutils literal notranslate"><span class="pre">msign</span></code> – default 0 (unknown); the sign of this polynomial at mid</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">bp1</span></code>, <code class="docutils literal notranslate"><span class="pre">bp2</span></code> – the new interval Bernstein polynomials</li>
<li><code class="docutils literal notranslate"><span class="pre">ok</span></code> – a boolean; True if the sign of the original polynomial at mid is known</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">50</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">70</span><span class="p">,</span> <span class="mi">200</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">mk_context</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">de_casteljau</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>
<span class="go">&lt;IBP: (50, 35, 0, -29, -31) + [0 .. 6) over [0 .. 1/2]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>
<span class="go">&lt;IBP: (-31, -33, -8, 65, 200) + [0 .. 6) over [1/2 .. 1]&gt;</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">de_casteljau</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>
<span class="go">&lt;IBP: (50, 30, -26, -55, -13) + [0 .. 6) over [0 .. 2/3]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>
<span class="go">&lt;IBP: (-13, 8, 47, 110, 200) + [0 .. 6) over [2/3 .. 1]&gt;</span>
<span class="gp">sage: </span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">de_casteljau</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">7</span><span class="o">/</span><span class="mi">39</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp1</span>
<span class="go">&lt;IBP: (50, 44, 36, 27, 17) + [0 .. 6) over [0 .. 7/39]&gt;</span>
<span class="gp">sage: </span><span class="n">bp2</span>
<span class="go">&lt;IBP: (17, -26, -75, -22, 200) + [0 .. 6) over [7/39 .. 1]&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.down_degree">
<code class="descname">down_degree</code><span class="sig-paren">(</span><em>ctx</em>, <em>max_err</em>, <em>exp_err_shift</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.down_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an interval_bernstein_polynomial_integer which bounds
all the polynomials this interval polynomial bounds, but is
of lesser degree.</p>
<p>During the computation, we find an “expected error”
expected_err, which is the error inherent in our approach
(this depends on the degrees involved, and is proportional
to the error of the current polynomial).</p>
<p>We require that the error of the new interval polynomial
be bounded both by max_err, and by expected_err &lt;&lt; exp_err_shift.
If we find such a polynomial p, then we return a pair of p and some
debugging/logging information.  Otherwise, we return the pair
(None, None).</p>
<p>If the resulting polynomial would have error more than 2^17,
then it is downscaled before returning.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">903</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">mk_context</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bp</span>
<span class="go">&lt;IBP: (0, 100, 400, 903) + [0 .. 2)&gt;</span>
<span class="gp">sage: </span><span class="n">dbp</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">down_degree</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dbp</span>
<span class="go">&lt;IBP: (-1, 148, 901) + [0 .. 4); level 1; slope_err 0.?e2&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.down_degree_iter">
<code class="descname">down_degree_iter</code><span class="sig-paren">(</span><em>ctx</em>, <em>max_scale</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.down_degree_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a degree-reduced version of this interval polynomial, by
iterating down_degree.</p>
<p>We stop when degree reduction would give a polynomial which is
too inaccurate, meaning that either we think the current polynomial
may have more roots in its region than the degree of the
reduced polynomial, or that the least significant accurate bit
in the result (on the absolute scale) would be larger than
1 &lt;&lt; max_scale.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">903</span><span class="p">,</span> <span class="mi">1600</span><span class="p">,</span> <span class="mi">2500</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">mk_context</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bp</span>
<span class="go">&lt;IBP: (0, 100, 400, 903, 1600, 2500) + [0 .. 2)&gt;</span>
<span class="gp">sage: </span><span class="n">rbp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">down_degree_iter</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rbp</span>
<span class="go">&lt;IBP: (-4, 249, 2497) + [0 .. 9); level 2; slope_err 0.?e3&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.downscale">
<code class="descname">downscale</code><span class="sig-paren">(</span><em>bits</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.downscale" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an interval_bernstein_polynomial_integer which
contains (or bounds) all the polynomials this interval
polynomial contains (or bounds), but uses
“bits” fewer bits.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">903</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp</span><span class="o">.</span><span class="n">downscale</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&lt;IBP: ((0, 3, 12, 28) + [0 .. 1)) * 2^5&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.get_msb_bit">
<code class="descname">get_msb_bit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.get_msb_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an approximation of the log2 of the maximum of the
absolute values of the coefficients, as an integer.</p>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.slope_range">
<code class="descname">slope_range</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.interval_bernstein_polynomial_integer.slope_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a bound on the derivative of this polynomial, over its region.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">903</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bp</span><span class="o">.</span><span class="n">slope_range</span><span class="p">()</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;brackets&#39;</span><span class="p">)</span>
<span class="go">&#39;[294.00000000000000 .. 1515.0000000000000]&#39;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.intvec_to_doublevec">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">intvec_to_doublevec</code><span class="sig-paren">(</span><em>b</em>, <em>err</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.intvec_to_doublevec" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a vector of integers A = [a1, …, an], and an integer
error bound E, returns a vector of floating-point numbers
B = [b1, …, bn], lower and upper error bounds F1 and F2, and
a scaling factor d, such that</p>
<div class="math notranslate nohighlight">
\[(bk + F1) * 2^d \le ak\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[ak + E \le (bk + F2) * 2^d\]</div>
<p>If bj is the element of B with largest absolute value, then
0.5 &lt;= abs(bj) &lt; 1.0 .</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">intvec_to_doublevec</span><span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]),</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">((0.125, 0.25, 0.375, 0.5, 0.625), -1.1275702593849246e-16, 0.37500000000000017, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.rings.polynomial.real_roots.island">
<em class="property">class </em><code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">island</code><a class="headerlink" href="#sage.rings.polynomial.real_roots.island" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This implements the island portion of my ocean-island root isolation
algorithm.  See the documentation for class ocean, for more
information on the overall algorithm.</p>
<p>Island root refinement starts with a Bernstein polynomial whose
region is the whole island (or perhaps slightly more than the
island in certain cases).  There are two subalgorithms; one when
looking at a Bernstein polynomial covering a whole island (so we
know that there are gaps on the left and right), and one when
looking at a Bernstein polynomial covering the left segment of an
island (so we know that there is a gap on the left, but the right
is in the middle of an island).  An important invariant of the
left-segment subalgorithm over the region [l .. r] is that it
always finds a gap [r0 .. r] ending at its right endpoint.</p>
<p>Ignoring degree reduction, downscaling (precision reduction), and
failures to split, the algorithm is roughly:</p>
<p>Whole island:</p>
<ol class="arabic simple">
<li>If the island definitely has exactly one root, then return.</li>
<li>Split the island in (approximately) half.</li>
<li>If both halves definitely have no roots, then remove this island from
its doubly-linked list (merging its left and right gaps) and return.</li>
<li>If either half definitely has no roots, then discard that half
and call the whole-island algorithm with the other half, then return.</li>
<li>If both halves may have roots, then call the left-segment algorithm
on the left half.</li>
<li>We now know that there is a gap immediately to the left of the
right half, so call the whole-island algorithm on the right half,
then return.</li>
</ol>
<p>Left segment:</p>
<ol class="arabic simple">
<li>Split the left segment in (approximately) half.</li>
<li>If both halves definitely have no roots, then extend the left gap
over the segment and return.</li>
<li>If the left half definitely has no roots, then extend the left gap
over this half and call the left-segment algorithm on the right half,
then return.</li>
<li>If the right half definitely has no roots, then split the island
in two, creating a new gap.  Call the whole-island algorithm on the
left half, then return.</li>
<li>Both halves may have roots.  Call the left-segment algorithm on
the left half.</li>
<li>We now know that there is a gap immediately to the left of the
right half, so call the left-segment algorithm on the right half,
then return.</li>
</ol>
<p>Degree reduction complicates this picture only slightly.  Basically,
we use heuristics to decide when degree reduction might be likely
to succeed and be helpful; whenever this is the case, we attempt
degree reduction.</p>
<p>Precision reduction and split failure add more complications.
The algorithm maintains a stack of different-precision representations
of the interval Bernstein polynomial.  The base of the stack
is at the highest (currently known) precision; each stack entry has
approximately half the precision of the entry below it.  When we
do a split, we pop off the top of the stack, split it, then push
whichever half we’re interested in back on the stack (so the
different Bernstein polynomials may be over different regions).
When we push a polynomial onto the stack, we may heuristically decide to
push further lower-precision versions of the same polynomial onto the
stack.</p>
<p>In the algorithm above, whenever we say “split in (approximately) half”,
we attempt to split the top-of-stack polynomial using try_split()
and try_rand_split().  However, these will fail if the sign of the
polynomial at the chosen split point is unknown (if the polynomial is
not known to high enough precision, or if the chosen split point
actually happens to be a root of the polynomial).  If this fails, then
we discard the top-of-stack polynomial, and try again with the
next polynomial down (which has approximately twice the precision).
This next polynomial may not be over the same region; if not, we
split it using de Casteljau’s algorithm to get a polynomial over
(approximately) the same region first.</p>
<p>If we run out of higher-precision polynomials (if we empty out the
entire stack), then we give up on root refinement for this island.
The ocean class will notice this, provide the island with a
higher-precision polynomial, and restart root refinement.  Basically
the only information kept in that case is the lower and upper bounds
on the island.  Since these are updated whenever we discover a “half”
(of an island or a segment) that definitely contains no roots, we
never need to re-examine these gaps.  (We could keep more information.
For example, we could keep a record of split points that succeeded
and failed.  However, a split point that failed at lower precision
is likely to succeed at higher precision, so it’s not worth avoiding.
It could be useful to select split points that are known to succeed,
but starting from a new Bernstein polynomial over a slightly different
region, hitting such split points would require de Casteljau splits
with non-power-of-two denominators, which are much much slower.)</p>
<dl class="method">
<dt id="sage.rings.polynomial.real_roots.island.bp_done">
<code class="descname">bp_done</code><span class="sig-paren">(</span><em>bp</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.island.bp_done" title="Permalink to this definition">¶</a></dt>
<dd><p>Examine the given Bernstein polynomial to see if it is known
to have exactly one root in its region.  (In addition, we require
that the polynomial region not include 0 or 1.  This makes things
work if the user gives explicit bounds to real_roots(),
where the lower or upper bound is a root of the polynomial.
real_roots() deals with this by explicitly detecting it,
dividing out the appropriate linear polynomial, and adding the
root to the returned list of roots; but then if the island
considers itself “done” with a region including 0 or 1, the returned
root regions can overlap with each other.)</p>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.island.done">
<code class="descname">done</code><span class="sig-paren">(</span><em>ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.island.done" title="Permalink to this definition">¶</a></dt>
<dd><p>Check to see if the island is known to contain zero roots or
is known to contain one root.</p>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.island.has_root">
<code class="descname">has_root</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.island.has_root" title="Permalink to this definition">¶</a></dt>
<dd><p>Assuming that the island is done (has either 0 or 1 roots),
reports whether the island has a root.</p>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.island.less_bits">
<code class="descname">less_bits</code><span class="sig-paren">(</span><em>ancestors</em>, <em>bp</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.island.less_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Heuristically pushes lower-precision polynomials on
the polynomial stack.  See the class documentation for class
island for more information.</p>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.island.more_bits">
<code class="descname">more_bits</code><span class="sig-paren">(</span><em>ctx</em>, <em>ancestors</em>, <em>bp</em>, <em>rightmost</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.island.more_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a Bernstein polynomial on the “ancestors” stack with
more precision than bp; if it is over a different region,
then shrink its region to (approximately) match that of bp.
(If this is rightmost – if bp covers the whole island – then
we only require that the new region cover the whole island
fairly tightly; if this is not rightmost, then the new region
will have exactly the same right boundary as bp, although the
left boundary may vary slightly.)</p>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.island.refine">
<code class="descname">refine</code><span class="sig-paren">(</span><em>ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.island.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to shrink and/or split this island into sub-island
that each definitely contain exactly one root.</p>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.island.refine_recurse">
<code class="descname">refine_recurse</code><span class="sig-paren">(</span><em>ctx</em>, <em>bp</em>, <em>ancestors</em>, <em>history</em>, <em>rightmost</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.island.refine_recurse" title="Permalink to this definition">¶</a></dt>
<dd><p>This implements the root isolation algorithm described in the
class documentation for class island.  This is the implementation
of both the whole-island and the left-segment algorithms;
if the flag rightmost is True, then it is the whole-island algorithm,
otherwise the left-segment algorithm.</p>
<p>The precision-reduction stack is (ancestors + [bp]); that is, the
top-of-stack is maintained separately.</p>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.island.reset_root_width">
<code class="descname">reset_root_width</code><span class="sig-paren">(</span><em>target_width</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.island.reset_root_width" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify the criteria for this island to require that it is not “done”
until its width is less than or equal to target_width.</p>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.island.shrink_bp">
<code class="descname">shrink_bp</code><span class="sig-paren">(</span><em>ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.island.shrink_bp" title="Permalink to this definition">¶</a></dt>
<dd><p>If the island’s Bernstein polynomial covers a region much larger
than the island itself (in particular, if either the island’s
left gap or right gap are totally contained in the polynomial’s
region) then shrink the polynomial down to cover the island more
tightly.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.rings.polynomial.real_roots.linear_map">
<em class="property">class </em><code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">linear_map</code><span class="sig-paren">(</span><em>lower</em>, <em>upper</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.linear_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A simple class to map linearly between original coordinates
(ranging from [lower .. upper]) and ocean coordinates (ranging
from [0 .. 1]).</p>
<dl class="method">
<dt id="sage.rings.polynomial.real_roots.linear_map.from_ocean">
<code class="descname">from_ocean</code><span class="sig-paren">(</span><em>region</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.linear_map.from_ocean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.linear_map.to_ocean">
<code class="descname">to_ocean</code><span class="sig-paren">(</span><em>region</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.linear_map.to_ocean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.max_abs_doublevec">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">max_abs_doublevec</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.max_abs_doublevec" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a floating-point vector, return the maximum of the
absolute values of its elements.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">max_abs_doublevec</span><span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.767</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.693</span><span class="p">]))</span>
<span class="go">0.767</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.max_bitsize_intvec_doctest">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">max_bitsize_intvec_doctest</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.max_bitsize_intvec_doctest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.maximum_root_first_lambda">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">maximum_root_first_lambda</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.maximum_root_first_lambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a polynomial with real coefficients, computes an upper bound
on its largest real root, using the first-lambda algorithm from
“Implementations of a New Theorem for Computing Bounds for Positive
Roots of Polynomials”, by Akritas, Strzebo’nski, and Vigklas.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">maximum_root_first_lambda</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="go">6.00000000000001</span>
<span class="gp">sage: </span><span class="n">maximum_root_first_lambda</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">))</span>
<span class="go">0.000000000000000</span>
<span class="gp">sage: </span><span class="n">maximum_root_first_lambda</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">1.00000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.maximum_root_local_max">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">maximum_root_local_max</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.maximum_root_local_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a polynomial with real coefficients, computes an upper bound
on its largest real root, using the local-max algorithm from
“Implementations of a New Theorem for Computing Bounds for Positive
Roots of Polynomials”, by Akritas, Strzebo’nski, and Vigklas.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">maximum_root_local_max</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="go">12.0000000000001</span>
<span class="gp">sage: </span><span class="n">maximum_root_local_max</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">))</span>
<span class="go">0.000000000000000</span>
<span class="gp">sage: </span><span class="n">maximum_root_local_max</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">1.41421356237310</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.min_max_delta_intvec">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">min_max_delta_intvec</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.min_max_delta_intvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two integer vectors a and b (of equal, nonzero length), return
a pair of the minimum and maximum values taken on by a[i] - b[i].</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">30</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="o">-</span><span class="mi">60</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">min_max_delta_intvec</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">(30, -5)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.min_max_diff_doublevec">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">min_max_diff_doublevec</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.min_max_diff_doublevec" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a floating-point vector b = (b0, …, bn), compute the
minimum and maximum values of b_{j+1} - b_j.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">min_max_diff_doublevec</span><span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">(-9.0, 6.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.min_max_diff_intvec">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">min_max_diff_intvec</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.min_max_diff_intvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an integer vector b = (b0, …, bn), compute the
minimum and maximum values of b_{j+1} - b_j.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">min_max_diff_intvec</span><span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">(-9, 6)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.mk_context">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">mk_context</code><span class="sig-paren">(</span><em>do_logging=False</em>, <em>seed=0</em>, <em>wordsize=32</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.mk_context" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple wrapper for creating context objects with coercions,
defaults, etc.</p>
<p>For use in doctests.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">mk_context</span><span class="p">(</span><span class="n">do_logging</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">wordsize</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
<span class="go">root isolation context: seed=3; do_logging=True; wordsize=64</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.mk_ibpf">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">mk_ibpf</code><span class="sig-paren">(</span><em>coeffs</em>, <em>lower=0</em>, <em>upper=1</em>, <em>lsign=0</em>, <em>usign=0</em>, <em>neg_err=0</em>, <em>pos_err=0</em>, <em>scale_log2=0</em>, <em>level=0</em>, <em>slope_err=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.mk_ibpf" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple wrapper for creating interval_bernstein_polynomial_float
objects with coercions, defaults, etc.</p>
<p>For use in doctests.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">mk_ibpf</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.9</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">],</span> <span class="n">pos_err</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">neg_err</span><span class="o">=-</span><span class="mf">0.01</span><span class="p">))</span>
<span class="go">degree 4 IBP with floating-point coefficients</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.mk_ibpi">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">mk_ibpi</code><span class="sig-paren">(</span><em>coeffs</em>, <em>lower=0</em>, <em>upper=1</em>, <em>lsign=0</em>, <em>usign=0</em>, <em>error=1</em>, <em>scale_log2=0</em>, <em>level=0</em>, <em>slope_err=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.mk_ibpi" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple wrapper for creating interval_bernstein_polynomial_integer
objects with coercions, defaults, etc.</p>
<p>For use in doctests.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">50</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">70</span><span class="p">,</span> <span class="mi">200</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span>
<span class="go">degree 4 IBP with 8-bit coefficients</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.rings.polynomial.real_roots.ocean">
<em class="property">class </em><code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">ocean</code><a class="headerlink" href="#sage.rings.polynomial.real_roots.ocean" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Given the tools we’ve defined so far, there are many possible root
isolation algorithms that differ on where to select split points,
what precision to work at when, and when to attempt degree
reduction.</p>
<p>Here we implement one particular algorithm, which I call the
ocean-island algorithm.  We start with an interval Bernstein
polynomial defined over the region [0 .. 1].  This region is
the “ocean”.  Using de Casteljau’s algorithm and Descartes’
rule of signs, we divide this region into subregions which may
contain roots, and subregions which are guaranteed not to contain
roots.  Subregions which may contain roots are “islands”; subregions
known not to contain roots are “gaps”.</p>
<p>All the real root isolation work happens in class island.  See the
documentation of that class for more information.</p>
<p>An island can be told to refine itself until it contains only a
single root.  This may not succeed, if the island’s interval
Bernstein polynomial does not have enough precision.  The ocean
basically loops, refining each of its islands, then increasing the
precision of islands which did not succeed in isolating a single
root; until all islands are done.</p>
<p>Increasing the precision of unsuccessful islands is done in a
single pass using split_for_target(); this means it is possible
to share work among multiple islands.</p>
<dl class="method">
<dt id="sage.rings.polynomial.real_roots.ocean.all_done">
<code class="descname">all_done</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.ocean.all_done" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true iff all islands are known to contain exactly one root.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">oc</span> <span class="o">=</span> <span class="n">ocean</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">193</span><span class="o">/</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">140</span><span class="o">/</span><span class="mi">99</span><span class="p">]),</span> <span class="n">lmap</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">all_done</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">find_roots</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">all_done</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.ocean.approx_bp">
<code class="descname">approx_bp</code><span class="sig-paren">(</span><em>scale_log2</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.ocean.approx_bp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an approximation to our Bernstein polynomial with the
given scale_log2.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">oc</span> <span class="o">=</span> <span class="n">ocean</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">193</span><span class="o">/</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">140</span><span class="o">/</span><span class="mi">99</span><span class="p">]),</span> <span class="n">lmap</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">approx_bp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&lt;IBP: (0, -4, 2, -2) + [0 .. 1); lsign 1&gt;</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">approx_bp</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">)</span>
<span class="go">&lt;IBP: ((349525, -3295525, 2850354, -1482835) + [0 .. 1)) * 2^-20&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.ocean.find_roots">
<code class="descname">find_roots</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.ocean.find_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Isolate all roots in this ocean.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">oc</span> <span class="o">=</span> <span class="n">ocean</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">193</span><span class="o">/</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">140</span><span class="o">/</span><span class="mi">99</span><span class="p">]),</span> <span class="n">lmap</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span>
<span class="go">ocean with precision 120 and 1 island(s)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">find_roots</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span>
<span class="go">ocean with precision 120 and 3 island(s)</span>
<span class="gp">sage: </span><span class="n">oc</span> <span class="o">=</span> <span class="n">ocean</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1111</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">11108889</span><span class="o">/</span><span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">lmap</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">find_roots</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span>
<span class="go">ocean with precision 240 and 3 island(s)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.ocean.increase_precision">
<code class="descname">increase_precision</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.ocean.increase_precision" title="Permalink to this definition">¶</a></dt>
<dd><p>Increase the precision of the interval Bernstein polynomial held
by any islands which are not done.  (In normal use, calls to this
function are separated by calls to self.refine_all().)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">oc</span> <span class="o">=</span> <span class="n">ocean</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">193</span><span class="o">/</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">140</span><span class="o">/</span><span class="mi">99</span><span class="p">]),</span> <span class="n">lmap</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span>
<span class="go">ocean with precision 120 and 1 island(s)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">increase_precision</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">increase_precision</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">increase_precision</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span>
<span class="go">ocean with precision 960 and 1 island(s)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.ocean.refine_all">
<code class="descname">refine_all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.ocean.refine_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Refine all islands which are not done (which are not known to
contain exactly one root).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">oc</span> <span class="o">=</span> <span class="n">ocean</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">193</span><span class="o">/</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">140</span><span class="o">/</span><span class="mi">99</span><span class="p">]),</span> <span class="n">lmap</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span>
<span class="go">ocean with precision 120 and 1 island(s)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">refine_all</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span>
<span class="go">ocean with precision 120 and 3 island(s)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.ocean.reset_root_width">
<code class="descname">reset_root_width</code><span class="sig-paren">(</span><em>isle_num</em>, <em>target_width</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.ocean.reset_root_width" title="Permalink to this definition">¶</a></dt>
<dd><p>Require that the isle_num island have a width at most target_width.</p>
<p>If this is followed by a call to find_roots(), then the
corresponding root will be refined to the specified width.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">oc</span> <span class="o">=</span> <span class="n">ocean</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">lmap</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">find_roots</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">roots</span><span class="p">()</span>
<span class="go">[(1/2, 3/4)]</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">reset_root_width</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">^</span><span class="mi">200</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">find_roots</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span>
<span class="go">ocean with precision 240 and 1 island(s)</span>
<span class="gp">sage: </span><span class="n">RR</span><span class="p">(</span><span class="n">RealIntervalField</span><span class="p">(</span><span class="mi">300</span><span class="p">)(</span><span class="n">oc</span><span class="o">.</span><span class="n">roots</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">absolute_diameter</span><span class="p">())</span><span class="o">.</span><span class="n">log2</span><span class="p">()</span>
<span class="go">-232.668979560890</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.ocean.roots">
<code class="descname">roots</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.ocean.roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the locations of all islands in this ocean.  (If run
after find_roots(), this is the location of all roots in the ocean.)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">oc</span> <span class="o">=</span> <span class="n">ocean</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">193</span><span class="o">/</span><span class="mi">71</span><span class="p">,</span> <span class="o">-</span><span class="mi">140</span><span class="o">/</span><span class="mi">99</span><span class="p">]),</span> <span class="n">lmap</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">find_roots</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">roots</span><span class="p">()</span>
<span class="go">[(1/32, 1/16), (1/2, 5/8), (3/4, 7/8)]</span>
<span class="gp">sage: </span><span class="n">oc</span> <span class="o">=</span> <span class="n">ocean</span><span class="p">(</span><span class="n">mk_context</span><span class="p">(),</span> <span class="n">bernstein_polynomial_factory_ratlist</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1111</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">11108889</span><span class="o">/</span><span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">lmap</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">find_roots</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">oc</span><span class="o">.</span><span class="n">roots</span><span class="p">()</span>
<span class="go">[(95761241267509487747625/9671406556917033397649408, 191522482605387719863145/19342813113834066795298816), (1496269395904347376805/151115727451828646838272, 374067366568272936175/37778931862957161709568), (31/32, 63/64)]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.precompute_degree_reduction_cache">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">precompute_degree_reduction_cache</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.precompute_degree_reduction_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute and cache the matrices used for degree reduction, starting
from degree n.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">precompute_degree_reduction_cache</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dr_cache</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
<span class="go">(</span>
<span class="go">   [121/126    8/63    -1/9   -2/63  11/126   -2/63]</span>
<span class="go">   [   -3/7   37/42   16/21    1/21    -3/7     1/6]</span>
<span class="go">   [    1/6    -3/7    1/21   16/21   37/42    -3/7]</span>
<span class="go">3, [  -2/63  11/126   -2/63    -1/9    8/63 121/126], 2,</span>

<span class="go">([121  16 -14  -4  11  -4]</span>
<span class="go">[-54 111  96   6 -54  21]</span>
<span class="go">[ 21 -54   6  96 111 -54]</span>
<span class="go">[ -4  11  -4 -14  16 121], 126)</span>
<span class="go">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.pseudoinverse">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">pseudoinverse</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.pseudoinverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.rational_root_bounds">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">rational_root_bounds</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.rational_root_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a polynomial p with real coefficients, computes rationals
a and b, such that for every real root r of p, a &lt; r &lt; b.
We try to find rationals which bound the roots somewhat tightly,
yet are simple (have small numerators and denominators).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rational_root_bounds</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="go">(0, 7)</span>
<span class="gp">sage: </span><span class="n">rational_root_bounds</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(-1/2, 1/2)</span>
<span class="gp">sage: </span><span class="n">rational_root_bounds</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="go">(-3/2, 1/2)</span>
<span class="gp">sage: </span><span class="n">rational_root_bounds</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="go">(-3, 6)</span>
<span class="gp">sage: </span><span class="n">rational_root_bounds</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">995</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">9999</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(-100, 1000/7)</span>
<span class="gp">sage: </span><span class="n">rational_root_bounds</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">995</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">9999</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(-142, 213/2)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>If we can see that the polynomial has no real roots, return None.</dt>
<dd>sage: rational_root_bounds(x^2 + 7) is None
True</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.real_roots">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">real_roots</code><span class="sig-paren">(</span><em>p</em>, <em>bounds=None</em>, <em>seed=None</em>, <em>skip_squarefree=False</em>, <em>do_logging=False</em>, <em>wordsize=32</em>, <em>retval='rational'</em>, <em>strategy=None</em>, <em>max_diameter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.real_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the real roots of a given polynomial with exact
coefficients (integer, rational, and algebraic real coefficients
are supported).  Returns a list of pairs of a root and its
multiplicity.</p>
<p>The root itself can be returned in one of three different ways.
If retval==’rational’, then it is returned as a pair of rationals
that define a region that includes exactly one root.  If
retval==’interval’, then it is returned as a RealIntervalFieldElement
that includes exactly one root.  If retval==’algebraic_real’, then
it is returned as an AlgebraicReal.  In the former two cases, all
the intervals are disjoint.</p>
<p>An alternate high-level algorithm can be used by selecting
strategy=’warp’.  This affects the conversion into Bernstein
polynomial form, but still uses the same ocean-island algorithm
as the default algorithm.  The ‘warp’ algorithm performs the conversion
into Bernstein polynomial form much more quickly, but performs
the rest of the computation slightly slower in some benchmarks.
The ‘warp’ algorithm is particularly likely to be helpful for
low-degree polynomials.</p>
<p>Part of the algorithm is randomized; the seed parameter gives a seed
for the random number generator.  (By default, the same
seed is used for every call, so that results are repeatable.)  The
random seed may affect the running time, or the exact intervals returned,
but the results are correct regardless of the seed used.</p>
<p>The bounds parameter lets you find roots in some proper subinterval of
the reals; it takes a pair of a rational lower and upper bound
and only roots within this bound will be found.  Currently, specifying
bounds does not work if you select strategy=’warp’, or if you
use a polynomial with algebraic real coefficients.</p>
<p>By default, the algorithm will do a squarefree decomposition
to get squarefree polynomials.  The skip_squarefree parameter
lets you skip this step.  (If this step is skipped, and the polynomial
has a repeated real root, then the algorithm will loop forever!
However, repeated non-real roots are not a problem.)</p>
<p>For integer and rational coefficients, the squarefree
decomposition is very fast, but it may be slow for algebraic
reals.  (It may trigger exact computation, so it might be
arbitrarily slow.  The only other way that this algorithm might
trigger exact computation on algebraic real coefficients is that
it checks the constant term of the input polynomial for equality with
zero.)</p>
<p>Part of the algorithm works (approximately) by splitting numbers into
word-size pieces (that is, pieces that fit into a machine word).
For portability, this defaults to always selecting pieces suitable
for a 32-bit machine; the wordsize parameter lets you make choices
suitable for a 64-bit machine instead.  (This affects the running
time, and the exact intervals returned, but the results are correct
on both 32- and 64-bit machines even if the wordsize is chosen “wrong”.)</p>
<p>The precision of the results can be improved (at the expense of time,
of course) by specifying the max_diameter parameter.  If specified,
this sets the maximum diameter() of the intervals returned.
(Sage defines diameter() to be the relative diameter for intervals
that do not contain 0, and the absolute diameter for intervals
containing 0.)  This directly affects the results in rational or
interval return mode; in algebraic_real mode, it increases the
precision of the intervals passed to the algebraic number package,
which may speed up some operations on that algebraic real.</p>
<p>Some logging can be enabled with do_logging=True.  If logging is enabled,
then the normal values are not returned; instead, a pair of
the internal context object and a list of all the roots in their
internal form is returned.</p>
<p>ALGORITHM: We convert the polynomial into the Bernstein basis, and
then use de Casteljau’s algorithm and Descartes’ rule of signs
(using interval arithmetic) to locate the roots.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[((7/4, 19/8), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">8</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">13</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">21</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">34</span><span class="p">))</span>
<span class="go">[((11/16, 33/32), 1), ((11/8, 33/16), 1), ((11/4, 55/16), 1), ((77/16, 165/32), 1), ((11/2, 33/4), 1), ((11, 55/4), 1), ((165/8, 341/16), 1), ((22, 44), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">9999</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[((-29274496381311/9007199254740992, 419601125186091/2251799813685248), 1), ((2126658450145849453951061654415153249597/21267647932558653966460912964485513216, 4253316902721330018853696359533061621799/42535295865117307932921825928971026432), 1), ((1063329226287740282451317352558954186101/10633823966279326983230456482242756608, 531664614358685696701445201630854654353/5316911983139663491615228241121378304), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">9999</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="go">[((-123196838480289/18014398509481984, 293964743458749/9007199254740992), 1), ((8307259573979551907841696381986376143/83076749736557242056487941267521536, 16614519150981033789137940378745325503/166153499473114484112975882535043072), 1), ((519203723562592617581015249797434335/5192296858534827628530496329220096, 60443268924081068060312183/604462909807314587353088), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">9999</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">wordsize</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
<span class="go">[((-62866503803202151050003/19342813113834066795298816, 901086554512564177624143/4835703278458516698824704), 1), ((544424563237337315214990987922809050101157/5444517870735015415413993718908291383296, 1088849127096660194637118845654929064385439/10889035741470030830827987437816582766592), 1), ((272212281929661439711063928866060007142141/2722258935367507707706996859454145691648, 136106141275823501959100399337685485662633/1361129467683753853853498429727072845824), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[((-47/256, 81/512), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[((-47/256, 81/512), 1), ((1/2, 1201/1024), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[((209/256, 593/512), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[((0, 0), 1), ((81/128, 337/256), 1), ((2, 2), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;algebraic_real&#39;</span><span class="p">)</span>
<span class="go">[(0, 1), (1, 1), (2, 1)]</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="mi">2</span><span class="o">^</span><span class="mi">40</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">((</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">v</span><span class="p">))</span>
<span class="go">[((-12855504354077768210885019021174120740504020581912910106032833/12855504354071922204335696738729300820177623950262342682411008, -6427752177038884105442509510587059395588605840418680645585479/6427752177035961102167848369364650410088811975131171341205504), 1), ((-1125899906842725/1125899906842624, -562949953421275/562949953421312), 2), ((62165404551223330269422781018352603934643403586760330761772204409982940218804935733653/62165404551223330269422781018352605012557018849668464680057997111644937126566671941632, 3885337784451458141838923813647037871787041539340705594199885610069035709862106085785/3885337784451458141838923813647037813284813678104279042503624819477808570410416996352), 2), ((509258994083853105745586001837045839749063767798922046787130823804169826426726965449697819/509258994083621521567111422102344540262867098416484062659035112338595324940834176545849344, 25711008708155536421770038042348240136257704305733983563630791/25711008708143844408671393477458601640355247900524685364822016), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[((-3/2, -1), 1), ((1, 3/2), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;interval&#39;</span><span class="p">)</span>
<span class="go">[(-2.?, 1), (2.?, 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_diameter</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">^</span><span class="mi">30</span><span class="p">)</span>
<span class="go">[((-22506280506048041472675379598886543645348790970912519198456805737131269246430553365310109/15914343565113172548972231940698266883214596825515126958094847260581103904401068017057792, -45012561012096082945350759197773086524448972309421182031053065599548946985601579935498343/31828687130226345097944463881396533766429193651030253916189694521162207808802136034115584), 1), ((45012561012096082945350759197773086524448972309421182031053065599548946985601579935498343/31828687130226345097944463881396533766429193651030253916189694521162207808802136034115584, 22506280506048041472675379598886543645348790970912519198456805737131269246430553365310109/15914343565113172548972231940698266883214596825515126958094847260581103904401068017057792), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;interval&#39;</span><span class="p">,</span> <span class="n">max_diameter</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">^</span><span class="mi">500</span><span class="p">)</span>
<span class="go">[(-1.414213562373095048801688724209698078569671875376948073176679737990732478462107038850387534327641572735013846230912297024924836055850737212644121497099935831413222665927505592755799950501152782060571470109559971605970274534596862014728517418640889198609552?, 1), (1.414213562373095048801688724209698078569671875376948073176679737990732478462107038850387534327641572735013846230912297024924836055850737212644121497099935831413222665927505592755799950501152782060571470109559971605970274534596862014728517418640889198609552?, 1)]</span>
<span class="gp">sage: </span><span class="n">ar_rts</span> <span class="o">=</span> <span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;algebraic_real&#39;</span><span class="p">);</span> <span class="n">ar_rts</span>
<span class="go">[(-1.414213562373095?, 1), (1.414213562373095?, 1)]</span>
<span class="gp">sage: </span><span class="n">ar_rts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="mi">2</span><span class="o">^</span><span class="mi">40</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">v</span><span class="p">),</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;interval&#39;</span><span class="p">)</span>
<span class="go">[(1.000000000000?, 1), (1.000000000001?, 1)]</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="mi">2</span><span class="o">^</span><span class="mi">60</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">v</span><span class="p">),</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;interval&#39;</span><span class="p">)</span>
<span class="go">[(1.000000000000000000?, 1), (1.000000000000000001?, 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;warp&#39;</span><span class="p">)</span>
<span class="go">[((499/525, 1173/875), 1), ((337/175, 849/175), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;warp&#39;</span><span class="p">)</span>
<span class="go">[((-1713/335, -689/335), 1), ((-2067/2029, -689/1359), 1), ((0, 0), 1), ((499/525, 1173/875), 1), ((337/175, 849/175), 1)]</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;warp&#39;</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;algebraic_real&#39;</span><span class="p">)</span>
<span class="go">[(-3.000000000000000?, 1), (-1.000000000000000?, 1), (0, 1), (1.000000000000000?, 1), (2.000000000000000?, 1)]</span>
<span class="gp">sage: </span><span class="n">ar_rts</span> <span class="o">=</span> <span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;algebraic_real&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ar_rts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If the polynomial has no real roots, we get an empty list.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">real_root_intervals</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>We can compute Conway’s constant
(see <a class="reference external" href="http://mathworld.wolfram.com/ConwaysConstant.html">http://mathworld.wolfram.com/ConwaysConstant.html</a>) to arbitrary
precision.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">71</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">69</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">68</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">67</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">66</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">65</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">64</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">63</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">62</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">61</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">60</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">59</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">58</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">57</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">56</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">55</span> <span class="o">-</span> <span class="mi">10</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">54</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">53</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">52</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">51</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">50</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">49</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">48</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">47</span> <span class="o">-</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">46</span> <span class="o">-</span> <span class="mi">8</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">45</span> <span class="o">-</span> <span class="mi">8</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">44</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">43</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">42</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">41</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">40</span> <span class="o">-</span> <span class="mi">12</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">39</span> <span class="o">+</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">38</span> <span class="o">-</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">37</span> <span class="o">+</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">36</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">35</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">34</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">33</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">32</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">31</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">30</span> <span class="o">-</span> <span class="mi">10</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">29</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">28</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">27</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">26</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">25</span> <span class="o">+</span> <span class="mi">14</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">24</span> <span class="o">-</span> <span class="mi">8</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">23</span> <span class="o">-</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">21</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">20</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">19</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">18</span> <span class="o">-</span> <span class="mi">10</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">17</span> <span class="o">-</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">16</span> <span class="o">+</span> <span class="mi">12</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">15</span> <span class="o">+</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">14</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">13</span> <span class="o">-</span> <span class="mi">12</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">12</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">11</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">9</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">7</span> <span class="o">-</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">12</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">6</span>
<span class="gp">sage: </span><span class="n">cc</span> <span class="o">=</span> <span class="n">real_roots</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;algebraic_real&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="n">RealField</span><span class="p">(</span><span class="mi">180</span><span class="p">)(</span><span class="n">cc</span><span class="p">)</span>                                <span class="c1"># long time</span>
<span class="go">1.3035772690342963912570991121525518907307025046594049</span>
</pre></div>
</div>
<p>Now we play with algebraic real coefficients.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">AA</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">AA</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">[((499/525, 2171/1925), 1), ((1173/875, 2521/1575), 1), ((337/175, 849/175), 1)]</span>
<span class="gp">sage: </span><span class="n">ar_rts</span> <span class="o">=</span> <span class="n">real_roots</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;algebraic_real&#39;</span><span class="p">);</span> <span class="n">ar_rts</span>
<span class="go">[(1.000000000000000?, 1), (1.414213562373095?, 1), (2.000000000000000?, 1)]</span>
<span class="gp">sage: </span><span class="n">ar_rts</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">ar_rts</span> <span class="o">=</span> <span class="n">real_roots</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;algebraic_real&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ar_rts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">p2</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">100</span><span class="p">);</span> <span class="n">p2</span>
<span class="go">x^6 - 8.82842712474619?*x^5 + 31.97056274847714?*x^4 - 60.77955262170047?*x^3 + 63.98526763257801?*x^2 - 35.37613490585595?*x + 8.028284271247462?</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;interval&#39;</span><span class="p">)</span>
<span class="go">[(1.00?, 1), (1.1?, 1), (1.38?, 1), (1.5?, 1), (2.00?, 1), (2.1?, 1)]</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">AA</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">3</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">AA</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">real_roots</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="s1">&#39;interval&#39;</span><span class="p">)</span>
<span class="go">[(1.000000000000000?, 1), (1.414213562373095?, 2), (2.000000000000000?, 3)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.relative_bounds">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">relative_bounds</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.relative_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">(al,</span> <span class="pre">ah)</span></code> – pair of rationals</li>
<li><code class="docutils literal notranslate"><span class="pre">(bl,</span> <span class="pre">bh)</span></code> – pair of rationals</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">(cl,</span> <span class="pre">ch)</span></code> – pair of rationals</li>
</ul>
<p>Computes the linear transformation that maps (al, ah) to (0, 1);
then applies this transformation to (bl, bh) and returns the result.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">relative_bounds</span><span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">))</span>
<span class="go">(2/9, 8/15)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.reverse_intvec">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">reverse_intvec</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.reverse_intvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a vector of integers, reverse the vector (like the reverse()
method on lists).</p>
<p>Modifies the input vector; has no return value.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span> <span class="n">v</span>
<span class="go">(1, 2, 3, 4)</span>
<span class="gp">sage: </span><span class="n">reverse_intvec</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span>
<span class="go">(4, 3, 2, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.root_bounds">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">root_bounds</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.root_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a polynomial with real coefficients, computes a lower and
upper bound on its real roots.  Uses algorithms of
Akritas, Strzebo’nski, and Vigklas.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">root_bounds</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="go">(0.545454545454545, 6.00000000000001)</span>
<span class="gp">sage: </span><span class="n">root_bounds</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(0.000000000000000, 0.000000000000000)</span>
<span class="gp">sage: </span><span class="n">root_bounds</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="go">(-1.00000000000000, 0.000000000000000)</span>
<span class="gp">sage: </span><span class="n">root_bounds</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
<span class="go">(-2.44948974278317, 3.46410161513776)</span>
<span class="gp">sage: </span><span class="n">root_bounds</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">995</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">9999</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(-99.9949998749937, 141.414284992713)</span>
<span class="gp">sage: </span><span class="n">root_bounds</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">995</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">9999</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(-141.414284992712, 99.9949998749938)</span>
</pre></div>
</div>
<p>If we can see that the polynomial has no real roots, return None.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">root_bounds</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.rings.polynomial.real_roots.rr_gap">
<em class="property">class </em><code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">rr_gap</code><a class="headerlink" href="#sage.rings.polynomial.real_roots.rr_gap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A simple class representing the gaps between islands, in my
ocean-island root isolation algorithm.  Named “rr_gap” for
“real roots gap”, because “gap” seemed too short and generic.</p>
<dl class="method">
<dt id="sage.rings.polynomial.real_roots.rr_gap.region">
<code class="descname">region</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.rr_gap.region" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.scale_intvec_var">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">scale_intvec_var</code><span class="sig-paren">(</span><em>c</em>, <em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.scale_intvec_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a vector of integers c of length n+1, and a rational
k == kn / kd, multiplies each element c[i] by (kd^i)*(kn^(n-i)).</p>
<p>Modifies the input vector; has no return value.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">scale_intvec_var</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span>
<span class="go">(64, 48, 36, 27)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.split_for_targets">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">split_for_targets</code><span class="sig-paren">(</span><em>ctx</em>, <em>bp</em>, <em>target_list</em>, <em>precise=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.split_for_targets" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an interval Bernstein polynomial over a particular region
(assumed to be a (not necessarily proper) subregion of [0 .. 1]),
and a list of targets, uses de Casteljau’s method to compute
representations of the Bernstein polynomial over each target.
Uses degree reduction as often as possible while maintaining the
requested precision.</p>
<p>Each target is of the form (lgap, ugap, b).  Suppose lgap.region()
is (l1, l2), and ugap.region() is (u1, u2).  Then we will compute
an interval Bernstein polynomial over a region [l .. u], where
l1 &lt;= l &lt;= l2 and u1 &lt;= u &lt;= u2.  (split_for_targets() is free to
select arbitrary region endpoints within these bounds; it picks
endpoints which make the computation easier.)  The third component
of the target, b, is the maximum allowed scale_log2 of the result;
this is used to decide when degree reduction is allowed.</p>
<p>The pair (l1, l2) can be replaced by None, meaning [-infinity .. 0];
or, (u1, u2) can be replaced by None, meaning [1 .. infinity].</p>
<p>There is another constraint on the region endpoints selected by
split_for_targets() for a target ((l1, l2), (u1, u2), b).
We set a size goal g, such that (u - l) &lt;= g * (u1 - l2).
Normally g is 256/255, but if precise is True, then g is 65536/65535.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">bp</span> <span class="o">=</span> <span class="n">mk_ibpi</span><span class="p">([</span><span class="mi">1000000</span><span class="p">,</span> <span class="o">-</span><span class="mi">2000000</span><span class="p">,</span> <span class="mi">3000000</span><span class="p">,</span> <span class="o">-</span><span class="mi">4000000</span><span class="p">,</span> <span class="o">-</span><span class="mi">5000000</span><span class="p">,</span> <span class="o">-</span><span class="mi">6000000</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">mk_context</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bps</span> <span class="o">=</span> <span class="n">split_for_targets</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="p">[(</span><span class="n">rr_gap</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1234567893</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1234567892</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">rr_gap</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1234567891</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1234567890</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">12</span><span class="p">),</span> <span class="p">(</span><span class="n">rr_gap</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">rr_gap</span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">bps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&lt;IBP: (999992, 999992, 999992) + [0 .. 15) over [8613397477114467984778830327/10633823966279326983230456482242756608 .. 591908168025934394813836527495938294787/730750818665451459101842416358141509827966271488]; level 2; slope_err 0.?e12&gt;</span>
<span class="gp">sage: </span><span class="n">bps</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&lt;IBP: (-1562500, -1875001, -2222223, -2592593, -2969137, -3337450) + [0 .. 4) over [1/2 .. 2863311531/4294967296]&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.subsample_vec_doctest">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">subsample_vec_doctest</code><span class="sig-paren">(</span><em>a</em>, <em>slen</em>, <em>llen</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.subsample_vec_doctest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.taylor_shift1_intvec">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">taylor_shift1_intvec</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.taylor_shift1_intvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a vector of integers c of length d+1, representing the
coefficients of a degree-d polynomial p, modify the vector
to perform a Taylor shift by 1 (that is, p becomes p(x+1)).</p>
<p>This is the straightforward algorithm, which is not asymptotically
optimal.</p>
<p>Modifies the input vector; has no return value.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span> <span class="n">v</span>
<span class="go">(x^3 - 6*x^2 + 11*x - 6, (-6, 11, -6, 1))</span>
<span class="gp">sage: </span><span class="n">taylor_shift1_intvec</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">v</span>
<span class="go">(x^3 - 3*x^2 + 2*x, (0, 2, -3, 1))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.to_bernstein">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">to_bernstein</code><span class="sig-paren">(</span><em>p</em>, <em>low=0</em>, <em>high=1</em>, <em>degree=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.to_bernstein" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a polynomial p with integer coefficients, and rational
bounds low and high, compute the exact rational Bernstein
coefficients of p over the region [low .. high].  The optional
parameter degree can be used to give a formal degree higher than
the actual degree.</p>
<p>The return value is a pair (c, scale); c represents the same
polynomial as p*scale.  (If you only care about the roots of
the polynomial, then of course scale can be ignored.)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">to_bernstein</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">([0, 1], 1)</span>
<span class="gp">sage: </span><span class="n">to_bernstein</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">([0, 1/5, 2/5, 3/5, 4/5, 1], 1)</span>
<span class="gp">sage: </span><span class="n">to_bernstein</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">low</span><span class="o">=-</span><span class="mi">3</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">([-16, 24, -32, 32], 1)</span>
<span class="gp">sage: </span><span class="n">to_bernstein</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="p">)</span>
<span class="go">([296352, 310464, 325206, 340605], 9261)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.to_bernstein_warp">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">to_bernstein_warp</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.to_bernstein_warp" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a polynomial p with rational coefficients, compute the
exact rational Bernstein coefficients of p(x/(x+1)).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">to_bernstein_warp</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">5</span><span class="p">)</span>
<span class="go">[1, 1/5, 1/10, 1/10, 1/5, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.rings.polynomial.real_roots.warp_map">
<em class="property">class </em><code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">warp_map</code><span class="sig-paren">(</span><em>neg</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.warp_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class to map between original coordinates and ocean coordinates.
If neg is False, then the original-&gt;ocean transform is
x -&gt; x/(x+1), and the ocean-&gt;original transform is x/(1-x);
this maps between [0 .. infinity] and [0 .. 1].
If neg is True, then the original-&gt;ocean transform is
x -&gt; -x/(1-x), and the ocean-&gt;original transform is the same thing:
-x/(1-x).  This maps between [0 .. -infinity] and [0 .. 1].</p>
<dl class="method">
<dt id="sage.rings.polynomial.real_roots.warp_map.from_ocean">
<code class="descname">from_ocean</code><span class="sig-paren">(</span><em>region</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.warp_map.from_ocean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.rings.polynomial.real_roots.warp_map.to_ocean">
<code class="descname">to_ocean</code><span class="sig-paren">(</span><em>region</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.warp_map.to_ocean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.rings.polynomial.real_roots.wordsize_rational">
<code class="descclassname">sage.rings.polynomial.real_roots.</code><code class="descname">wordsize_rational</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>wordsize</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.rings.polynomial.real_roots.wordsize_rational" title="Permalink to this definition">¶</a></dt>
<dd><p>Given rationals a and b, selects a de Casteljau split point r between
a and b.  An attempt is made to select an efficient split point
(according to the criteria mentioned in the documentation
for de_casteljau_intvec), with a bias towards split points near a.</p>
<p>In full detail:</p>
<p>Takes as input two rationals, a and b, such that 0&lt;=a&lt;=1, 0&lt;=b&lt;=1,
and a!=b.  Returns rational r, such that a&lt;=r&lt;=b or b&lt;=r&lt;=a.
The denominator of r is a power of 2.  Let m be min(r, 1-r),
nm be numerator(m), and dml be log2(denominator(m)).  The return value
r is taken from the first of the following classes to have any
members between a and b (except that if a &lt;= 1/8, or 7/8 &lt;= a, then
class 2 is preferred to class 1).</p>
<ol class="arabic simple">
<li>dml &lt; wordsize</li>
<li>bitsize(nm) &lt;= wordsize</li>
<li>bitsize(nm) &lt;= 2*wordsize</li>
<li>bitsize(nm) &lt;= 3*wordsize</li>
</ol>
<p>…</p>
<ol class="loweralpha simple" start="11">
<li>bitsize(nm) &lt;= (k-1)*wordsize</li>
</ol>
<p>From the first class to have members between a and b, r is chosen
as the element of the class which is closest to a.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.polynomial.real_roots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">sage: </span><span class="n">wordsize_rational</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="go">429496729/2147483648</span>
<span class="gp">sage: </span><span class="n">wordsize_rational</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="go">306783379/2147483648</span>
<span class="gp">sage: </span><span class="n">wordsize_rational</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="go">1844674407370955161/9223372036854775808</span>
<span class="gp">sage: </span><span class="n">wordsize_rational</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="go">658812288346769701/4611686018427387904</span>
<span class="gp">sage: </span><span class="n">wordsize_rational</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">17</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">19</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="go">252645135/4294967296</span>
<span class="gp">sage: </span><span class="n">wordsize_rational</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">17</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">19</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="go">1085102592571150095/18446744073709551616</span>
<span class="gp">sage: </span><span class="n">wordsize_rational</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1234567890</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1234567891</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="go">933866427/1152921504606846976</span>
<span class="gp">sage: </span><span class="n">wordsize_rational</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1234567890</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1234567891</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="go">4010925763784056541/4951760157141521099596496896</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="polynomial_zz_pex.html"
                        title="previous chapter">Univariate Polynomials over GF(p^e) via NTL’s ZZ_pEX.</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="complex_roots.html"
                        title="next chapter">Isolate Complex Roots of Polynomials</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/sage/rings/polynomial/real_roots.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="complex_roots.html" title="Isolate Complex Roots of Polynomials"
             >next</a> |</li>
        <li class="right" >
          <a href="polynomial_zz_pex.html" title="Univariate Polynomials over GF(p^e) via NTL’s ZZ_pEX."
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Polynomials</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../../polynomial_rings_univar.html" >Univariate Polynomials and Polynomial Rings</a> &#187;</li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2020, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>