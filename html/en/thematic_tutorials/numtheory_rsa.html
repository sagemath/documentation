<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Number Theory and the RSA Public Key Cryptosystem &mdash; Thematic Tutorials v7.1</title>
    
    <link rel="stylesheet" href="_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="Thematic Tutorials v7.1" href="index.html" />
    <link rel="up" title="Thematic tutorial document tree" href="toctree.html" />
    <link rel="next" title="Coding Theory in Sage" href="coding_theory.html" />
    <link rel="prev" title="Linear Programming (Mixed Integer)" href="linear_programming.html" />
    <link rel="icon" href="_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="coding_theory.html" title="Coding Theory in Sage"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="linear_programming.html" title="Linear Programming (Mixed Integer)"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../index.html"><img src="_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="index.html">Thematic Tutorials v7.1</a> &raquo;</li>

          <li><a href="toctree.html" accesskey="U">Thematic tutorial document tree</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="number-theory-and-the-rsa-public-key-cryptosystem">
<span id="numtheory-rsa"></span><h1>Number Theory and the RSA Public Key Cryptosystem<a class="headerlink" href="#number-theory-and-the-rsa-public-key-cryptosystem" title="Permalink to this headline">¶</a></h1>
<p><em>Author: Minh Van Nguyen &lt;<a class="reference external" href="mailto:nguyenminh2&#37;&#52;&#48;gmail&#46;com">nguyenminh2<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</em></p>
<p>This tutorial uses Sage to study elementary number theory and the RSA
public key cryptosystem.  A number of Sage commands will be presented
that help us to perform basic number theoretic operations such as
greatest common divisor and Euler&#8217;s phi function.  We then present the
RSA cryptosystem and use Sage&#8217;s built-in commands to encrypt and
decrypt data via the RSA algorithm.  Note that this tutorial on RSA is
for pedagogy purposes only.  For further details on cryptography or
the security of various cryptosystems, consult specialized texts such
as
<a class="reference internal" href="#menezesetal1996" id="id1">[MenezesEtAl1996]</a>,
<a class="reference internal" href="#stinson2006" id="id2">[Stinson2006]</a>, and
<a class="reference internal" href="#trappewashington2006" id="id3">[TrappeWashington2006]</a>.</p>
<div class="section" id="elementary-number-theory">
<h2>Elementary number theory<a class="headerlink" href="#elementary-number-theory" title="Permalink to this headline">¶</a></h2>
<p>We first review basic concepts from elementary number theory,
including the notion of primes, greatest common divisors, congruences
and Euler&#8217;s phi function.  The number theoretic concepts and Sage
commands introduced will be referred to in later sections when we
present the RSA algorithm.</p>
<div class="section" id="prime-numbers">
<h3>Prime numbers<a class="headerlink" href="#prime-numbers" title="Permalink to this headline">¶</a></h3>
<p>Public key cryptography uses many fundamental concepts from number
theory, such as prime numbers and greatest common divisors.  A
positive integer <span class="math">\(n &gt; 1\)</span> is said to be <em>prime</em> if its factors are
exclusively 1 and itself.  In Sage, we can obtain the first 20 prime
numbers using the command <tt class="docutils literal"><span class="pre">primes_first_n</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">primes_first_n</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]</span>
</pre></div>
</div>
</div>
<div class="section" id="greatest-common-divisors">
<h3>Greatest common divisors<a class="headerlink" href="#greatest-common-divisors" title="Permalink to this headline">¶</a></h3>
<p>Let <span class="math">\(a\)</span> and <span class="math">\(b\)</span> be integers, not both zero. Then the greatest common
divisor (GCD) of <span class="math">\(a\)</span> and <span class="math">\(b\)</span> is the largest positive integer which is
a factor of both <span class="math">\(a\)</span> and <span class="math">\(b\)</span>. We use <span class="math">\(\gcd(a,b)\)</span> to denote this
largest positive factor. One can extend this definition by setting
<span class="math">\(\gcd(0,0) = 0\)</span>. Sage uses <tt class="docutils literal"><span class="pre">gcd(a,</span> <span class="pre">b)</span></tt> to denote the GCD of <span class="math">\(a\)</span>
and <span class="math">\(b\)</span>. The GCD of any two distinct primes is 1, and the GCD of 18
and 27 is 9.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">gcd</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">59</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">gcd</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="mi">27</span><span class="p">)</span>
<span class="go">9</span>
</pre></div>
</div>
<p>If <span class="math">\(\gcd(a,b) = 1\)</span>, we say that <span class="math">\(a\)</span> is <em>coprime</em> (or relatively
prime) to <span class="math">\(b\)</span>.  In particular, <span class="math">\(\gcd(3, 59) = 1\)</span> so 3 is coprime to 59
and vice versa.</p>
</div>
<div class="section" id="congruences">
<h3>Congruences<a class="headerlink" href="#congruences" title="Permalink to this headline">¶</a></h3>
<p>When one integer is divided by a non-zero integer, we usually get a
remainder.  For example, upon dividing 23 by 5, we get a remainder of
3; when 8 is divided by 5, the remainder is again 3.  The notion of
congruence helps us to describe the situation in which two integers
have the same remainder upon division by a non-zero integer.  Let
<span class="math">\(a,b,n \in \ZZ\)</span> such that <span class="math">\(n \neq 0\)</span>.  If <span class="math">\(a\)</span> and <span class="math">\(b\)</span> have the
same remainder upon division by <span class="math">\(n\)</span>, then we say that <span class="math">\(a\)</span> is
<em>congruent</em> to <span class="math">\(b\)</span> modulo <span class="math">\(n\)</span> and denote this relationship by</p>
<div class="math">
\[a \equiv b \pmod{n}\]</div>
<p>This definition is equivalent to saying that <span class="math">\(n\)</span> divides the
difference of <span class="math">\(a\)</span> and <span class="math">\(b\)</span>, i.e. <span class="math">\(n \;|\; (a - b)\)</span>.  Thus
<span class="math">\(23 \equiv 8 \pmod{5}\)</span> because when both 23 and 8 are divided by 5, we
end up with a remainder of 3.  The command <tt class="docutils literal"><span class="pre">mod</span></tt> allows us to
compute such a remainder:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">mod</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">mod</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</div>
<div class="section" id="euler-s-phi-function">
<h3>Euler&#8217;s phi function<a class="headerlink" href="#euler-s-phi-function" title="Permalink to this headline">¶</a></h3>
<p>Consider all the integers from 1 to 20, inclusive.  List all those
integers that are coprime to 20.  In other words, we want to find
those integers <span class="math">\(n\)</span>, where <span class="math">\(1 \leq n \leq 20\)</span>, such that
<span class="math">\(\gcd(n,20) = 1\)</span>.  The latter task can be easily accomplished with a
little bit of Sage programming:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">21</span><span class="p">):</span>
<span class="go">....:     if gcd(n, 20) == 1:</span>
<span class="go">....:         print n,</span>
<span class="gp">...</span>
<span class="go">1 3 7 9 11 13 17 19</span>
</pre></div>
</div>
<p>The above programming statements can be saved to a text file called,
say, <tt class="docutils literal"><span class="pre">/home/mvngu/totient.sage</span></tt>, organizing it as follows to enhance
readability.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">21</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">gcd</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">n</span><span class="p">,</span>
</pre></div>
</div>
<p>We refer to <tt class="docutils literal"><span class="pre">totient.sage</span></tt> as a Sage script, just as one would refer
to a file containing Python code as a Python script.  We use 4 space
indentations, which is a coding convention in Sage as well as Python
programming, instead of tabs.</p>
<p>The command <tt class="docutils literal"><span class="pre">load</span></tt> can be used to read the file containing our
programming statements into Sage and, upon loading the content of the
file, have Sage execute those statements:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>load(&quot;/home/mvngu/totient.sage&quot;)
1 3 7 9 11 13 17 19
</pre></div>
</div>
<p>From the latter list, there are 8 integers in the closed interval
<span class="math">\([1, 20]\)</span> that are coprime to 20.  Without explicitly generating the
list</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>1  3  7  9  11  13  17  19
</pre></div>
</div>
<p>how can we compute the number of integers in <span class="math">\([1, 20]\)</span> that are
coprime to 20?  This is where Euler&#8217;s phi function comes in handy.
Let <span class="math">\(n \in \ZZ\)</span> be positive.  Then <em>Euler&#8217;s phi function</em> counts the
number of integers <span class="math">\(a\)</span>, with <span class="math">\(1 \leq a \leq n\)</span>, such that
<span class="math">\(\gcd(a,n) = 1\)</span>.  This number is denoted by <span class="math">\(\varphi(n)\)</span>.  Euler&#8217;s phi
function is sometimes referred to as Euler&#8217;s totient function, hence
the name <tt class="docutils literal"><span class="pre">totient.sage</span></tt> for the above Sage script.  The command
<tt class="docutils literal"><span class="pre">euler_phi</span></tt> implements Euler&#8217;s phi function.  To compute
<span class="math">\(\varphi(20)\)</span> without explicitly generating the above list, we proceed
as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">euler_phi</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">8</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="how-to-keep-a-secret">
<h2>How to keep a secret?<a class="headerlink" href="#how-to-keep-a-secret" title="Permalink to this headline">¶</a></h2>
<p><em>Cryptography</em> is the science (some might say art) of concealing
data.  Imagine that we are composing a confidential email to
someone.  Having written the email, we can send it in one of two ways.
The first, and usually convenient, way is to simply press the send
button and not care about how our email will be delivered.  Sending an
email in this manner is similar to writing our confidential message on
a postcard and post it without enclosing our postcard inside an
envelope.  Anyone who can access our postcard can see our message.
On the other hand, before sending our email, we can scramble the
confidential message and then press the send button.  Scrambling our
message is similar to enclosing our postcard inside an envelope.
While not 100% secure, at least we know that anyone wanting to read
our postcard has to open the envelope.</p>
<p>In cryptography parlance, our message is called <em>plaintext</em>.  The
process of scrambling our message is referred to as <em>encryption</em>.
After encrypting our message, the scrambled version is called
<em>ciphertext</em>.  From the ciphertext, we can recover our original
unscrambled message via <em>decryption</em>. The following figure
illustrates the processes of encryption and decryption.  A
<em>cryptosystem</em> is comprised of a pair of related encryption and
decryption processes.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>+ ---------+   encrypt    +------------+   decrypt    +-----------+
| plaintext| -----------&gt; | ciphertext | -----------&gt; | plaintext |
+----------+              +------------+              +-----------+
</pre></div>
</div>
<p>The following table provides a very simple method of scrambling a
message written in English and using only upper case letters,
excluding punctuation characters.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>+----------------------------------------------------+
| A   B   C   D   E   F   G   H   I   J   K   L   M  |
| 65  66  67  68  69  70  71  72  73  74  75  76  77 |
+----------------------------------------------------+
| N   O   P   Q   R   S   T   U   V   W   X   Y   Z  |
| 78  79  80  81  82  83  84  85  86  87  88  89  90 |
+----------------------------------------------------+
</pre></div>
</div>
<p>Formally, let</p>
<div class="math">
\[\Sigma
=
\{ \mathtt{A}, \mathtt{B}, \mathtt{C}, \dots, \mathtt{Z} \}\]</div>
<p>be the set of capital letters of the English alphabet. Furthermore,
let</p>
<div class="math">
\[\Phi
=
\{ 65, 66, 67, \dots, 90 \}\]</div>
<p>be the American Standard Code for Information Interchange (ASCII)
encodings of the upper case English letters.  Then the above table
explicitly describes the mapping <span class="math">\(f: \Sigma \longrightarrow \Phi\)</span>.
(For those familiar with ASCII, <span class="math">\(f\)</span> is actually a common process for
<em>encoding</em> elements of <span class="math">\(\Sigma\)</span>, rather than a cryptographic
&#8220;scrambling&#8221; process <em>per se</em>.)  To scramble a message written using
the alphabet <span class="math">\(\Sigma\)</span>, we simply replace each capital letter of the
message with its corresponding ASCII encoding.  However, the
scrambling process described in the above table provides,
cryptographically speaking, very little to no security at all and we
strongly discourage its use in practice.</p>
</div>
<div class="section" id="keeping-a-secret-with-two-keys">
<h2>Keeping a secret with two keys<a class="headerlink" href="#keeping-a-secret-with-two-keys" title="Permalink to this headline">¶</a></h2>
<p>The Rivest, Shamir, Adleman (RSA) cryptosystem is an example of a
<em>public key cryptosystem</em>.  RSA uses a <em>public key</em> to
encrypt messages and decryption is performed using a corresponding
<em>private key</em>.  We can distribute our public keys, but for
security reasons we should keep our private keys to ourselves.  The
encryption and decryption processes draw upon techniques from
elementary number theory.  The algorithm below is adapted from page
165 of <a class="reference internal" href="#trappewashington2006" id="id4">[TrappeWashington2006]</a>. It outlines the RSA procedure for
encryption and decryption.</p>
<ol class="arabic simple">
<li>Choose two primes <span class="math">\(p\)</span> and <span class="math">\(q\)</span> and let <span class="math">\(n = pq\)</span>.</li>
<li>Let <span class="math">\(e \in \ZZ\)</span> be positive such that
<span class="math">\(\gcd \big( e, \varphi(n) \big) = 1\)</span>.</li>
<li>Compute a value for <span class="math">\(d \in \ZZ\)</span> such that
<span class="math">\(de \equiv 1 \pmod{\varphi(n)}\)</span>.</li>
<li>Our public key is the pair <span class="math">\((n, e)\)</span> and our private key is the
triple <span class="math">\((p,q,d)\)</span>.</li>
<li>For any non-zero integer <span class="math">\(m &lt; n\)</span>, encrypt <span class="math">\(m\)</span> using
<span class="math">\(c \equiv m^e \pmod{n}\)</span>.</li>
<li>Decrypt <span class="math">\(c\)</span> using <span class="math">\(m \equiv c^d \pmod{n}\)</span>.</li>
</ol>
<p>The next two sections will step through the RSA algorithm, using
Sage to generate public and private keys, and perform encryption
and decryption based on those keys.</p>
</div>
<div class="section" id="generating-public-and-private-keys">
<h2>Generating public and private keys<a class="headerlink" href="#generating-public-and-private-keys" title="Permalink to this headline">¶</a></h2>
<p>Positive integers of the form <span class="math">\(M_m = 2^m - 1\)</span> are called
<em>Mersenne numbers</em>.  If <span class="math">\(p\)</span> is prime and <span class="math">\(M_p = 2^p - 1\)</span> is also
prime, then <span class="math">\(M_p\)</span> is called a <em>Mersenne prime</em>.  For example, 31
is prime and <span class="math">\(M_{31} = 2^{31} - 1\)</span> is a Mersenne prime, as can be
verified using the command <tt class="docutils literal"><span class="pre">is_prime(p)</span></tt>.  This command returns
<tt class="docutils literal"><span class="pre">True</span></tt> if its argument <tt class="docutils literal"><span class="pre">p</span></tt> is precisely a prime number;
otherwise it returns <tt class="docutils literal"><span class="pre">False</span></tt>.  By definition, a prime must be a
positive integer, hence <tt class="docutils literal"><span class="pre">is_prime(-2)</span></tt> returns <tt class="docutils literal"><span class="pre">False</span></tt>
although we know that 2 is prime.  Indeed, the number
<span class="math">\(M_{61} = 2^{61} - 1\)</span> is also a Mersenne prime.  We can use
<span class="math">\(M_{31}\)</span> and <span class="math">\(M_{61}\)</span> to work through step 1 in the RSA algorithm:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">31</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">is_prime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">61</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">is_prime</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">q</span> <span class="p">;</span> <span class="n">n</span>
<span class="go">4951760154835678088235319297</span>
</pre></div>
</div>
<p>A word of warning is in order here.  In the above code example, the
choice of <span class="math">\(p\)</span> and <span class="math">\(q\)</span> as Mersenne primes, and with so many digits far
apart from each other, is a very bad choice in terms of cryptographic
security.  However, we shall use the above chosen numeric values for
<span class="math">\(p\)</span> and <span class="math">\(q\)</span> for the remainder of this tutorial, always bearing in mind
that they have been chosen for pedagogy purposes only.  Refer to
<a class="reference internal" href="#menezesetal1996" id="id5">[MenezesEtAl1996]</a>,
<a class="reference internal" href="#stinson2006" id="id6">[Stinson2006]</a>, and
<a class="reference internal" href="#trappewashington2006" id="id7">[TrappeWashington2006]</a>
for in-depth discussions on the security of RSA, or consult other
specialized texts.</p>
<p>For step 2, we need to find a positive integer that is coprime to
<span class="math">\(\varphi(n)\)</span>.  The set of integers is implemented within the Sage
module <tt class="docutils literal"><span class="pre">sage.rings.integer_ring</span></tt>.  Various operations on
integers can be accessed via the <tt class="docutils literal"><span class="pre">ZZ.*</span></tt> family of functions.
For instance, the command <tt class="docutils literal"><span class="pre">ZZ.random_element(n)</span></tt> returns a
pseudo-random integer uniformly distributed within the closed interval
<span class="math">\([0, n-1]\)</span>.</p>
<p>We can compute the value <span class="math">\(\varphi(n)\)</span> by calling the sage function
<tt class="docutils literal"><span class="pre">euler_phi(n)</span></tt>, but for arbitrarily large prime numbers <span class="math">\(p\)</span> and <span class="math">\(q\)</span>,
this can take an enormous amount of time. Indeed, the private key
can be quickly deduced from the public key once you know <span class="math">\(\varphi(n)\)</span>,
so it is an important part of the security of the RSA cryptosystem that
<span class="math">\(\varphi(n)\)</span> cannot be computed in a short time, if only <span class="math">\(n\)</span> is known.
On the other hand, if the private key is available, we can compute
<span class="math">\(\varphi(n)=(p-1)(q-1)\)</span> in a very short time.</p>
<p>Using a simple programming loop, we can compute the
required value of <span class="math">\(e\)</span> as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">31</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">61</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">q</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">phi</span>
<span class="go">4951760152529835076874141700</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">random_element</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">while</span> <span class="n">gcd</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
<span class="go">....:     e = ZZ.random_element(phi)</span>
<span class="gp">...</span>
<span class="gp">sage: </span><span class="n">e</span>  <span class="c1"># random</span>
<span class="go">1850567623300615966303954877</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">&lt;</span> <span class="n">n</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As <tt class="docutils literal"><span class="pre">e</span></tt> is a pseudo-random integer, its numeric value changes
after each execution of <tt class="docutils literal"><span class="pre">e</span> <span class="pre">=</span> <span class="pre">ZZ.random_element(phi)</span></tt>.</p>
<p>To calculate a value for <tt class="docutils literal"><span class="pre">d</span></tt> in step 3 of the RSA algorithm, we use
the extended Euclidean algorithm.  By definition of congruence,
<span class="math">\(de \equiv 1 \pmod{\varphi(n)}\)</span> is equivalent to</p>
<div class="math">
\[de - k \cdot \varphi(n) = 1\]</div>
<p>where <span class="math">\(k \in \ZZ\)</span>.  From steps 1 and 2, we already know the numeric
values of <span class="math">\(e\)</span> and <span class="math">\(\varphi(n)\)</span>.  The extended Euclidean algorithm
allows us to compute <span class="math">\(d\)</span> and <span class="math">\(-k\)</span>.  In Sage, this can be accomplished
via the command <tt class="docutils literal"><span class="pre">xgcd</span></tt>.  Given two integers <span class="math">\(x\)</span> and <span class="math">\(y\)</span>,
<tt class="docutils literal"><span class="pre">xgcd(x,</span> <span class="pre">y)</span></tt> returns a 3-tuple <tt class="docutils literal"><span class="pre">(g,</span> <span class="pre">s,</span> <span class="pre">t)</span></tt> that satisfies
the Bézout identity <span class="math">\(g = \gcd(x,y) = sx + ty\)</span>.  Having computed a
value for <tt class="docutils literal"><span class="pre">d</span></tt>, we then use the command
<tt class="docutils literal"><span class="pre">mod(d*e,</span> <span class="pre">phi)</span></tt> to check that <tt class="docutils literal"><span class="pre">d*e</span></tt> is indeed congruent
to 1 modulo <tt class="docutils literal"><span class="pre">phi</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="mi">4951760154835678088235319297</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="mi">1850567623300615966303954877</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="mi">4951760152529835076874141700</span>
<span class="gp">sage: </span><span class="n">bezout</span> <span class="o">=</span> <span class="n">xgcd</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">phi</span><span class="p">);</span> <span class="n">bezout</span>  <span class="c1"># random</span>
<span class="go">(1, 4460824882019967172592779313, -1667095708515377925087033035)</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="n">mod</span><span class="p">(</span><span class="n">bezout</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">phi</span><span class="p">))</span> <span class="p">;</span> <span class="n">d</span>  <span class="c1"># random</span>
<span class="go">4460824882019967172592779313</span>
<span class="gp">sage: </span><span class="n">mod</span><span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="n">e</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Thus, our RSA public key is</p>
<div class="math">
\[(n, e)
=
(4951760154835678088235319297,\, 1850567623300615966303954877)\]</div>
<p>and our corresponding private key is</p>
<div class="math">
\[(p, q, d)
=
(2147483647,\, 2305843009213693951,\, 4460824882019967172592779313)\]</div>
</div>
<div class="section" id="encryption-and-decryption">
<h2>Encryption and decryption<a class="headerlink" href="#encryption-and-decryption" title="Permalink to this headline">¶</a></h2>
<p>Suppose we want to scramble the message <tt class="docutils literal"><span class="pre">HELLOWORLD</span></tt> using RSA
encryption.  From the above ASCII table, our message maps to integers
of the ASCII encodings as given below.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>+----------------------------------------+
| H   E   L   L   O   W   O   R   L   D  |
| 72  69  76  76  79  87  79  82  76  68 |
+----------------------------------------+
</pre></div>
</div>
<p>Concatenating all the integers in the last table, our message can be
represented by the integer</p>
<div class="math">
\[m = 72697676798779827668\]</div>
<p>There are other more cryptographically secure means for representing
our message as an integer.  The above process is used for
demonstration purposes only and we strongly discourage its use in
practice. In Sage, we can obtain an integer representation of our
message as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="s2">&quot;HELLOWORLD&quot;</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">ord</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span> <span class="n">m</span>
<span class="go">[72, 69, 76, 76, 79, 87, 79, 82, 76, 68]</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">m</span><span class="p">)),</span> <span class="mi">100</span><span class="p">)</span> <span class="p">;</span> <span class="n">m</span>
<span class="go">72697676798779827668</span>
</pre></div>
</div>
<p>To encrypt our message, we raise <span class="math">\(m\)</span> to the power of <span class="math">\(e\)</span> and reduce
the result modulo <span class="math">\(n\)</span>.  The command <tt class="docutils literal"><span class="pre">mod(a^b,</span> <span class="pre">n)</span></tt> first computes
<tt class="docutils literal"><span class="pre">a^b</span></tt> and then reduces the result modulo <tt class="docutils literal"><span class="pre">n</span></tt>.  If the exponent
<tt class="docutils literal"><span class="pre">b</span></tt> is a &#8220;large&#8221; integer, say with more than 20 digits, then
performing modular exponentiation in this naive manner takes quite
some time.  Brute force (or naive) modular exponentiation is
inefficient and, when performed using a computer, can quickly
consume a huge quantity of the computer&#8217;s memory or result in overflow
messages.  For instance, if we perform naive modular exponentiation
using the command <tt class="docutils literal"><span class="pre">mod(m^e,</span> <span class="pre">n)</span></tt>, where <tt class="docutils literal"><span class="pre">m</span></tt>, <tt class="docutils literal"><span class="pre">n</span></tt> and <tt class="docutils literal"><span class="pre">e</span></tt> are as
given above, we would get an error message similar to the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>mod(m^e, n)
Traceback (most recent call last)
/home/mvngu/&lt;ipython console&gt; in &lt;module&gt;()
/home/mvngu/usr/bin/sage-3.1.4/local/lib/python2.5/site-packages/sage/rings/integer.so
in sage.rings.integer.Integer.__pow__ (sage/rings/integer.c:9650)()
RuntimeError: exponent must be at most 2147483647
</pre></div>
</div>
<p>There is a trick to efficiently perform modular exponentiation, called
the method of repeated squaring, cf. page 879 of <a class="reference internal" href="#cormenetal2001" id="id8">[CormenEtAl2001]</a>.
Suppose we want to compute <span class="math">\(a^b \mod n\)</span>.  First, let
<span class="math">\(d \mathrel{\mathop:}= 1\)</span> and obtain the binary representation of <span class="math">\(b\)</span>,
say <span class="math">\((b_1, b_2, \dots, b_k)\)</span> where each <span class="math">\(b_i \in \ZZ/2\ZZ\)</span>.  For
<span class="math">\(i \mathrel{\mathop:}= 1, \dots, k\)</span>, let
<span class="math">\(d \mathrel{\mathop:}= d^2 \mod n\)</span> and if <span class="math">\(b_i = 1\)</span> then let
<span class="math">\(d \mathrel{\mathop:}= da \mod n\)</span>.  This algorithm is implemented in
the function <tt class="docutils literal"><span class="pre">power_mod</span></tt>. We now use the function <tt class="docutils literal"><span class="pre">power_mod</span></tt> to
encrypt our message:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="mi">72697676798779827668</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="mi">1850567623300615966303954877</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="mi">4951760154835678088235319297</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">power_mod</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="n">c</span>
<span class="go">630913632577520058415521090</span>
</pre></div>
</div>
<p>Thus <span class="math">\(c = 630913632577520058415521090\)</span> is the ciphertext.  To recover
our plaintext, we raise <tt class="docutils literal"><span class="pre">c</span></tt> to the power of <tt class="docutils literal"><span class="pre">d</span></tt> and reduce the
result modulo <tt class="docutils literal"><span class="pre">n</span></tt>.  Again, we use modular exponentiation via
repeated squaring in the decryption process:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="mi">72697676798779827668</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="mi">630913632577520058415521090</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="mi">4460824882019967172592779313</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="mi">4951760154835678088235319297</span>
<span class="gp">sage: </span><span class="n">power_mod</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="go">72697676798779827668</span>
<span class="gp">sage: </span><span class="n">power_mod</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Notice in the last output that the value 72697676798779827668 is the
same as the integer that represents our original message.  Hence we
have recovered our plaintext.</p>
</div>
<div class="section" id="acknowledgements">
<h2>Acknowledgements<a class="headerlink" href="#acknowledgements" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>2009-07-25: Ron Evans (Department of Mathematics, UCSD) reported
a typo in the definition of greatest common divisors. The revised
definition incorporates his suggestions.</li>
<li>2008-11-04: Martin Albrecht (Information Security Group, Royal
Holloway, University of London), John Cremona (Mathematics
Institute, University of Warwick) and William Stein (Department of
Mathematics, University of Washington) reviewed this tutorial. Many
of their invaluable suggestions have been incorporated into this
document.</li>
</ol>
</div>
<div class="section" id="bibliography">
<h2>Bibliography<a class="headerlink" href="#bibliography" title="Permalink to this headline">¶</a></h2>
<table class="docutils citation" frame="void" id="cormenetal2001" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[CormenEtAl2001]</a></td><td>T. H. Cormen, C. E. Leiserson, R. L. Rivest, and
C. Stein. <em>Introduction to Algorithms</em>. The MIT Press, USA, 2nd
edition, 2001.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="menezesetal1996" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[MenezesEtAl1996]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> A. J. Menezes, P. C. van Oorschot, and
S. A. Vanstone. <em>Handbook of Applied Cryptography</em>. CRC Press, Boca
Raton, FL, USA, 1996.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="stinson2006" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Stinson2006]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> D. R. Stinson. <em>Cryptography: Theory and Practice</em>.
Chapman &amp; Hall/CRC, Boca Raton, USA, 3rd edition, 2006.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="trappewashington2006" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[TrappeWashington2006]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id4">2</a>, <a class="fn-backref" href="#id7">3</a>)</em> W. Trappe and L. C. Washington. <em>Introduction
to Cryptography with Coding Theory</em>. Pearson Prentice Hall, Upper
Saddle River, New Jersey, USA, 2nd edition, 2006.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Number Theory and the RSA Public Key Cryptosystem</a><ul>
<li><a class="reference internal" href="#elementary-number-theory">Elementary number theory</a><ul>
<li><a class="reference internal" href="#prime-numbers">Prime numbers</a></li>
<li><a class="reference internal" href="#greatest-common-divisors">Greatest common divisors</a></li>
<li><a class="reference internal" href="#congruences">Congruences</a></li>
<li><a class="reference internal" href="#euler-s-phi-function">Euler&#8217;s phi function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-to-keep-a-secret">How to keep a secret?</a></li>
<li><a class="reference internal" href="#keeping-a-secret-with-two-keys">Keeping a secret with two keys</a></li>
<li><a class="reference internal" href="#generating-public-and-private-keys">Generating public and private keys</a></li>
<li><a class="reference internal" href="#encryption-and-decryption">Encryption and decryption</a></li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#bibliography">Bibliography</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="linear_programming.html"
                                  title="previous chapter">Linear Programming (Mixed Integer)</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="coding_theory.html"
                                  title="next chapter">Coding Theory in Sage</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/numtheory_rsa.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <!-- The shading of the "Go" button should be consistent -->
                <!-- with the colour of the header and footer. See the file -->
                <!-- doc/common/themes/sage/theme.conf for colours used by -->
                <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="coding_theory.html" title="Coding Theory in Sage"
             >next</a> |</li>
        <li class="right" >
          <a href="linear_programming.html" title="Linear Programming (Mixed Integer)"
             >previous</a> |</li>
  
    
      <a href="../index.html"><img src="_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="index.html">Thematic Tutorials v7.1</a> &raquo;</li>

          <li><a href="toctree.html" >Thematic tutorial document tree</a> &raquo;</li> 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2016, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>