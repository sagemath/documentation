<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>How to implement new algebraic structures in Sage &mdash; Thematic Tutorials v7.1</title>
    
    <link rel="stylesheet" href="_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="Thematic Tutorials v7.1" href="index.html" />
    <link rel="up" title="Thematic tutorial document tree" href="toctree.html" />
    <link rel="next" title="How to call a C code (or a compiled library) from Sage ?" href="cython_interface.html" />
    <link rel="prev" title="Functional Programming for Mathematicians" href="functional_programming.html" />
    <link rel="icon" href="_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="cython_interface.html" title="How to call a C code (or a compiled library) from Sage ?"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="functional_programming.html" title="Functional Programming for Mathematicians"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../index.html"><img src="_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="index.html">Thematic Tutorials v7.1</a> &raquo;</li>

          <li><a href="toctree.html" accesskey="U">Thematic tutorial document tree</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="how-to-implement-new-algebraic-structures-in-sage">
<span id="coercion-and-categories"></span><h1><a class="toc-backref" href="#id1">How to implement new algebraic structures in Sage</a><a class="headerlink" href="#how-to-implement-new-algebraic-structures-in-sage" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#how-to-implement-new-algebraic-structures-in-sage" id="id1">How to implement new algebraic structures in Sage</a><ul>
<li><a class="reference internal" href="#sage-s-category-and-coercion-framework" id="id2">Sage&#8217;s category and coercion framework</a><ul>
<li><a class="reference internal" href="#outline" id="id3">Outline</a></li>
<li><a class="reference internal" href="#base-classes" id="id4">Base classes</a></li>
<li><a class="reference internal" href="#categories-in-sage" id="id5">Categories in Sage</a></li>
<li><a class="reference internal" href="#coercion-the-basics" id="id6">Coercion&#8212;the basics</a></li>
<li><a class="reference internal" href="#coercion-the-advanced-parts" id="id7">Coercion&#8212;the advanced parts</a></li>
<li><a class="reference internal" href="#the-test-suites-of-the-category-framework" id="id8">The test suites of the category framework</a></li>
<li><a class="reference internal" href="#appendix-the-complete-code" id="id9">Appendix: The complete code</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="sage-s-category-and-coercion-framework">
<h2><a class="toc-backref" href="#id2">Sage&#8217;s category and coercion framework</a><a class="headerlink" href="#sage-s-category-and-coercion-framework" title="Permalink to this headline">¶</a></h2>
<p><em>Author: Simon King,
Friedrich&#8211;Schiller&#8211;Universität Jena,
&lt;<a class="reference external" href="mailto:simon&#46;king&#37;&#52;&#48;uni-jena&#46;de">simon<span>&#46;</span>king<span>&#64;</span>uni-jena<span>&#46;</span>de</a>&gt;
© 2011/2013</em></p>
<p>The aim of this tutorial is to explain how one can benefit from Sage&#8217;s
category framework and coercion model when implementing new algebraic
structures. It is based on a worksheet created in 2011.</p>
<p>We illustrate the concepts of Sage&#8217;s category framework and coercion model by
means of a detailed example, namely a toy implementation of fraction fields.
The code is developed step by step, so that the reader can focus on one detail
in each part of this tutorial. The complete code can be found in the appendix.</p>
<div class="section" id="outline">
<h3><a class="toc-backref" href="#id3">Outline</a><a class="headerlink" href="#outline" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Use existing base classes</p>
<p>For using Sage&#8217;s coercion system, it is essential to work with sub&#8211;classes
of <a class="reference external" href="../reference/structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage Reference Manual: Basic Structures v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.parent.Parent</span></tt></a> or
<a class="reference external" href="../reference/structure/sage/structure/element.html#sage.structure.element.Element" title="(in Sage Reference Manual: Basic Structures v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.element.Element</span></tt></a>, respectively. They provide default
implementations of many &#8220;magical&#8221; double-underscore Python methods, which
must not be overridden. Instead, the actual implementation should be in
<em>single underscore</em> methods, such as <tt class="docutils literal"><span class="pre">_add_</span></tt> or <tt class="docutils literal"><span class="pre">_mul_</span></tt>.</p>
</li>
<li><p class="first">Turn your parent structure into an object of a category</p>
<p>Declare the category during initialisation&#8212;Your parent structure will
inherit further useful methods and consistency tests.</p>
</li>
<li><p class="first">Provide your parent structure with an element class</p>
<p>Assign to it an attribute called <tt class="docutils literal"><span class="pre">Element</span></tt>&#8212;The elements will inherit
further useful methods from the category. In addition, some basic
conversions will immediately work.</p>
</li>
<li><p class="first">Implement further conversions</p>
<p>Never override a parent&#8217;s <tt class="docutils literal"><span class="pre">__call__</span></tt> method! Provide the method
<tt class="docutils literal"><span class="pre">_element_constructor_</span></tt> instead.</p>
</li>
<li><p class="first">Declare coercions</p>
<p>If a conversion happens to be a morphism, you may consider to turn it into a
coercion. It will then <em>implicitly</em> be used in arithmetic operations.</p>
</li>
<li><p class="first">Advanced coercion:  Define construction functors for your parent structure</p>
<p>Sage will automatically create new parents for you when needed, by the
so&#8211;called <a class="reference external" href="../reference/coercion/sage/categories/pushout.html#sage.categories.pushout.pushout" title="(in Sage Reference Manual: Coercion v7.1)"><tt class="xref py py-func docutils literal"><span class="pre">sage.categories.pushout.pushout()</span></tt></a> construction.</p>
</li>
<li><p class="first">Run the automatic test suites</p>
<p>Each method should be documented and provide a doc test (we are not giving
examples here). In addition, any method defined for the objects or elements
of a category should be supported by a test method, that is executed when
running the test suite.</p>
</li>
</ul>
</div>
<div class="section" id="base-classes">
<h3><a class="toc-backref" href="#id4">Base classes</a><a class="headerlink" href="#base-classes" title="Permalink to this headline">¶</a></h3>
<p>In Sage, a &#8220;Parent&#8221; is an object of a category and contains elements.  Parents
should inherit from <a class="reference external" href="../reference/structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage Reference Manual: Basic Structures v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.parent.Parent</span></tt></a> and their elements
from <a class="reference external" href="../reference/structure/sage/structure/element.html#sage.structure.element.Element" title="(in Sage Reference Manual: Basic Structures v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.element.Element</span></tt></a>.</p>
<p>Sage provides appropriate sub&#8211;classes of
<a class="reference external" href="../reference/structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage Reference Manual: Basic Structures v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">Parent</span></tt></a> and
<a class="reference external" href="../reference/structure/sage/structure/element.html#sage.structure.element.Element" title="(in Sage Reference Manual: Basic Structures v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">Element</span></tt></a> for a variety of more concrete
algebraic structures, such as groups, rings, or fields, and of their
elements. But some old stuff in Sage doesn&#8217;t use it.  <strong>Volunteers for
refactoring are welcome!</strong></p>
<div class="section" id="the-parent">
<h4>The parent<a class="headerlink" href="#the-parent" title="Permalink to this headline">¶</a></h4>
<p>Since we wish to implement a special kind of fields, namely fraction fields,
it makes sense to build on top of the base class
<a class="reference external" href="../reference/rings/sage/rings/ring.html#sage.rings.ring.Field" title="(in Sage Reference Manual: General Rings, Ideals, and Morphisms v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.rings.ring.Field</span></tt></a> provided by Sage.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.ring</span> <span class="kn">import</span> <span class="n">Field</span>
</pre></div>
</div>
<p>This base class provides a lot more methods than a general parent:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">Field</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">Parent</span><span class="p">)]</span>
<span class="go">[&#39;__fraction_field&#39;,</span>
<span class="go"> &#39;__ideal_monoid&#39;,</span>
<span class="go"> &#39;__iter__&#39;,</span>
<span class="go"> &#39;__pow__&#39;,</span>
<span class="go"> &#39;__rpow__&#39;,</span>
<span class="go"> &#39;__rtruediv__&#39;,</span>
<span class="go"> &#39;__rxor__&#39;,</span>
<span class="go"> &#39;__truediv__&#39;,</span>
<span class="go"> &#39;__xor__&#39;,</span>
<span class="go"> &#39;_an_element&#39;,</span>
<span class="go"> &#39;_an_element_c&#39;,</span>
<span class="go"> &#39;_an_element_impl&#39;,</span>
<span class="go"> &#39;_coerce_&#39;,</span>
<span class="go"> &#39;_coerce_c&#39;,</span>
<span class="go"> &#39;_coerce_impl&#39;,</span>
<span class="go"> &#39;_coerce_try&#39;,</span>
<span class="go"> &#39;_default_category&#39;,</span>
<span class="go"> &#39;_gcd_univariate_polynomial&#39;,</span>
<span class="go"> &#39;_gens&#39;,</span>
<span class="go"> &#39;_has_coerce_map_from&#39;,</span>
<span class="go"> &#39;_ideal_class_&#39;,</span>
<span class="go"> &#39;_latex_names&#39;,</span>
<span class="go"> &#39;_list&#39;,</span>
<span class="go"> &#39;_one_element&#39;,</span>
<span class="go"> &#39;_pseudo_fraction_field&#39;,</span>
<span class="go"> &#39;_random_nonzero_element&#39;,</span>
<span class="go"> &#39;_unit_ideal&#39;,</span>
<span class="go"> &#39;_xgcd_univariate_polynomial&#39;,</span>
<span class="go"> &#39;_zero_element&#39;,</span>
<span class="go"> &#39;_zero_ideal&#39;,</span>
<span class="go"> &#39;algebraic_closure&#39;,</span>
<span class="go"> &#39;base_extend&#39;,</span>
<span class="go"> &#39;cardinality&#39;,</span>
<span class="go"> &#39;class_group&#39;,</span>
<span class="go"> &#39;coerce_map_from_c&#39;,</span>
<span class="go"> &#39;content&#39;,</span>
<span class="go"> &#39;divides&#39;,</span>
<span class="go"> &#39;epsilon&#39;,</span>
<span class="go"> &#39;extension&#39;,</span>
<span class="go"> &#39;fraction_field&#39;,</span>
<span class="go"> &#39;frobenius_endomorphism&#39;,</span>
<span class="go"> &#39;gcd&#39;,</span>
<span class="go"> &#39;gen&#39;,</span>
<span class="go"> &#39;gens&#39;,</span>
<span class="go"> &#39;get_action_c&#39;,</span>
<span class="go"> &#39;get_action_impl&#39;,</span>
<span class="go"> &#39;has_coerce_map_from_c&#39;,</span>
<span class="go"> &#39;ideal&#39;,</span>
<span class="go"> &#39;ideal_monoid&#39;,</span>
<span class="go"> &#39;integral_closure&#39;,</span>
<span class="go"> &#39;is_commutative&#39;,</span>
<span class="go"> &#39;is_field&#39;,</span>
<span class="go"> &#39;is_finite&#39;,</span>
<span class="go"> &#39;is_integral_domain&#39;,</span>
<span class="go"> &#39;is_integrally_closed&#39;,</span>
<span class="go"> &#39;is_noetherian&#39;,</span>
<span class="go"> &#39;is_prime_field&#39;,</span>
<span class="go"> &#39;is_ring&#39;,</span>
<span class="go"> &#39;is_subring&#39;,</span>
<span class="go"> &#39;krull_dimension&#39;,</span>
<span class="go"> &#39;list&#39;,</span>
<span class="go"> &#39;ngens&#39;,</span>
<span class="go"> &#39;one&#39;,</span>
<span class="go"> &#39;order&#39;,</span>
<span class="go"> &#39;prime_subfield&#39;,</span>
<span class="go"> &#39;principal_ideal&#39;,</span>
<span class="go"> &#39;quo&#39;,</span>
<span class="go"> &#39;quotient&#39;,</span>
<span class="go"> &#39;quotient_ring&#39;,</span>
<span class="go"> &#39;random_element&#39;,</span>
<span class="go"> &#39;unit_ideal&#39;,</span>
<span class="go"> &#39;zero&#39;,</span>
<span class="go"> &#39;zero_ideal&#39;,</span>
<span class="go"> &#39;zeta&#39;,</span>
<span class="go"> &#39;zeta_order&#39;]</span>
</pre></div>
</div>
<p>The following is a very basic implementation of fraction fields, that needs to
be complemented later.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.structure.unique_representation</span> <span class="kn">import</span> <span class="n">UniqueRepresentation</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFrac</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="n">Field</span><span class="p">):</span>
<span class="go">....:     def __init__(self, base):</span>
<span class="go">....:         if base not in IntegralDomains():</span>
<span class="go">....:             raise ValueError, &quot;%s is no integral domain&quot;%base</span>
<span class="go">....:         Field.__init__(self, base)</span>
<span class="go">....:     def _repr_(self):</span>
<span class="go">....:         return &quot;NewFrac(%s)&quot;%repr(self.base())</span>
<span class="go">....:     def base_ring(self):</span>
<span class="go">....:         return self.base().base_ring()</span>
<span class="go">....:     def characteristic(self):</span>
<span class="go">....:         return self.base().characteristic()</span>
</pre></div>
</div>
<p>This basic implementation is formed by the following steps:</p>
<ul>
<li><p class="first">Any ring in Sage has a <strong>base</strong> and a <strong>base ring</strong>. The &#8220;usual&#8221; fraction
field of a ring <span class="math">\(R\)</span> has the base <span class="math">\(R\)</span> and the base ring <tt class="docutils literal"><span class="pre">R.base_ring()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Frac</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">base</span><span class="p">(),</span> <span class="n">Frac</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
<span class="go">(Univariate Polynomial Ring in x over Rational Field, Rational Field)</span>
</pre></div>
</div>
<p>Declaring the base is easy: We just pass it as an argument to the field
constructor.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Field</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">base</span><span class="p">()</span>
<span class="go">Univariate Polynomial Ring in x over Integer Ring</span>
</pre></div>
</div>
<p>We are implementing a seperate method returning the base ring.</p>
</li>
<li><p class="first">Python uses double&#8211;underscore methods for arithemetic methods and string
representations. Sage&#8217;s base classes often have a default implementation,
and it is requested to <strong>implement SINGLE underscore methods _repr_, and
similarly _add_, _mul_ etc.</strong></p>
</li>
<li><p class="first">You are encouraged to <strong>make your parent &#8220;unique&#8221;</strong>. That&#8217;s to say, parents
should only evaluate equal if they are identical. Sage provides frameworks
to create unique parents. We use here the most easy one: Inheriting from the
class <a class="reference external" href="../reference/structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Basic Structures v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></tt></a> is
enough. Making parents unique can be quite important for an efficient
implementation, because the repeated creation of &#8220;the same&#8221; parent would
take a lot of time.</p>
</li>
<li><p class="first">Fraction fields are only defined for integral domains. Hence, we raise an
error if the given ring does not belong to the category of integral
domains. This is our first use case of categories.</p>
</li>
<li><p class="first">Last, we add a method that returns the characteristic of the field. We don&#8217;t
go into details, but some automated tests that we study below implicitly
rely on this method.</p>
</li>
</ul>
<p>We see that our basic implementation correctly refuses a ring that is not an
integral domain:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span>
<span class="go">NewFrac(Univariate Polynomial Ring in x over Integer Ring)</span>
<span class="gp">sage: </span><span class="n">MyFrac</span><span class="p">(</span><span class="n">Integers</span><span class="p">(</span><span class="mi">15</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Ring of integers modulo 15 is no integral domain</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Inheritance from <a class="reference external" href="../reference/structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Basic Structures v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">UniqueRepresentation</span></tt></a>
automatically provides our class with pickling, preserving the unique
parent condition. If we had defined the class in some external module or
in an interactive session, pickling would work immediately.</p>
<p class="last">However, for making the following example work in Sage&#8217;s doctesting
framework, we need to assign our class as an attribute of the <tt class="docutils literal"><span class="pre">__main__</span></tt>
module, so that the class can be looked up during unpickling.</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">MyFrac</span> <span class="o">=</span> <span class="n">MyFrac</span>
<span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)))</span> <span class="ow">is</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In the following sections, we will successively add or change details of
<tt class="docutils literal"><span class="pre">MyFrac</span></tt>. Rather than giving a full class definition in each step, we
define new versions of <tt class="docutils literal"><span class="pre">MyFrac</span></tt> by inheriting from the previously
defined version of <tt class="docutils literal"><span class="pre">MyFrac</span></tt>. We believe this will help the reader to
focus on the single detail that is relevant in each section.</p>
<p class="last">The complete code can be found in the appendix.</p>
</div>
</div>
<div class="section" id="the-elements">
<h4>The elements<a class="headerlink" href="#the-elements" title="Permalink to this headline">¶</a></h4>
<p>We use the base class <a class="reference external" href="../reference/structure/sage/structure/element.html#sage.structure.element.FieldElement" title="(in Sage Reference Manual: Basic Structures v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.element.FieldElement</span></tt></a>. Note that
in the creation of field elements it is not tested that the given parent is a
field:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.structure.element</span> <span class="kn">import</span> <span class="n">FieldElement</span>
<span class="gp">sage: </span><span class="n">FieldElement</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Generic element of a structure</span>
</pre></div>
</div>
<p>Our toy implementation of fraction field elements is based on the following
considerations:</p>
<ul>
<li><p class="first">A fraction field element is defined by numerator and denominator, which both
need to be elements of the base. There should be methods returning numerator
resp. denominator.</p>
</li>
<li><p class="first">The denominator must not be zero, and (provided that the base is an ordered
ring) we can make it non-negative, without loss of generality. By default,
the denominator is one.</p>
</li>
<li><p class="first">The string representation is returned by the single&#8211;underscore method
<tt class="docutils literal"><span class="pre">_repr_</span></tt>. In order to make our fraction field elements distinguishable
from those already present in Sage, we use a different string representation.</p>
</li>
<li><p class="first">Arithmetic is implemented in single&#8211;underscore method <tt class="docutils literal"><span class="pre">_add_</span></tt>, <tt class="docutils literal"><span class="pre">_mul_</span></tt>,
etc. <strong>We do not override the default double underscore __add__, __mul__</strong>,
since otherwise, we could not use Sage&#8217;s coercion model.</p>
</li>
<li><p class="first">Comparisons can be implemented using <tt class="docutils literal"><span class="pre">_cmp_</span></tt>. This automatically
makes the relational operators like <tt class="docutils literal"><span class="pre">==</span></tt> and <tt class="docutils literal"><span class="pre">&lt;</span></tt> work. In order
to support the Python <tt class="docutils literal"><span class="pre">cmp()</span></tt> function, it is safest to define both
<tt class="docutils literal"><span class="pre">_cmp_</span></tt> and <tt class="docutils literal"><span class="pre">__cmp__</span></tt> (because <tt class="docutils literal"><span class="pre">__cmp__</span></tt> is not inherited if
other comparison operators or <tt class="docutils literal"><span class="pre">__hash__</span></tt> are defined). Of course you
can just do <tt class="docutils literal"><span class="pre">__cmp__</span> <span class="pre">=</span> <span class="pre">_cmp_</span></tt>.</p>
<p>Note that <tt class="docutils literal"><span class="pre">_cmp_</span></tt> should be provided, since otherwise comparison
does not work:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">sage</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">Element</span><span class="p">):</span>
<span class="go">....:  def __init__(self, parent, x):</span>
<span class="go">....:      self.x = x</span>
<span class="go">....:  def _repr_(self):</span>
<span class="go">....:      return &quot;&lt;%s&gt;&quot;%self.x</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">cmp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">comparison not implemented for &lt;class &#39;__main__.Foo&#39;&gt;</span>
</pre></div>
</div>
</li>
<li><p class="first">In the single underscore methods, we can assume that
<em>both arguments belong to the same parent</em>.
This is one benefit of the coercion model.</p>
</li>
<li><p class="first">When constructing new elements as the result of arithmetic operations, we do
not directly name our class, but we use <tt class="docutils literal"><span class="pre">self.__class__</span></tt>. Later, this will
come in handy.</p>
</li>
</ul>
<p>This gives rise to the following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyElement</span><span class="p">(</span><span class="n">FieldElement</span><span class="p">):</span>
<span class="go">....:     def __init__(self, parent,n,d=None):</span>
<span class="go">....:         B = parent.base()</span>
<span class="go">....:         if d is None:</span>
<span class="go">....:             d = B.one()</span>
<span class="go">....:         if n not in B or d not in B:</span>
<span class="go">....:             raise ValueError(&quot;Numerator and denominator must be elements of %s&quot;%B)</span>
<span class="go">....:         # Numerator and denominator should not just be &quot;in&quot; B,</span>
<span class="go">....:         # but should be defined as elements of B</span>
<span class="go">....:         d = B(d)</span>
<span class="go">....:         n = B(n)</span>
<span class="go">....:         if d==0:</span>
<span class="go">....:             raise ZeroDivisionError(&quot;The denominator must not be zero&quot;)</span>
<span class="go">....:         if d&lt;0:</span>
<span class="go">....:             self.n = -n</span>
<span class="go">....:             self.d = -d</span>
<span class="go">....:         else:</span>
<span class="go">....:             self.n = n</span>
<span class="go">....:             self.d = d</span>
<span class="go">....:         FieldElement.__init__(self,parent)</span>
<span class="go">....:     def numerator(self):</span>
<span class="go">....:         return self.n</span>
<span class="go">....:     def denominator(self):</span>
<span class="go">....:         return self.d</span>
<span class="go">....:     def _repr_(self):</span>
<span class="go">....:         return &quot;(%s):(%s)&quot;%(self.n,self.d)</span>
<span class="go">....:     def _cmp_(self, other):</span>
<span class="go">....:         return cmp(self.n*other.denominator(), other.numerator()*self.d)</span>
<span class="go">....:     __cmp__ = _cmp_</span>
<span class="go">....:     def _add_(self, other):</span>
<span class="go">....:         C = self.__class__</span>
<span class="go">....:         D = self.d*other.denominator()</span>
<span class="go">....:         return C(self.parent(), self.n*other.denominator()+self.d*other.numerator(), D)</span>
<span class="go">....:     def _sub_(self, other):</span>
<span class="go">....:         C = self.__class__</span>
<span class="go">....:         D = self.d*other.denominator()</span>
<span class="go">....:         return C(self.parent(), self.n*other.denominator()-self.d*other.numerator(),D)</span>
<span class="go">....:     def _mul_(self, other):</span>
<span class="go">....:         C = self.__class__</span>
<span class="go">....:         return C(self.parent(), self.n*other.numerator(), self.d*other.denominator())</span>
<span class="go">....:     def _div_(self, other):</span>
<span class="go">....:         C = self.__class__</span>
<span class="go">....:         return C(self.parent(), self.n*other.denominator(), self.d*other.numerator())</span>
</pre></div>
</div>
<div class="section" id="features-and-limitations-of-the-basic-implementation">
<h5>Features and limitations of the basic implementation<a class="headerlink" href="#features-and-limitations-of-the-basic-implementation" title="Permalink to this headline">¶</a></h5>
<p>Thanks to the single underscore methods, some basic arithmetics works, <strong>if</strong>
we stay inside a single parent structure:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">MyElement</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">MyElement</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span>
<span class="go">((10):(8), (2):(8), (3):(8), (6):(4))</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">-</span><span class="n">b</span> <span class="o">==</span> <span class="n">MyElement</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We didn&#8217;t implement exponentiation&#8212;but it just works:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span><span class="o">^</span><span class="mi">3</span>
<span class="go">(27):(64)</span>
</pre></div>
</div>
<p>There is a default implementation of element tests. We can already do</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="ow">in</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<p>since <span class="math">\(a\)</span> is defined as an element of <span class="math">\(P\)</span>. However, we can not verify yet that
the integers are contained in the fraction field of the ring of integers. It
does not even give a wrong answer, but results in an error:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="mi">1</span> <span class="ow">in</span> <span class="n">P</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>
</pre></div>
</div>
<p>We will take care of this later.</p>
</div>
</div>
</div>
<div class="section" id="categories-in-sage">
<h3><a class="toc-backref" href="#id5">Categories in Sage</a><a class="headerlink" href="#categories-in-sage" title="Permalink to this headline">¶</a></h3>
<p>Sometimes the base classes do not reflect the mathematics: The set of <span class="math">\(m\times
n\)</span> matrices over a field forms, in general, not more than a vector
space. Hence, this set (called <a class="reference external" href="../reference/matrices/sage/matrix/matrix_space.html#sage.matrix.matrix_space.MatrixSpace" title="(in Sage Reference Manual: Matrices and Spaces of Matrices v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">MatrixSpace</span></tt></a>)
is not implemented on top of <a class="reference external" href="../reference/rings/sage/rings/ring.html#sage.rings.ring.Ring" title="(in Sage Reference Manual: General Rings, Ideals, and Morphisms v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.rings.ring.Ring</span></tt></a>.  However, if
<span class="math">\(m=n\)</span>, then the matrix space is an algebra, thus, is a ring.</p>
<p>From the point of view of Python base classes, both cases are the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MS1</span> <span class="o">=</span> <span class="n">MatrixSpace</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">MS1</span><span class="p">,</span> <span class="n">Ring</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">MS2</span> <span class="o">=</span> <span class="n">MatrixSpace</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">MS2</span><span class="p">,</span> <span class="n">Ring</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Sage&#8217;s category framework can differentiate the two cases:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span>
<span class="go">Category of rings</span>
<span class="gp">sage: </span><span class="n">MS1</span> <span class="ow">in</span> <span class="n">Rings</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">MS2</span> <span class="ow">in</span> <span class="n">Rings</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>And indeed, <tt class="docutils literal"><span class="pre">MS2</span></tt> has <em>more</em> methods than <tt class="docutils literal"><span class="pre">MS1</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">inspect</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">MS1</span><span class="p">)</span> <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">MS1</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="bp">None</span><span class="p">))])</span>
<span class="go">59</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">MS2</span><span class="p">)</span> <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">MS2</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="bp">None</span><span class="p">))])</span>
<span class="go">89</span>
</pre></div>
</div>
<p>This is because the class of <tt class="docutils literal"><span class="pre">MS2</span></tt> also inherits from the parent
class for algebras:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MS1</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__bases__</span>
<span class="go">(&lt;class &#39;sage.matrix.matrix_space.MatrixSpace&#39;&gt;,</span>
<span class="go">&lt;class &#39;sage.categories.category.JoinCategory.parent_class&#39;&gt;)</span>
<span class="gp">sage: </span><span class="n">MS2</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__bases__</span>
<span class="go">(&lt;class &#39;sage.matrix.matrix_space.MatrixSpace&#39;&gt;,</span>
<span class="go">&lt;class &#39;sage.categories.category.JoinCategory.parent_class&#39;&gt;)</span>
</pre></div>
</div>
<p>Below, we will explain how this can be taken advantage of.</p>
<p>It is no surprise that our parent <span class="math">\(P\)</span> defined above knows that it belongs to
the category of fields, as it is derived from the base class of fields.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of fields</span>
</pre></div>
</div>
<p>However, we could choose a smaller category, namely the category of quotient fields.</p>
<div class="section" id="why-should-one-choose-a-category">
<h4>Why should one choose a category?<a class="headerlink" href="#why-should-one-choose-a-category" title="Permalink to this headline">¶</a></h4>
<p>One can provide <strong>default methods</strong> <em>for all objects</em> of a category, and
<em>for all elements</em> of such objects. Hence, the category framework is a way
to inherit useful stuff that is not present in the base classes.  These
default methods do not rely on implementation details, but on mathematical
concepts.</p>
<p>In addition, the categories define <strong>test suites</strong> for their objects and
elements&#8212;see the last section. Hence, one also gets basic sanity tests for
free.</p>
<div class="section" id="how-does-the-category-framework-work">
<h5>How does the  <em>category framework</em> work?<a class="headerlink" href="#how-does-the-category-framework-work" title="Permalink to this headline">¶</a></h5>
<p>Abstract base classes for the objects (&#8220;parent_class&#8221;) and the elements of
objects (&#8220;element_class&#8221;) are provided by attributes of the category. During
initialisation of a parent, the class of the parent is <em>dynamically changed</em>
into a sub&#8211;class of the category&#8217;s parent class. Likewise, sub&#8211;classes of
the category&#8217;s element class are available for the creation of elements of the
parent, as explained below.</p>
<p>A dynamic change of classes does not work in Cython. Nevertheless, method
inheritance still works, by virtue of a <tt class="docutils literal"><span class="pre">__getattr__</span></tt> method.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is strongly recommended to use the category framework both in Python
and in Cython.</p>
</div>
<p>Let us see whether there is any gain in chosing the category of quotient
fields instead of the category of fields:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="p">,</span> <span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span>
<span class="go">(&lt;class &#39;sage.categories.quotient_fields.QuotientFields.parent_class&#39;&gt;,</span>
<span class="go"> &lt;class &#39;sage.categories.quotient_fields.QuotientFields.element_class&#39;&gt;)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">Fields</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="p">)]</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">Fields</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span><span class="p">)]</span>
<span class="go">[&#39;_derivative&#39;, &#39;denominator&#39;, &#39;derivative&#39;, &#39;factor&#39;,</span>
<span class="go"> &#39;numerator&#39;, &#39;partial_fraction_decomposition&#39;]</span>
</pre></div>
</div>
<p>So, there is no immediate gain for our fraction fields, but additional methods
become available to our fraction field elements. Note that some of these
methods are place-holders: There is no default implementation, but it is
<em>required</em> (respectively is <em>optional</em>) to implement these methods:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span><span class="o">.</span><span class="n">denominator</span>
<span class="go">&lt;abstract method denominator at ...&gt;</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.misc.abstract_method</span> <span class="kn">import</span> <span class="n">abstract_methods_of_class</span>
<span class="gp">sage: </span><span class="n">abstract_methods_of_class</span><span class="p">(</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span><span class="p">)[</span><span class="s1">&#39;optional&#39;</span><span class="p">]</span>
<span class="go">[&#39;_add_&#39;, &#39;_mul_&#39;]</span>
<span class="gp">sage: </span><span class="n">abstract_methods_of_class</span><span class="p">(</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span><span class="p">)[</span><span class="s1">&#39;required&#39;</span><span class="p">]</span>
<span class="go">[&#39;__nonzero__&#39;, &#39;denominator&#39;, &#39;numerator&#39;]</span>
</pre></div>
</div>
<p>Hence, when implementing elements of a quotient field, it is <em>required</em> to
implement methods returning the denominator and the numerator, and a method
that tells whether the element is nonzero, and in addition, it is <em>optional</em>
(but certainly recommended) to provide some arithmetic methods. If one forgets
to implement the required methods, the test suites of the category framework
will complain&#8212;see below.</p>
</div>
</div>
<div class="section" id="implementing-the-category-framework-for-the-parent">
<h4>Implementing the category framework for the parent<a class="headerlink" href="#implementing-the-category-framework-for-the-parent" title="Permalink to this headline">¶</a></h4>
<p>We simply need to declare the correct category by an optional argument of the
field constructor, where we provide the possibility to override the default
category:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.quotient_fields</span> <span class="kn">import</span> <span class="n">QuotientFields</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFrac</span><span class="p">(</span><span class="n">MyFrac</span><span class="p">):</span>
<span class="go">....:     def __init__(self, base, category=None):</span>
<span class="go">....:         if base not in IntegralDomains():</span>
<span class="go">....:             raise ValueError, &quot;%s is no integral domain&quot;%base</span>
<span class="go">....:         Field.__init__(self, base, category=category or QuotientFields())</span>
</pre></div>
</div>
<p>When constructing instances of <tt class="docutils literal"><span class="pre">MyFrac</span></tt>, their class is dynamically changed
into a new class called <tt class="docutils literal"><span class="pre">MyFrac_with_category</span></tt>. It is a common sub&#8211;class of
<tt class="docutils literal"><span class="pre">MyFrac</span></tt> and of the category&#8217;s parent class:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">&lt;class &#39;__main__.MyFrac_with_category&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">MyFrac</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The fraction field <span class="math">\(P\)</span> inherits additional methods. For example, the base
class <tt class="xref py py-class docutils literal"><span class="pre">Field</span></tt> does not have a method <tt class="docutils literal"><span class="pre">sum</span></tt>. But
<span class="math">\(P\)</span> inherits such method from the category of commutative additive
monoids&#8212;see
<tt class="xref py py-meth docutils literal"><span class="pre">sum()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">sum</span><span class="o">.</span><span class="n">__module__</span>
<span class="go">&#39;sage.categories.additive_monoids&#39;</span>
</pre></div>
</div>
<p>We have seen above that we can add elements. Nevertheless, the <tt class="docutils literal"><span class="pre">sum</span></tt> method
does not work, yet:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">MyElement</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">MyElement</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">MyElement</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>
</pre></div>
</div>
<p>The reason is that the <tt class="docutils literal"><span class="pre">sum</span></tt> method starts with the return value of
<tt class="docutils literal"><span class="pre">P.zero()</span></tt>, which defaults to <tt class="docutils literal"><span class="pre">P(0)</span></tt>&#8212;but the conversion of
integers into <tt class="docutils literal"><span class="pre">P</span></tt> is not implemented, yet.</p>
</div>
<div class="section" id="implementing-the-category-framework-for-the-elements">
<h4>Implementing the category framework for the elements<a class="headerlink" href="#implementing-the-category-framework-for-the-elements" title="Permalink to this headline">¶</a></h4>
<p>Similar to what we have seen for parents, a new class is dynamically created
that combines the element class of the parent&#8217;s category with the class that
we have implemented above. However, the category framework is implemented in a
different way for elements than for parents:</p>
<ul class="simple">
<li>We provide the parent <span class="math">\(P\)</span> (or its class) with an attribute called
&#8220;<tt class="docutils literal"><span class="pre">Element</span></tt>&#8221;, whose value is a class.</li>
<li>The parent <em>automatically</em> obtains an attribute <tt class="docutils literal"><span class="pre">P.element_class</span></tt>, that
subclasses both <tt class="docutils literal"><span class="pre">P.Element</span></tt> and <tt class="docutils literal"><span class="pre">P.category().element_class</span></tt>.</li>
</ul>
<p>Hence, for providing our fraction fields with their own element classes, <strong>we
just need to add a single line to our class</strong>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFrac</span><span class="p">(</span><span class="n">MyFrac</span><span class="p">):</span>
<span class="go">....:     Element = MyElement</span>
</pre></div>
</div>
<p>This little change provides several benefits:</p>
<ul>
<li><p class="first">We can now create elements by simply calling the parent:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">((1):(1), (2):(3))</span>
</pre></div>
</div>
</li>
<li><p class="first">There is a method <tt class="docutils literal"><span class="pre">zero</span></tt> returning the expected result:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="go">(0):(1)</span>
</pre></div>
</div>
</li>
<li><p class="first">The <tt class="docutils literal"><span class="pre">sum</span></tt> method mentioned above suddenly works:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">MyElement</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">MyElement</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">MyElement</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">])</span>
<span class="go">(36):(16)</span>
</pre></div>
</div>
</li>
</ul>
<div class="section" id="what-did-happen-behind-the-scenes-to-make-this-work">
<h5>What did happen behind the scenes to make this work?<a class="headerlink" href="#what-did-happen-behind-the-scenes-to-make-this-work" title="Permalink to this headline">¶</a></h5>
<p>We provided <tt class="docutils literal"><span class="pre">P.Element</span></tt>, and thus obtain <tt class="docutils literal"><span class="pre">P.element_class</span></tt>, which is a
<em>lazy attribute</em>.  It provides a <em>dynamic</em> class, which is a sub&#8211;class of
both <tt class="docutils literal"><span class="pre">MyElement</span></tt> defined above and of <tt class="docutils literal"><span class="pre">P.category().element_class</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">element_class</span>
<span class="go">&lt;sage.misc.lazy_attribute.lazy_attribute object at ...&gt;</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">element_class</span>
<span class="go">&lt;class &#39;__main__.MyFrac_with_category.element_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">element_class</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.structure.dynamic_class.DynamicInheritComparisonMetaclass&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">element_class</span><span class="p">,</span> <span class="n">MyElement</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">element_class</span><span class="p">,</span><span class="n">P</span><span class="o">.</span><span class="n">category</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The <em>default</em> <tt class="docutils literal"><span class="pre">__call__</span></tt> method of <span class="math">\(P\)</span> passes the given arguments to
<tt class="docutils literal"><span class="pre">P.element_class</span></tt>, adding the argument <tt class="docutils literal"><span class="pre">parent=P</span></tt>. This is why we are now
able to create elements by calling the parent.</p>
<p>In particular, these elements are instances of that new dynamic class:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="go">&lt;class &#39;__main__.MyFrac_with_category.element_class&#39;&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><em>All</em> elements of <span class="math">\(P\)</span> should use the element class. In order to make sure
that this also holds for the result of arithmetic operations, we created
them as instances of <tt class="docutils literal"><span class="pre">self.__class__</span></tt> in the arithmetic methods of
<tt class="docutils literal"><span class="pre">MyElement</span></tt>.</p>
</div>
<p><tt class="docutils literal"><span class="pre">P.zero()</span></tt> defaults to returning <tt class="docutils literal"><span class="pre">P(0)</span></tt> and thus returns an
instance of <tt class="docutils literal"><span class="pre">P.element_class</span></tt>. Since <tt class="docutils literal"><span class="pre">P.sum([...])</span></tt> starts the summation with
<tt class="docutils literal"><span class="pre">P.zero()</span></tt> and the class of the sum only depends on the first
summand, by our implementation, we have:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;class &#39;__main__.MyElement&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">P</span><span class="o">.</span><span class="n">element_class</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]))</span>
<span class="go">&lt;class &#39;__main__.MyFrac_with_category.element_class&#39;&gt;</span>
</pre></div>
</div>
<p>The method <tt class="docutils literal"><span class="pre">factor</span></tt> provided by <tt class="docutils literal"><span class="pre">P.category().element_class</span></tt> (see above)
simply works:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span><span class="p">;</span> <span class="n">a</span><span class="o">.</span><span class="n">factor</span><span class="p">();</span> <span class="n">P</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(9):(4)</span>
<span class="go">2^-2 * 3^2</span>
<span class="go">2^-1 * 3</span>
</pre></div>
</div>
<p>But that&#8217;s surprising: The element <span class="math">\(a\)</span> is just an instance of <tt class="docutils literal"><span class="pre">MyElement</span></tt>,
but not of <tt class="docutils literal"><span class="pre">P.element_class</span></tt>, and its class does not know about the factor
method.  In fact, this is due to a <tt class="docutils literal"><span class="pre">__getattr__</span></tt> method defined for
<a class="reference external" href="../reference/structure/sage/structure/element.html#sage.structure.element.Element" title="(in Sage Reference Manual: Basic Structures v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.element.Element</span></tt></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">hasattr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s1">&#39;factor&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">element_class</span><span class="p">,</span> <span class="s1">&#39;factor&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;factor&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="a-first-note-on-performance">
<h4>A first note on performance<a class="headerlink" href="#a-first-note-on-performance" title="Permalink to this headline">¶</a></h4>
<p>The category framework is sometimes blamed for speed regressions, as in
<a class="reference external" href="http://trac.sagemath.org/9138">trac ticket #9138</a> and <a class="reference external" href="http://trac.sagemath.org/11900">trac ticket #11900</a>. But if the category framework is <em>used
properly</em>, then it is fast. For illustration, we determine the time needed to
access an attribute inherited from the element class. First, we consider an
element that uses the class that we implemented above, but does not use the
category framework properly:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;class &#39;__main__.MyElement&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;a.factor&#39;</span><span class="p">,</span><span class="n">number</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>     <span class="c1"># random</span>
<span class="go">1000 loops, best of 3: 2 us per loop</span>
</pre></div>
</div>
<p>Now, we consider an element that is equal to <span class="math">\(a\)</span>, but uses the category
framework properly:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a2</span> <span class="o">=</span> <span class="n">P</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a2</span> <span class="o">==</span> <span class="n">a</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="go">&lt;class &#39;__main__.MyFrac_with_category.element_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;a2.factor&#39;</span><span class="p">,</span><span class="n">number</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>    <span class="c1"># random</span>
<span class="go">1000 loops, best of 3: 365 ns per loop</span>
</pre></div>
</div>
<p>So,  <em>don&#8217;t be afraid of using categories!</em></p>
</div>
</div>
<div class="section" id="coercion-the-basics">
<h3><a class="toc-backref" href="#id6">Coercion&#8212;the basics</a><a class="headerlink" href="#coercion-the-basics" title="Permalink to this headline">¶</a></h3>
<div class="section" id="theoretical-background">
<h4>Theoretical background<a class="headerlink" href="#theoretical-background" title="Permalink to this headline">¶</a></h4>
<div class="section" id="coercion-is-not-just-type-conversion">
<h5>Coercion is not just <em>type conversion</em><a class="headerlink" href="#coercion-is-not-just-type-conversion" title="Permalink to this headline">¶</a></h5>
<p>&#8220;Coercion&#8221; in the C programming language means &#8220;automatic type
conversion&#8221;. However, in Sage, coercion is involved if one wants to be able to
do arithmetic, comparisons, etc. between elements of distinct parents. Hence,
<strong>coercion is not about a change of types, but about a change of parents.</strong></p>
<p>As an illustration, we show that elements of the same type may very well belong
to rather different parents:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;v,w&#39;</span><span class="p">];</span> <span class="n">P2</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;w,v&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">gen</span><span class="p">())</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">P2</span><span class="o">.</span><span class="n">gen</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">==</span> <span class="n">P2</span>
<span class="go">False</span>
</pre></div>
</div>
<p><span class="math">\(P_2\)</span> naturally is a sub&#8211;ring of <span class="math">\(P_1\)</span>. So, it makes sense to be able to add
elements of the two rings&#8212;the result should then live in <span class="math">\(P_1\)</span>, and indeed
it does:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span><span class="o">+</span><span class="n">P2</span><span class="o">.</span><span class="n">gen</span><span class="p">())</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P1</span>
<span class="go">True</span>
</pre></div>
</div>
<p>It would be rather inconvenient if one needed to <em>manually</em> convert an element
of <span class="math">\(P_2\)</span> into <span class="math">\(P_1\)</span> before adding. The coercion system does that conversion
automatically.</p>
</div>
<div class="section" id="not-every-conversion-is-a-coercion">
<h5>Not every conversion is a coercion<a class="headerlink" href="#not-every-conversion-is-a-coercion" title="Permalink to this headline">¶</a></h5>
<p>A coercion happens implicitly, without being explicitly requested by the
user. Hence, coercion must be based on mathematical rigour. In our example,
any element of <span class="math">\(P_2\)</span> can be naturally interpreted as an element of <span class="math">\(P_1\)</span>. We
thus have:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span>
<span class="go">Conversion map:</span>
<span class="go">  From: Multivariate Polynomial Ring in w, v over Integer Ring</span>
<span class="go">  To:   Multivariate Polynomial Ring in v, w over Rational Field</span>
</pre></div>
</div>
<p>While there is a conversion from <span class="math">\(P_1\)</span> to <span class="math">\(P_2\)</span> (namely restricted to
polynomials with integral coefficients), this conversion is not a coercion:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P2</span><span class="o">.</span><span class="n">convert_map_from</span><span class="p">(</span><span class="n">P1</span><span class="p">)</span>
<span class="go">Conversion map:</span>
<span class="go">  From: Multivariate Polynomial Ring in v, w over Rational Field</span>
<span class="go">  To:   Multivariate Polynomial Ring in w, v over Integer Ring</span>
<span class="gp">sage: </span><span class="n">P2</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">P1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P2</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">P1</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="section" id="the-four-axioms-requested-for-coercions">
<h6>The four axioms requested for coercions<a class="headerlink" href="#the-four-axioms-requested-for-coercions" title="Permalink to this headline">¶</a></h6>
<ol class="arabic">
<li><p class="first">A coercion is a morphism in an appropriate category.</p>
<p>This first axiom has two implications:</p>
<ol class="upperalpha">
<li><p class="first">A coercion is defined on all elements of a parent.</p>
<p>A polynomial of degree zero over the integers can be interpreted as an
integer&#8212;but the attempt to convert a polynomial of non-zero degree
would result in an error:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ZZ</span><span class="p">(</span><span class="n">P2</span><span class="o">.</span><span class="n">one</span><span class="p">())</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">ZZ</span><span class="p">(</span><span class="n">P2</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">not a constant polynomial</span>
</pre></div>
</div>
<p>Hence, we only have a <em>partial</em> map. This is fine for a <em>conversion</em>,
but a partial map does not qualify as a <em>coercion</em>.</p>
</li>
<li><p class="first">Coercions are structure preserving.</p>
<p>Any real number can be converted to an integer, namely by
rounding. However, such a conversion is not useful in arithmetic
operations, since the underlying algebraic structure is not preserved:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">int</span><span class="p">(</span><span class="mf">1.6</span><span class="p">)</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="mf">2.7</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.6</span><span class="o">+</span><span class="mf">2.7</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The structure that is to be preserved depends on the category of the
involved parents. For example, the coercion from the integers into the
rational field is a homomorphism of euclidean domains:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QQ</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">category_for</span><span class="p">()</span>
<span class="go">Join of Category of euclidean domains and Category of metric spaces</span>
</pre></div>
</div>
</li>
</ol>
</li>
<li><p class="first">There is at most one coercion from one parent to another</p>
<p>In addition, if there is a <em>coercion</em> from <span class="math">\(P_2\)</span> to <span class="math">\(P_1\)</span>, then a
<em>conversion</em> from <span class="math">\(P_2\)</span> to <span class="math">\(P_1\)</span> is defined for all elements of <span class="math">\(P_2\)</span> and
coincides with the coercion.
Nonetheless, user-exposed maps are copies of the internally used maps whence
the lack of identity between different instantiations:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P1</span><span class="o">.</span><span class="n">convert_map_from</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>For internally used maps, the maps are identical:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">_internal_coerce_map_from</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P1</span><span class="o">.</span><span class="n">_internal_convert_map_from</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
<li><p class="first">Coercions can be composed</p>
<p>If there is a coercion <span class="math">\(\varphi: P_1 \to P_2\)</span> and another coercion <span class="math">\(\psi:
P_2 \to P_3\)</span>, then the composition of <span class="math">\(\varphi\)</span> followed by <span class="math">\(\psi\)</span> must
yield the unique coercion from <span class="math">\(P_1\)</span> to <span class="math">\(P_3\)</span>.</p>
</li>
<li><p class="first">The identity is a coercion</p>
<p>Together with the two preceding axioms, it follows: If there are coercions
from <span class="math">\(P_1\)</span> to <span class="math">\(P_2\)</span> and from <span class="math">\(P_2\)</span> to <span class="math">\(P_1\)</span>, then they are mutually
inverse.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="section" id="implementing-a-conversion">
<h4>Implementing a conversion<a class="headerlink" href="#implementing-a-conversion" title="Permalink to this headline">¶</a></h4>
<p>We have seen above that some conversions into our fraction fields became
available after providing the attribute <tt class="docutils literal"><span class="pre">Element</span></tt>.  However, we can not
convert elements of a fraction field into elements of another fraction field,
yet:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Numerator and denominator must be elements of Integer Ring</span>
</pre></div>
</div>
<p>For implementing a conversion, <strong>the default __call__ method should (almost)
never be overridden.</strong> Instead, <strong>we implement the method
_element_constructor_</strong>, that should return an instance of the parent&#8217;s
element class.  Some old parent classes violate that rule&#8212;please help to
refactor them!</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFrac</span><span class="p">(</span><span class="n">MyFrac</span><span class="p">):</span>
<span class="go">....:     def _element_constructor_(self, *args, **kwds):</span>
<span class="go">....:         if len(args)!=1:</span>
<span class="go">....:             return self.element_class(self, *args, **kwds)</span>
<span class="go">....:         x = args[0]</span>
<span class="go">....:         try:</span>
<span class="go">....:             P = x.parent()</span>
<span class="go">....:         except AttributeError:</span>
<span class="go">....:             return self.element_class(self, x, **kwds)</span>
<span class="go">....:         if P in QuotientFields() and P != self.base():</span>
<span class="go">....:             return self.element_class(self, x.numerator(), x.denominator(), **kwds)</span>
<span class="go">....:         return self.element_class(self, x, **kwds)</span>
</pre></div>
</div>
<p>In addition to the conversion from the base ring and from pairs of base ring
elements, we now also have a conversion from the rationals to our fraction
field of <span class="math">\(\ZZ\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span> <span class="n">P</span><span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
<span class="go">(2):(1)</span>
<span class="go">(2):(3)</span>
<span class="go">(3):(4)</span>
</pre></div>
</div>
<p>Recall that above, the test <span class="math">\(1 \in P\)</span> failed with an error. We try again and
find that the error has disappeared. This is because we are now able to
convert the integer <span class="math">\(1\)</span> into <span class="math">\(P\)</span>. But the containment test still yields a
wrong answer:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="mi">1</span> <span class="ow">in</span> <span class="n">P</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The technical reason: We have a conversion <span class="math">\(P(1)\)</span> of <span class="math">\(1\)</span> into <span class="math">\(P\)</span>, but this is
not known as a coercion&#8212;yet!</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">ZZ</span><span class="p">),</span> <span class="n">P</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">(False, False)</span>
</pre></div>
</div>
</div>
<div class="section" id="establishing-a-coercion">
<h4>Establishing a coercion<a class="headerlink" href="#establishing-a-coercion" title="Permalink to this headline">¶</a></h4>
<p>There are two main ways to make Sage use a particular conversion as a
coercion:</p>
<ul class="simple">
<li>One can use <a class="reference external" href="../reference/structure/sage/structure/parent.html#sage.structure.parent.Parent.register_coercion" title="(in Sage Reference Manual: Basic Structures v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">sage.structure.parent.Parent.register_coercion()</span></tt></a>, normally
during initialisation of the parent (see documentation of the method).</li>
<li>A more flexible way is to provide a method <tt class="docutils literal"><span class="pre">_coerce_map_from_</span></tt> for the
parent.</li>
</ul>
<p>Let <span class="math">\(P\)</span> and <span class="math">\(R\)</span> be parents. If <tt class="docutils literal"><span class="pre">P._coerce_map_from_(R)</span></tt> returns <tt class="docutils literal"><span class="pre">False</span></tt>
or <tt class="docutils literal"><span class="pre">None</span></tt>, then there is no coercion from <span class="math">\(R\)</span> to <span class="math">\(P\)</span>. If it returns a map
with domain <span class="math">\(R\)</span> and codomain <span class="math">\(P\)</span>, then this map is used for coercion. If it
returns <tt class="docutils literal"><span class="pre">True</span></tt>, then the conversion from <span class="math">\(R\)</span> to <span class="math">\(P\)</span> is used as coercion.</p>
<p>Note that in the following implementation, we need a special case for the
rational field, since <tt class="docutils literal"><span class="pre">QQ.base()</span></tt> is not the ring of integers.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFrac</span><span class="p">(</span><span class="n">MyFrac</span><span class="p">):</span>
<span class="go">....:     def _coerce_map_from_(self, S):</span>
<span class="go">....:         if self.base().has_coerce_map_from(S):</span>
<span class="go">....:             return True</span>
<span class="go">....:         if S in QuotientFields():</span>
<span class="go">....:             if self.base().has_coerce_map_from(S.base()):</span>
<span class="go">....:                 return True</span>
<span class="go">....:             if hasattr(S,&#39;ring_of_integers&#39;) and self.base().has_coerce_map_from(S.ring_of_integers()):</span>
<span class="go">....:                 return True</span>
</pre></div>
</div>
<p>By the method above, a parent coercing into the base ring will also coerce
into the fraction field, and a fraction field coerces into another fraction
field if there is a coercion of the corresponding base rings. Now, we have:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]),</span> <span class="n">P</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">Frac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])),</span> <span class="n">P</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">(True, True, True)</span>
</pre></div>
</div>
<p>We can now use coercion from <span class="math">\(\ZZ[x]\)</span> and from <span class="math">\(\QQ\)</span> into <span class="math">\(P\)</span> for arithmetic
operations between the two rings:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="o">+</span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">gen</span><span class="p">(),</span> <span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">gen</span><span class="p">())</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">((4*x + 11):(4), True)</span>
</pre></div>
</div>
<div class="section" id="equality-and-element-containment">
<h5>Equality and element containment<a class="headerlink" href="#equality-and-element-containment" title="Permalink to this headline">¶</a></h5>
<p>Recall that above, the test <span class="math">\(1 \in P\)</span> gave a wrong answer. Let us repeat the
test now:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="mi">1</span> <span class="ow">in</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Why is that?</p>
<p>The default element containment test <span class="math">\(x \in P\)</span> is based on the interplay of
three building blocks: conversion, coercion, and equality test.</p>
<ol class="arabic simple">
<li>Clearly, if the conversion <span class="math">\(P(x)\)</span> raises an error, then <span class="math">\(x\)</span> can not be seen as an element of <span class="math">\(P\)</span>. On the other hand, a conversion <span class="math">\(P(x)\)</span> can generally do very nasty things. So, the fact that <span class="math">\(P(x)\)</span> works without error is necessary, but not sufficient for <span class="math">\(x \in P\)</span>.</li>
<li>If <span class="math">\(P\)</span> is the parent of <span class="math">\(x\)</span>, then the conversion <span class="math">\(P(x)\)</span> will not change <span class="math">\(x\)</span> (at least, that&#8217;s the default). Hence, we will have <span class="math">\(x=P(x)\)</span>.</li>
<li>Sage uses coercion not only for arithmetic operations, but also for comparison: <em>If</em> there is a coercion from the parent of <span class="math">\(x\)</span> to <span class="math">\(P\)</span>, then the equality test <tt class="docutils literal"><span class="pre">x==P(x)</span></tt> reduces to <tt class="docutils literal"><span class="pre">P(x)==P(x)</span></tt>. Otherwise, <tt class="docutils literal"><span class="pre">x==P(x)</span></tt> will evaluate as false.</li>
</ol>
<p>That leads to the following default implementation of element containment testing:</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><span class="math">\(x \in P\)</span> holds if and only if the test <tt class="docutils literal"><span class="pre">x==P(x)</span></tt> does not
raise an error and evaluates as true.</p>
</div>
<p>If the user is not happy with that behaviour, the &#8220;magical&#8221; Python method
<tt class="docutils literal"><span class="pre">__contains__</span></tt> can be overridden.</p>
</div>
</div>
</div>
<div class="section" id="coercion-the-advanced-parts">
<h3><a class="toc-backref" href="#id7">Coercion&#8212;the advanced parts</a><a class="headerlink" href="#coercion-the-advanced-parts" title="Permalink to this headline">¶</a></h3>
<p>So far, we are able to add integers and rational numbers to elements of our
new implementation of the fraction field of <span class="math">\(\ZZ\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
<span class="go">(13):(6)</span>
</pre></div>
</div>
<p>Surprisingly, we can even add a polynomial over the integers to an element of
<span class="math">\(P\)</span>, even though the <em>result lives in a new parent</em>, namely in a polynomial
ring over <span class="math">\(P\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">gen</span><span class="p">(),</span> <span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">gen</span><span class="p">())</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">((1):(1)*x + (1):(2), True)</span>
</pre></div>
</div>
<p>In the next, seemingly more easy example, there &#8220;obviously&#8221; is a coercion from
the fraction field of <span class="math">\(\ZZ\)</span> to the fraction field of <span class="math">\(\ZZ[x]\)</span>.  However, Sage
does not know enough about our new implementation of fraction fields. Hence,
it does not recognise the coercion:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Frac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Two obvious questions arise:</p>
<ol class="arabic simple">
<li>How / why has the new ring been constructed in the example above?</li>
<li>How can we establish a coercion from <span class="math">\(P\)</span>  to  <span class="math">\(\mathrm{Frac}(\ZZ[x])\)</span>?</li>
</ol>
<p>The key to answering both question is the construction of parents from simpler
pieces, that we are studying now. Note that we will answer the second question
<em>not</em> by providing a coercion from <span class="math">\(P\)</span>  to  <span class="math">\(\mathrm{Frac}(\ZZ[x])\)</span>, but by
teaching Sage to automatically construct <span class="math">\(\mathrm{MyFrac}(\ZZ[x])\)</span> and coerce
both <span class="math">\(P\)</span> and <span class="math">\(\mathrm{Frac}(\ZZ[x])\)</span> into it.</p>
<p>If we are lucky, a parent can tell how it has been constructed:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poly</span><span class="p">,</span><span class="n">R</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">construction</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Poly</span><span class="p">,</span><span class="n">R</span>
<span class="go">(Poly[x], Rational Field)</span>
<span class="gp">sage: </span><span class="n">Fract</span><span class="p">,</span><span class="n">R</span> <span class="o">=</span> <span class="n">QQ</span><span class="o">.</span><span class="n">construction</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Fract</span><span class="p">,</span><span class="n">R</span>
<span class="go">(FractionField, Integer Ring)</span>
</pre></div>
</div>
<p>In both cases, the first value returned by
<a class="reference external" href="../reference/structure/sage/structure/parent.html#sage.structure.parent.Parent.construction" title="(in Sage Reference Manual: Basic Structures v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">construction()</span></tt></a> is a mathematical
construction, called <em>construction functor</em>&#8212;see
<a class="reference external" href="../reference/coercion/sage/categories/pushout.html#sage.categories.pushout.ConstructionFunctor" title="(in Sage Reference Manual: Coercion v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">ConstructionFunctor</span></tt></a>. The second return value
is a simpler parent to which the construction functor is applied.</p>
<p>Being functors, the same construction can be applied to different objects of a
category:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poly</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span> <span class="ow">is</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Poly</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Poly</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Fract</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span>
<span class="go">Fraction Field of Univariate Polynomial Ring in x over Rational Field</span>
</pre></div>
</div>
<p>Let us see on which categories these construction functors are defined:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poly</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span>
<span class="go">Category of rings</span>
<span class="gp">sage: </span><span class="n">Poly</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span>
<span class="go">Category of rings</span>
<span class="gp">sage: </span><span class="n">Fract</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span>
<span class="go">Category of integral domains</span>
<span class="gp">sage: </span><span class="n">Fract</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span>
<span class="go">Category of fields</span>
</pre></div>
</div>
<p>In particular, the construction functors can be composed:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poly</span><span class="o">*</span><span class="n">Fract</span>
<span class="go">Poly[x](FractionField(...))</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Poly</span><span class="o">*</span><span class="n">Fract</span><span class="p">)(</span><span class="n">ZZ</span><span class="p">)</span> <span class="ow">is</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In addition, it is often assumed that we have a coercion from input to output of the
construction functor:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">((</span><span class="n">Poly</span><span class="o">*</span><span class="n">Fract</span><span class="p">)(</span><span class="n">ZZ</span><span class="p">))</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Composite map:</span>
<span class="go">  From: Integer Ring</span>
<span class="go">  To:   Univariate Polynomial Ring in x over Rational Field</span>
<span class="go">  Defn:   Natural morphism:</span>
<span class="go">          From: Integer Ring</span>
<span class="go">          To:   Rational Field</span>
<span class="go">        then</span>
<span class="go">          Polynomial base injection morphism:</span>
<span class="go">          From: Rational Field</span>
<span class="go">          To:   Univariate Polynomial Ring in x over Rational Field</span>
</pre></div>
</div>
<p>Construction functors do not necessarily commute:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">Fract</span><span class="o">*</span><span class="n">Poly</span><span class="p">)(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Fraction Field of Univariate Polynomial Ring in x over Integer Ring</span>
</pre></div>
</div>
<div class="section" id="the-pushout-of-construction-functors">
<h4>The pushout of construction functors<a class="headerlink" href="#the-pushout-of-construction-functors" title="Permalink to this headline">¶</a></h4>
<p>We can now formulate our problem. We have parents <span class="math">\(P_1\)</span>, <span class="math">\(P_2\)</span> and <span class="math">\(R\)</span>, and
construction functors <span class="math">\(F_1\)</span>, <span class="math">\(F_2\)</span>, such that <span class="math">\(P_1 = F_1(R)\)</span> and <span class="math">\(P_2 =
F_2(R)\)</span>. We want to find a new construction functor <span class="math">\(F_3\)</span>, such that both
<span class="math">\(P_1\)</span> and <span class="math">\(P_2\)</span> coerce into <span class="math">\(P_3 = F_3(R)\)</span>.</p>
<p>In analogy to a notion of category theory, <span class="math">\(P_3\)</span> is called the
<a class="reference external" href="../reference/coercion/sage/categories/pushout.html#sage.categories.pushout.pushout" title="(in Sage Reference Manual: Coercion v7.1)"><tt class="xref py py-func docutils literal"><span class="pre">pushout()</span></tt></a> of <span class="math">\(P_1\)</span> and <span class="math">\(P_2\)</span>; and similarly
<span class="math">\(F_3\)</span> is called the pushout of <span class="math">\(F_1\)</span> and <span class="math">\(F_2\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.pushout</span> <span class="kn">import</span> <span class="n">pushout</span>
<span class="gp">sage: </span><span class="n">pushout</span><span class="p">(</span><span class="n">Fract</span><span class="p">(</span><span class="n">ZZ</span><span class="p">),</span><span class="n">Poly</span><span class="p">(</span><span class="n">ZZ</span><span class="p">))</span>
<span class="go">Univariate Polynomial Ring in x over Rational Field</span>
</pre></div>
</div>
<p><span class="math">\(F_1\circ F_2\)</span> and <span class="math">\(F_2\circ F_1\)</span> are natural candidates for the pushout of
<span class="math">\(F_1\)</span> and <span class="math">\(F_2\)</span>. However, the order of the functors must rely on a canonical
choice. &#8220;Indecomposable&#8221; construction functors have a <em>rank</em>, and this allows
to order them canonically:</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <tt class="docutils literal"><span class="pre">F1.rank</span></tt> is smaller than <tt class="docutils literal"><span class="pre">F2.rank</span></tt>, then the pushout is <span class="math">\(F_2\circ
F_1\)</span> (hence, <span class="math">\(F_1\)</span> is applied first).</p>
</div>
<p>We have</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Fract</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">Poly</span><span class="o">.</span><span class="n">rank</span>
<span class="go">(5, 9)</span>
</pre></div>
</div>
<p>and thus the pushout is</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Fract</span><span class="o">.</span><span class="n">pushout</span><span class="p">(</span><span class="n">Poly</span><span class="p">),</span> <span class="n">Poly</span><span class="o">.</span><span class="n">pushout</span><span class="p">(</span><span class="n">Fract</span><span class="p">)</span>
<span class="go">(Poly[x](FractionField(...)), Poly[x](FractionField(...)))</span>
</pre></div>
</div>
<p>This is why the example above has worked.</p>
<p>However, only &#8220;elementary&#8221; construction functors have a rank:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">Fract</span><span class="o">*</span><span class="n">Poly</span><span class="p">)</span><span class="o">.</span><span class="n">rank</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;CompositeConstructionFunctor&#39; object has no attribute &#39;rank&#39;</span>
</pre></div>
</div>
<div class="section" id="shuffling-composite-construction-functors">
<h5>Shuffling composite construction functors<a class="headerlink" href="#shuffling-composite-construction-functors" title="Permalink to this headline">¶</a></h5>
<p>If composed construction fuctors <span class="math">\(...\circ F_2\circ F_1\)</span> and <span class="math">\(...\circ
G_2\circ G_1\)</span> are given, then Sage determines their pushout by <em>shuffling</em> the
constituents:</p>
<ul class="simple">
<li>If <tt class="docutils literal"><span class="pre">F1.rank</span> <span class="pre">&lt;</span> <span class="pre">G1.rank</span></tt> then we apply <span class="math">\(F_1\)</span> first, and continue with <span class="math">\(...\circ F_3\circ F_2\)</span> and <span class="math">\(...\circ G_2\circ G_1\)</span>.</li>
<li>If <tt class="docutils literal"><span class="pre">F1.rank</span> <span class="pre">&gt;</span> <span class="pre">G1.rank</span></tt> then we apply <span class="math">\(G_1\)</span> first, and continue with <span class="math">\(...\circ F_2\circ F_1\)</span> and <span class="math">\(...\circ G_3\circ G_2\)</span>.</li>
</ul>
<p>If <tt class="docutils literal"><span class="pre">F1.rank</span> <span class="pre">==</span> <span class="pre">G1.rank</span></tt>, then the tie needs to be broken by other techniques
(see below).</p>
<p>As an illustration, we first get us some functors and then see how chains of
functors are shuffled.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">AlgClos</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">construction</span><span class="p">();</span> <span class="n">AlgClos</span>
<span class="go">AlgebraicClosureFunctor</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Compl</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">RR</span><span class="o">.</span><span class="n">construction</span><span class="p">();</span> <span class="n">Compl</span>
<span class="go">Completion[+Infinity]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Matr</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">MatrixSpace</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">construction</span><span class="p">();</span> <span class="n">Matr</span>
<span class="go">MatrixFunctor</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">AlgClos</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">Compl</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">Fract</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">Poly</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">Matr</span><span class="o">.</span><span class="n">rank</span>
<span class="go">(3, 4, 5, 9, 10)</span>
</pre></div>
</div>
<p>When we apply <tt class="docutils literal"><span class="pre">Fract</span></tt>, <tt class="docutils literal"><span class="pre">AlgClos</span></tt>, <tt class="docutils literal"><span class="pre">Poly</span></tt> and <tt class="docutils literal"><span class="pre">Fract</span></tt> to the ring of
integers, we obtain:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">Fract</span><span class="o">*</span><span class="n">Poly</span><span class="o">*</span><span class="n">AlgClos</span><span class="o">*</span><span class="n">Fract</span><span class="p">)(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Fraction Field of Univariate Polynomial Ring in x over Algebraic Field</span>
</pre></div>
</div>
<p>When we apply <tt class="docutils literal"><span class="pre">Compl</span></tt>, <tt class="docutils literal"><span class="pre">Matr</span></tt> and <tt class="docutils literal"><span class="pre">Poly</span></tt> to the ring of integers, we
obtain:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">Poly</span><span class="o">*</span><span class="n">Matr</span><span class="o">*</span><span class="n">Compl</span><span class="p">)(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Univariate Polynomial Ring in x over Full MatrixSpace of 3 by 3 dense matrices over Real Field with 53 bits of precision</span>
</pre></div>
</div>
<p>Applying the shuffling procedure yields</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">Poly</span><span class="o">*</span><span class="n">Matr</span><span class="o">*</span><span class="n">Fract</span><span class="o">*</span><span class="n">Poly</span><span class="o">*</span><span class="n">AlgClos</span><span class="o">*</span><span class="n">Fract</span><span class="o">*</span><span class="n">Compl</span><span class="p">)(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Univariate Polynomial Ring in x over Full MatrixSpace of 3 by 3 dense matrices over Fraction Field of Univariate Polynomial Ring in x over Complex Field with 53 bits of precision</span>
</pre></div>
</div>
<p>and this is indeed equal to the pushout found by Sage:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pushout</span><span class="p">((</span><span class="n">Fract</span><span class="o">*</span><span class="n">Poly</span><span class="o">*</span><span class="n">AlgClos</span><span class="o">*</span><span class="n">Fract</span><span class="p">)(</span><span class="n">ZZ</span><span class="p">),</span> <span class="p">(</span><span class="n">Poly</span><span class="o">*</span><span class="n">Matr</span><span class="o">*</span><span class="n">Compl</span><span class="p">)(</span><span class="n">ZZ</span><span class="p">))</span>
<span class="go">Univariate Polynomial Ring in x over Full MatrixSpace of 3 by 3 dense matrices over Fraction Field of Univariate Polynomial Ring in x over Complex Field with 53 bits of precision</span>
</pre></div>
</div>
</div>
<div class="section" id="breaking-the-tie">
<h5>Breaking the tie<a class="headerlink" href="#breaking-the-tie" title="Permalink to this headline">¶</a></h5>
<p>If <tt class="docutils literal"><span class="pre">F1.rank==G1.rank</span></tt> then Sage&#8217;s pushout constructions offers two ways to
proceed:</p>
<ol class="arabic simple">
<li>Construction functors have a method <a class="reference external" href="../reference/coercion/sage/categories/pushout.html#sage.categories.pushout.ConstructionFunctor.merge" title="(in Sage Reference Manual: Coercion v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">merge()</span></tt></a> that either returns <tt class="docutils literal"><span class="pre">None</span></tt> or returns a construction functor&#8212;see below. If either <tt class="docutils literal"><span class="pre">F1.merge(G1)</span></tt> or <tt class="docutils literal"><span class="pre">G1.merge(F1)</span></tt> returns a construction functor <span class="math">\(H_1\)</span>, then we apply <span class="math">\(H_1\)</span> and continue with <span class="math">\(...\circ F_3\circ F_2\)</span> and <span class="math">\(...\circ G_3\circ G_2\)</span>.</li>
<li>Construction functors have a method <a class="reference external" href="../reference/coercion/sage/categories/pushout.html#sage.categories.pushout.ConstructionFunctor.commutes" title="(in Sage Reference Manual: Coercion v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">commutes()</span></tt></a>. If either <tt class="docutils literal"><span class="pre">F1.commutes(G1)</span></tt> or <tt class="docutils literal"><span class="pre">G1.commutes(F1)</span></tt> returns <tt class="docutils literal"><span class="pre">True</span></tt>, then we apply both <span class="math">\(F_1\)</span> and <span class="math">\(G_1\)</span> in any order, and continue with <span class="math">\(...\circ F_3\circ F_2\)</span> and <span class="math">\(...\circ G_3\circ G_2\)</span>.</li>
</ol>
<p>By default, <tt class="docutils literal"><span class="pre">F1.merge(G1)</span></tt> returns <tt class="docutils literal"><span class="pre">F1</span></tt> if <tt class="docutils literal"><span class="pre">F1==G1</span></tt>, and returns
<tt class="docutils literal"><span class="pre">None</span></tt> otherwise. The <tt class="docutils literal"><span class="pre">commutes()</span></tt> method exists, but it seems that so far
nobody has implemented two functors of the same rank that commute.</p>
</div>
</div>
<div class="section" id="establishing-a-default-implementation">
<h4>Establishing a default implementation<a class="headerlink" href="#establishing-a-default-implementation" title="Permalink to this headline">¶</a></h4>
<p>The typical application of
<a class="reference external" href="../reference/coercion/sage/categories/pushout.html#sage.categories.pushout.ConstructionFunctor.merge" title="(in Sage Reference Manual: Coercion v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">merge()</span></tt></a> is to provide a
coercion between <em>different implementations</em> of the <em>same algebraic
structure</em>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <tt class="docutils literal"><span class="pre">F1(P)</span></tt> and <tt class="docutils literal"><span class="pre">F2(P)</span></tt> are different implementations of the same thing, then <tt class="docutils literal"><span class="pre">F1.merge(F2)(P)</span></tt> should return the default implementation.</p>
</div>
<p>We want to boldly turn our toy implementation of fraction fields into the new
default implementation. Hence:</p>
<ul class="simple">
<li>Next, we implement a new version of the &#8220;usual&#8221; fraction field functor, having the same rank, but returning our new implementation.</li>
<li>We make our new implementation the default, by virtue of a merge method.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<ul class="last simple">
<li>Do not override the default <tt class="docutils literal"><span class="pre">__call__</span></tt> method of <a class="reference external" href="../reference/coercion/sage/categories/pushout.html#sage.categories.pushout.ConstructionFunctor" title="(in Sage Reference Manual: Coercion v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">ConstructionFunctor</span></tt></a>&#8212;implement <tt class="docutils literal"><span class="pre">_apply_functor</span></tt> instead.</li>
<li>Declare domain and codomain of the functor during initialisation.</li>
</ul>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.pushout</span> <span class="kn">import</span> <span class="n">ConstructionFunctor</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFracFunctor</span><span class="p">(</span><span class="n">ConstructionFunctor</span><span class="p">):</span>
<span class="go">....:     rank = 5</span>
<span class="go">....:     def __init__(self):</span>
<span class="go">....:         ConstructionFunctor.__init__(self, IntegralDomains(), Fields())</span>
<span class="go">....:     def _apply_functor(self, R):</span>
<span class="go">....:         return MyFrac(R)</span>
<span class="go">....:     def merge(self, other):</span>
<span class="go">....:         if isinstance(other, (type(self), sage.categories.pushout.FractionField)):</span>
<span class="go">....:             return self</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MyFracFunctor</span><span class="p">()</span>
<span class="go">MyFracFunctor</span>
</pre></div>
</div>
<p>We verify that our functor can really be used to construct our implementation of fraction fields, and that it can be merged with either itself or the usual fraction field constructor:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MyFracFunctor</span><span class="p">()(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">NewFrac(Integer Ring)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MyFracFunctor</span><span class="p">()</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">MyFracFunctor</span><span class="p">())</span>
<span class="go">MyFracFunctor</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MyFracFunctor</span><span class="p">()</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">Fract</span><span class="p">)</span>
<span class="go">MyFracFunctor</span>
</pre></div>
</div>
<p>There remains to let our new fraction fields know about the new construction functor:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFrac</span><span class="p">(</span><span class="n">MyFrac</span><span class="p">):</span>
<span class="go">....:     def construction(self):</span>
<span class="go">....:         return MyFracFunctor(), self.base()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">construction</span><span class="p">()</span>
<span class="go">(MyFracFunctor, Univariate Polynomial Ring in x over Integer Ring)</span>
</pre></div>
</div>
<p>Due to merging, we have:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pushout</span><span class="p">(</span><span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]),</span> <span class="n">Frac</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]))</span>
<span class="go">NewFrac(Univariate Polynomial Ring in x over Rational Field)</span>
</pre></div>
</div>
</div>
<div class="section" id="a-second-note-on-performance">
<h4>A second note on performance<a class="headerlink" href="#a-second-note-on-performance" title="Permalink to this headline">¶</a></h4>
<p>Being able to do arithmetics involving elements of different parents, with the
automatic creation of a pushout to contain the result, is certainly
convenient&#8212;but one should not rely on it, if speed matters. Simply the
conversion of elements into different parents takes time. Moreover, by
<a class="reference external" href="http://trac.sagemath.org/14058">trac ticket #14058</a>, the pushout may be subject to Python&#8217;s cyclic garbage
collection. Hence, if one does not keep a strong reference to it, the same
parent may be created repeatedly, which is a waste of time. In the following
example, we illustrate the slow&#8211;down resulting from blindly relying on
coercion:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ZZxy</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">ZZxy</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="n">timeit</span><span class="p">(</span><span class="s2">&quot;c = a+b&quot;</span><span class="p">)</span>    <span class="c1"># random</span>
<span class="go">10000 loops, best of 3: 172 us per loop</span>
<span class="gp">sage: </span><span class="n">QQxy</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">timeit</span><span class="p">(</span><span class="s2">&quot;c2 = QQxy(a)+QQxy(b)&quot;</span><span class="p">)</span> <span class="c1"># random</span>
<span class="go">10000 loops, best of 3: 168 us per loop</span>
<span class="gp">sage: </span><span class="n">a2</span> <span class="o">=</span> <span class="n">QQxy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b2</span> <span class="o">=</span> <span class="n">QQxy</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">timeit</span><span class="p">(</span><span class="s2">&quot;c2 = a2+b2&quot;</span><span class="p">)</span> <span class="c1"># random</span>
<span class="go">100000 loops, best of 3: 10.5 us per loop</span>
</pre></div>
</div>
<p>Hence, if one avoids the explicit or implicit conversion into the pushout, but
works in the pushout right away, one can get a more than 10&#8211;fold speed&#8211;up.</p>
</div>
</div>
<div class="section" id="the-test-suites-of-the-category-framework">
<h3><a class="toc-backref" href="#id8">The test suites of the category framework</a><a class="headerlink" href="#the-test-suites-of-the-category-framework" title="Permalink to this headline">¶</a></h3>
<p>The category framework does not only provide functionality but also a test
framework. This section logically belongs to the section on categories, but
without the bits that we have implemented in the section on coercion, our
implementation of fraction fields would not have passed the tests yet.</p>
<div class="section" id="abstract-methods">
<h4>&#8220;Abstract&#8221; methods<a class="headerlink" href="#abstract-methods" title="Permalink to this headline">¶</a></h4>
<p>We have already seen above that a category can require/suggest certain parent
or element methods, that the user must/should implement. This is in order to
smoothly blend with the methods that already exist in Sage.</p>
<p>The methods that ought to be provided are called
<a class="reference external" href="../reference/misc/sage/misc/abstract_method.html#sage.misc.abstract_method.abstract_method" title="(in Sage Reference Manual: Utilities v7.1)"><tt class="xref py py-func docutils literal"><span class="pre">abstract_method()</span></tt></a>. Let us see what methods
are needed for quotient fields and their elements:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.misc.abstract_method</span> <span class="kn">import</span> <span class="n">abstract_methods_of_class</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">abstract_methods_of_class</span><span class="p">(</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="p">)[</span><span class="s1">&#39;optional&#39;</span><span class="p">]</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">abstract_methods_of_class</span><span class="p">(</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="p">)[</span><span class="s1">&#39;required&#39;</span><span class="p">]</span>
<span class="go">[&#39;__contains__&#39;]</span>
</pre></div>
</div>
<p>Hence, the only required method (that is actually required for all parents
that belong to the category of sets) is an element containment test. That&#8217;s
fine, because the base class <a class="reference external" href="../reference/structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage Reference Manual: Basic Structures v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">Parent</span></tt></a> provides a
default containment test.</p>
<p>The elements have to provide more:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">abstract_methods_of_class</span><span class="p">(</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span><span class="p">)[</span><span class="s1">&#39;optional&#39;</span><span class="p">]</span>
<span class="go">[&#39;_add_&#39;, &#39;_mul_&#39;]</span>
<span class="gp">sage: </span><span class="n">abstract_methods_of_class</span><span class="p">(</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span><span class="p">)[</span><span class="s1">&#39;required&#39;</span><span class="p">]</span>
<span class="go">[&#39;__nonzero__&#39;, &#39;denominator&#39;, &#39;numerator&#39;]</span>
</pre></div>
</div>
<p>Hence, the elements must provide <tt class="docutils literal"><span class="pre">denominator()</span></tt> and <tt class="docutils literal"><span class="pre">numerator()</span></tt>
methods, and must be able to tell whether they are zero or not. The base class
<a class="reference external" href="../reference/structure/sage/structure/element.html#sage.structure.element.Element" title="(in Sage Reference Manual: Basic Structures v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">Element</span></tt></a> provides a default <tt class="docutils literal"><span class="pre">__nonzero__()</span></tt>
method. In addition, the elements may provide Sage&#8217;s single underscore
arithmetic methods (actually any ring element <em>should</em> provide them).</p>
</div>
<div class="section" id="the-test-methods">
<h4>The <tt class="docutils literal"><span class="pre">_test_...</span></tt> methods<a class="headerlink" href="#the-test-methods" title="Permalink to this headline">¶</a></h4>
<p>If a parent or element method&#8217;s name start with &#8220;_test_&#8221;, it gives rise to a
test in the automatic test suite. For example, it is tested</p>
<ul class="simple">
<li>whether a parent <span class="math">\(P\)</span> actually is an instance of the parent class of the category of <span class="math">\(P\)</span>,</li>
<li>whether the user has implemented the required abstract methods,</li>
<li>whether some defining structural properties (e.g., commutativity) hold.</li>
</ul>
<p>For example, if one forgets to implement required methods, one obtains the
following error:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">Parent</span><span class="p">):</span>
<span class="go">....:  Element = sage.structure.element.Element</span>
<span class="go">....:  def __init__(self):</span>
<span class="go">....:      Parent.__init__(self, category=QuotientFields())</span>
<span class="gp">sage: </span><span class="n">Bar</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="n">Bar</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bar</span><span class="o">.</span><span class="n">_test_not_implemented_methods</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AssertionError</span>: <span class="n">Not implemented method: denominator</span>
</pre></div>
</div>
<p>Here are the tests that form the test suite of quotient fields:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="p">)</span> <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_test_&#39;</span><span class="p">)]</span>
<span class="go">[&#39;_test_additive_associativity&#39;,</span>
<span class="go"> &#39;_test_an_element&#39;,</span>
<span class="go"> &#39;_test_associativity&#39;,</span>
<span class="go"> &#39;_test_cardinality&#39;,</span>
<span class="go"> &#39;_test_characteristic&#39;,</span>
<span class="go"> &#39;_test_characteristic_fields&#39;,</span>
<span class="go"> &#39;_test_distributivity&#39;,</span>
<span class="go"> &#39;_test_elements&#39;,</span>
<span class="go"> &#39;_test_elements_eq_reflexive&#39;,</span>
<span class="go"> &#39;_test_elements_eq_symmetric&#39;,</span>
<span class="go"> &#39;_test_elements_eq_transitive&#39;,</span>
<span class="go"> &#39;_test_elements_neq&#39;,</span>
<span class="go"> &#39;_test_euclidean_degree&#39;,</span>
<span class="go"> &#39;_test_gcd_vs_xgcd&#39;,</span>
<span class="go"> &#39;_test_one&#39;, &#39;_test_prod&#39;,</span>
<span class="go"> &#39;_test_quo_rem&#39;,</span>
<span class="go"> &#39;_test_some_elements&#39;,</span>
<span class="go"> &#39;_test_zero&#39;,</span>
<span class="go"> &#39;_test_zero_divisors&#39;]</span>
</pre></div>
</div>
<p>We have implemented all abstract methods (or inherit them from base classes),
we use the category framework, and we have implemented coercions. So, we are
confident that the test suite runs without an error. In fact, it does!</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The following trick with the <tt class="docutils literal"><span class="pre">__main__</span></tt> module is only needed in
doctests, not in an interactive session or when defining the classes
externally.</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">MyFrac</span> <span class="o">=</span> <span class="n">MyFrac</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">MyElement</span> <span class="o">=</span> <span class="n">MyElement</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>Let us see what tests are actually performed:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">running ._test_additive_associativity() . . . pass</span>
<span class="go">running ._test_an_element() . . . pass</span>
<span class="go">running ._test_associativity() . . . pass</span>
<span class="go">running ._test_cardinality() . . . pass</span>
<span class="go">running ._test_category() . . . pass</span>
<span class="go">running ._test_characteristic() . . . pass</span>
<span class="go">running ._test_characteristic_fields() . . . pass</span>
<span class="go">running ._test_distributivity() . . . pass</span>
<span class="go">running ._test_elements() . . .</span>
<span class="go">  Running the test suite of self.an_element()</span>
<span class="go">  running ._test_category() . . . pass</span>
<span class="go">  running ._test_eq() . . . pass</span>
<span class="go">  running ._test_nonzero_equal() . . . pass</span>
<span class="go">  running ._test_not_implemented_methods() . . . pass</span>
<span class="go">  running ._test_pickling() . . . pass</span>
<span class="go">  pass</span>
<span class="go">running ._test_elements_eq_reflexive() . . . pass</span>
<span class="go">running ._test_elements_eq_symmetric() . . . pass</span>
<span class="go">running ._test_elements_eq_transitive() . . . pass</span>
<span class="go">running ._test_elements_neq() . . . pass</span>
<span class="go">running ._test_eq() . . . pass</span>
<span class="go">running ._test_euclidean_degree() . . . pass</span>
<span class="go">running ._test_gcd_vs_xgcd() . . . pass</span>
<span class="go">running ._test_not_implemented_methods() . . . pass</span>
<span class="go">running ._test_one() . . . pass</span>
<span class="go">running ._test_pickling() . . . pass</span>
<span class="go">running ._test_prod() . . . pass</span>
<span class="go">running ._test_quo_rem() . . . pass</span>
<span class="go">running ._test_some_elements() . . . pass</span>
<span class="go">running ._test_zero() . . . pass</span>
<span class="go">running ._test_zero_divisors() . . . pass</span>
</pre></div>
</div>
</div>
<div class="section" id="implementing-a-new-category-with-additional-tests">
<h4>Implementing a new category with additional tests<a class="headerlink" href="#implementing-a-new-category-with-additional-tests" title="Permalink to this headline">¶</a></h4>
<p>As one can see, tests are also performed on elements. There are methods that
return one element or a list of some elements, relying on &#8220;typical&#8221; elements
that can be found in most algebraic structures.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">P</span><span class="o">.</span><span class="n">some_elements</span><span class="p">()</span>
<span class="go">(2):(1)</span>
<span class="go">[(2):(1)]</span>
</pre></div>
</div>
<p>Unfortunately, the list of elements that is returned by the default method is
of length one, and that single element could also be a bit more interesting.
The method an_element relies on a method <tt class="docutils literal"><span class="pre">_an_element_()</span></tt>, so, we implement
that. We also override the some_elements method.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFrac</span><span class="p">(</span><span class="n">MyFrac</span><span class="p">):</span>
<span class="go">....:     def _an_element_(self):</span>
<span class="go">....:         a = self.base().an_element()</span>
<span class="go">....:         b = self.base_ring().an_element()</span>
<span class="go">....:         if (a+b)!=0:</span>
<span class="go">....:             return self(a)**2/(self(a+b)**3)</span>
<span class="go">....:         if b != 0:</span>
<span class="go">....:             return self(a)/self(b)**2</span>
<span class="go">....:         return self(a)**2*self(b)**3</span>
<span class="go">....:     def some_elements(self):</span>
<span class="go">....:         return [self.an_element(),self(self.base().an_element()),self(self.base_ring().an_element())]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">P</span><span class="o">.</span><span class="n">some_elements</span><span class="p">()</span>
<span class="go">(x^2):(x^3 + 3*x^2 + 3*x + 1)</span>
<span class="go">[(x^2):(x^3 + 3*x^2 + 3*x + 1), (x):(1), (1):(1)]</span>
</pre></div>
</div>
<p>Now, as we have more interesting elements, we may also add a test for the
&#8220;factor&#8221; method. Recall that the method was inherited from the category, but
it appears that it is not tested.</p>
<p>Normally, a test for a method defined by a category should be provided by the
same category. Hence, since <tt class="docutils literal"><span class="pre">factor</span></tt> is defined in the category of quotient
fields, a test should be added there. But we won&#8217;t change source code here and
will instead create a sub&#8211;category.</p>
<p>Apparently, If <span class="math">\(e\)</span> is an element of a quotient field, the product of the
factors returned by <tt class="docutils literal"><span class="pre">e.factor()</span></tt> should be equal to <span class="math">\(e\)</span>. For forming the
product, we use the <tt class="docutils literal"><span class="pre">prod</span></tt> method, that, no surprise, is inherited from
another category:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">prod</span><span class="o">.</span><span class="n">__module__</span>
<span class="go">&#39;sage.categories.monoids&#39;</span>
</pre></div>
</div>
<p>When we want to create a sub&#8211;category, we need to provide a method
<a class="reference external" href="../reference/categories/sage/categories/category.html#sage.categories.category.Category.super_categories" title="(in Sage Reference Manual: Category Framework v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">super_categories()</span></tt></a>, that returns a
list of all immediate super categories (here: category of quotient fields).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">A sub&#8211;category <span class="math">\(S\)</span> of a category <span class="math">\(C\)</span> is <em>not</em> implemented as a
sub&#8211;class of <tt class="docutils literal"><span class="pre">C.__class__</span></tt>! <span class="math">\(S\)</span> becomes a sub&#8211;category of <span class="math">\(C\)</span> only
if <tt class="docutils literal"><span class="pre">S.super_categories()</span></tt> returns (a sub&#8211;category of) <span class="math">\(C\)</span>!</p>
</div>
<p>The parent and element methods of a category are provided as methods of
classes that are the attributes <tt class="docutils literal"><span class="pre">ParentMethods</span></tt> and <tt class="docutils literal"><span class="pre">Element</span> <span class="pre">Methods</span></tt> of
the category, as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.category</span> <span class="kn">import</span> <span class="n">Category</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">QuotientFieldsWithTest</span><span class="p">(</span><span class="n">Category</span><span class="p">):</span> <span class="c1"># do *not* inherit from QuotientFields, but ...</span>
<span class="go">....:     def super_categories(self):</span>
<span class="go">....:         return [QuotientFields()]       # ... declare QuotientFields as a super category!</span>
<span class="go">....:     class ParentMethods:</span>
<span class="go">....:         pass</span>
<span class="go">....:     class ElementMethods:</span>
<span class="go">....:         def _test_factorisation(self, **options):</span>
<span class="go">....:             P = self.parent()</span>
<span class="go">....:             assert self == P.prod([P(b)**e for b,e in self.factor()])</span>
</pre></div>
</div>
<p>We provide an instance of our quotient field implementation with that new
category. Note that categories have a default <tt class="docutils literal"><span class="pre">_repr_</span></tt> method, that guesses
a good string representation from the name of the class:
<tt class="docutils literal"><span class="pre">QuotientFieldsWithTest</span></tt> becomes &#8220;quotient fields with test&#8221;.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The following trick with the <tt class="docutils literal"><span class="pre">__main__</span></tt> module is only needed in
doctests, not in an interactive session or when defining the classes
externally.</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">MyFrac</span> <span class="o">=</span> <span class="n">MyFrac</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">MyElement</span> <span class="o">=</span> <span class="n">MyElement</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">QuotientFieldsWithTest</span> <span class="o">=</span> <span class="n">QuotientFieldsWithTest</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">category</span><span class="o">=</span><span class="n">QuotientFieldsWithTest</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of quotient fields with test</span>
</pre></div>
</div>
<p>The new test is inherited from the category. Since <tt class="docutils literal"><span class="pre">an_element()</span></tt> is returning a
complicated element, <tt class="docutils literal"><span class="pre">_test_factorisation</span></tt> is a serious test:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span><span class="o">.</span><span class="n">_test_factorisation</span>
<span class="go">&lt;bound method MyFrac_with_category.element_class._test_factorisation of (x^2):(x^3 + 3*x^2 + 3*x + 1)&gt;</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x + 1)^-3 * x^2</span>
</pre></div>
</div>
<p>Last, we observe that the new test has automatically become part of the test
suite. We remark that the existing tests became more serious as well, since we
made <a class="reference external" href="../reference/structure/sage/structure/parent.html#sage.structure.parent.Parent.an_element" title="(in Sage Reference Manual: Basic Structures v7.1)"><tt class="xref py py-meth docutils literal"><span class="pre">sage.structure.parent.Parent.an_element()</span></tt></a> return something more
interesting.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">running ._test_additive_associativity() . . . pass</span>
<span class="go">running ._test_an_element() . . . pass</span>
<span class="go">running ._test_associativity() . . . pass</span>
<span class="go">running ._test_cardinality() . . . pass</span>
<span class="go">running ._test_category() . . . pass</span>
<span class="go">running ._test_characteristic() . . . pass</span>
<span class="go">running ._test_characteristic_fields() . . . pass</span>
<span class="go">running ._test_distributivity() . . . pass</span>
<span class="go">running ._test_elements() . . .</span>
<span class="go">  Running the test suite of self.an_element()</span>
<span class="go">  running ._test_category() . . . pass</span>
<span class="go">  running ._test_eq() . . . pass</span>
<span class="go">  running ._test_factorisation() . . . pass</span>
<span class="go">  running ._test_nonzero_equal() . . . pass</span>
<span class="go">  running ._test_not_implemented_methods() . . . pass</span>
<span class="go">  running ._test_pickling() . . . pass</span>
<span class="go">  pass</span>
<span class="go">running ._test_elements_eq_reflexive() . . . pass</span>
<span class="go">running ._test_elements_eq_symmetric() . . . pass</span>
<span class="go">running ._test_elements_eq_transitive() . . . pass</span>
<span class="go">running ._test_elements_neq() . . . pass</span>
<span class="go">running ._test_eq() . . . pass</span>
<span class="go">running ._test_euclidean_degree() . . . pass</span>
<span class="go">running ._test_gcd_vs_xgcd() . . . pass</span>
<span class="go">running ._test_not_implemented_methods() . . . pass</span>
<span class="go">running ._test_one() . . . pass</span>
<span class="go">running ._test_pickling() . . . pass</span>
<span class="go">running ._test_prod() . . . pass</span>
<span class="go">running ._test_quo_rem() . . . pass</span>
<span class="go">running ._test_some_elements() . . . pass</span>
<span class="go">running ._test_zero() . . . pass</span>
<span class="go">running ._test_zero_divisors() . . . pass</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="appendix-the-complete-code">
<h3><a class="toc-backref" href="#id9">Appendix: The complete code</a><a class="headerlink" href="#appendix-the-complete-code" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># Importing base classes, ...</span>
<span class="kn">import</span> <span class="nn">sage</span>
<span class="kn">from</span> <span class="nn">sage.rings.ring</span> <span class="kn">import</span> <span class="n">Field</span>
<span class="kn">from</span> <span class="nn">sage.structure.element</span> <span class="kn">import</span> <span class="n">FieldElement</span>
<span class="kn">from</span> <span class="nn">sage.categories.category</span> <span class="kn">import</span> <span class="n">Category</span>
<span class="c1"># ... the UniqueRepresentation tool,</span>
<span class="kn">from</span> <span class="nn">sage.structure.unique_representation</span> <span class="kn">import</span> <span class="n">UniqueRepresentation</span>
<span class="c1"># ... some categories, and ...</span>
<span class="kn">from</span> <span class="nn">sage.categories.fields</span> <span class="kn">import</span> <span class="n">Fields</span>
<span class="kn">from</span> <span class="nn">sage.categories.quotient_fields</span> <span class="kn">import</span> <span class="n">QuotientFields</span>
<span class="kn">from</span> <span class="nn">sage.categories.integral_domains</span> <span class="kn">import</span> <span class="n">IntegralDomains</span>
<span class="c1"># construction functors</span>
<span class="kn">from</span> <span class="nn">sage.categories.pushout</span> <span class="kn">import</span> <span class="n">ConstructionFunctor</span>

<span class="c1"># Fraction field elements</span>
<span class="k">class</span> <span class="nc">MyElement</span><span class="p">(</span><span class="n">FieldElement</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The parent must be provided&quot;</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">base</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># The default denominator is one</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
        <span class="c1"># verify that both numerator and denominator belong to the base</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">B</span> <span class="ow">or</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">B</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Numerator and denominator must be elements of </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">B</span><span class="p">)</span>
        <span class="c1"># Numerator and denominator should not just be &quot;in&quot; B,</span>
        <span class="c1"># but should be defined as elements of B</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="c1"># the denominator must not be zero</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s2">&quot;The denominator must not be zero&quot;</span><span class="p">)</span>
        <span class="c1"># normalize the denominator: WLOG, it shall be non-negative.</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">d</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">d</span>
        <span class="n">FieldElement</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">parent</span><span class="p">)</span>

    <span class="c1"># Methods required by the category of fraction fields:</span>
    <span class="k">def</span> <span class="nf">numerator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
    <span class="k">def</span> <span class="nf">denominator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span>

    <span class="c1"># String representation (single underscore!)</span>
    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">):(</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>

    <span class="c1"># Comparison: We can assume that both arguments are coerced</span>
    <span class="c1"># into the same parent, which is a fraction field. Hence, we</span>
    <span class="c1"># are allowed to use the denominator() and numerator() methods</span>
    <span class="c1"># on the second argument.</span>
    <span class="k">def</span> <span class="nf">_cmp_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">numerator</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>

    <span class="c1"># Support for cmp() (in this example, we don&#39;t define __hash__</span>
    <span class="c1"># so this is not strictly needed)</span>
    <span class="n">__cmp__</span> <span class="o">=</span> <span class="n">_cmp_</span>

    <span class="c1"># Arithmetic methods, single underscore. We can assume that both</span>
    <span class="c1"># arguments are coerced into the same parent.</span>
    <span class="c1"># We return instances of self.__class__, because self.__class__ will</span>
    <span class="c1"># eventually be a sub-class of MyElement.</span>
    <span class="k">def</span> <span class="nf">_add_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span>
        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">C</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">numerator</span><span class="p">(),</span><span class="n">D</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_sub_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span>
        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">C</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">numerator</span><span class="p">(),</span><span class="n">D</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_mul_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span>
        <span class="k">return</span> <span class="n">C</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">numerator</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">())</span>
    <span class="k">def</span> <span class="nf">_div_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span>
        <span class="k">return</span> <span class="n">C</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">numerator</span><span class="p">())</span>

<span class="c1"># Inheritance from UniqueRepresentation implements the unique parent</span>
<span class="c1"># behaviour. Moreover, it implements pickling (provided that Python</span>
<span class="c1"># succeeds to look up the class definition).</span>
<span class="k">class</span> <span class="nc">MyFrac</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="n">Field</span><span class="p">):</span>
    <span class="c1"># Implement the category framework for elements, which also</span>
    <span class="c1"># makes some basic conversions work.</span>
    <span class="n">Element</span> <span class="o">=</span> <span class="n">MyElement</span>

    <span class="c1"># Allow to pass to a different category, by an optional argument</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c1"># Fraction fields only exist for integral domains</span>
        <span class="k">if</span> <span class="n">base</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">IntegralDomains</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is no integral domain&quot;</span><span class="o">%</span><span class="n">base</span>
        <span class="c1"># Implement the category framework for the parent</span>
        <span class="n">Field</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">category</span> <span class="ow">or</span> <span class="n">QuotientFields</span><span class="p">())</span>

    <span class="c1"># Single-underscore method for string representation</span>
    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;NewFrac(</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">())</span>

    <span class="c1"># Two methods that are implicitly used in some tests</span>
    <span class="k">def</span> <span class="nf">base_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">characteristic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">characteristic</span><span class="p">()</span>

    <span class="c1"># Implement conversions. Do not override __call__!</span>
    <span class="k">def</span> <span class="nf">_element_constructor_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
           <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">QuotientFields</span><span class="p">()</span> <span class="ow">and</span> <span class="n">P</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">numerator</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">denominator</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="c1"># Implement coercion from the base and from fraction fields</span>
    <span class="c1"># over a ring that coerces into the base</span>
    <span class="k">def</span> <span class="nf">_coerce_map_from_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">QuotientFields</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">base</span><span class="p">()):</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="s1">&#39;ring_of_integers&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">ring_of_integers</span><span class="p">()):</span>
                <span class="k">return</span> <span class="bp">True</span>
    <span class="c1"># Tell how this parent was constructed, in order to enable pushout constructions</span>
    <span class="k">def</span> <span class="nf">construction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">MyFracFunctor</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span>

    <span class="c1"># return some elements of this parent</span>
    <span class="k">def</span> <span class="nf">_an_element_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>
    <span class="k">def</span> <span class="nf">some_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">an_element</span><span class="p">(),</span><span class="bp">self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">an_element</span><span class="p">()),</span><span class="bp">self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">an_element</span><span class="p">())]</span>


<span class="c1"># A construction functor for our implementation of fraction fields</span>
<span class="k">class</span> <span class="nc">MyFracFunctor</span><span class="p">(</span><span class="n">ConstructionFunctor</span><span class="p">):</span>
    <span class="c1"># The rank is the same for Sage&#39;s original fraction field functor</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The fraction field construction is a functor</span>
        <span class="c1"># from the category of integral domains into the category of</span>
        <span class="c1"># fields</span>
        <span class="c1"># NOTE: We could actually narrow the codomain and use the</span>
        <span class="c1"># category QuotientFields()</span>
        <span class="n">ConstructionFunctor</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IntegralDomains</span><span class="p">(),</span> <span class="n">Fields</span><span class="p">())</span>
    <span class="c1"># Applying the functor to an object. Do not override __call__!</span>
    <span class="k">def</span> <span class="nf">_apply_functor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="c1"># Note: To apply the functor to morphisms, implement</span>
    <span class="c1">#       _apply_functor_to_morphism</span>

    <span class="c1"># Make sure that arithmetic involving elements of Frac(R) and</span>
    <span class="c1"># MyFrac(R) works and yields elements of MyFrac(R)</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">pushout</span><span class="o">.</span><span class="n">FractionField</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span>

<span class="c1"># A quotient field category with additional tests.</span>
<span class="c1"># Notes:</span>
<span class="c1"># - Category inherits from UniqueRepresentation. Hence, there</span>
<span class="c1">#   is only one category for given arguments.</span>
<span class="c1"># - Since QuotientFieldsWithTest is a singleton (there is only</span>
<span class="c1">#   one instance of this class), we could inherit from</span>
<span class="c1">#   sage.categories.category_singleton.Category_singleton</span>
<span class="c1">#   rather than from sage.categories.category.Category</span>
<span class="k">class</span> <span class="nc">QuotientFieldsWithTest</span><span class="p">(</span><span class="n">Category</span><span class="p">):</span>
    <span class="c1"># Our category is a sub-category of the category of quotient fields,</span>
    <span class="c1"># by means of the following method.</span>
    <span class="k">def</span> <span class="nf">super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">QuotientFields</span><span class="p">()]</span>

    <span class="c1"># Here, we could implement methods that are available for</span>
    <span class="c1"># all objects in this category.</span>
    <span class="k">class</span> <span class="nc">ParentMethods</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># Here, we add a new test that is available for all elements</span>
    <span class="c1"># of any object in this category.</span>
    <span class="k">class</span> <span class="nc">ElementMethods</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">_test_factorisation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
            <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
            <span class="c1"># The methods prod() and factor() are inherited from</span>
            <span class="c1"># some other categories.</span>
            <span class="k">assert</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="n">P</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">e</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">()])</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">How to implement new algebraic structures in Sage</a><ul>
<li><a class="reference internal" href="#sage-s-category-and-coercion-framework">Sage&#8217;s category and coercion framework</a><ul>
<li><a class="reference internal" href="#outline">Outline</a></li>
<li><a class="reference internal" href="#base-classes">Base classes</a><ul>
<li><a class="reference internal" href="#the-parent">The parent</a></li>
<li><a class="reference internal" href="#the-elements">The elements</a><ul>
<li><a class="reference internal" href="#features-and-limitations-of-the-basic-implementation">Features and limitations of the basic implementation</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#categories-in-sage">Categories in Sage</a><ul>
<li><a class="reference internal" href="#why-should-one-choose-a-category">Why should one choose a category?</a><ul>
<li><a class="reference internal" href="#how-does-the-category-framework-work">How does the  <em>category framework</em> work?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementing-the-category-framework-for-the-parent">Implementing the category framework for the parent</a></li>
<li><a class="reference internal" href="#implementing-the-category-framework-for-the-elements">Implementing the category framework for the elements</a><ul>
<li><a class="reference internal" href="#what-did-happen-behind-the-scenes-to-make-this-work">What did happen behind the scenes to make this work?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-first-note-on-performance">A first note on performance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coercion-the-basics">Coercion&#8212;the basics</a><ul>
<li><a class="reference internal" href="#theoretical-background">Theoretical background</a><ul>
<li><a class="reference internal" href="#coercion-is-not-just-type-conversion">Coercion is not just <em>type conversion</em></a></li>
<li><a class="reference internal" href="#not-every-conversion-is-a-coercion">Not every conversion is a coercion</a><ul>
<li><a class="reference internal" href="#the-four-axioms-requested-for-coercions">The four axioms requested for coercions</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#implementing-a-conversion">Implementing a conversion</a></li>
<li><a class="reference internal" href="#establishing-a-coercion">Establishing a coercion</a><ul>
<li><a class="reference internal" href="#equality-and-element-containment">Equality and element containment</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#coercion-the-advanced-parts">Coercion&#8212;the advanced parts</a><ul>
<li><a class="reference internal" href="#the-pushout-of-construction-functors">The pushout of construction functors</a><ul>
<li><a class="reference internal" href="#shuffling-composite-construction-functors">Shuffling composite construction functors</a></li>
<li><a class="reference internal" href="#breaking-the-tie">Breaking the tie</a></li>
</ul>
</li>
<li><a class="reference internal" href="#establishing-a-default-implementation">Establishing a default implementation</a></li>
<li><a class="reference internal" href="#a-second-note-on-performance">A second note on performance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-test-suites-of-the-category-framework">The test suites of the category framework</a><ul>
<li><a class="reference internal" href="#abstract-methods">&#8220;Abstract&#8221; methods</a></li>
<li><a class="reference internal" href="#the-test-methods">The <tt class="docutils literal"><span class="pre">_test_...</span></tt> methods</a></li>
<li><a class="reference internal" href="#implementing-a-new-category-with-additional-tests">Implementing a new category with additional tests</a></li>
</ul>
</li>
<li><a class="reference internal" href="#appendix-the-complete-code">Appendix: The complete code</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="functional_programming.html"
                                  title="previous chapter">Functional Programming for Mathematicians</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="cython_interface.html"
                                  title="next chapter">How to call a C code (or a compiled library) from Sage ?</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/coercion_and_categories.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <!-- The shading of the "Go" button should be consistent -->
                <!-- with the colour of the header and footer. See the file -->
                <!-- doc/common/themes/sage/theme.conf for colours used by -->
                <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="cython_interface.html" title="How to call a C code (or a compiled library) from Sage ?"
             >next</a> |</li>
        <li class="right" >
          <a href="functional_programming.html" title="Functional Programming for Mathematicians"
             >previous</a> |</li>
  
    
      <a href="../index.html"><img src="_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="index.html">Thematic Tutorials v7.1</a> &raquo;</li>

          <li><a href="toctree.html" >Thematic tutorial document tree</a> &raquo;</li> 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2016, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>