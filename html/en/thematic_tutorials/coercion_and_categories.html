
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>How to implement new algebraic structures in Sage &#8212; Thematic Tutorials</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sage.css" />
    <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="_static/thebelab.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script async="async" src="_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Tutorial: Implementing Algebraic Structures" href="tutorial-implementing-algebraic-structures.html" />
    <link rel="prev" title="Functional Programming for Mathematicians" href="functional_programming.html" />
  <link rel="icon" href="_static/sageicon.png" type="image/x-icon" />
  <!-- <script src="_static/thebe.js" type="text/javascript"></script> -->
  <!-- <script src="_static/thebe-sage.js" type="text/javascript"></script> -->

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="tutorial-implementing-algebraic-structures.html" title="Tutorial: Implementing Algebraic Structures"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="functional_programming.html" title="Functional Programming for Mathematicians"
             accesskey="P">previous</a> |</li>
  <li class="nav-item nav-item-0">
    <a href="http://www.sagemath.org"><img src="_static/logo_sagemath_black.svg" class="sage-logo" title="Sage Logo"></a>
    
      <a href="../index.html">Sage 9.6 Documentation</a> &#187;
      
      <a href="index.html">Thematic Tutorials</a> &#187;
    
  </li>

          <li class="nav-item nav-item-1"><a href="toctree.html" accesskey="U">Thematic tutorial document tree</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">How to implement new algebraic structures in Sage</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="how-to-implement-new-algebraic-structures-in-sage">
<span id="coercion-and-categories"></span><h1><a class="toc-backref" href="#id1">How to implement new algebraic structures in Sage</a><a class="headerlink" href="#how-to-implement-new-algebraic-structures-in-sage" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#how-to-implement-new-algebraic-structures-in-sage" id="id1">How to implement new algebraic structures in Sage</a></p>
<ul>
<li><p><a class="reference internal" href="#sage-s-category-and-coercion-framework" id="id2">Sage’s category and coercion framework</a></p>
<ul>
<li><p><a class="reference internal" href="#outline" id="id3">Outline</a></p></li>
<li><p><a class="reference internal" href="#base-classes" id="id4">Base classes</a></p></li>
<li><p><a class="reference internal" href="#categories-in-sage" id="id5">Categories in Sage</a></p></li>
<li><p><a class="reference internal" href="#coercion-the-basics" id="id6">Coercion-–the basics</a></p></li>
<li><p><a class="reference internal" href="#coercion-the-advanced-parts" id="id7">Coercion-–the advanced parts</a></p></li>
<li><p><a class="reference internal" href="#the-test-suites-of-the-category-framework" id="id8">The test suites of the category framework</a></p></li>
<li><p><a class="reference internal" href="#appendix-the-complete-code" id="id9">Appendix: The complete code</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<section id="sage-s-category-and-coercion-framework">
<h2><a class="toc-backref" href="#id2">Sage’s category and coercion framework</a><a class="headerlink" href="#sage-s-category-and-coercion-framework" title="Permalink to this headline">¶</a></h2>
<p><em>Author: Simon King,
Friedrich--Schiller--Universität Jena,
&lt;<a class="reference external" href="mailto:simon&#46;king&#37;&#52;&#48;uni-jena&#46;de">simon<span>&#46;</span>king<span>&#64;</span>uni-jena<span>&#46;</span>de</a>&gt;
© 2011/2013</em></p>
<p>The aim of this tutorial is to explain how one can benefit from Sage’s
category framework and coercion model when implementing new algebraic
structures. It is based on a worksheet created in 2011.</p>
<p>We illustrate the concepts of Sage’s category framework and coercion model by
means of a detailed example, namely a toy implementation of fraction fields.
The code is developed step by step, so that the reader can focus on one detail
in each part of this tutorial. The complete code can be found in the appendix.</p>
<section id="outline">
<h3><a class="toc-backref" href="#id3">Outline</a><a class="headerlink" href="#outline" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>Use existing base classes</p>
<p>For using Sage’s coercion system, it is essential to work with sub--classes
of <a class="reference external" href="../reference/structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Parents and Elements v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.parent.Parent</span></code></a> or
<a class="reference external" href="../reference/structure/sage/structure/element.html#sage.structure.element.Element" title="(in Parents and Elements v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.element.Element</span></code></a>, respectively. They provide default
implementations of many “magical” double-underscore Python methods, which
must not be overridden. Instead, the actual implementation should be in
<em>single underscore</em> methods, such as <code class="docutils literal notranslate"><span class="pre">_add_</span></code> or <code class="docutils literal notranslate"><span class="pre">_mul_</span></code>.</p>
</li>
<li><p>Turn your parent structure into an object of a category</p>
<p>Declare the category during initialisation-–Your parent structure will
inherit further useful methods and consistency tests.</p>
</li>
<li><p>Provide your parent structure with an element class</p>
<p>Assign to it an attribute called <code class="docutils literal notranslate"><span class="pre">Element</span></code>-–The elements will inherit
further useful methods from the category. In addition, some basic
conversions will immediately work.</p>
</li>
<li><p>Implement further conversions</p>
<p>Never override a parent’s <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method! Provide the method
<code class="docutils literal notranslate"><span class="pre">_element_constructor_</span></code> instead.</p>
</li>
<li><p>Declare coercions</p>
<p>If a conversion happens to be a morphism, you may consider to turn it into a
coercion. It will then <em>implicitly</em> be used in arithmetic operations.</p>
</li>
<li><p>Advanced coercion:  Define construction functors for your parent structure</p>
<p>Sage will automatically create new parents for you when needed, by the
so--called <a class="reference external" href="../reference/categories/sage/categories/pushout.html#sage.categories.pushout.pushout" title="(in Category Framework v9.6)"><code class="xref py py-func docutils literal notranslate"><span class="pre">sage.categories.pushout.pushout()</span></code></a> construction.</p>
</li>
<li><p>Run the automatic test suites</p>
<p>Each method should be documented and provide a doc test (we are not giving
examples here). In addition, any method defined for the objects or elements
of a category should be supported by a test method, that is executed when
running the test suite.</p>
</li>
</ul>
</section>
<section id="base-classes">
<h3><a class="toc-backref" href="#id4">Base classes</a><a class="headerlink" href="#base-classes" title="Permalink to this headline">¶</a></h3>
<p>In Sage, a “Parent” is an object of a category and contains elements.  Parents
should inherit from <a class="reference external" href="../reference/structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Parents and Elements v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.parent.Parent</span></code></a> and their elements
from <a class="reference external" href="../reference/structure/sage/structure/element.html#sage.structure.element.Element" title="(in Parents and Elements v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.element.Element</span></code></a>.</p>
<p>Sage provides appropriate sub--classes of
<a class="reference external" href="../reference/structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Parents and Elements v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parent</span></code></a> and
<a class="reference external" href="../reference/structure/sage/structure/element.html#sage.structure.element.Element" title="(in Parents and Elements v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> for a variety of more concrete
algebraic structures, such as groups, rings, or fields, and of their
elements. But some old stuff in Sage doesn’t use it.  <strong>Volunteers for
refactoring are welcome!</strong></p>
<section id="the-parent">
<h4>The parent<a class="headerlink" href="#the-parent" title="Permalink to this headline">¶</a></h4>
<p>Since we wish to implement a special kind of fields, namely fraction fields,
it makes sense to build on top of the base class
<a class="reference external" href="../reference/rings/sage/rings/ring.html#sage.rings.ring.Field" title="(in General Rings, Ideals, and Morphisms v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.rings.ring.Field</span></code></a> provided by Sage.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.rings.ring</span> <span class="kn">import</span> <span class="n">Field</span>
</pre></div>
</div>
<p>This base class provides a lot more methods than a general parent:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">Field</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">Parent</span><span class="p">)]</span>
<span class="go">[&#39;__fraction_field&#39;,</span>
<span class="go"> &#39;__ideal_monoid&#39;,</span>
<span class="go"> &#39;__iter__&#39;,</span>
<span class="go"> &#39;__len__&#39;,</span>
<span class="go"> &#39;__rtruediv__&#39;,</span>
<span class="go"> &#39;__rxor__&#39;,</span>
<span class="go"> &#39;__truediv__&#39;,</span>
<span class="go"> &#39;__xor__&#39;,</span>
<span class="go"> &#39;_an_element_impl&#39;,</span>
<span class="go"> &#39;_coerce_&#39;,</span>
<span class="go"> &#39;_coerce_c&#39;,</span>
<span class="go"> &#39;_coerce_impl&#39;,</span>
<span class="go"> &#39;_coerce_try&#39;,</span>
<span class="go"> &#39;_default_category&#39;,</span>
<span class="go"> &#39;_gens&#39;,</span>
<span class="go"> &#39;_ideal_class_&#39;,</span>
<span class="go"> &#39;_latex_names&#39;,</span>
<span class="go"> &#39;_list&#39;,</span>
<span class="go"> &#39;_one_element&#39;,</span>
<span class="go"> &#39;_pseudo_fraction_field&#39;,</span>
<span class="go"> &#39;_random_nonzero_element&#39;,</span>
<span class="go"> &#39;_unit_ideal&#39;,</span>
<span class="go"> &#39;_zero_element&#39;,</span>
<span class="go"> &#39;_zero_ideal&#39;,</span>
<span class="go"> &#39;algebraic_closure&#39;,</span>
<span class="go"> &#39;base_extend&#39;,</span>
<span class="go"> &#39;class_group&#39;,</span>
<span class="go"> &#39;content&#39;,</span>
<span class="go"> &#39;derivation&#39;,</span>
<span class="go"> &#39;derivation_module&#39;,</span>
<span class="go"> &#39;divides&#39;,</span>
<span class="go"> &#39;epsilon&#39;,</span>
<span class="go"> &#39;extension&#39;,</span>
<span class="go"> &#39;fraction_field&#39;,</span>
<span class="go"> &#39;frobenius_endomorphism&#39;,</span>
<span class="go"> &#39;gcd&#39;,</span>
<span class="go"> &#39;gen&#39;,</span>
<span class="go"> &#39;gens&#39;,</span>
<span class="go"> &#39;ideal&#39;,</span>
<span class="go"> &#39;ideal_monoid&#39;,</span>
<span class="go"> &#39;integral_closure&#39;,</span>
<span class="go"> &#39;is_commutative&#39;,</span>
<span class="go"> &#39;is_field&#39;,</span>
<span class="go"> &#39;is_integral_domain&#39;,</span>
<span class="go"> &#39;is_integrally_closed&#39;,</span>
<span class="go"> &#39;is_noetherian&#39;,</span>
<span class="go"> &#39;is_prime_field&#39;,</span>
<span class="go"> &#39;is_subring&#39;,</span>
<span class="go"> &#39;krull_dimension&#39;,</span>
<span class="go"> &#39;localization&#39;,</span>
<span class="go"> &#39;ngens&#39;,</span>
<span class="go"> &#39;one&#39;,</span>
<span class="go"> &#39;order&#39;,</span>
<span class="go"> &#39;prime_subfield&#39;,</span>
<span class="go"> &#39;principal_ideal&#39;,</span>
<span class="go"> &#39;quo&#39;,</span>
<span class="go"> &#39;quotient&#39;,</span>
<span class="go"> &#39;quotient_ring&#39;,</span>
<span class="go"> &#39;random_element&#39;,</span>
<span class="go"> &#39;unit_ideal&#39;,</span>
<span class="go"> &#39;zero&#39;,</span>
<span class="go"> &#39;zero_ideal&#39;,</span>
<span class="go"> &#39;zeta&#39;,</span>
<span class="go"> &#39;zeta_order&#39;]</span>
</pre></div>
</div>
<p>The following is a very basic implementation of fraction fields, that needs to
be complemented later.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.structure.unique_representation</span> <span class="kn">import</span> <span class="n">UniqueRepresentation</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFrac</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="n">Field</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">base</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">IntegralDomains</span><span class="p">():</span>
<span class="gp">....: </span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is no integral domain&quot;</span> <span class="o">%</span> <span class="n">base</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="n">Field</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="s2">&quot;NewFrac(</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="k">repr</span>(self.base())
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">base_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">characteristic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">characteristic</span><span class="p">()</span>
</pre></div>
</div>
<p>This basic implementation is formed by the following steps:</p>
<ul>
<li><p>Any ring in Sage has a <strong>base</strong> and a <strong>base ring</strong>. The “usual” fraction
field of a ring <span class="math notranslate nohighlight">\(R\)</span> has the base <span class="math notranslate nohighlight">\(R\)</span> and the base ring <code class="docutils literal notranslate"><span class="pre">R.base_ring()</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Frac</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">base</span><span class="p">(),</span> <span class="n">Frac</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
<span class="go">(Univariate Polynomial Ring in x over Rational Field, Rational Field)</span>
</pre></div>
</div>
<p>Declaring the base is easy: We just pass it as an argument to the field
constructor.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Field</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">base</span><span class="p">()</span>
<span class="go">Univariate Polynomial Ring in x over Integer Ring</span>
</pre></div>
</div>
<p>We are implementing a separate method returning the base ring.</p>
</li>
<li><p>Python uses double--underscore methods for arithmetic methods and string
representations. Sage’s base classes often have a default implementation,
and it is requested to <strong>implement SINGLE underscore methods _repr_, and
similarly _add_, _mul_ etc.</strong></p></li>
<li><p>You are encouraged to <strong>make your parent “unique”</strong>. That’s to say, parents
should only evaluate equal if they are identical. Sage provides frameworks
to create unique parents. We use here the most easy one: Inheriting from the
class <a class="reference external" href="../reference/structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Parents and Elements v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></code></a> is
enough. Making parents unique can be quite important for an efficient
implementation, because the repeated creation of “the same” parent would
take a lot of time.</p></li>
<li><p>Fraction fields are only defined for integral domains. Hence, we raise an
error if the given ring does not belong to the category of integral
domains. This is our first use case of categories.</p></li>
<li><p>Last, we add a method that returns the characteristic of the field. We don’t
go into details, but some automated tests that we study below implicitly
rely on this method.</p></li>
</ul>
<p>We see that our basic implementation correctly refuses a ring that is not an
integral domain:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span>
<span class="go">NewFrac(Univariate Polynomial Ring in x over Integer Ring)</span>
<span class="gp">sage: </span><span class="n">MyFrac</span><span class="p">(</span><span class="n">Integers</span><span class="p">(</span><span class="mi">15</span><span class="p">))</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: Ring of integers modulo 15 is no integral domain</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Inheritance from <a class="reference external" href="../reference/structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Parents and Elements v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueRepresentation</span></code></a>
automatically provides our class with pickling, preserving the unique
parent condition. If we had defined the class in some external module or
in an interactive session, pickling would work immediately.</p>
<p>However, for making the following example work in Sage’s doctesting
framework, we need to assign our class as an attribute of the <code class="docutils literal notranslate"><span class="pre">__main__</span></code>
module, so that the class can be looked up during unpickling.</p>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">MyFrac</span> <span class="o">=</span> <span class="n">MyFrac</span>
<span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)))</span> <span class="ow">is</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the following sections, we will successively add or change details of
<code class="docutils literal notranslate"><span class="pre">MyFrac</span></code>. Rather than giving a full class definition in each step, we
define new versions of <code class="docutils literal notranslate"><span class="pre">MyFrac</span></code> by inheriting from the previously
defined version of <code class="docutils literal notranslate"><span class="pre">MyFrac</span></code>. We believe this will help the reader to
focus on the single detail that is relevant in each section.</p>
<p>The complete code can be found in the appendix.</p>
</div>
</section>
<section id="the-elements">
<h4>The elements<a class="headerlink" href="#the-elements" title="Permalink to this headline">¶</a></h4>
<p>We use the base class <a class="reference external" href="../reference/structure/sage/structure/element.html#sage.structure.element.FieldElement" title="(in Parents and Elements v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.element.FieldElement</span></code></a>. Note that
in the creation of field elements it is not tested that the given parent is a
field:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.structure.element</span> <span class="kn">import</span> <span class="n">FieldElement</span>
<span class="gp">sage: </span><span class="n">FieldElement</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Generic element of a structure</span>
</pre></div>
</div>
<p>Our toy implementation of fraction field elements is based on the following
considerations:</p>
<ul>
<li><p>A fraction field element is defined by numerator and denominator, which both
need to be elements of the base. There should be methods returning numerator
resp. denominator.</p></li>
<li><p>The denominator must not be zero, and (provided that the base is an ordered
ring) we can make it non-negative, without loss of generality. By default,
the denominator is one.</p></li>
<li><p>The string representation is returned by the single--underscore method
<code class="docutils literal notranslate"><span class="pre">_repr_</span></code>. In order to make our fraction field elements distinguishable
from those already present in Sage, we use a different string representation.</p></li>
<li><p>Arithmetic is implemented in single--underscore method <code class="docutils literal notranslate"><span class="pre">_add_</span></code>, <code class="docutils literal notranslate"><span class="pre">_mul_</span></code>,
etc. <strong>We do not override the default double underscore __add__, __mul__</strong>,
since otherwise, we could not use Sage’s coercion model.</p></li>
<li><p>Comparisons can be implemented using <code class="docutils literal notranslate"><span class="pre">_richcmp_</span></code>.
This automatically makes the relational operators like
<code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> work. Inside this method, you can use
the <code class="docutils literal notranslate"><span class="pre">richcmp</span></code> functions and related tools provided by sage.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">_richcmp_</span></code> should be provided,
since otherwise comparison does not work:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">sage</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">Element</span><span class="p">):</span>
<span class="gp">....: </span> <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">....: </span>     <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">....: </span> <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>     <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: &#39;&lt;=&#39; not supported between instances of &#39;Foo&#39; and &#39;Foo&#39;</span>
</pre></div>
</div>
</li>
<li><p>In the single underscore methods, we can assume that
<em>both arguments belong to the same parent</em>.
This is one benefit of the coercion model.</p></li>
<li><p>When constructing new elements as the result of arithmetic operations, we do
not directly name our class, but we use <code class="docutils literal notranslate"><span class="pre">self.__class__</span></code>. Later, this will
come in handy.</p></li>
</ul>
<p>This gives rise to the following code:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyElement</span><span class="p">(</span><span class="n">FieldElement</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">B</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">base</span><span class="p">()</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="n">d</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">B</span> <span class="ow">or</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">B</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Numerator and denominator must be elements of </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="k">B</span>)
<span class="gp">....: </span>        <span class="c1"># Numerator and denominator should not just be &quot;in&quot; B,</span>
<span class="gp">....: </span>        <span class="c1"># but should be defined as elements of B</span>
<span class="gp">....: </span>        <span class="n">d</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="n">n</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">d</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s2">&quot;The denominator must not be zero&quot;</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">d</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span>
<span class="gp">....: </span>            <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">d</span>
<span class="gp">....: </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
<span class="gp">....: </span>            <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">d</span>
<span class="gp">....: </span>        <span class="n">FieldElement</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">parent</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">numerator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">denominator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">):(</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">_richcmp_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="kn">from</span> <span class="nn">sage.structure.richcmp</span> <span class="kn">import</span> <span class="n">richcmp</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="n">richcmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">numerator</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">_add_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
<span class="gp">....: </span>        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="n">C</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">numerator</span><span class="p">(),</span> <span class="n">D</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">_sub_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
<span class="gp">....: </span>        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="n">C</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">numerator</span><span class="p">(),</span><span class="n">D</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">_mul_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="n">C</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">numerator</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">())</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">_div_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="n">C</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">numerator</span><span class="p">())</span>
</pre></div>
</div>
<section id="features-and-limitations-of-the-basic-implementation">
<h5>Features and limitations of the basic implementation<a class="headerlink" href="#features-and-limitations-of-the-basic-implementation" title="Permalink to this headline">¶</a></h5>
<p>Thanks to the single underscore methods, some basic arithmetics works, <strong>if</strong>
we stay inside a single parent structure:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">MyElement</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">MyElement</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span>
<span class="go">((10):(8), (2):(8), (3):(8), (6):(4))</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">-</span><span class="n">b</span> <span class="o">==</span> <span class="n">MyElement</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>There is a default implementation of element tests. We can already do</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="ow">in</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<p>since <span class="math notranslate nohighlight">\(a\)</span> is defined as an element of <span class="math notranslate nohighlight">\(P\)</span>. However, we cannot verify yet that
the integers are contained in the fraction field of the ring of integers. It
does not even give a wrong answer, but results in an error:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="mi">1</span> <span class="ow">in</span> <span class="n">P</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: cannot construct elements of NewFrac(Integer Ring)</span>
</pre></div>
</div>
<p>We will take care of this later.</p>
</section>
</section>
</section>
<section id="categories-in-sage">
<h3><a class="toc-backref" href="#id5">Categories in Sage</a><a class="headerlink" href="#categories-in-sage" title="Permalink to this headline">¶</a></h3>
<p>Sometimes the base classes do not reflect the mathematics: The set of <span class="math notranslate nohighlight">\(m\times
n\)</span> matrices over a field forms, in general, not more than a vector
space. Hence, this set (called <a class="reference external" href="../reference/matrices/sage/matrix/matrix_space.html#sage.matrix.matrix_space.MatrixSpace" title="(in Matrices and Spaces of Matrices v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MatrixSpace</span></code></a>)
is not implemented on top of <a class="reference external" href="../reference/rings/sage/rings/ring.html#sage.rings.ring.Ring" title="(in General Rings, Ideals, and Morphisms v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.rings.ring.Ring</span></code></a>.  However, if
<span class="math notranslate nohighlight">\(m=n\)</span>, then the matrix space is an algebra, thus, is a ring.</p>
<p>From the point of view of Python base classes, both cases are the same:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MS1</span> <span class="o">=</span> <span class="n">MatrixSpace</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">MS1</span><span class="p">,</span> <span class="n">Ring</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">MS2</span> <span class="o">=</span> <span class="n">MatrixSpace</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">MS2</span><span class="p">,</span> <span class="n">Ring</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Sage’s category framework can differentiate the two cases:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Rings</span><span class="p">()</span>
<span class="go">Category of rings</span>
<span class="gp">sage: </span><span class="n">MS1</span> <span class="ow">in</span> <span class="n">Rings</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">MS2</span> <span class="ow">in</span> <span class="n">Rings</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>And indeed, <code class="docutils literal notranslate"><span class="pre">MS2</span></code> has <em>more</em> methods than <code class="docutils literal notranslate"><span class="pre">MS1</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">inspect</span>
<span class="gp">sage: </span><span class="n">L1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">MS1</span><span class="p">)</span> <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">MS1</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="kc">None</span><span class="p">))])</span>
<span class="gp">sage: </span><span class="n">L2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">MS2</span><span class="p">)</span> <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">MS2</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="kc">None</span><span class="p">))])</span>
<span class="gp">sage: </span><span class="n">L1</span> <span class="o">&lt;</span> <span class="n">L2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This is because the class of <code class="docutils literal notranslate"><span class="pre">MS2</span></code> also inherits from the parent
class for algebras:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MS1</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__bases__</span>
<span class="go">(&lt;class &#39;sage.matrix.matrix_space.MatrixSpace&#39;&gt;,</span>
<span class="go">&lt;class &#39;sage.categories.category.JoinCategory.parent_class&#39;&gt;)</span>
<span class="gp">sage: </span><span class="n">MS2</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__bases__</span>
<span class="go">(&lt;class &#39;sage.matrix.matrix_space.MatrixSpace&#39;&gt;,</span>
<span class="go">&lt;class &#39;sage.categories.category.JoinCategory.parent_class&#39;&gt;)</span>
</pre></div>
</div>
<p>Below, we will explain how this can be taken advantage of.</p>
<p>It is no surprise that our parent <span class="math notranslate nohighlight">\(P\)</span> defined above knows that it belongs to
the category of fields, as it is derived from the base class of fields.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of fields</span>
</pre></div>
</div>
<p>However, we could choose a smaller category, namely the category of quotient fields.</p>
<section id="why-should-one-choose-a-category">
<h4>Why should one choose a category?<a class="headerlink" href="#why-should-one-choose-a-category" title="Permalink to this headline">¶</a></h4>
<p>One can provide <strong>default methods</strong> <em>for all objects</em> of a category, and
<em>for all elements</em> of such objects. Hence, the category framework is a way
to inherit useful stuff that is not present in the base classes.  These
default methods do not rely on implementation details, but on mathematical
concepts.</p>
<p>In addition, the categories define <strong>test suites</strong> for their objects and
elements-–see the last section. Hence, one also gets basic sanity tests for
free.</p>
<section id="how-does-the-category-framework-work">
<h5>How does the  <em>category framework</em> work?<a class="headerlink" href="#how-does-the-category-framework-work" title="Permalink to this headline">¶</a></h5>
<p>Abstract base classes for the objects (“parent_class”) and the elements of
objects (“element_class”) are provided by attributes of the category. During
initialisation of a parent, the class of the parent is <em>dynamically changed</em>
into a sub--class of the category’s parent class. Likewise, sub--classes of
the category’s element class are available for the creation of elements of the
parent, as explained below.</p>
<p>A dynamic change of classes does not work in Cython. Nevertheless, method
inheritance still works, by virtue of a <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> method.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is strongly recommended to use the category framework both in Python
and in Cython.</p>
</div>
<p>Let us see whether there is any gain in choosing the category of quotient
fields instead of the category of fields:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="p">,</span> <span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span>
<span class="go">(&lt;class &#39;sage.categories.quotient_fields.QuotientFields.parent_class&#39;&gt;,</span>
<span class="go"> &lt;class &#39;sage.categories.quotient_fields.QuotientFields.element_class&#39;&gt;)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">Fields</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="p">)]</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">Fields</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span><span class="p">)]</span>
<span class="go">[&#39;_derivative&#39;,</span>
<span class="go"> &#39;denominator&#39;,</span>
<span class="go"> &#39;derivative&#39;,</span>
<span class="go"> &#39;numerator&#39;,</span>
<span class="go"> &#39;partial_fraction_decomposition&#39;]</span>
</pre></div>
</div>
<p>So, there is no immediate gain for our fraction fields, but additional methods
become available to our fraction field elements. Note that some of these
methods are place-holders: There is no default implementation, but it is
<em>required</em> (respectively is <em>optional</em>) to implement these methods:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span><span class="o">.</span><span class="n">denominator</span>
<span class="go">&lt;abstract method denominator at ...&gt;</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.misc.abstract_method</span> <span class="kn">import</span> <span class="n">abstract_methods_of_class</span>
<span class="gp">sage: </span><span class="n">abstract_methods_of_class</span><span class="p">(</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span><span class="p">)[</span><span class="s1">&#39;optional&#39;</span><span class="p">]</span>
<span class="go">[&#39;_add_&#39;, &#39;_mul_&#39;]</span>
<span class="gp">sage: </span><span class="n">abstract_methods_of_class</span><span class="p">(</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span><span class="p">)[</span><span class="s1">&#39;required&#39;</span><span class="p">]</span>
<span class="go">[&#39;__bool__&#39;, &#39;denominator&#39;, &#39;numerator&#39;]</span>
</pre></div>
</div>
<p>Hence, when implementing elements of a quotient field, it is <em>required</em> to
implement methods returning the denominator and the numerator, and a method
that tells whether the element is nonzero, and in addition, it is <em>optional</em>
(but certainly recommended) to provide some arithmetic methods. If one forgets
to implement the required methods, the test suites of the category framework
will complain-–see below.</p>
</section>
</section>
<section id="implementing-the-category-framework-for-the-parent">
<h4>Implementing the category framework for the parent<a class="headerlink" href="#implementing-the-category-framework-for-the-parent" title="Permalink to this headline">¶</a></h4>
<p>We simply need to declare the correct category by an optional argument of the
field constructor, where we provide the possibility to override the default
category:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.quotient_fields</span> <span class="kn">import</span> <span class="n">QuotientFields</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFrac</span><span class="p">(</span><span class="n">MyFrac</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">base</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">IntegralDomains</span><span class="p">():</span>
<span class="gp">....: </span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is no integral domain&quot;</span> <span class="o">%</span> <span class="n">base</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="n">Field</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">category</span> <span class="ow">or</span> <span class="n">QuotientFields</span><span class="p">())</span>
</pre></div>
</div>
<p>When constructing instances of <code class="docutils literal notranslate"><span class="pre">MyFrac</span></code>, their class is dynamically changed
into a new class called <code class="docutils literal notranslate"><span class="pre">MyFrac_with_category</span></code>. It is a common sub--class of
<code class="docutils literal notranslate"><span class="pre">MyFrac</span></code> and of the category’s parent class:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">&lt;class &#39;__main__.MyFrac_with_category&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">MyFrac</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The fraction field <span class="math notranslate nohighlight">\(P\)</span> inherits additional methods. For example, the base
class <code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code> does not have a method <code class="docutils literal notranslate"><span class="pre">sum</span></code>. But
<span class="math notranslate nohighlight">\(P\)</span> inherits such method from the category of commutative additive
monoids-–see
<code class="xref py py-meth docutils literal notranslate"><span class="pre">sum()</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">sum</span><span class="o">.</span><span class="vm">__module__</span>
<span class="go">&#39;sage.categories.additive_monoids&#39;</span>
</pre></div>
</div>
<p>We have seen above that we can add elements. Nevertheless, the <code class="docutils literal notranslate"><span class="pre">sum</span></code> method
does not work, yet:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">MyElement</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">MyElement</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">MyElement</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: cannot construct elements of NewFrac(Integer Ring)</span>
</pre></div>
</div>
<p>The reason is that the <code class="docutils literal notranslate"><span class="pre">sum</span></code> method starts with the return value of
<code class="docutils literal notranslate"><span class="pre">P.zero()</span></code>, which defaults to <code class="docutils literal notranslate"><span class="pre">P(0)</span></code>-–but the conversion of
integers into <code class="docutils literal notranslate"><span class="pre">P</span></code> is not implemented, yet.</p>
</section>
<section id="implementing-the-category-framework-for-the-elements">
<h4>Implementing the category framework for the elements<a class="headerlink" href="#implementing-the-category-framework-for-the-elements" title="Permalink to this headline">¶</a></h4>
<p>Similar to what we have seen for parents, a new class is dynamically created
that combines the element class of the parent’s category with the class that
we have implemented above. However, the category framework is implemented in a
different way for elements than for parents:</p>
<ul class="simple">
<li><p>We provide the parent <span class="math notranslate nohighlight">\(P\)</span> (or its class) with an attribute called
“<code class="docutils literal notranslate"><span class="pre">Element</span></code>”, whose value is a class.</p></li>
<li><p>The parent <em>automatically</em> obtains an attribute <code class="docutils literal notranslate"><span class="pre">P.element_class</span></code>, that
subclasses both <code class="docutils literal notranslate"><span class="pre">P.Element</span></code> and <code class="docutils literal notranslate"><span class="pre">P.category().element_class</span></code>.</p></li>
</ul>
<p>Hence, for providing our fraction fields with their own element classes, <strong>we
just need to add a single line to our class</strong>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFrac</span><span class="p">(</span><span class="n">MyFrac</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">Element</span> <span class="o">=</span> <span class="n">MyElement</span>
</pre></div>
</div>
<p>This little change provides several benefits:</p>
<ul>
<li><p>We can now create elements by simply calling the parent:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">((1):(1), (2):(3))</span>
</pre></div>
</div>
</li>
<li><p>There is a method <code class="docutils literal notranslate"><span class="pre">zero</span></code> returning the expected result:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="go">(0):(1)</span>
</pre></div>
</div>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">sum</span></code> method mentioned above suddenly works:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">MyElement</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">MyElement</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">MyElement</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">])</span>
<span class="go">(36):(16)</span>
</pre></div>
</div>
</li>
<li><p>Exponentiation now works out of the box using the multiplication
that we defined:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span><span class="o">^</span><span class="mi">3</span>
<span class="go">(729):(64)</span>
</pre></div>
</div>
</li>
</ul>
<section id="what-did-happen-behind-the-scenes-to-make-this-work">
<h5>What did happen behind the scenes to make this work?<a class="headerlink" href="#what-did-happen-behind-the-scenes-to-make-this-work" title="Permalink to this headline">¶</a></h5>
<p>We provided <code class="docutils literal notranslate"><span class="pre">P.Element</span></code>, and thus obtain <code class="docutils literal notranslate"><span class="pre">P.element_class</span></code>, which is a
<em>lazy attribute</em>.  It provides a <em>dynamic</em> class, which is a sub--class of
both <code class="docutils literal notranslate"><span class="pre">MyElement</span></code> defined above and of <code class="docutils literal notranslate"><span class="pre">P.category().element_class</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">element_class</span>
<span class="go">&lt;sage.misc.lazy_attribute.lazy_attribute object at ...&gt;</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">element_class</span>
<span class="go">&lt;class &#39;__main__.MyFrac_with_category.element_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">element_class</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.structure.dynamic_class.DynamicInheritComparisonMetaclass&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">element_class</span><span class="p">,</span> <span class="n">MyElement</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">element_class</span><span class="p">,</span><span class="n">P</span><span class="o">.</span><span class="n">category</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The <em>default</em> <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method of <span class="math notranslate nohighlight">\(P\)</span> passes the given arguments to
<code class="docutils literal notranslate"><span class="pre">P.element_class</span></code>, adding the argument <code class="docutils literal notranslate"><span class="pre">parent=P</span></code>. This is why we are now
able to create elements by calling the parent.</p>
<p>In particular, these elements are instances of that new dynamic class:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="go">&lt;class &#39;__main__.MyFrac_with_category.element_class&#39;&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>All</em> elements of <span class="math notranslate nohighlight">\(P\)</span> should use the element class. In order to make sure
that this also holds for the result of arithmetic operations, we created
them as instances of <code class="docutils literal notranslate"><span class="pre">self.__class__</span></code> in the arithmetic methods of
<code class="docutils literal notranslate"><span class="pre">MyElement</span></code>.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">P.zero()</span></code> defaults to returning <code class="docutils literal notranslate"><span class="pre">P(0)</span></code> and thus returns an
instance of <code class="docutils literal notranslate"><span class="pre">P.element_class</span></code>. Since <code class="docutils literal notranslate"><span class="pre">P.sum([...])</span></code> starts the summation with
<code class="docutils literal notranslate"><span class="pre">P.zero()</span></code> and the class of the sum only depends on the first
summand, by our implementation, we have:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;class &#39;__main__.MyElement&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">P</span><span class="o">.</span><span class="n">element_class</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]))</span>
<span class="go">&lt;class &#39;__main__.MyFrac_with_category.element_class&#39;&gt;</span>
</pre></div>
</div>
<p>The method <code class="docutils literal notranslate"><span class="pre">factor</span></code> provided by <code class="docutils literal notranslate"><span class="pre">P.category().element_class</span></code> (see above)
simply works:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span><span class="p">;</span> <span class="n">a</span><span class="o">.</span><span class="n">factor</span><span class="p">();</span> <span class="n">P</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(9):(4)</span>
<span class="go">2^-2 * 3^2</span>
<span class="go">2^-1 * 3</span>
</pre></div>
</div>
<p>But that’s surprising: The element <span class="math notranslate nohighlight">\(a\)</span> is just an instance of <code class="docutils literal notranslate"><span class="pre">MyElement</span></code>,
but not of <code class="docutils literal notranslate"><span class="pre">P.element_class</span></code>, and its class does not know about the factor
method.  In fact, this is due to a <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> method defined for
<a class="reference external" href="../reference/structure/sage/structure/element.html#sage.structure.element.Element" title="(in Parents and Elements v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.element.Element</span></code></a>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">hasattr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s1">&#39;factor&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">element_class</span><span class="p">,</span> <span class="s1">&#39;factor&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;factor&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</section>
</section>
<section id="a-first-note-on-performance">
<h4>A first note on performance<a class="headerlink" href="#a-first-note-on-performance" title="Permalink to this headline">¶</a></h4>
<p>The category framework is sometimes blamed for speed regressions, as in
<a class="reference external" href="https://trac.sagemath.org/9138">trac ticket #9138</a> and <a class="reference external" href="https://trac.sagemath.org/11900">trac ticket #11900</a>. But if the category framework is <em>used
properly</em>, then it is fast. For illustration, we determine the time needed to
access an attribute inherited from the element class. First, we consider an
element that uses the class that we implemented above, but does not use the
category framework properly:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;class &#39;__main__.MyElement&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;a.factor&#39;</span><span class="p">,</span><span class="n">number</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>     <span class="c1"># random</span>
<span class="go">1000 loops, best of 3: 2 us per loop</span>
</pre></div>
</div>
<p>Now, we consider an element that is equal to <span class="math notranslate nohighlight">\(a\)</span>, but uses the category
framework properly:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a2</span> <span class="o">=</span> <span class="n">P</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a2</span> <span class="o">==</span> <span class="n">a</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="go">&lt;class &#39;__main__.MyFrac_with_category.element_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;a2.factor&#39;</span><span class="p">,</span><span class="n">number</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>    <span class="c1"># random</span>
<span class="go">1000 loops, best of 3: 365 ns per loop</span>
</pre></div>
</div>
<p>So,  <em>don’t be afraid of using categories!</em></p>
</section>
</section>
<section id="coercion-the-basics">
<h3><a class="toc-backref" href="#id6">Coercion-–the basics</a><a class="headerlink" href="#coercion-the-basics" title="Permalink to this headline">¶</a></h3>
<section id="theoretical-background">
<h4>Theoretical background<a class="headerlink" href="#theoretical-background" title="Permalink to this headline">¶</a></h4>
<section id="coercion-is-not-just-type-conversion">
<h5>Coercion is not just <em>type conversion</em><a class="headerlink" href="#coercion-is-not-just-type-conversion" title="Permalink to this headline">¶</a></h5>
<p>“Coercion” in the C programming language means “automatic type
conversion”. However, in Sage, coercion is involved if one wants to be able to
do arithmetic, comparisons, etc. between elements of distinct parents. Hence,
<strong>coercion is not about a change of types, but about a change of parents.</strong></p>
<p>As an illustration, we show that elements of the same type may very well belong
to rather different parents:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;v,w&#39;</span><span class="p">];</span> <span class="n">P2</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;w,v&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">gen</span><span class="p">())</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">P2</span><span class="o">.</span><span class="n">gen</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">==</span> <span class="n">P2</span>
<span class="go">False</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\(P_2\)</span> naturally is a sub--ring of <span class="math notranslate nohighlight">\(P_1\)</span>. So, it makes sense to be able to add
elements of the two rings-–the result should then live in <span class="math notranslate nohighlight">\(P_1\)</span>, and indeed
it does:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span><span class="o">+</span><span class="n">P2</span><span class="o">.</span><span class="n">gen</span><span class="p">())</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P1</span>
<span class="go">True</span>
</pre></div>
</div>
<p>It would be rather inconvenient if one needed to <em>manually</em> convert an element
of <span class="math notranslate nohighlight">\(P_2\)</span> into <span class="math notranslate nohighlight">\(P_1\)</span> before adding. The coercion system does that conversion
automatically.</p>
</section>
<section id="not-every-conversion-is-a-coercion">
<h5>Not every conversion is a coercion<a class="headerlink" href="#not-every-conversion-is-a-coercion" title="Permalink to this headline">¶</a></h5>
<p>A coercion happens implicitly, without being explicitly requested by the
user. Hence, coercion must be based on mathematical rigour. In our example,
any element of <span class="math notranslate nohighlight">\(P_2\)</span> can be naturally interpreted as an element of <span class="math notranslate nohighlight">\(P_1\)</span>. We
thus have:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span>
<span class="go">Coercion map:</span>
<span class="go">  From: Multivariate Polynomial Ring in w, v over Integer Ring</span>
<span class="go">  To:   Multivariate Polynomial Ring in v, w over Rational Field</span>
</pre></div>
</div>
<p>While there is a conversion from <span class="math notranslate nohighlight">\(P_1\)</span> to <span class="math notranslate nohighlight">\(P_2\)</span> (namely restricted to
polynomials with integral coefficients), this conversion is not a coercion:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P2</span><span class="o">.</span><span class="n">convert_map_from</span><span class="p">(</span><span class="n">P1</span><span class="p">)</span>
<span class="go">Conversion map:</span>
<span class="go">  From: Multivariate Polynomial Ring in v, w over Rational Field</span>
<span class="go">  To:   Multivariate Polynomial Ring in w, v over Integer Ring</span>
<span class="gp">sage: </span><span class="n">P2</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">P1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P2</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">P1</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
<section id="the-four-axioms-requested-for-coercions">
<h6>The four axioms requested for coercions<a class="headerlink" href="#the-four-axioms-requested-for-coercions" title="Permalink to this headline">¶</a></h6>
<ol class="arabic">
<li><p>A coercion is a morphism in an appropriate category.</p>
<p>This first axiom has two implications:</p>
<ol class="upperalpha">
<li><p>A coercion is defined on all elements of a parent.</p>
<p>A polynomial of degree zero over the integers can be interpreted as an
integer-–but the attempt to convert a polynomial of non-zero degree
would result in an error:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ZZ</span><span class="p">(</span><span class="n">P2</span><span class="o">.</span><span class="n">one</span><span class="p">())</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">ZZ</span><span class="p">(</span><span class="n">P2</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: not a constant polynomial</span>
</pre></div>
</div>
<p>Hence, we only have a <em>partial</em> map. This is fine for a <em>conversion</em>,
but a partial map does not qualify as a <em>coercion</em>.</p>
</li>
<li><p>Coercions are structure preserving.</p>
<p>Any real number can be converted to an integer, namely by
rounding. However, such a conversion is not useful in arithmetic
operations, since the underlying algebraic structure is not preserved:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">int</span><span class="p">(</span><span class="mf">1.6</span><span class="p">)</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="mf">2.7</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.6</span><span class="o">+</span><span class="mf">2.7</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The structure that is to be preserved depends on the category of the
involved parents. For example, the coercion from the integers into the
rational field is a homomorphism of euclidean domains:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QQ</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">category_for</span><span class="p">()</span>
<span class="go">Join of Category of euclidean domains and Category of infinite sets</span>
<span class="go">and Category of metric spaces</span>
</pre></div>
</div>
</li>
</ol>
</li>
<li><p>There is at most one coercion from one parent to another</p>
<p>In addition, if there is a <em>coercion</em> from <span class="math notranslate nohighlight">\(P_2\)</span> to <span class="math notranslate nohighlight">\(P_1\)</span>, then a
<em>conversion</em> from <span class="math notranslate nohighlight">\(P_2\)</span> to <span class="math notranslate nohighlight">\(P_1\)</span> is defined for all elements of <span class="math notranslate nohighlight">\(P_2\)</span> and
coincides with the coercion.
Nonetheless, user-exposed maps are copies of the internally used maps whence
the lack of identity between different instantiations:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P1</span><span class="o">.</span><span class="n">convert_map_from</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>For internally used maps, the maps are identical:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">_internal_coerce_map_from</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P1</span><span class="o">.</span><span class="n">_internal_convert_map_from</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
<li><p>Coercions can be composed</p>
<p>If there is a coercion <span class="math notranslate nohighlight">\(\varphi: P_1 \to P_2\)</span> and another coercion <span class="math notranslate nohighlight">\(\psi:
P_2 \to P_3\)</span>, then the composition of <span class="math notranslate nohighlight">\(\varphi\)</span> followed by <span class="math notranslate nohighlight">\(\psi\)</span> must
yield the unique coercion from <span class="math notranslate nohighlight">\(P_1\)</span> to <span class="math notranslate nohighlight">\(P_3\)</span>.</p>
</li>
<li><p>The identity is a coercion</p>
<p>Together with the two preceding axioms, it follows: If there are coercions
from <span class="math notranslate nohighlight">\(P_1\)</span> to <span class="math notranslate nohighlight">\(P_2\)</span> and from <span class="math notranslate nohighlight">\(P_2\)</span> to <span class="math notranslate nohighlight">\(P_1\)</span>, then they are mutually
inverse.</p>
</li>
</ol>
</section>
</section>
</section>
<section id="implementing-a-conversion">
<h4>Implementing a conversion<a class="headerlink" href="#implementing-a-conversion" title="Permalink to this headline">¶</a></h4>
<p>We have seen above that some conversions into our fraction fields became
available after providing the attribute <code class="docutils literal notranslate"><span class="pre">Element</span></code>.  However, we cannot
convert elements of a fraction field into elements of another fraction field,
yet:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: Numerator and denominator must be elements of Integer Ring</span>
</pre></div>
</div>
<p>For implementing a conversion, <strong>the default __call__ method should (almost)
never be overridden.</strong> Instead, <strong>we implement the method
_element_constructor_</strong>, that should return an instance of the parent’s
element class.  Some old parent classes violate that rule-–please help to
refactor them!</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFrac</span><span class="p">(</span><span class="n">MyFrac</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">_element_constructor_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="n">x</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">....: </span>        <span class="k">try</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="n">P</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="gp">....: </span>        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">QuotientFields</span><span class="p">()</span> <span class="ow">and</span> <span class="n">P</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">():</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">numerator</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">denominator</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition to the conversion from the base ring and from pairs of base ring
elements, we now also have a conversion from the rationals to our fraction
field of <span class="math notranslate nohighlight">\(\ZZ\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span> <span class="n">P</span><span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
<span class="go">(2):(1)</span>
<span class="go">(2):(3)</span>
<span class="go">(3):(4)</span>
</pre></div>
</div>
<p>Recall that above, the test <span class="math notranslate nohighlight">\(1 \in P\)</span> failed with an error. We try again and
find that the error has disappeared. This is because we are now able to
convert the integer <span class="math notranslate nohighlight">\(1\)</span> into <span class="math notranslate nohighlight">\(P\)</span>. But the containment test still yields a
wrong answer:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="mi">1</span> <span class="ow">in</span> <span class="n">P</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The technical reason: We have a conversion <span class="math notranslate nohighlight">\(P(1)\)</span> of <span class="math notranslate nohighlight">\(1\)</span> into <span class="math notranslate nohighlight">\(P\)</span>, but this is
not known as a coercion-–yet!</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">ZZ</span><span class="p">),</span> <span class="n">P</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">(False, False)</span>
</pre></div>
</div>
</section>
<section id="establishing-a-coercion">
<h4>Establishing a coercion<a class="headerlink" href="#establishing-a-coercion" title="Permalink to this headline">¶</a></h4>
<p>There are two main ways to make Sage use a particular conversion as a
coercion:</p>
<ul class="simple">
<li><p>One can use <a class="reference external" href="../reference/structure/sage/structure/parent.html#sage.structure.parent.Parent.register_coercion" title="(in Parents and Elements v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.structure.parent.Parent.register_coercion()</span></code></a>, normally
during initialisation of the parent (see documentation of the method).</p></li>
<li><p>A more flexible way is to provide a method <code class="docutils literal notranslate"><span class="pre">_coerce_map_from_</span></code> for the
parent.</p></li>
</ul>
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(R\)</span> be parents. If <code class="docutils literal notranslate"><span class="pre">P._coerce_map_from_(R)</span></code> returns <code class="docutils literal notranslate"><span class="pre">False</span></code>
or <code class="docutils literal notranslate"><span class="pre">None</span></code>, then there is no coercion from <span class="math notranslate nohighlight">\(R\)</span> to <span class="math notranslate nohighlight">\(P\)</span>. If it returns a map
with domain <span class="math notranslate nohighlight">\(R\)</span> and codomain <span class="math notranslate nohighlight">\(P\)</span>, then this map is used for coercion. If it
returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the conversion from <span class="math notranslate nohighlight">\(R\)</span> to <span class="math notranslate nohighlight">\(P\)</span> is used as coercion.</p>
<p>Note that in the following implementation, we need a special case for the
rational field, since <code class="docutils literal notranslate"><span class="pre">QQ.base()</span></code> is not the ring of integers.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFrac</span><span class="p">(</span><span class="n">MyFrac</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">_coerce_map_from_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="kc">True</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">QuotientFields</span><span class="p">():</span>
<span class="gp">....: </span>            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">base</span><span class="p">()):</span>
<span class="gp">....: </span>                <span class="k">return</span> <span class="kc">True</span>
<span class="gp">....: </span>            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="s1">&#39;ring_of_integers&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">ring_of_integers</span><span class="p">()):</span>
<span class="gp">....: </span>                <span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
<p>By the method above, a parent coercing into the base ring will also coerce
into the fraction field, and a fraction field coerces into another fraction
field if there is a coercion of the corresponding base rings. Now, we have:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]),</span> <span class="n">P</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">Frac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])),</span> <span class="n">P</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">(True, True, True)</span>
</pre></div>
</div>
<p>We can now use coercion from <span class="math notranslate nohighlight">\(\ZZ[x]\)</span> and from <span class="math notranslate nohighlight">\(\QQ\)</span> into <span class="math notranslate nohighlight">\(P\)</span> for arithmetic
operations between the two rings:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="o">+</span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">gen</span><span class="p">(),</span> <span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">gen</span><span class="p">())</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">((4*x + 11):(4), True)</span>
</pre></div>
</div>
<section id="equality-and-element-containment">
<h5>Equality and element containment<a class="headerlink" href="#equality-and-element-containment" title="Permalink to this headline">¶</a></h5>
<p>Recall that above, the test <span class="math notranslate nohighlight">\(1 \in P\)</span> gave a wrong answer. Let us repeat the
test now:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="mi">1</span> <span class="ow">in</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Why is that?</p>
<p>The default element containment test <span class="math notranslate nohighlight">\(x \in P\)</span> is based on the interplay of
three building blocks: conversion, coercion, and equality test.</p>
<ol class="arabic simple">
<li><p>Clearly, if the conversion <span class="math notranslate nohighlight">\(P(x)\)</span> raises an error, then <span class="math notranslate nohighlight">\(x\)</span> cannot be seen as an element of <span class="math notranslate nohighlight">\(P\)</span>. On the other hand, a conversion <span class="math notranslate nohighlight">\(P(x)\)</span> can generally do very nasty things. So, the fact that <span class="math notranslate nohighlight">\(P(x)\)</span> works without error is necessary, but not sufficient for <span class="math notranslate nohighlight">\(x \in P\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(P\)</span> is the parent of <span class="math notranslate nohighlight">\(x\)</span>, then the conversion <span class="math notranslate nohighlight">\(P(x)\)</span> will not change <span class="math notranslate nohighlight">\(x\)</span> (at least, that’s the default). Hence, we will have <span class="math notranslate nohighlight">\(x=P(x)\)</span>.</p></li>
<li><p>Sage uses coercion not only for arithmetic operations, but also for comparison: <em>If</em> there is a coercion from the parent of <span class="math notranslate nohighlight">\(x\)</span> to <span class="math notranslate nohighlight">\(P\)</span>, then the equality test <code class="docutils literal notranslate"><span class="pre">x==P(x)</span></code> reduces to <code class="docutils literal notranslate"><span class="pre">P(x)==P(x)</span></code>. Otherwise, <code class="docutils literal notranslate"><span class="pre">x==P(x)</span></code> will evaluate as false.</p></li>
</ol>
<p>That leads to the following default implementation of element containment testing:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><span class="math notranslate nohighlight">\(x \in P\)</span> holds if and only if the test <code class="docutils literal notranslate"><span class="pre">x==P(x)</span></code> does not
raise an error and evaluates as true.</p>
</div>
<p>If the user is not happy with that behaviour, the “magical” Python method
<code class="docutils literal notranslate"><span class="pre">__contains__</span></code> can be overridden.</p>
</section>
</section>
</section>
<section id="coercion-the-advanced-parts">
<h3><a class="toc-backref" href="#id7">Coercion-–the advanced parts</a><a class="headerlink" href="#coercion-the-advanced-parts" title="Permalink to this headline">¶</a></h3>
<p>So far, we are able to add integers and rational numbers to elements of our
new implementation of the fraction field of <span class="math notranslate nohighlight">\(\ZZ\)</span>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
<span class="go">(13):(6)</span>
</pre></div>
</div>
<p>Surprisingly, we can even add a polynomial over the integers to an element of
<span class="math notranslate nohighlight">\(P\)</span>, even though the <em>result lives in a new parent</em>, namely in a polynomial
ring over <span class="math notranslate nohighlight">\(P\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">gen</span><span class="p">(),</span> <span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">gen</span><span class="p">())</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">((1):(1)*x + (1):(2), True)</span>
</pre></div>
</div>
<p>In the next, seemingly more easy example, there “obviously” is a coercion from
the fraction field of <span class="math notranslate nohighlight">\(\ZZ\)</span> to the fraction field of <span class="math notranslate nohighlight">\(\ZZ[x]\)</span>.  However, Sage
does not know enough about our new implementation of fraction fields. Hence,
it does not recognise the coercion:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Frac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Two obvious questions arise:</p>
<ol class="arabic simple">
<li><p>How / why has the new ring been constructed in the example above?</p></li>
<li><p>How can we establish a coercion from <span class="math notranslate nohighlight">\(P\)</span>  to  <span class="math notranslate nohighlight">\(\mathrm{Frac}(\ZZ[x])\)</span>?</p></li>
</ol>
<p>The key to answering both question is the construction of parents from simpler
pieces, that we are studying now. Note that we will answer the second question
<em>not</em> by providing a coercion from <span class="math notranslate nohighlight">\(P\)</span>  to  <span class="math notranslate nohighlight">\(\mathrm{Frac}(\ZZ[x])\)</span>, but by
teaching Sage to automatically construct <span class="math notranslate nohighlight">\(\mathrm{MyFrac}(\ZZ[x])\)</span> and coerce
both <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(\mathrm{Frac}(\ZZ[x])\)</span> into it.</p>
<p>If we are lucky, a parent can tell how it has been constructed:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poly</span><span class="p">,</span><span class="n">R</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">construction</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Poly</span><span class="p">,</span><span class="n">R</span>
<span class="go">(Poly[x], Rational Field)</span>
<span class="gp">sage: </span><span class="n">Fract</span><span class="p">,</span><span class="n">R</span> <span class="o">=</span> <span class="n">QQ</span><span class="o">.</span><span class="n">construction</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Fract</span><span class="p">,</span><span class="n">R</span>
<span class="go">(FractionField, Integer Ring)</span>
</pre></div>
</div>
<p>In both cases, the first value returned by
<code class="xref py py-meth docutils literal notranslate"><span class="pre">construction()</span></code> is a mathematical
construction, called <em>construction functor</em>-–see
<a class="reference external" href="../reference/categories/sage/categories/pushout.html#sage.categories.pushout.ConstructionFunctor" title="(in Category Framework v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstructionFunctor</span></code></a>. The second return value
is a simpler parent to which the construction functor is applied.</p>
<p>Being functors, the same construction can be applied to different objects of a
category:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poly</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span> <span class="ow">is</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Poly</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Poly</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Fract</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span>
<span class="go">Fraction Field of Univariate Polynomial Ring in x over Rational Field</span>
</pre></div>
</div>
<p>Let us see on which categories these construction functors are defined:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poly</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span>
<span class="go">Category of rings</span>
<span class="gp">sage: </span><span class="n">Poly</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span>
<span class="go">Category of rings</span>
<span class="gp">sage: </span><span class="n">Fract</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span>
<span class="go">Category of integral domains</span>
<span class="gp">sage: </span><span class="n">Fract</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span>
<span class="go">Category of fields</span>
</pre></div>
</div>
<p>In particular, the construction functors can be composed:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Poly</span><span class="o">*</span><span class="n">Fract</span>
<span class="go">Poly[x](FractionField(...))</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Poly</span><span class="o">*</span><span class="n">Fract</span><span class="p">)(</span><span class="n">ZZ</span><span class="p">)</span> <span class="ow">is</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In addition, it is often assumed that we have a coercion from input to output of the
construction functor:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">((</span><span class="n">Poly</span><span class="o">*</span><span class="n">Fract</span><span class="p">)(</span><span class="n">ZZ</span><span class="p">))</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Composite map:</span>
<span class="go">  From: Integer Ring</span>
<span class="go">  To:   Univariate Polynomial Ring in x over Rational Field</span>
<span class="go">  Defn:   Natural morphism:</span>
<span class="go">          From: Integer Ring</span>
<span class="go">          To:   Rational Field</span>
<span class="go">        then</span>
<span class="go">          Polynomial base injection morphism:</span>
<span class="go">          From: Rational Field</span>
<span class="go">          To:   Univariate Polynomial Ring in x over Rational Field</span>
</pre></div>
</div>
<p>Construction functors do not necessarily commute:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">Fract</span><span class="o">*</span><span class="n">Poly</span><span class="p">)(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Fraction Field of Univariate Polynomial Ring in x over Integer Ring</span>
</pre></div>
</div>
<section id="the-pushout-of-construction-functors">
<h4>The pushout of construction functors<a class="headerlink" href="#the-pushout-of-construction-functors" title="Permalink to this headline">¶</a></h4>
<p>We can now formulate our problem. We have parents <span class="math notranslate nohighlight">\(P_1\)</span>, <span class="math notranslate nohighlight">\(P_2\)</span> and <span class="math notranslate nohighlight">\(R\)</span>, and
construction functors <span class="math notranslate nohighlight">\(F_1\)</span>, <span class="math notranslate nohighlight">\(F_2\)</span>, such that <span class="math notranslate nohighlight">\(P_1 = F_1(R)\)</span> and <span class="math notranslate nohighlight">\(P_2 =
F_2(R)\)</span>. We want to find a new construction functor <span class="math notranslate nohighlight">\(F_3\)</span>, such that both
<span class="math notranslate nohighlight">\(P_1\)</span> and <span class="math notranslate nohighlight">\(P_2\)</span> coerce into <span class="math notranslate nohighlight">\(P_3 = F_3(R)\)</span>.</p>
<p>In analogy to a notion of category theory, <span class="math notranslate nohighlight">\(P_3\)</span> is called the
<a class="reference external" href="../reference/categories/sage/categories/pushout.html#sage.categories.pushout.pushout" title="(in Category Framework v9.6)"><code class="xref py py-func docutils literal notranslate"><span class="pre">pushout()</span></code></a> of <span class="math notranslate nohighlight">\(P_1\)</span> and <span class="math notranslate nohighlight">\(P_2\)</span>; and similarly
<span class="math notranslate nohighlight">\(F_3\)</span> is called the pushout of <span class="math notranslate nohighlight">\(F_1\)</span> and <span class="math notranslate nohighlight">\(F_2\)</span>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.pushout</span> <span class="kn">import</span> <span class="n">pushout</span>
<span class="gp">sage: </span><span class="n">pushout</span><span class="p">(</span><span class="n">Fract</span><span class="p">(</span><span class="n">ZZ</span><span class="p">),</span><span class="n">Poly</span><span class="p">(</span><span class="n">ZZ</span><span class="p">))</span>
<span class="go">Univariate Polynomial Ring in x over Rational Field</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\(F_1\circ F_2\)</span> and <span class="math notranslate nohighlight">\(F_2\circ F_1\)</span> are natural candidates for the pushout of
<span class="math notranslate nohighlight">\(F_1\)</span> and <span class="math notranslate nohighlight">\(F_2\)</span>. However, the order of the functors must rely on a canonical
choice. “Indecomposable” construction functors have a <em>rank</em>, and this allows
to order them canonically:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">F1.rank</span></code> is smaller than <code class="docutils literal notranslate"><span class="pre">F2.rank</span></code>, then the pushout is <span class="math notranslate nohighlight">\(F_2\circ
F_1\)</span> (hence, <span class="math notranslate nohighlight">\(F_1\)</span> is applied first).</p>
</div>
<p>We have</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Fract</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">Poly</span><span class="o">.</span><span class="n">rank</span>
<span class="go">(5, 9)</span>
</pre></div>
</div>
<p>and thus the pushout is</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Fract</span><span class="o">.</span><span class="n">pushout</span><span class="p">(</span><span class="n">Poly</span><span class="p">),</span> <span class="n">Poly</span><span class="o">.</span><span class="n">pushout</span><span class="p">(</span><span class="n">Fract</span><span class="p">)</span>
<span class="go">(Poly[x](FractionField(...)), Poly[x](FractionField(...)))</span>
</pre></div>
</div>
<p>This is why the example above has worked.</p>
<p>However, only “elementary” construction functors have a rank:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">Fract</span><span class="o">*</span><span class="n">Poly</span><span class="p">)</span><span class="o">.</span><span class="n">rank</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">AttributeError: &#39;CompositeConstructionFunctor&#39; object has no attribute &#39;rank&#39;</span>
</pre></div>
</div>
<section id="shuffling-composite-construction-functors">
<h5>Shuffling composite construction functors<a class="headerlink" href="#shuffling-composite-construction-functors" title="Permalink to this headline">¶</a></h5>
<p>If composed construction fuctors <span class="math notranslate nohighlight">\(...\circ F_2\circ F_1\)</span> and <span class="math notranslate nohighlight">\(...\circ
G_2\circ G_1\)</span> are given, then Sage determines their pushout by <em>shuffling</em> the
constituents:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">F1.rank</span> <span class="pre">&lt;</span> <span class="pre">G1.rank</span></code> then we apply <span class="math notranslate nohighlight">\(F_1\)</span> first, and continue with <span class="math notranslate nohighlight">\(...\circ F_3\circ F_2\)</span> and <span class="math notranslate nohighlight">\(...\circ G_2\circ G_1\)</span>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">F1.rank</span> <span class="pre">&gt;</span> <span class="pre">G1.rank</span></code> then we apply <span class="math notranslate nohighlight">\(G_1\)</span> first, and continue with <span class="math notranslate nohighlight">\(...\circ F_2\circ F_1\)</span> and <span class="math notranslate nohighlight">\(...\circ G_3\circ G_2\)</span>.</p></li>
</ul>
<p>If <code class="docutils literal notranslate"><span class="pre">F1.rank</span> <span class="pre">==</span> <span class="pre">G1.rank</span></code>, then the tie needs to be broken by other techniques
(see below).</p>
<p>As an illustration, we first get us some functors and then see how chains of
functors are shuffled.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">AlgClos</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">construction</span><span class="p">();</span> <span class="n">AlgClos</span>
<span class="go">AlgebraicClosureFunctor</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Compl</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">RR</span><span class="o">.</span><span class="n">construction</span><span class="p">();</span> <span class="n">Compl</span>
<span class="go">Completion[+Infinity, prec=53]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Matr</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">MatrixSpace</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">construction</span><span class="p">();</span> <span class="n">Matr</span>
<span class="go">MatrixFunctor</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">AlgClos</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">Compl</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">Fract</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">Poly</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">Matr</span><span class="o">.</span><span class="n">rank</span>
<span class="go">(3, 4, 5, 9, 10)</span>
</pre></div>
</div>
<p>When we apply <code class="docutils literal notranslate"><span class="pre">Fract</span></code>, <code class="docutils literal notranslate"><span class="pre">AlgClos</span></code>, <code class="docutils literal notranslate"><span class="pre">Poly</span></code> and <code class="docutils literal notranslate"><span class="pre">Fract</span></code> to the ring of
integers, we obtain:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">Fract</span><span class="o">*</span><span class="n">Poly</span><span class="o">*</span><span class="n">AlgClos</span><span class="o">*</span><span class="n">Fract</span><span class="p">)(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Fraction Field of Univariate Polynomial Ring in x over Algebraic Field</span>
</pre></div>
</div>
<p>When we apply <code class="docutils literal notranslate"><span class="pre">Compl</span></code>, <code class="docutils literal notranslate"><span class="pre">Matr</span></code> and <code class="docutils literal notranslate"><span class="pre">Poly</span></code> to the ring of integers, we
obtain:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">Poly</span><span class="o">*</span><span class="n">Matr</span><span class="o">*</span><span class="n">Compl</span><span class="p">)(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Univariate Polynomial Ring in x over Full MatrixSpace of 3 by 3 dense matrices over Integer Ring</span>
</pre></div>
</div>
<p>Applying the shuffling procedure yields</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">Poly</span><span class="o">*</span><span class="n">Matr</span><span class="o">*</span><span class="n">Fract</span><span class="o">*</span><span class="n">Poly</span><span class="o">*</span><span class="n">AlgClos</span><span class="o">*</span><span class="n">Fract</span><span class="o">*</span><span class="n">Compl</span><span class="p">)(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Univariate Polynomial Ring in x over Full MatrixSpace of 3 by 3 dense matrices over Fraction Field of Univariate Polynomial Ring in x over Algebraic Field</span>
</pre></div>
</div>
<p>and this is indeed equal to the pushout found by Sage:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pushout</span><span class="p">((</span><span class="n">Fract</span><span class="o">*</span><span class="n">Poly</span><span class="o">*</span><span class="n">AlgClos</span><span class="o">*</span><span class="n">Fract</span><span class="p">)(</span><span class="n">ZZ</span><span class="p">),</span> <span class="p">(</span><span class="n">Poly</span><span class="o">*</span><span class="n">Matr</span><span class="o">*</span><span class="n">Compl</span><span class="p">)(</span><span class="n">ZZ</span><span class="p">))</span>
<span class="go">Univariate Polynomial Ring in x over Full MatrixSpace of 3 by 3 dense matrices over Fraction Field of Univariate Polynomial Ring in x over Algebraic Field</span>
</pre></div>
</div>
</section>
<section id="breaking-the-tie">
<h5>Breaking the tie<a class="headerlink" href="#breaking-the-tie" title="Permalink to this headline">¶</a></h5>
<p>If <code class="docutils literal notranslate"><span class="pre">F1.rank==G1.rank</span></code> then Sage’s pushout constructions offers two ways to
proceed:</p>
<ol class="arabic simple">
<li><p>Construction functors have a method <a class="reference external" href="../reference/categories/sage/categories/pushout.html#sage.categories.pushout.ConstructionFunctor.merge" title="(in Category Framework v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">merge()</span></code></a> that either returns <code class="docutils literal notranslate"><span class="pre">None</span></code> or returns a construction functor-–see below. If either <code class="docutils literal notranslate"><span class="pre">F1.merge(G1)</span></code> or <code class="docutils literal notranslate"><span class="pre">G1.merge(F1)</span></code> returns a construction functor <span class="math notranslate nohighlight">\(H_1\)</span>, then we apply <span class="math notranslate nohighlight">\(H_1\)</span> and continue with <span class="math notranslate nohighlight">\(...\circ F_3\circ F_2\)</span> and <span class="math notranslate nohighlight">\(...\circ G_3\circ G_2\)</span>.</p></li>
<li><p>Construction functors have a method <a class="reference external" href="../reference/categories/sage/categories/pushout.html#sage.categories.pushout.ConstructionFunctor.commutes" title="(in Category Framework v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">commutes()</span></code></a>. If either <code class="docutils literal notranslate"><span class="pre">F1.commutes(G1)</span></code> or <code class="docutils literal notranslate"><span class="pre">G1.commutes(F1)</span></code> returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, then we apply both <span class="math notranslate nohighlight">\(F_1\)</span> and <span class="math notranslate nohighlight">\(G_1\)</span> in any order, and continue with <span class="math notranslate nohighlight">\(...\circ F_3\circ F_2\)</span> and <span class="math notranslate nohighlight">\(...\circ G_3\circ G_2\)</span>.</p></li>
</ol>
<p>By default, <code class="docutils literal notranslate"><span class="pre">F1.merge(G1)</span></code> returns <code class="docutils literal notranslate"><span class="pre">F1</span></code> if <code class="docutils literal notranslate"><span class="pre">F1==G1</span></code>, and returns
<code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise. The <code class="docutils literal notranslate"><span class="pre">commutes()</span></code> method exists, but it seems that so far
nobody has implemented two functors of the same rank that commute.</p>
</section>
</section>
<section id="establishing-a-default-implementation">
<h4>Establishing a default implementation<a class="headerlink" href="#establishing-a-default-implementation" title="Permalink to this headline">¶</a></h4>
<p>The typical application of
<a class="reference external" href="../reference/categories/sage/categories/pushout.html#sage.categories.pushout.ConstructionFunctor.merge" title="(in Category Framework v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">merge()</span></code></a> is to provide a
coercion between <em>different implementations</em> of the <em>same algebraic
structure</em>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">F1(P)</span></code> and <code class="docutils literal notranslate"><span class="pre">F2(P)</span></code> are different implementations of the same thing, then <code class="docutils literal notranslate"><span class="pre">F1.merge(F2)(P)</span></code> should return the default implementation.</p>
</div>
<p>We want to boldly turn our toy implementation of fraction fields into the new
default implementation. Hence:</p>
<ul class="simple">
<li><p>Next, we implement a new version of the “usual” fraction field functor, having the same rank, but returning our new implementation.</p></li>
<li><p>We make our new implementation the default, by virtue of a merge method.</p></li>
<li><p>Since our fraction fields accept an optional argument <code class="docutils literal notranslate"><span class="pre">category</span></code>, we pass
the optional arguments to the construction functor, which will in turn use
it to create a fraction field.</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<ul class="simple">
<li><p>Do not override the default <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method of <a class="reference external" href="../reference/categories/sage/categories/pushout.html#sage.categories.pushout.ConstructionFunctor" title="(in Category Framework v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstructionFunctor</span></code></a>-–implement <code class="docutils literal notranslate"><span class="pre">_apply_functor</span></code> instead.</p></li>
<li><p>Declare domain and codomain of the functor during initialisation.</p></li>
</ul>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.pushout</span> <span class="kn">import</span> <span class="n">ConstructionFunctor</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFracFunctor</span><span class="p">(</span><span class="n">ConstructionFunctor</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">rank</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span> <span class="ow">or</span> <span class="p">()</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">kwds</span> <span class="o">=</span> <span class="n">kwds</span> <span class="ow">or</span> <span class="p">{}</span>
<span class="gp">....: </span>        <span class="n">ConstructionFunctor</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IntegralDomains</span><span class="p">(),</span> <span class="n">Fields</span><span class="p">())</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">_apply_functor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">pushout</span><span class="o">.</span><span class="n">FractionField</span><span class="p">)):</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="bp">self</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MyFracFunctor</span><span class="p">()</span>
<span class="go">MyFracFunctor</span>
</pre></div>
</div>
<p>We verify that our functor can really be used to construct our implementation of fraction fields, and that it can be merged with either itself or the usual fraction field constructor:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MyFracFunctor</span><span class="p">()(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">NewFrac(Integer Ring)</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MyFracFunctor</span><span class="p">()</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">MyFracFunctor</span><span class="p">())</span>
<span class="go">MyFracFunctor</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MyFracFunctor</span><span class="p">()</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">Fract</span><span class="p">)</span>
<span class="go">MyFracFunctor</span>
</pre></div>
</div>
<p>There remains to let our new fraction fields know about the new construction
functor. The arguments that were used when creating the fraction field are
stored as an attribute—this is a feature provided by
<a class="reference external" href="../reference/structure/sage/structure/unique_representation.html#sage.structure.unique_representation.CachedRepresentation" title="(in Parents and Elements v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a>. We pass
all but the first of these arguments to the construction functor, such that
the construction functor is able to reconstruct the fraction field.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFrac</span><span class="p">(</span><span class="n">MyFrac</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">construction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="n">MyFracFunctor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reduction</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduction</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">construction</span><span class="p">()</span>
<span class="go">(MyFracFunctor, Univariate Polynomial Ring in x over Integer Ring)</span>
</pre></div>
</div>
<p>Due to merging, we have:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pushout</span><span class="p">(</span><span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]),</span> <span class="n">Frac</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]))</span>
<span class="go">NewFrac(Univariate Polynomial Ring in x over Rational Field)</span>
</pre></div>
</div>
</section>
<section id="a-second-note-on-performance">
<h4>A second note on performance<a class="headerlink" href="#a-second-note-on-performance" title="Permalink to this headline">¶</a></h4>
<p>Being able to do arithmetics involving elements of different parents, with the
automatic creation of a pushout to contain the result, is certainly
convenient-–but one should not rely on it, if speed matters. Simply the
conversion of elements into different parents takes time. Moreover, by
<a class="reference external" href="https://trac.sagemath.org/14058">trac ticket #14058</a>, the pushout may be subject to Python’s cyclic garbage
collection. Hence, if one does not keep a strong reference to it, the same
parent may be created repeatedly, which is a waste of time. In the following
example, we illustrate the slow--down resulting from blindly relying on
coercion:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ZZxy</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">ZZxy</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="n">timeit</span><span class="p">(</span><span class="s2">&quot;c = a+b&quot;</span><span class="p">)</span>    <span class="c1"># random</span>
<span class="go">10000 loops, best of 3: 172 us per loop</span>
<span class="gp">sage: </span><span class="n">QQxy</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">timeit</span><span class="p">(</span><span class="s2">&quot;c2 = QQxy(a)+QQxy(b)&quot;</span><span class="p">)</span> <span class="c1"># random</span>
<span class="go">10000 loops, best of 3: 168 us per loop</span>
<span class="gp">sage: </span><span class="n">a2</span> <span class="o">=</span> <span class="n">QQxy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b2</span> <span class="o">=</span> <span class="n">QQxy</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">timeit</span><span class="p">(</span><span class="s2">&quot;c2 = a2+b2&quot;</span><span class="p">)</span> <span class="c1"># random</span>
<span class="go">100000 loops, best of 3: 10.5 us per loop</span>
</pre></div>
</div>
<p>Hence, if one avoids the explicit or implicit conversion into the pushout, but
works in the pushout right away, one can get a more than 10--fold speed--up.</p>
</section>
</section>
<section id="the-test-suites-of-the-category-framework">
<h3><a class="toc-backref" href="#id8">The test suites of the category framework</a><a class="headerlink" href="#the-test-suites-of-the-category-framework" title="Permalink to this headline">¶</a></h3>
<p>The category framework does not only provide functionality but also a test
framework. This section logically belongs to the section on categories, but
without the bits that we have implemented in the section on coercion, our
implementation of fraction fields would not have passed the tests yet.</p>
<section id="abstract-methods">
<h4>“Abstract” methods<a class="headerlink" href="#abstract-methods" title="Permalink to this headline">¶</a></h4>
<p>We have already seen above that a category can require/suggest certain parent
or element methods, that the user must/should implement. This is in order to
smoothly blend with the methods that already exist in Sage.</p>
<p>The methods that ought to be provided are called
<a class="reference external" href="../reference/misc/sage/misc/abstract_method.html#sage.misc.abstract_method.abstract_method" title="(in Utilities v9.6)"><code class="xref py py-func docutils literal notranslate"><span class="pre">abstract_method()</span></code></a>. Let us see what methods
are needed for quotient fields and their elements:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.misc.abstract_method</span> <span class="kn">import</span> <span class="n">abstract_methods_of_class</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">abstract_methods_of_class</span><span class="p">(</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="p">)[</span><span class="s1">&#39;optional&#39;</span><span class="p">]</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">abstract_methods_of_class</span><span class="p">(</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="p">)[</span><span class="s1">&#39;required&#39;</span><span class="p">]</span>
<span class="go">[&#39;__contains__&#39;]</span>
</pre></div>
</div>
<p>Hence, the only required method (that is actually required for all parents
that belong to the category of sets) is an element containment test. That’s
fine, because the base class <a class="reference external" href="../reference/structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Parents and Elements v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parent</span></code></a> provides a
default containment test.</p>
<p>The elements have to provide more:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">abstract_methods_of_class</span><span class="p">(</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span><span class="p">)[</span><span class="s1">&#39;optional&#39;</span><span class="p">]</span>
<span class="go">[&#39;_add_&#39;, &#39;_mul_&#39;]</span>
<span class="gp">sage: </span><span class="n">abstract_methods_of_class</span><span class="p">(</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">element_class</span><span class="p">)[</span><span class="s1">&#39;required&#39;</span><span class="p">]</span>
<span class="go">[&#39;__bool__&#39;, &#39;denominator&#39;, &#39;numerator&#39;]</span>
</pre></div>
</div>
<p>Hence, the elements must provide <code class="docutils literal notranslate"><span class="pre">denominator()</span></code> and <code class="docutils literal notranslate"><span class="pre">numerator()</span></code>
methods, and must be able to tell whether they are zero or not. The base class
<a class="reference external" href="../reference/structure/sage/structure/element.html#sage.structure.element.Element" title="(in Parents and Elements v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> provides a default <code class="docutils literal notranslate"><span class="pre">__bool__()</span></code>
method. In addition, the elements may provide Sage’s single underscore
arithmetic methods (actually any ring element <em>should</em> provide them).</p>
</section>
<section id="the-test-methods">
<h4>The <code class="docutils literal notranslate"><span class="pre">_test_...</span></code> methods<a class="headerlink" href="#the-test-methods" title="Permalink to this headline">¶</a></h4>
<p>If a parent or element method’s name start with “_test_”, it gives rise to a
test in the automatic test suite. For example, it is tested</p>
<ul class="simple">
<li><p>whether a parent <span class="math notranslate nohighlight">\(P\)</span> actually is an instance of the parent class of the category of <span class="math notranslate nohighlight">\(P\)</span>,</p></li>
<li><p>whether the user has implemented the required abstract methods,</p></li>
<li><p>whether some defining structural properties (e.g., commutativity) hold.</p></li>
</ul>
<p>For example, if one forgets to implement required methods, one obtains the
following error:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">Parent</span><span class="p">):</span>
<span class="gp">....: </span> <span class="n">Element</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">Element</span>
<span class="gp">....: </span> <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>     <span class="n">Parent</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">QuotientFields</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Bar</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="n">Bar</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bar</span><span class="o">.</span><span class="n">_test_not_implemented_methods</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">AssertionError: Not implemented method: denominator</span>
</pre></div>
</div>
<p>Here are the tests that form the test suite of quotient fields:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">QuotientFields</span><span class="p">()</span><span class="o">.</span><span class="n">parent_class</span><span class="p">)</span> <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_test_&#39;</span><span class="p">)]</span>
<span class="go">[&#39;_test_additive_associativity&#39;,</span>
<span class="go"> &#39;_test_an_element&#39;,</span>
<span class="go"> &#39;_test_associativity&#39;,</span>
<span class="go"> &#39;_test_cardinality&#39;,</span>
<span class="go"> &#39;_test_characteristic&#39;,</span>
<span class="go"> &#39;_test_characteristic_fields&#39;,</span>
<span class="go"> &#39;_test_construction&#39;,</span>
<span class="go"> &#39;_test_distributivity&#39;,</span>
<span class="go"> &#39;_test_divides&#39;,</span>
<span class="go"> &#39;_test_elements&#39;,</span>
<span class="go"> &#39;_test_elements_eq_reflexive&#39;,</span>
<span class="go"> &#39;_test_elements_eq_symmetric&#39;,</span>
<span class="go"> &#39;_test_elements_eq_transitive&#39;,</span>
<span class="go"> &#39;_test_elements_neq&#39;,</span>
<span class="go"> &#39;_test_euclidean_degree&#39;,</span>
<span class="go"> &#39;_test_fraction_field&#39;,</span>
<span class="go"> &#39;_test_gcd_vs_xgcd&#39;,</span>
<span class="go"> &#39;_test_one&#39;,</span>
<span class="go"> &#39;_test_prod&#39;,</span>
<span class="go"> &#39;_test_quo_rem&#39;,</span>
<span class="go"> &#39;_test_some_elements&#39;,</span>
<span class="go"> &#39;_test_zero&#39;,</span>
<span class="go"> &#39;_test_zero_divisors&#39;]</span>
</pre></div>
</div>
<p>We have implemented all abstract methods (or inherit them from base classes),
we use the category framework, and we have implemented coercions. So, we are
confident that the test suite runs without an error. In fact, it does!</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following trick with the <code class="docutils literal notranslate"><span class="pre">__main__</span></code> module is only needed in
doctests, not in an interactive session or when defining the classes
externally.</p>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">MyFrac</span> <span class="o">=</span> <span class="n">MyFrac</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">MyElement</span> <span class="o">=</span> <span class="n">MyElement</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>Let us see what tests are actually performed:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">running ._test_additive_associativity() . . . pass</span>
<span class="go">running ._test_an_element() . . . pass</span>
<span class="go">running ._test_associativity() . . . pass</span>
<span class="go">running ._test_cardinality() . . . pass</span>
<span class="go">running ._test_category() . . . pass</span>
<span class="go">running ._test_characteristic() . . . pass</span>
<span class="go">running ._test_characteristic_fields() . . . pass</span>
<span class="go">running ._test_construction() . . . pass</span>
<span class="go">running ._test_distributivity() . . . pass</span>
<span class="go">running ._test_divides() . . . pass</span>
<span class="go">running ._test_elements() . . .</span>
<span class="go">  Running the test suite of self.an_element()</span>
<span class="go">  running ._test_category() . . . pass</span>
<span class="go">  running ._test_eq() . . . pass</span>
<span class="go">  running ._test_new() . . . pass</span>
<span class="go">  running ._test_nonzero_equal() . . . pass</span>
<span class="go">  running ._test_not_implemented_methods() . . . pass</span>
<span class="go">  running ._test_pickling() . . . pass</span>
<span class="go">  pass</span>
<span class="go">running ._test_elements_eq_reflexive() . . . pass</span>
<span class="go">running ._test_elements_eq_symmetric() . . . pass</span>
<span class="go">running ._test_elements_eq_transitive() . . . pass</span>
<span class="go">running ._test_elements_neq() . . . pass</span>
<span class="go">running ._test_eq() . . . pass</span>
<span class="go">running ._test_euclidean_degree() . . . pass</span>
<span class="go">running ._test_fraction_field() . . . pass</span>
<span class="go">running ._test_gcd_vs_xgcd() . . . pass</span>
<span class="go">running ._test_new() . . . pass</span>
<span class="go">running ._test_not_implemented_methods() . . . pass</span>
<span class="go">running ._test_one() . . . pass</span>
<span class="go">running ._test_pickling() . . . pass</span>
<span class="go">running ._test_prod() . . . pass</span>
<span class="go">running ._test_quo_rem() . . . pass</span>
<span class="go">running ._test_some_elements() . . . pass</span>
<span class="go">running ._test_zero() . . . pass</span>
<span class="go">running ._test_zero_divisors() . . . pass</span>
</pre></div>
</div>
</section>
<section id="implementing-a-new-category-with-additional-tests">
<h4>Implementing a new category with additional tests<a class="headerlink" href="#implementing-a-new-category-with-additional-tests" title="Permalink to this headline">¶</a></h4>
<p>As one can see, tests are also performed on elements. There are methods that
return one element or a list of some elements, relying on “typical” elements
that can be found in most algebraic structures.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">P</span><span class="o">.</span><span class="n">some_elements</span><span class="p">()</span>
<span class="go">(2):(1)</span>
<span class="go">[(2):(1)]</span>
</pre></div>
</div>
<p>Unfortunately, the list of elements that is returned by the default method is
of length one, and that single element could also be a bit more interesting.
The method an_element relies on a method <code class="docutils literal notranslate"><span class="pre">_an_element_()</span></code>, so, we implement
that. We also override the some_elements method.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFrac</span><span class="p">(</span><span class="n">MyFrac</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">_an_element_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">....: </span>        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">some_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">an_element</span><span class="p">(),</span><span class="bp">self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">an_element</span><span class="p">()),</span><span class="bp">self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">an_element</span><span class="p">())]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">P</span><span class="o">.</span><span class="n">some_elements</span><span class="p">()</span>
<span class="go">(x^2):(x^3 + 3*x^2 + 3*x + 1)</span>
<span class="go">[(x^2):(x^3 + 3*x^2 + 3*x + 1), (x):(1), (1):(1)]</span>
</pre></div>
</div>
<p>Now, as we have more interesting elements, we may also add a test for the
“factor” method. Recall that the method was inherited from the category, but
it appears that it is not tested.</p>
<p>Normally, a test for a method defined by a category should be provided by the
same category. Hence, since <code class="docutils literal notranslate"><span class="pre">factor</span></code> is defined in the category of quotient
fields, a test should be added there. But we won’t change source code here and
will instead create a sub--category.</p>
<p>Apparently, If <span class="math notranslate nohighlight">\(e\)</span> is an element of a quotient field, the product of the
factors returned by <code class="docutils literal notranslate"><span class="pre">e.factor()</span></code> should be equal to <span class="math notranslate nohighlight">\(e\)</span>. For forming the
product, we use the <code class="docutils literal notranslate"><span class="pre">prod</span></code> method, that, no surprise, is inherited from
another category:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">prod</span><span class="o">.</span><span class="vm">__module__</span>
<span class="go">&#39;sage.categories.monoids&#39;</span>
</pre></div>
</div>
<p>When we want to create a sub--category, we need to provide a method
<a class="reference external" href="../reference/categories/sage/categories/category.html#sage.categories.category.Category.super_categories" title="(in Category Framework v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">super_categories()</span></code></a>, that returns a
list of all immediate super categories (here: category of quotient fields).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>A sub--category <span class="math notranslate nohighlight">\(S\)</span> of a category <span class="math notranslate nohighlight">\(C\)</span> is <em>not</em> implemented as a
sub--class of <code class="docutils literal notranslate"><span class="pre">C.__class__</span></code>! <span class="math notranslate nohighlight">\(S\)</span> becomes a sub--category of <span class="math notranslate nohighlight">\(C\)</span> only
if <code class="docutils literal notranslate"><span class="pre">S.super_categories()</span></code> returns (a sub--category of) <span class="math notranslate nohighlight">\(C\)</span>!</p>
</div>
<p>The parent and element methods of a category are provided as methods of
classes that are the attributes <code class="docutils literal notranslate"><span class="pre">ParentMethods</span></code> and <code class="docutils literal notranslate"><span class="pre">Element</span> <span class="pre">Methods</span></code> of
the category, as follows:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.category</span> <span class="kn">import</span> <span class="n">Category</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">QuotientFieldsWithTest</span><span class="p">(</span><span class="n">Category</span><span class="p">):</span> <span class="c1"># do *not* inherit from QuotientFields, but ...</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="p">[</span><span class="n">QuotientFields</span><span class="p">()]</span>       <span class="c1"># ... declare QuotientFields as a super category!</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">ParentMethods</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">pass</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">ElementMethods</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">def</span> <span class="nf">_test_factorisation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="gp">....: </span>            <span class="k">assert</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="n">P</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">e</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">()])</span>
</pre></div>
</div>
<p>We provide an instance of our quotient field implementation with that new
category. Note that categories have a default <code class="docutils literal notranslate"><span class="pre">_repr_</span></code> method, that guesses
a good string representation from the name of the class:
<code class="docutils literal notranslate"><span class="pre">QuotientFieldsWithTest</span></code> becomes “quotient fields with test”.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following trick with the <code class="docutils literal notranslate"><span class="pre">__main__</span></code> module is only needed in
doctests, not in an interactive session or when defining the classes
externally.</p>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">MyFrac</span> <span class="o">=</span> <span class="n">MyFrac</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">MyElement</span> <span class="o">=</span> <span class="n">MyElement</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">QuotientFieldsWithTest</span> <span class="o">=</span> <span class="n">QuotientFieldsWithTest</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">category</span><span class="o">=</span><span class="n">QuotientFieldsWithTest</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of quotient fields with test</span>
</pre></div>
</div>
<p>The new test is inherited from the category. Since <code class="docutils literal notranslate"><span class="pre">an_element()</span></code> is returning a
complicated element, <code class="docutils literal notranslate"><span class="pre">_test_factorisation</span></code> is a serious test:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span><span class="o">.</span><span class="n">_test_factorisation</span>
<span class="go">&lt;bound method QuotientFieldsWithTest.ElementMethods._test_factorisation of (x^2):(x^3 + 3*x^2 + 3*x + 1)&gt;</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">(x + 1)^-3 * x^2</span>
</pre></div>
</div>
<p>Last, we observe that the new test has automatically become part of the test
suite. We remark that the existing tests became more serious as well, since we
made <a class="reference external" href="../reference/structure/sage/structure/parent.html#sage.structure.parent.Parent.an_element" title="(in Parents and Elements v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.structure.parent.Parent.an_element()</span></code></a> return something more
interesting.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">running ._test_additive_associativity() . . . pass</span>
<span class="go">running ._test_an_element() . . . pass</span>
<span class="go">running ._test_associativity() . . . pass</span>
<span class="go">running ._test_cardinality() . . . pass</span>
<span class="go">running ._test_category() . . . pass</span>
<span class="go">running ._test_characteristic() . . . pass</span>
<span class="go">running ._test_characteristic_fields() . . . pass</span>
<span class="go">running ._test_construction() . . . pass</span>
<span class="go">running ._test_distributivity() . . . pass</span>
<span class="go">running ._test_divides() . . . pass</span>
<span class="go">running ._test_elements() . . .</span>
<span class="go">  Running the test suite of self.an_element()</span>
<span class="go">  running ._test_category() . . . pass</span>
<span class="go">  running ._test_eq() . . . pass</span>
<span class="go">  running ._test_factorisation() . . . pass</span>
<span class="go">  running ._test_new() . . . pass</span>
<span class="go">  running ._test_nonzero_equal() . . . pass</span>
<span class="go">  running ._test_not_implemented_methods() . . . pass</span>
<span class="go">  running ._test_pickling() . . . pass</span>
<span class="go">  pass</span>
<span class="go">running ._test_elements_eq_reflexive() . . . pass</span>
<span class="go">running ._test_elements_eq_symmetric() . . . pass</span>
<span class="go">running ._test_elements_eq_transitive() . . . pass</span>
<span class="go">running ._test_elements_neq() . . . pass</span>
<span class="go">running ._test_eq() . . . pass</span>
<span class="go">running ._test_euclidean_degree() . . . pass</span>
<span class="go">running ._test_fraction_field() . . . pass</span>
<span class="go">running ._test_gcd_vs_xgcd() . . . pass</span>
<span class="go">running ._test_new() . . . pass</span>
<span class="go">running ._test_not_implemented_methods() . . . pass</span>
<span class="go">running ._test_one() . . . pass</span>
<span class="go">running ._test_pickling() . . . pass</span>
<span class="go">running ._test_prod() . . . pass</span>
<span class="go">running ._test_quo_rem() . . . pass</span>
<span class="go">running ._test_some_elements() . . . pass</span>
<span class="go">running ._test_zero() . . . pass</span>
<span class="go">running ._test_zero_divisors() . . . pass</span>
</pre></div>
</div>
</section>
</section>
<section id="appendix-the-complete-code">
<h3><a class="toc-backref" href="#id9">Appendix: The complete code</a><a class="headerlink" href="#appendix-the-complete-code" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span><span class="c1"># Importing base classes, ...</span>
<span class="linenos">  2</span><span class="kn">import</span> <span class="nn">sage</span>
<span class="linenos">  3</span><span class="kn">from</span> <span class="nn">sage.rings.ring</span> <span class="kn">import</span> <span class="n">Field</span>
<span class="linenos">  4</span><span class="kn">from</span> <span class="nn">sage.structure.element</span> <span class="kn">import</span> <span class="n">FieldElement</span>
<span class="linenos">  5</span><span class="kn">from</span> <span class="nn">sage.categories.category</span> <span class="kn">import</span> <span class="n">Category</span>
<span class="linenos">  6</span><span class="c1"># ... the UniqueRepresentation tool,</span>
<span class="linenos">  7</span><span class="kn">from</span> <span class="nn">sage.structure.unique_representation</span> <span class="kn">import</span> <span class="n">UniqueRepresentation</span>
<span class="linenos">  8</span><span class="c1"># ... some categories, and ...</span>
<span class="linenos">  9</span><span class="kn">from</span> <span class="nn">sage.categories.fields</span> <span class="kn">import</span> <span class="n">Fields</span>
<span class="linenos"> 10</span><span class="kn">from</span> <span class="nn">sage.categories.quotient_fields</span> <span class="kn">import</span> <span class="n">QuotientFields</span>
<span class="linenos"> 11</span><span class="kn">from</span> <span class="nn">sage.categories.integral_domains</span> <span class="kn">import</span> <span class="n">IntegralDomains</span>
<span class="linenos"> 12</span><span class="c1"># construction functors</span>
<span class="linenos"> 13</span><span class="kn">from</span> <span class="nn">sage.categories.pushout</span> <span class="kn">import</span> <span class="n">ConstructionFunctor</span>
<span class="linenos"> 14</span>
<span class="linenos"> 15</span><span class="c1"># Fraction field elements</span>
<span class="linenos"> 16</span><span class="k">class</span> <span class="nc">MyElement</span><span class="p">(</span><span class="n">FieldElement</span><span class="p">):</span>
<span class="linenos"> 17</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="linenos"> 18</span>        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos"> 19</span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The parent must be provided&quot;</span><span class="p">)</span>
<span class="linenos"> 20</span>        <span class="n">B</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">base</span><span class="p">()</span>
<span class="linenos"> 21</span>        <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos"> 22</span>            <span class="c1"># The default denominator is one</span>
<span class="linenos"> 23</span>            <span class="n">d</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="linenos"> 24</span>        <span class="c1"># verify that both numerator and denominator belong to the base</span>
<span class="linenos"> 25</span>        <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">B</span> <span class="ow">or</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">B</span><span class="p">:</span>
<span class="linenos"> 26</span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Numerator and denominator must be elements of </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">B</span><span class="p">)</span>
<span class="linenos"> 27</span>        <span class="c1"># Numerator and denominator should not just be &quot;in&quot; B,</span>
<span class="linenos"> 28</span>        <span class="c1"># but should be defined as elements of B</span>
<span class="linenos"> 29</span>        <span class="n">d</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="linenos"> 30</span>        <span class="n">n</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="linenos"> 31</span>        <span class="c1"># the denominator must not be zero</span>
<span class="linenos"> 32</span>        <span class="k">if</span> <span class="n">d</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
<span class="linenos"> 33</span>            <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s2">&quot;The denominator must not be zero&quot;</span><span class="p">)</span>
<span class="linenos"> 34</span>        <span class="c1"># normalize the denominator: WLOG, it shall be non-negative.</span>
<span class="linenos"> 35</span>        <span class="k">if</span> <span class="n">d</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
<span class="linenos"> 36</span>            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span>
<span class="linenos"> 37</span>            <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">d</span>
<span class="linenos"> 38</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 39</span>            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
<span class="linenos"> 40</span>            <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">d</span>
<span class="linenos"> 41</span>        <span class="n">FieldElement</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">parent</span><span class="p">)</span>
<span class="linenos"> 42</span>
<span class="linenos"> 43</span>    <span class="c1"># Methods required by the category of fraction fields:</span>
<span class="linenos"> 44</span>    <span class="k">def</span> <span class="nf">numerator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos"> 45</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
<span class="linenos"> 46</span>    <span class="k">def</span> <span class="nf">denominator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos"> 47</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span>
<span class="linenos"> 48</span>
<span class="linenos"> 49</span>    <span class="c1"># String representation (single underscore!)</span>
<span class="linenos"> 50</span>    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos"> 51</span>        <span class="k">return</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">):(</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
<span class="linenos"> 52</span>
<span class="linenos"> 53</span>    <span class="c1"># Comparison: We can assume that both arguments are coerced</span>
<span class="linenos"> 54</span>    <span class="c1"># into the same parent, which is a fraction field. Hence, we</span>
<span class="linenos"> 55</span>    <span class="c1"># are allowed to use the denominator() and numerator() methods</span>
<span class="linenos"> 56</span>    <span class="c1"># on the second argument.</span>
<span class="linenos"> 57</span>    <span class="k">def</span> <span class="nf">_richcmp_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
<span class="linenos"> 58</span>        <span class="kn">from</span> <span class="nn">sage.structure.richcmp</span> <span class="kn">import</span> <span class="n">richcmp</span>
<span class="linenos"> 59</span>        <span class="k">return</span> <span class="n">richcmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">numerator</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
<span class="linenos"> 60</span>
<span class="linenos"> 61</span>    <span class="c1"># Arithmetic methods, single underscore. We can assume that both</span>
<span class="linenos"> 62</span>    <span class="c1"># arguments are coerced into the same parent.</span>
<span class="linenos"> 63</span>    <span class="c1"># We return instances of self.__class__, because self.__class__ will</span>
<span class="linenos"> 64</span>    <span class="c1"># eventually be a sub-class of MyElement.</span>
<span class="linenos"> 65</span>    <span class="k">def</span> <span class="nf">_add_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="linenos"> 66</span>        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
<span class="linenos"> 67</span>        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span>
<span class="linenos"> 68</span>        <span class="k">return</span> <span class="n">C</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">numerator</span><span class="p">(),</span><span class="n">D</span><span class="p">)</span>
<span class="linenos"> 69</span>    <span class="k">def</span> <span class="nf">_sub_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="linenos"> 70</span>        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
<span class="linenos"> 71</span>        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span>
<span class="linenos"> 72</span>        <span class="k">return</span> <span class="n">C</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">numerator</span><span class="p">(),</span><span class="n">D</span><span class="p">)</span>
<span class="linenos"> 73</span>    <span class="k">def</span> <span class="nf">_mul_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="linenos"> 74</span>        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
<span class="linenos"> 75</span>        <span class="k">return</span> <span class="n">C</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">numerator</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">())</span>
<span class="linenos"> 76</span>    <span class="k">def</span> <span class="nf">_div_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="linenos"> 77</span>        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
<span class="linenos"> 78</span>        <span class="k">return</span> <span class="n">C</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">denominator</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">numerator</span><span class="p">())</span>
<span class="linenos"> 79</span>
<span class="linenos"> 80</span><span class="c1"># Inheritance from UniqueRepresentation implements the unique parent</span>
<span class="linenos"> 81</span><span class="c1"># behaviour. Moreover, it implements pickling (provided that Python</span>
<span class="linenos"> 82</span><span class="c1"># succeeds to look up the class definition).</span>
<span class="linenos"> 83</span><span class="k">class</span> <span class="nc">MyFrac</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="n">Field</span><span class="p">):</span>
<span class="linenos"> 84</span>    <span class="c1"># Implement the category framework for elements, which also</span>
<span class="linenos"> 85</span>    <span class="c1"># makes some basic conversions work.</span>
<span class="linenos"> 86</span>    <span class="n">Element</span> <span class="o">=</span> <span class="n">MyElement</span>
<span class="linenos"> 87</span>
<span class="linenos"> 88</span>    <span class="c1"># Allow to pass to a different category, by an optional argument</span>
<span class="linenos"> 89</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="linenos"> 90</span>        <span class="c1"># Fraction fields only exist for integral domains</span>
<span class="linenos"> 91</span>        <span class="k">if</span> <span class="n">base</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">IntegralDomains</span><span class="p">():</span>
<span class="linenos"> 92</span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is no integral domain&quot;</span> <span class="o">%</span> <span class="n">base</span><span class="p">)</span>
<span class="linenos"> 93</span>        <span class="c1"># Implement the category framework for the parent</span>
<span class="linenos"> 94</span>        <span class="n">Field</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">category</span> <span class="ow">or</span> <span class="n">QuotientFields</span><span class="p">())</span>
<span class="linenos"> 95</span>
<span class="linenos"> 96</span>    <span class="c1"># Single-underscore method for string representation</span>
<span class="linenos"> 97</span>    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos"> 98</span>        <span class="k">return</span> <span class="s2">&quot;NewFrac(</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">())</span>
<span class="linenos"> 99</span>
<span class="linenos">100</span>    <span class="c1"># Two methods that are implicitly used in some tests</span>
<span class="linenos">101</span>    <span class="k">def</span> <span class="nf">base_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">102</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
<span class="linenos">103</span>    <span class="k">def</span> <span class="nf">characteristic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">104</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">characteristic</span><span class="p">()</span>
<span class="linenos">105</span>
<span class="linenos">106</span>    <span class="c1"># Implement conversions. Do not override __call__!</span>
<span class="linenos">107</span>    <span class="k">def</span> <span class="nf">_element_constructor_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="linenos">108</span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
<span class="linenos">109</span>           <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
<span class="linenos">110</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="linenos">111</span>        <span class="k">try</span><span class="p">:</span>
<span class="linenos">112</span>            <span class="n">P</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="linenos">113</span>        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
<span class="linenos">114</span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
<span class="linenos">115</span>        <span class="k">if</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">QuotientFields</span><span class="p">()</span> <span class="ow">and</span> <span class="n">P</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">():</span>
<span class="linenos">116</span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">numerator</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">denominator</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
<span class="linenos">117</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
<span class="linenos">118</span>
<span class="linenos">119</span>    <span class="c1"># Implement coercion from the base and from fraction fields</span>
<span class="linenos">120</span>    <span class="c1"># over a ring that coerces into the base</span>
<span class="linenos">121</span>    <span class="k">def</span> <span class="nf">_coerce_map_from_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
<span class="linenos">122</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
<span class="linenos">123</span>            <span class="k">return</span> <span class="kc">True</span>
<span class="linenos">124</span>        <span class="k">if</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">QuotientFields</span><span class="p">():</span>
<span class="linenos">125</span>            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">base</span><span class="p">()):</span>
<span class="linenos">126</span>                <span class="k">return</span> <span class="kc">True</span>
<span class="linenos">127</span>            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="s1">&#39;ring_of_integers&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">ring_of_integers</span><span class="p">()):</span>
<span class="linenos">128</span>                <span class="k">return</span> <span class="kc">True</span>
<span class="linenos">129</span>    <span class="c1"># Tell how this parent was constructed, in order to enable pushout constructions</span>
<span class="linenos">130</span>    <span class="k">def</span> <span class="nf">construction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">131</span>        <span class="k">return</span> <span class="n">MyFracFunctor</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span>
<span class="linenos">132</span>
<span class="linenos">133</span>    <span class="c1"># return some elements of this parent</span>
<span class="linenos">134</span>    <span class="k">def</span> <span class="nf">_an_element_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">135</span>        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="linenos">136</span>        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="linenos">137</span>        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
<span class="linenos">138</span>            <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="linenos">139</span>        <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
<span class="linenos">140</span>            <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="linenos">141</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>
<span class="linenos">142</span>    <span class="k">def</span> <span class="nf">some_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">143</span>        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">an_element</span><span class="p">(),</span><span class="bp">self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">()</span><span class="o">.</span><span class="n">an_element</span><span class="p">()),</span><span class="bp">self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">an_element</span><span class="p">())]</span>
<span class="linenos">144</span>
<span class="linenos">145</span>
<span class="linenos">146</span><span class="c1"># A construction functor for our implementation of fraction fields</span>
<span class="linenos">147</span><span class="k">class</span> <span class="nc">MyFracFunctor</span><span class="p">(</span><span class="n">ConstructionFunctor</span><span class="p">):</span>
<span class="linenos">148</span>    <span class="c1"># The rank is the same for Sage&#39;s original fraction field functor</span>
<span class="linenos">149</span>    <span class="n">rank</span> <span class="o">=</span> <span class="mi">5</span>
<span class="linenos">150</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">151</span>        <span class="c1"># The fraction field construction is a functor</span>
<span class="linenos">152</span>        <span class="c1"># from the category of integral domains into the category of</span>
<span class="linenos">153</span>        <span class="c1"># fields</span>
<span class="linenos">154</span>        <span class="c1"># NOTE: We could actually narrow the codomain and use the</span>
<span class="linenos">155</span>        <span class="c1"># category QuotientFields()</span>
<span class="linenos">156</span>        <span class="n">ConstructionFunctor</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IntegralDomains</span><span class="p">(),</span> <span class="n">Fields</span><span class="p">())</span>
<span class="linenos">157</span>    <span class="c1"># Applying the functor to an object. Do not override __call__!</span>
<span class="linenos">158</span>    <span class="k">def</span> <span class="nf">_apply_functor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
<span class="linenos">159</span>        <span class="k">return</span> <span class="n">MyFrac</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
<span class="linenos">160</span>    <span class="c1"># Note: To apply the functor to morphisms, implement</span>
<span class="linenos">161</span>    <span class="c1">#       _apply_functor_to_morphism</span>
<span class="linenos">162</span>
<span class="linenos">163</span>    <span class="c1"># Make sure that arithmetic involving elements of Frac(R) and</span>
<span class="linenos">164</span>    <span class="c1"># MyFrac(R) works and yields elements of MyFrac(R)</span>
<span class="linenos">165</span>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="linenos">166</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">pushout</span><span class="o">.</span><span class="n">FractionField</span><span class="p">)):</span>
<span class="linenos">167</span>            <span class="k">return</span> <span class="bp">self</span>
<span class="linenos">168</span>
<span class="linenos">169</span><span class="c1"># A quotient field category with additional tests.</span>
<span class="linenos">170</span><span class="c1"># Notes:</span>
<span class="linenos">171</span><span class="c1"># - Category inherits from UniqueRepresentation. Hence, there</span>
<span class="linenos">172</span><span class="c1">#   is only one category for given arguments.</span>
<span class="linenos">173</span><span class="c1"># - Since QuotientFieldsWithTest is a singleton (there is only</span>
<span class="linenos">174</span><span class="c1">#   one instance of this class), we could inherit from</span>
<span class="linenos">175</span><span class="c1">#   sage.categories.category_singleton.Category_singleton</span>
<span class="linenos">176</span><span class="c1">#   rather than from sage.categories.category.Category</span>
<span class="linenos">177</span><span class="k">class</span> <span class="nc">QuotientFieldsWithTest</span><span class="p">(</span><span class="n">Category</span><span class="p">):</span>
<span class="linenos">178</span>    <span class="c1"># Our category is a sub-category of the category of quotient fields,</span>
<span class="linenos">179</span>    <span class="c1"># by means of the following method.</span>
<span class="linenos">180</span>    <span class="k">def</span> <span class="nf">super_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">181</span>        <span class="k">return</span> <span class="p">[</span><span class="n">QuotientFields</span><span class="p">()]</span>
<span class="linenos">182</span>
<span class="linenos">183</span>    <span class="c1"># Here, we could implement methods that are available for</span>
<span class="linenos">184</span>    <span class="c1"># all objects in this category.</span>
<span class="linenos">185</span>    <span class="k">class</span> <span class="nc">ParentMethods</span><span class="p">:</span>
<span class="linenos">186</span>        <span class="k">pass</span>
<span class="linenos">187</span>
<span class="linenos">188</span>    <span class="c1"># Here, we add a new test that is available for all elements</span>
<span class="linenos">189</span>    <span class="c1"># of any object in this category.</span>
<span class="linenos">190</span>    <span class="k">class</span> <span class="nc">ElementMethods</span><span class="p">:</span>
<span class="linenos">191</span>        <span class="k">def</span> <span class="nf">_test_factorisation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="linenos">192</span>            <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="linenos">193</span>            <span class="c1"># The methods prod() and factor() are inherited from</span>
<span class="linenos">194</span>            <span class="c1"># some other categories.</span>
<span class="linenos">195</span>            <span class="k">assert</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="n">P</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">e</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">()])</span>
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">How to implement new algebraic structures in Sage</a><ul>
<li><a class="reference internal" href="#sage-s-category-and-coercion-framework">Sage’s category and coercion framework</a><ul>
<li><a class="reference internal" href="#outline">Outline</a></li>
<li><a class="reference internal" href="#base-classes">Base classes</a><ul>
<li><a class="reference internal" href="#the-parent">The parent</a></li>
<li><a class="reference internal" href="#the-elements">The elements</a><ul>
<li><a class="reference internal" href="#features-and-limitations-of-the-basic-implementation">Features and limitations of the basic implementation</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#categories-in-sage">Categories in Sage</a><ul>
<li><a class="reference internal" href="#why-should-one-choose-a-category">Why should one choose a category?</a><ul>
<li><a class="reference internal" href="#how-does-the-category-framework-work">How does the  <em>category framework</em> work?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementing-the-category-framework-for-the-parent">Implementing the category framework for the parent</a></li>
<li><a class="reference internal" href="#implementing-the-category-framework-for-the-elements">Implementing the category framework for the elements</a><ul>
<li><a class="reference internal" href="#what-did-happen-behind-the-scenes-to-make-this-work">What did happen behind the scenes to make this work?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-first-note-on-performance">A first note on performance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coercion-the-basics">Coercion-–the basics</a><ul>
<li><a class="reference internal" href="#theoretical-background">Theoretical background</a><ul>
<li><a class="reference internal" href="#coercion-is-not-just-type-conversion">Coercion is not just <em>type conversion</em></a></li>
<li><a class="reference internal" href="#not-every-conversion-is-a-coercion">Not every conversion is a coercion</a><ul>
<li><a class="reference internal" href="#the-four-axioms-requested-for-coercions">The four axioms requested for coercions</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#implementing-a-conversion">Implementing a conversion</a></li>
<li><a class="reference internal" href="#establishing-a-coercion">Establishing a coercion</a><ul>
<li><a class="reference internal" href="#equality-and-element-containment">Equality and element containment</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#coercion-the-advanced-parts">Coercion-–the advanced parts</a><ul>
<li><a class="reference internal" href="#the-pushout-of-construction-functors">The pushout of construction functors</a><ul>
<li><a class="reference internal" href="#shuffling-composite-construction-functors">Shuffling composite construction functors</a></li>
<li><a class="reference internal" href="#breaking-the-tie">Breaking the tie</a></li>
</ul>
</li>
<li><a class="reference internal" href="#establishing-a-default-implementation">Establishing a default implementation</a></li>
<li><a class="reference internal" href="#a-second-note-on-performance">A second note on performance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-test-suites-of-the-category-framework">The test suites of the category framework</a><ul>
<li><a class="reference internal" href="#abstract-methods">“Abstract” methods</a></li>
<li><a class="reference internal" href="#the-test-methods">The <code class="docutils literal notranslate"><span class="pre">_test_...</span></code> methods</a></li>
<li><a class="reference internal" href="#implementing-a-new-category-with-additional-tests">Implementing a new category with additional tests</a></li>
</ul>
</li>
<li><a class="reference internal" href="#appendix-the-complete-code">Appendix: The complete code</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="functional_programming.html"
                          title="previous chapter">Functional Programming for Mathematicians</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="tutorial-implementing-algebraic-structures.html"
                          title="next chapter">Tutorial: Implementing Algebraic Structures</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/coercion_and_categories.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="tutorial-implementing-algebraic-structures.html" title="Tutorial: Implementing Algebraic Structures"
             >next</a> |</li>
        <li class="right" >
          <a href="functional_programming.html" title="Functional Programming for Mathematicians"
             >previous</a> |</li>
  <li class="nav-item nav-item-0">
    <a href="http://www.sagemath.org"><img src="_static/logo_sagemath_black.svg" class="sage-logo" title="Sage Logo"></a>
    
      <a href="../index.html">Sage 9.6 Documentation</a> &#187;
      
      <a href="index.html">Thematic Tutorials</a> &#187;
    
  </li>

          <li class="nav-item nav-item-1"><a href="toctree.html" >Thematic tutorial document tree</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">How to implement new algebraic structures in Sage</a></li> 
      </ul>
    </div>
  
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2022, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
  </script>
  <script type="text/javascript">
/* detex the document title by removing "\(", "\)", "\", "$" */
document.title = document.title.replace(/\\\(/g, '').replace(/\\\)/g, '').replace(/\\/g, '').replace(/\$/g, '');
  </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>